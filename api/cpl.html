

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Common Portability Library &mdash; GDAL  documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://gdal.orgapi/cpl.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/gdal.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="gdal.h: Raster C API" href="raster_c_api.html" />
    <link rel="prev" title="API" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/gdalicon.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programs/index.html">Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/raster/index.html">Raster drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/vector/index.html">Vector drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Full Doxygen output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#c-api">C API</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Common Portability Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cpl-conv-h">cpl_conv.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-csv-h">cpl_csv.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-error-h">cpl_error.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-http-h">cpl_http.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-minixml-h">cpl_minixml.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-multiproc-h">cpl_multiproc.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-odbc-h">cpl_odbc.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-port-h">cpl_port.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-progress-h">cpl_progress.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-string-h">cpl_string.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-time-h">cpl_time.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-virtualmem-h">cpl_virtualmem.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-vsi-error-h">cpl_vsi_error.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-vsi-h">cpl_vsi.h</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpl-vsi-virtual-h">cpl_vsi_virtual.h</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="raster_c_api.html">gdal.h: Raster C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="vector_c_api.html">ogr_api.h: Vector C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gdal_alg.html">gdal_alg.h: GDAL Algorithms C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="ogr_srs_api.html">ogr_srs_api.h: Spatial Reference System C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gdal_utils.html">gdal_utils.h: GDAL Algorithms C API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">C++ API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Python API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id5">Java API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">How to contribute?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDAL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html"> GDAL  documentation </a> &raquo;</li>
      
          <li><a href="index.html">API</a> &raquo;</li>
      
      <li>Common Portability Library</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/OSGeo/gdal/blob//master/gdal/doc/source/api/cpl.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="raster_c_api.html" class="btn btn-neutral float-right" title="gdal.h: Raster C API" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="API" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="common-portability-library">
<span id="cpl-api"></span><h1>Common Portability Library<a class="headerlink" href="#common-portability-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="cpl-conv-h">
<h2>cpl_conv.h<a class="headerlink" href="#cpl-conv-h" title="Permalink to this headline">¶</a></h2>
<p>Various convenience functions for CPL. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.CPLFree">
<span class="target" id="cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"></span><code class="descname">CPLFree</code><a class="headerlink" href="#c.CPLFree" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv413CPLFileFinder">
<span id="_CPPv313CPLFileFinder"></span><span id="_CPPv213CPLFileFinder"></span><span id="CPLFileFinder"></span><span class="target" id="cpl__conv_8h_1adc72eb27f2c83e58454fd3c3e08ed269"></span><em class="property">typedef </em><em class="property">const</em> char *(*<code class="descname">CPLFileFinder</code>)<span class="sig-paren">(</span><em class="property">const</em> char *, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLFileFinder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback for CPLPushFileFinder. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv418CPLGetConfigOptionPKcPKc">
<span id="_CPPv318CPLGetConfigOptionPKcPKc"></span><span id="_CPPv218CPLGetConfigOptionPKcPKc"></span><span id="CPLGetConfigOption__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1a21a509890bf6632f1b1d836c1d3bb970"></span><em class="property">const</em> char *<code class="descname">CPLGetConfigOption</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, <em class="property">const</em> char *<em>pszDefault</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLGetConfigOptionPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the value of a configuration option. </p>
<p>The value is the value of a (key, value) option set with <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a>, or <a class="reference internal" href="#cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"><span class="std std-ref">CPLSetThreadLocalConfigOption()</span></a> of the same thread. If the given option was no defined with <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a>, it tries to find it in environment variables.</p>
<p>Note: the string returned by <a class="reference internal" href="#cpl__conv_8h_1a21a509890bf6632f1b1d836c1d3bb970"><span class="std std-ref">CPLGetConfigOption()</span></a> might be short-lived, and in particular it will become invalid after a call to <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a> with the same key.</p>
<p>To override temporary a potentially existing option with a new value, you can use the following snippet : </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the value associated to the key, or the default value if not found</p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a>, <a class="reference external" href="http://trac.osgeo.org/gdal/wiki/ConfigOptions">http://trac.osgeo.org/gdal/wiki/ConfigOptions</a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key of the option to retrieve </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDefault</span></code>: a default value if the key does not match existing defined options (may be NULL) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429CPLGetThreadLocalConfigOptionPKcPKc">
<span id="_CPPv329CPLGetThreadLocalConfigOptionPKcPKc"></span><span id="_CPPv229CPLGetThreadLocalConfigOptionPKcPKc"></span><span id="CPLGetThreadLocalConfigOption__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1af0c65535f313d7508c8054899a143311"></span><em class="property">const</em> char *<code class="descname">CPLGetThreadLocalConfigOption</code><span class="sig-paren">(</span><em class="property">const</em> char *, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429CPLGetThreadLocalConfigOptionPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#cpl__conv_8h_1a21a509890bf6632f1b1d836c1d3bb970"><span class="std std-ref">CPLGetConfigOption()</span></a> but only with options set with <a class="reference internal" href="#cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"><span class="std std-ref">CPLSetThreadLocalConfigOption()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLSetConfigOptionPKcPKc">
<span id="_CPPv318CPLSetConfigOptionPKcPKc"></span><span id="_CPPv218CPLSetConfigOptionPKcPKc"></span><span id="CPLSetConfigOption__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"></span>void <code class="descname">CPLSetConfigOption</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLSetConfigOptionPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a configuration option for GDAL/OGR use. </p>
<p>Those options are defined as a (key, value) couple. The value corresponding to a key can be got later with the <a class="reference internal" href="#cpl__conv_8h_1a21a509890bf6632f1b1d836c1d3bb970"><span class="std std-ref">CPLGetConfigOption()</span></a> method.</p>
<p>This mechanism is similar to environment variables, but options set with <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a> overrides, for <a class="reference internal" href="#cpl__conv_8h_1a21a509890bf6632f1b1d836c1d3bb970"><span class="std std-ref">CPLGetConfigOption()</span></a> point of view, values defined in the environment.</p>
<p>If <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a> is called several times with the same key, the value provided during the last call will be used.</p>
<p>Options can also be passed on the command line of most GDAL utilities with the with ‘config KEY VALUE’. For example, ogrinfo config CPL_DEBUG ON ~/data/test/point.shp</p>
<p>This function can also be used to clear a setting by passing NULL as the value (note: passing NULL will not unset an existing environment variable; it will just unset a value previously set by <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a>).</p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://trac.osgeo.org/gdal/wiki/ConfigOptions">http://trac.osgeo.org/gdal/wiki/ConfigOptions</a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key of the option </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the value of the option, or NULL to clear a setting.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429CPLSetThreadLocalConfigOptionPKcPKc">
<span id="_CPPv329CPLSetThreadLocalConfigOptionPKcPKc"></span><span id="_CPPv229CPLSetThreadLocalConfigOptionPKcPKc"></span><span id="CPLSetThreadLocalConfigOption__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"></span>void <code class="descname">CPLSetThreadLocalConfigOption</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429CPLSetThreadLocalConfigOptionPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a configuration option for GDAL/OGR use. </p>
<p>Those options are defined as a (key, value) couple. The value corresponding to a key can be got later with the <a class="reference internal" href="#cpl__conv_8h_1a21a509890bf6632f1b1d836c1d3bb970"><span class="std std-ref">CPLGetConfigOption()</span></a> method.</p>
<p>This function sets the configuration option that only applies in the current thread, as opposed to <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a> which sets an option that applies on all threads. <a class="reference internal" href="#cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"><span class="std std-ref">CPLSetThreadLocalConfigOption()</span></a> will override the effect of CPLSetConfigOption) for the current thread.</p>
<p>This function can also be used to clear a setting by passing NULL as the value (note: passing NULL will not unset an existing environment variable or a value set through <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a>; it will just unset a value previously set by <a class="reference internal" href="#cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"><span class="std std-ref">CPLSetThreadLocalConfigOption()</span></a>).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key of the option </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the value of the option, or NULL to clear a setting. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CPLGetConfigOptionsv">
<span id="_CPPv319CPLGetConfigOptionsv"></span><span id="_CPPv219CPLGetConfigOptionsv"></span><span id="CPLGetConfigOptions__void"></span><span class="target" id="cpl__conv_8h_1a1856615bd350914d70f0200f7f6eb59c"></span>char **<code class="descname">CPLGetConfigOptions</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLGetConfigOptionsv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of configuration options as KEY=VALUE pairs. </p>
<p>The list is the one set through the <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a> API.</p>
<p>Options that through environment variables or with <a class="reference internal" href="#cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"><span class="std std-ref">CPLSetThreadLocalConfigOption()</span></a> will <em>not</em> be listed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a copy of the list, to be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a>. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CPLSetConfigOptionsPPCKc">
<span id="_CPPv319CPLSetConfigOptionsPPCKc"></span><span id="_CPPv219CPLSetConfigOptionsPPCKc"></span><span id="CPLSetConfigOptions__cCPCP"></span><span class="target" id="cpl__conv_8h_1a344c2f785aa2bc4ac853e8c4729b31a5"></span>void <code class="descname">CPLSetConfigOptions</code><span class="sig-paren">(</span><em class="property">const</em> char *<em class="property">const</em> *<em>papszConfigOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLSetConfigOptionsPPCKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace the full list of configuration options with the passed list of KEY=VALUE pairs. </p>
<p>This has the same effect of clearing the existing list, and setting individually each pair with the <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a> API.</p>
<p>This does not affect options set through environment variables or with <a class="reference internal" href="#cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"><span class="std std-ref">CPLSetThreadLocalConfigOption()</span></a>.</p>
<p>The passed list is copied by the function.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszConfigOptions</span></code>: the new list (or NULL).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430CPLGetThreadLocalConfigOptionsv">
<span id="_CPPv330CPLGetThreadLocalConfigOptionsv"></span><span id="_CPPv230CPLGetThreadLocalConfigOptionsv"></span><span id="CPLGetThreadLocalConfigOptions__void"></span><span class="target" id="cpl__conv_8h_1affd1b72b5afec36930784d87171ff706"></span>char **<code class="descname">CPLGetThreadLocalConfigOptions</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430CPLGetThreadLocalConfigOptionsv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of thread local configuration options as KEY=VALUE pairs. </p>
<p>Options that through environment variables or with <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a> will <em>not</em> be listed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a copy of the list, to be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a>. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430CPLSetThreadLocalConfigOptionsPPCKc">
<span id="_CPPv330CPLSetThreadLocalConfigOptionsPPCKc"></span><span id="_CPPv230CPLSetThreadLocalConfigOptionsPPCKc"></span><span id="CPLSetThreadLocalConfigOptions__cCPCP"></span><span class="target" id="cpl__conv_8h_1af8f7cb2472b60a21c7b019de160f88bb"></span>void <code class="descname">CPLSetThreadLocalConfigOptions</code><span class="sig-paren">(</span><em class="property">const</em> char *<em class="property">const</em> *<em>papszConfigOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430CPLSetThreadLocalConfigOptionsPPCKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace the full list of thread local configuration options with the passed list of KEY=VALUE pairs. </p>
<p>This has the same effect of clearing the existing list, and setting individually each pair with the <a class="reference internal" href="#cpl__conv_8h_1ac8f0d1de8f2b2069c6ea9352ca4442cd"><span class="std std-ref">CPLSetThreadLocalConfigOption()</span></a> API.</p>
<p>This does not affect options set through environment variables or with <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a>.</p>
<p>The passed list is copied by the function.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszConfigOptions</span></code>: the new list (or NULL).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLMalloc6size_t">
<span id="_CPPv39CPLMalloc6size_t"></span><span id="_CPPv29CPLMalloc6size_t"></span><span id="CPLMalloc__s"></span><span class="target" id="cpl__conv_8h_1a9a806de98fbddb1337efdb18651aa0f7"></span>void *<code class="descname">CPLMalloc</code><span class="sig-paren">(</span>size_t <em>nSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLMalloc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Safe version of malloc(). </p>
<p>This function is like the C library malloc(), but raises a CE_Fatal error with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses <a class="reference internal" href="#cpl__vsi_8h_1a3e403f4f7e059d12da468d20d604e13c"><span class="std std-ref">VSIMalloc()</span></a> to get the memory, so any hooking of <a class="reference internal" href="#cpl__vsi_8h_1a3e403f4f7e059d12da468d20d604e13c"><span class="std std-ref">VSIMalloc()</span></a> will apply to <a class="reference internal" href="#cpl__conv_8h_1a9a806de98fbddb1337efdb18651aa0f7"><span class="std std-ref">CPLMalloc()</span></a> as well. <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> or <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> can be used free memory allocated by <a class="reference internal" href="#cpl__conv_8h_1a9a806de98fbddb1337efdb18651aa0f7"><span class="std std-ref">CPLMalloc()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to newly allocated memory, only NULL if nSize is zero. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: size (in bytes) of memory block to allocate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLCalloc6size_t6size_t">
<span id="_CPPv39CPLCalloc6size_t6size_t"></span><span id="_CPPv29CPLCalloc6size_t6size_t"></span><span id="CPLCalloc__s.s"></span><span class="target" id="cpl__conv_8h_1a638021df488a13e18115e2e0c013bef0"></span>void *<code class="descname">CPLCalloc</code><span class="sig-paren">(</span>size_t <em>nCount</em>, size_t <em>nSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLCalloc6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Safe version of calloc(). </p>
<p>This function is like the C library calloc(), but raises a CE_Fatal error with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses <a class="reference internal" href="#cpl__vsi_8h_1a84892f1a5065294b3e3c400534e6a86c"><span class="std std-ref">VSICalloc()</span></a> to get the memory, so any hooking of <a class="reference internal" href="#cpl__vsi_8h_1a84892f1a5065294b3e3c400534e6a86c"><span class="std std-ref">VSICalloc()</span></a> will apply to <a class="reference internal" href="#cpl__conv_8h_1a638021df488a13e18115e2e0c013bef0"><span class="std std-ref">CPLCalloc()</span></a> as well. <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> or <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> can be used free memory allocated by <a class="reference internal" href="#cpl__conv_8h_1a638021df488a13e18115e2e0c013bef0"><span class="std std-ref">CPLCalloc()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to newly allocated memory, only NULL if nSize * nCount is NULL. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: number of objects to allocate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: size (in bytes) of object to allocate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLReallocPv6size_t">
<span id="_CPPv310CPLReallocPv6size_t"></span><span id="_CPPv210CPLReallocPv6size_t"></span><span id="CPLRealloc__voidP.s"></span><span class="target" id="cpl__conv_8h_1a4fb9e0ce588e0d7360e5f54a453e6f82"></span>void *<code class="descname">CPLRealloc</code><span class="sig-paren">(</span>void *<em>pData</em>, size_t <em>nNewSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLReallocPv6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Safe version of realloc(). </p>
<p>This function is like the C library realloc(), but raises a CE_Fatal error with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses <a class="reference internal" href="#cpl__vsi_8h_1ac022eb90a80c108cc43c619ccd17792c"><span class="std std-ref">VSIRealloc()</span></a> to get the memory, so any hooking of <a class="reference internal" href="#cpl__vsi_8h_1ac022eb90a80c108cc43c619ccd17792c"><span class="std std-ref">VSIRealloc()</span></a> will apply to <a class="reference internal" href="#cpl__conv_8h_1a4fb9e0ce588e0d7360e5f54a453e6f82"><span class="std std-ref">CPLRealloc()</span></a> as well. <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> or <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> can be used free memory allocated by <a class="reference internal" href="#cpl__conv_8h_1a4fb9e0ce588e0d7360e5f54a453e6f82"><span class="std std-ref">CPLRealloc()</span></a>.</p>
<p>It is also safe to pass NULL in as the existing memory block for <a class="reference internal" href="#cpl__conv_8h_1a4fb9e0ce588e0d7360e5f54a453e6f82"><span class="std std-ref">CPLRealloc()</span></a>, in which case it uses <a class="reference internal" href="#cpl__vsi_8h_1a3e403f4f7e059d12da468d20d604e13c"><span class="std std-ref">VSIMalloc()</span></a> to allocate a new block.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to allocated memory, only NULL if nNewSize is zero. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pData</span></code>: existing memory block which should be copied to the new block. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nNewSize</span></code>: new size (in bytes) of memory block to allocate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLStrdupPKc">
<span id="_CPPv39CPLStrdupPKc"></span><span id="_CPPv29CPLStrdupPKc"></span><span id="CPLStrdup__cCP"></span><span class="target" id="cpl__conv_8h_1a0430cfd9565379fa7c9452316c863c07"></span>char *<code class="descname">CPLStrdup</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLStrdupPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Safe version of strdup() function. </p>
<p>This function is similar to the C library strdup() function, but if the memory allocation fails it will issue a CE_Fatal error with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> instead of returning NULL. Memory allocated with <a class="reference internal" href="#cpl__conv_8h_1a0430cfd9565379fa7c9452316c863c07"><span class="std std-ref">CPLStrdup()</span></a> can be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> or <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a>.</p>
<p>It is also safe to pass a NULL string into <a class="reference internal" href="#cpl__conv_8h_1a0430cfd9565379fa7c9452316c863c07"><span class="std std-ref">CPLStrdup()</span></a>. <a class="reference internal" href="#cpl__conv_8h_1a0430cfd9565379fa7c9452316c863c07"><span class="std std-ref">CPLStrdup()</span></a> will allocate and return a zero length string (as opposed to a NULL string).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to a newly allocated copy of the string. Free with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> or <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: input string to be duplicated. May be NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLStrlwrPc">
<span id="_CPPv39CPLStrlwrPc"></span><span id="_CPPv29CPLStrlwrPc"></span><span id="CPLStrlwr__cP"></span><span class="target" id="cpl__conv_8h_1a1dac5cfc5a7e9dbcf511b461812d89b9"></span>char *<code class="descname">CPLStrlwr</code><span class="sig-paren">(</span>char *<em>pszString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLStrlwrPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert each characters of the string to lower case. </p>
<p>For example, “ABcdE” will be converted to “abcde”. This function is locale dependent.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to the same string, pszString. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: input string to be converted. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48CPLFGetsPciP4FILE">
<span id="_CPPv38CPLFGetsPciP4FILE"></span><span id="_CPPv28CPLFGetsPciP4FILE"></span><span id="CPLFGets__cP.i.FILEP"></span><span class="target" id="cpl__conv_8h_1a98e99149a5cb64a79c6a683dc4a4efe2"></span>char *<code class="descname">CPLFGets</code><span class="sig-paren">(</span>char *<em>pszBuffer</em>, int <em>nBufferSize</em>, FILE *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CPLFGetsPciP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reads in at most one less than nBufferSize characters from the fp stream and stores them into the buffer pointed to by pszBuffer. </p>
<p>Reading stops after an EOF or a newline. If a newline is read, it is <em>not</em> stored into the buffer. A ‘\0’ is stored after the last character in the buffer. All three types of newline terminators recognized by the <a class="reference internal" href="#cpl__conv_8h_1a98e99149a5cb64a79c6a683dc4a4efe2"><span class="std std-ref">CPLFGets()</span></a>: single ‘\r’ and ‘\n’ and ‘\r\n’ combination.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to the pszBuffer containing a string read from the file or NULL if the error or end of file was encountered. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszBuffer</span></code>: pointer to the targeting character buffer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBufferSize</span></code>: maximum size of the string to read (not including terminating ‘\0’). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file pointer to read from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLReadLineP4FILE">
<span id="_CPPv311CPLReadLineP4FILE"></span><span id="_CPPv211CPLReadLineP4FILE"></span><span id="CPLReadLine__FILEP"></span><span class="target" id="cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"></span><em class="property">const</em> char *<code class="descname">CPLReadLine</code><span class="sig-paren">(</span>FILE *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLReadLineP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simplified line reading from text file. </p>
<p>Read a line of text from the given file handle, taking care to capture CR and/or LF and strip off … equivalent of DKReadLine(). Pointer to an internal buffer is returned. The application shouldn’t free it, or depend on its value past the next call to <a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a>.</p>
<p>Note that <a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a> uses VSIFGets(), so any hooking of VSI file services should apply to <a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a> as well.</p>
<p><a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a> maintains an internal buffer, which will appear as a single block memory leak in some circumstances. <a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a> may be called with a NULL FILE * at any time to free this working buffer.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file pointer opened with VSIFOpen().</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLReadLineLP8VSILFILE">
<span id="_CPPv312CPLReadLineLP8VSILFILE"></span><span id="_CPPv212CPLReadLineLP8VSILFILE"></span><span id="CPLReadLineL__VSILFILEP"></span><span class="target" id="cpl__conv_8h_1af049d0b413b82ac770d33cc76f525825"></span><em class="property">const</em> char *<code class="descname">CPLReadLineL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLReadLineLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simplified line reading from text file. </p>
<p>Similar to <a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a>, but reading from a large file API handle.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file pointer opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLReadLine2LP8VSILFILEi12CSLConstList">
<span id="_CPPv313CPLReadLine2LP8VSILFILEi12CSLConstList"></span><span id="_CPPv213CPLReadLine2LP8VSILFILEi12CSLConstList"></span><span id="CPLReadLine2L__VSILFILEP.i.CSLConstList"></span><span class="target" id="cpl__conv_8h_1a406af5691fe60f59a33a28ffff9c3410"></span><em class="property">const</em> char *<code class="descname">CPLReadLine2L</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, int <em>nMaxCars</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLReadLine2LP8VSILFILEi12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simplified line reading from text file. </p>
<p>Similar to <a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a>, but reading from a large file API handle.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered or the maximum number of characters allowed reached.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.7.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file pointer opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxCars</span></code>: maximum number of characters allowed, or -1 for no limit. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL-terminated array of options. Unused for now.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLReadLine3LP8VSILFILEiPi12CSLConstList">
<span id="_CPPv313CPLReadLine3LP8VSILFILEiPi12CSLConstList"></span><span id="_CPPv213CPLReadLine3LP8VSILFILEiPi12CSLConstList"></span><span id="CPLReadLine3L__VSILFILEP.i.iP.CSLConstList"></span><span class="target" id="cpl__conv_8h_1a6ba19cdc06e4f30238e2d8c909466f0d"></span><em class="property">const</em> char *<code class="descname">CPLReadLine3L</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, int <em>nMaxCars</em>, int *<em>pnBufLength</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLReadLine3LP8VSILFILEiPi12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simplified line reading from text file. </p>
<p>Similar to <a class="reference internal" href="#cpl__conv_8h_1a0ad35dbadd4f1d04bbedd66774be940f"><span class="std std-ref">CPLReadLine()</span></a>, but reading from a large file API handle.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered or the maximum number of characters allowed reached.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file pointer opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxCars</span></code>: maximum number of characters allowed, or -1 for no limit. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL-terminated array of options. Unused for now. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">pnBufLength</span></code>: size of output string (must be non-NULL)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv47CPLAtofPKc">
<span id="_CPPv37CPLAtofPKc"></span><span id="_CPPv27CPLAtofPKc"></span><span id="CPLAtof__cCP"></span><span class="target" id="cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"></span>double <code class="descname">CPLAtof</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>nptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47CPLAtofPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. The behaviour is the same as</p>
<p>CPLStrtod(nptr, (char **)NULL);</p>
<p>This function does the same as standard atof(3), but does not take locale in account. That means, the decimal delimiter is always ‘.’ (decimal point). Use <a class="reference internal" href="#cpl__conv_8h_1a0a01ca071035c36d4b4f85336e08c5d5"><span class="std std-ref">CPLAtofDelim()</span></a> function if you want to specify custom delimiter.</p>
<p>IMPORTANT NOTE:</p>
<p>Existence of this function does not mean you should always use it. Sometimes you should use standard locale aware atof(3) and its family. When you need to process the user’s input (for example, command line parameters) use atof(3), because the user works in a localized environment and the user’s input will be done according to the locale set. In particular that means we should not make assumptions about character used as decimal delimiter, it can be either “.” or “,”.</p>
<p>But when you are parsing some ASCII file in predefined format, you most likely need <a class="reference internal" href="#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a>, because such files distributed across the systems with different locales and floating point representation should be considered as a part of file format. If the format uses “.” as a delimiter the same character must be used when parsing number regardless of actual locale setting.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Converted value, if any. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nptr</span></code>: Pointer to string to convert.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLAtofDelimPKcc">
<span id="_CPPv312CPLAtofDelimPKcc"></span><span id="_CPPv212CPLAtofDelimPKcc"></span><span id="CPLAtofDelim__cCP.c"></span><span class="target" id="cpl__conv_8h_1a0a01ca071035c36d4b4f85336e08c5d5"></span>double <code class="descname">CPLAtofDelim</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>nptr</em>, char <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLAtofDelimPKcc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. The behaviour is the same as</p>
<p>CPLStrtodDelim(nptr, (char **)NULL, point);</p>
<p>This function does the same as standard atof(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for <a class="reference internal" href="#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a> function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Converted value, if any. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nptr</span></code>: Pointer to string to convert. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point</span></code>: Decimal delimiter.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLStrtodPKcPPc">
<span id="_CPPv39CPLStrtodPKcPPc"></span><span id="_CPPv29CPLStrtodPKcPPc"></span><span id="CPLStrtod__cCP.cPP"></span><span class="target" id="cpl__conv_8h_1a2388e43fb089a354eb3583016b2a3b00"></span>double <code class="descname">CPLStrtod</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>nptr</em>, char **<em>endptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLStrtodPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard strtod(3), but does not take locale in account. That means, the decimal delimiter is always ‘.’ (decimal point). Use <a class="reference internal" href="#cpl__conv_8h_1ac96c5f1823c54ef96b5783208c817817"><span class="std std-ref">CPLStrtodDelim()</span></a> function if you want to specify custom delimiter. Also see notes for <a class="reference internal" href="#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a> function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Converted value, if any. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nptr</span></code>: Pointer to string to convert. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endptr</span></code>: If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLStrtodDelimPKcPPcc">
<span id="_CPPv314CPLStrtodDelimPKcPPcc"></span><span id="_CPPv214CPLStrtodDelimPKcPPcc"></span><span id="CPLStrtodDelim__cCP.cPP.c"></span><span class="target" id="cpl__conv_8h_1ac96c5f1823c54ef96b5783208c817817"></span>double <code class="descname">CPLStrtodDelim</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>nptr</em>, char **<em>endptr</em>, char <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLStrtodDelimPKcPPcc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts ASCII string to floating point number using specified delimiter. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard strtod(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for <a class="reference internal" href="#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a> function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Converted value, if any. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nptr</span></code>: Pointer to string to convert. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endptr</span></code>: If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point</span></code>: Decimal delimiter.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLStrtofPKcPPc">
<span id="_CPPv39CPLStrtofPKcPPc"></span><span id="_CPPv29CPLStrtofPKcPPc"></span><span id="CPLStrtof__cCP.cPP"></span><span class="target" id="cpl__conv_8h_1a1ccda187ed172fd6e33cd98223328531"></span>float <code class="descname">CPLStrtof</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>nptr</em>, char **<em>endptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLStrtofPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to single floating point representation. This function does the same as standard strtof(3), but does not take locale in account. That means, the decimal delimiter is always ‘.’ (decimal point). Use <a class="reference internal" href="#cpl__conv_8h_1a3a102a1417c98a242900fb8c0076fc1b"><span class="std std-ref">CPLStrtofDelim()</span></a> function if you want to specify custom delimiter. Also see notes for <a class="reference internal" href="#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a> function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Converted value, if any. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nptr</span></code>: Pointer to string to convert. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endptr</span></code>: If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLStrtofDelimPKcPPcc">
<span id="_CPPv314CPLStrtofDelimPKcPPcc"></span><span id="_CPPv214CPLStrtofDelimPKcPPcc"></span><span id="CPLStrtofDelim__cCP.cPP.c"></span><span class="target" id="cpl__conv_8h_1a3a102a1417c98a242900fb8c0076fc1b"></span>float <code class="descname">CPLStrtofDelim</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>nptr</em>, char **<em>endptr</em>, char <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLStrtofDelimPKcPPcc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts ASCII string to floating point number using specified delimiter. </p>
<p>This function converts the initial portion of the string pointed to by nptr to single floating point representation. This function does the same as standard strtof(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for <a class="reference internal" href="#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a> function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Converted value, if any. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nptr</span></code>: Pointer to string to convert. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endptr</span></code>: If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">point</span></code>: Decimal delimiter.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48CPLAtofMPKc">
<span id="_CPPv38CPLAtofMPKc"></span><span id="_CPPv28CPLAtofMPKc"></span><span id="CPLAtofM__cCP"></span><span class="target" id="cpl__conv_8h_1aa07cd1b2aa5e76eb67ba952440198796"></span>double <code class="descname">CPLAtofM</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>nptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CPLAtofMPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts ASCII string to floating point number using any numeric locale. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard atof(), but it allows a variety of locale representations. That is it supports numeric values with either a comma or a period for the decimal delimiter.</p>
<p>PS. The M stands for Multi-lingual.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Converted value, if any. Zero on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nptr</span></code>: The string to convert.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLScanStringPKciii">
<span id="_CPPv313CPLScanStringPKciii"></span><span id="_CPPv213CPLScanStringPKciii"></span><span id="CPLScanString__cCP.i.i.i"></span><span class="target" id="cpl__conv_8h_1a9c2ddf6a8bdb1a9bf2e90e7acbea2cdc"></span>char *<code class="descname">CPLScanString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>nMaxLength</em>, int <em>bTrimSpaces</em>, int <em>bNormalize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLScanStringPKciii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scan up to a maximum number of characters from a given string, allocate a buffer for a new string and fill it with scanned characters. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Pointer to the resulting string buffer. Caller responsible to free this buffer with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing characters to be scanned. It may be terminated with a null character.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLength</span></code>: The maximum number of character to read. Less characters will be read if a null character is encountered.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bTrimSpaces</span></code>: If TRUE, trim ending spaces from the input string. Character considered as empty using isspace(3) function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bNormalize</span></code>: If TRUE, replace ‘:’ symbol with the ‘_’. It is needed if resulting string will be used in CPL dictionaries.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLScanDoublePKci">
<span id="_CPPv313CPLScanDoublePKci"></span><span id="_CPPv213CPLScanDoublePKci"></span><span id="CPLScanDouble__cCP.i"></span><span class="target" id="cpl__conv_8h_1abcdeae39a61518c9c31ecc593eeff621"></span>double <code class="descname">CPLScanDouble</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>nMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLScanDoublePKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract double from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a double. This function uses <a class="reference internal" href="#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a> to convert string to double value, so it uses a comma as a decimal delimiter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Double value, converted from its ASCII form. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing characters to be scanned. It may be terminated with a null character.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLength</span></code>: The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLScanLongPKci">
<span id="_CPPv311CPLScanLongPKci"></span><span id="_CPPv211CPLScanLongPKci"></span><span id="CPLScanLong__cCP.i"></span><span class="target" id="cpl__conv_8h_1a338bbe67c148d2555861eb5563b17303"></span>long <code class="descname">CPLScanLong</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>nMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLScanLongPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scan up to a maximum number of characters from a string and convert the result to a long. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Long value, converted from its ASCII form. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing characters to be scanned. It may be terminated with a null character.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLength</span></code>: The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLScanULongPKci">
<span id="_CPPv312CPLScanULongPKci"></span><span id="_CPPv212CPLScanULongPKci"></span><span id="CPLScanULong__cCP.i"></span><span class="target" id="cpl__conv_8h_1ac6e9643c26ab4ee22df95e3dd18c959a"></span>unsigned long <code class="descname">CPLScanULong</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>nMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLScanULongPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scan up to a maximum number of characters from a string and convert the result to a unsigned long. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Unsigned long value, converted from its ASCII form. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing characters to be scanned. It may be terminated with a null character.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLength</span></code>: The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLScanUIntBigPKci">
<span id="_CPPv314CPLScanUIntBigPKci"></span><span id="_CPPv214CPLScanUIntBigPKci"></span><span id="CPLScanUIntBig__cCP.i"></span><span class="target" id="cpl__conv_8h_1ab4a8e6cf7a0d0f662f6cd4555b074bb5"></span><a class="reference internal" href="#_CPPv48GUIntBig" title="GUIntBig">GUIntBig</a> <code class="descname">CPLScanUIntBig</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>nMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLScanUIntBigPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract big integer from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a GUIntBig.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GUIntBig value, converted from its ASCII form. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing characters to be scanned. It may be terminated with a null character.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLength</span></code>: The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLAtoGIntBigPKc">
<span id="_CPPv313CPLAtoGIntBigPKc"></span><span id="_CPPv213CPLAtoGIntBigPKc"></span><span id="CPLAtoGIntBig__cCP"></span><span class="target" id="cpl__conv_8h_1aa35579a348f417a35965d6be69cde090"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">CPLAtoGIntBig</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLAtoGIntBigPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a string to a 64 bit signed integer. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>64 bit signed integer. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing 64 bit signed integer. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLAtoGIntBigExPKciPi">
<span id="_CPPv315CPLAtoGIntBigExPKciPi"></span><span id="_CPPv215CPLAtoGIntBigExPKciPi"></span><span id="CPLAtoGIntBigEx__cCP.i.iP"></span><span class="target" id="cpl__conv_8h_1a646aeb2044bf0ff4dace5793f17c11e8"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">CPLAtoGIntBigEx</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>bWarn</em>, int *<em>pbOverflow</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLAtoGIntBigExPKciPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a string to a 64 bit signed integer. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>64 bit signed integer. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing 64 bit signed integer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bWarn</span></code>: Issue a warning if an overflow occurs during conversion </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pbOverflow</span></code>: Pointer to an integer to store if an overflow occurred, or NULL </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLScanPointerPKci">
<span id="_CPPv314CPLScanPointerPKci"></span><span id="_CPPv214CPLScanPointerPKci"></span><span id="CPLScanPointer__cCP.i"></span><span class="target" id="cpl__conv_8h_1a2dea859a1f5690d25e5eb32f8d091905"></span>void *<code class="descname">CPLScanPointer</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>nMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLScanPointerPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract pointer from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a pointer.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer value, converted from its ASCII form. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: String containing characters to be scanned. It may be terminated with a null character.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLength</span></code>: The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLPrintStringPcPKci">
<span id="_CPPv314CPLPrintStringPcPKci"></span><span id="_CPPv214CPLPrintStringPcPKci"></span><span id="CPLPrintString__cP.cCP.i"></span><span class="target" id="cpl__conv_8h_1ae284b3e504edca3eb1eaf568469d61ba"></span>int <code class="descname">CPLPrintString</code><span class="sig-paren">(</span>char *<em>pszDest</em>, <em class="property">const</em> char *<em>pszSrc</em>, int <em>nMaxLen</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLPrintStringPcPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy the string pointed to by pszSrc, NOT including the terminating `\0’ character, to the array pointed to by pszDest. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Number of characters printed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDest</span></code>: Pointer to the destination string buffer. Should be large enough to hold the resulting string.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrc</span></code>: Pointer to the source buffer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLen</span></code>: Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLPrintStringFillPcPKci">
<span id="_CPPv318CPLPrintStringFillPcPKci"></span><span id="_CPPv218CPLPrintStringFillPcPKci"></span><span id="CPLPrintStringFill__cP.cCP.i"></span><span class="target" id="cpl__conv_8h_1a0bdbcb209eb9b8e2e6be4fa6e0b750f6"></span>int <code class="descname">CPLPrintStringFill</code><span class="sig-paren">(</span>char *<em>pszDest</em>, <em class="property">const</em> char *<em>pszSrc</em>, int <em>nMaxLen</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLPrintStringFillPcPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy the string pointed to by pszSrc, NOT including the terminating `\0’ character, to the array pointed to by pszDest. </p>
<p>Remainder of the destination string will be filled with space characters. This is only difference from the PrintString().</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Number of characters printed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDest</span></code>: Pointer to the destination string buffer. Should be large enough to hold the resulting string.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrc</span></code>: Pointer to the source buffer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLen</span></code>: Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLPrintInt32Pc6GInt32i">
<span id="_CPPv313CPLPrintInt32Pc6GInt32i"></span><span id="_CPPv213CPLPrintInt32Pc6GInt32i"></span><span id="CPLPrintInt32__cP.GInt32.i"></span><span class="target" id="cpl__conv_8h_1a33618500e56ec12e6775b3ed9014b8fb"></span>int <code class="descname">CPLPrintInt32</code><span class="sig-paren">(</span>char *<em>pszBuffer</em>, <a class="reference internal" href="#_CPPv46GInt32" title="GInt32">GInt32</a> <em>iValue</em>, int <em>nMaxLen</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLPrintInt32Pc6GInt32i" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print GInt32 value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Number of characters printed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszBuffer</span></code>: Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iValue</span></code>: Numerical value to print.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLen</span></code>: Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLPrintUIntBigPc8GUIntBigi">
<span id="_CPPv315CPLPrintUIntBigPc8GUIntBigi"></span><span id="_CPPv215CPLPrintUIntBigPc8GUIntBigi"></span><span id="CPLPrintUIntBig__cP.GUIntBig.i"></span><span class="target" id="cpl__conv_8h_1a13ca1da1151489f1eee7770296f164aa"></span>int <code class="descname">CPLPrintUIntBig</code><span class="sig-paren">(</span>char *<em>pszBuffer</em>, <a class="reference internal" href="#_CPPv48GUIntBig" title="GUIntBig">GUIntBig</a> <em>iValue</em>, int <em>nMaxLen</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLPrintUIntBigPc8GUIntBigi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print GUIntBig value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Number of characters printed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszBuffer</span></code>: Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iValue</span></code>: Numerical value to print.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLen</span></code>: Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLPrintDoublePcPKcdPKc">
<span id="_CPPv314CPLPrintDoublePcPKcdPKc"></span><span id="_CPPv214CPLPrintDoublePcPKcdPKc"></span><span id="CPLPrintDouble__cP.cCP.double.cCP"></span><span class="target" id="cpl__conv_8h_1ad77e478b4f2e14cc03ae23a9c81434c9"></span>int <code class="descname">CPLPrintDouble</code><span class="sig-paren">(</span>char *<em>pszBuffer</em>, <em class="property">const</em> char *<em>pszFormat</em>, double <em>dfValue</em>, <em class="property">const</em> char *<em>pszLocale</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLPrintDoublePcPKcdPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print double value into specified string buffer. </p>
<p>Exponential character flag ‘E’ (or ‘e’) will be replaced with ‘D’, as in Fortran. Resulting string will not to be NULL-terminated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Number of characters printed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszBuffer</span></code>: Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFormat</span></code>: Format specifier (for example, “%16.9E”).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfValue</span></code>: Numerical value to print.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszLocale</span></code>: Unused.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLPrintTimePciPKcPK2tmPKc">
<span id="_CPPv312CPLPrintTimePciPKcPK2tmPKc"></span><span id="_CPPv212CPLPrintTimePciPKcPK2tmPKc"></span><span id="CPLPrintTime__cP.i.cCP.tmCP.cCP"></span><span class="target" id="cpl__conv_8h_1a5be9cf1de05769139a77339ffb970ce4"></span>int <code class="descname">CPLPrintTime</code><span class="sig-paren">(</span>char *<em>pszBuffer</em>, int <em>nMaxLen</em>, <em class="property">const</em> char *<em>pszFormat</em>, <em class="property">const</em> <em class="property">struct</em> tm *<em>poBrokenTime</em>, <em class="property">const</em> char *<em>pszLocale</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLPrintTimePciPKcPK2tmPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print specified time value accordingly to the format options and specified locale name. </p>
<p>This function does following:</p>
<p><ul class="simple">
<li><p>if locale parameter is not NULL, the current locale setting will be stored and replaced with the specified one;</p></li>
<li><p>format time value with the strftime(3) function;</p></li>
<li><p>restore back current locale, if was saved.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Number of characters printed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszBuffer</span></code>: Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLen</span></code>: Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFormat</span></code>: Controls the output format. Options are the same as for strftime(3) function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poBrokenTime</span></code>: Pointer to the broken-down time structure. May be requested with the VSIGMTime() and VSILocalTime() functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszLocale</span></code>: Pointer to a character string containing locale name (“C”, “POSIX”, “us_US”, “ru_RU.KOI8-R” etc.). If NULL we will not manipulate with locale settings and current process locale will be used for printing. Be aware that it may be unsuitable to use current locale for printing time, because all names will be printed in your native language, as well as time format settings also may be adjusted differently from the C/POSIX defaults. To solve these problems this option was introduced.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLPrintPointerPcPvi">
<span id="_CPPv315CPLPrintPointerPcPvi"></span><span id="_CPPv215CPLPrintPointerPcPvi"></span><span id="CPLPrintPointer__cP.voidP.i"></span><span class="target" id="cpl__conv_8h_1af268becc479787ae48bb2607d0000886"></span>int <code class="descname">CPLPrintPointer</code><span class="sig-paren">(</span>char *<em>pszBuffer</em>, void *<em>pValue</em>, int <em>nMaxLen</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLPrintPointerPcPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print pointer value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Number of characters printed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszBuffer</span></code>: Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pValue</span></code>: Pointer to ASCII encode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLen</span></code>: Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLGetSymbolPKcPKc">
<span id="_CPPv312CPLGetSymbolPKcPKc"></span><span id="_CPPv212CPLGetSymbolPKcPKc"></span><span id="CPLGetSymbol__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1affa4a3c8bb4ecbbb9ae3d7ffb35d3572"></span>void *<code class="descname">CPLGetSymbol</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszLibrary</em>, <em class="property">const</em> char *<em>pszSymbolName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLGetSymbolPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a function pointer from a shared library / DLL. </p>
<p>This function is meant to abstract access to shared libraries and DLLs and performs functions similar to dlopen()/dlsym() on Unix and LoadLibrary() / GetProcAddress() on Windows.</p>
<p>If no support for loading entry points from a shared library is available this function will always return NULL. Rules on when this function issues a <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> or not are not currently well defined, and will have to be resolved in the future.</p>
<p>Currently <a class="reference internal" href="#cpl__conv_8h_1affa4a3c8bb4ecbbb9ae3d7ffb35d3572"><span class="std std-ref">CPLGetSymbol()</span></a> doesn’t try to: <ul class="simple">
<li><p>prevent the reference count on the library from going up for every request, or given any opportunity to unload the library. </p></li>
<li><p>Attempt to look for the library in non-standard locations. </p></li>
<li><p>Attempt to try variations on the symbol name, like pre-pending or post-pending an underscore. </p></li>
</ul>
</p>
<p>Some of these issues may be worked on in the future.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A pointer to the function if found, or NULL if the function isn’t found, or the shared library can’t be loaded. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszLibrary</span></code>: the name of the shared library or DLL containing the function. May contain path to file. If not system supplies search paths will be used. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSymbolName</span></code>: the name of the function to fetch a pointer to. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLGetExecPathPci">
<span id="_CPPv314CPLGetExecPathPci"></span><span id="_CPPv214CPLGetExecPathPci"></span><span id="CPLGetExecPath__cP.i"></span><span class="target" id="cpl__conv_8h_1a5325c900de0918020b747ed07d98da24"></span>int <code class="descname">CPLGetExecPath</code><span class="sig-paren">(</span>char *<em>pszPathBuf</em>, int <em>nMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLGetExecPathPci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch path of executable. </p>
<p>The path to the executable currently running is returned. This path includes the name of the executable. Currently this only works on win32 and linux platforms. The returned path is UTF-8 encoded.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>FALSE on failure or TRUE on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPathBuf</span></code>: the buffer into which the path is placed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLength</span></code>: the buffer size, MAX_PATH+1 is suggested.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLGetPathPKc">
<span id="_CPPv310CPLGetPathPKc"></span><span id="_CPPv210CPLGetPathPKc"></span><span id="CPLGetPath__cCP"></span><span class="target" id="cpl__conv_8h_1a3773ac99e54aaaa6c6210160d0042fec"></span><em class="property">const</em> char *<code class="descname">CPLGetPath</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLGetPathPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract directory path portion of filename. </p>
<p>Returns a string containing the directory path portion of the passed filename. If there is no path in the passed filename an empty string will be returned (not NULL).</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. The returned will generally not contain a trailing path separator. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the filename potentially including a path.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLGetDirnamePKc">
<span id="_CPPv313CPLGetDirnamePKc"></span><span id="_CPPv213CPLGetDirnamePKc"></span><span id="CPLGetDirname__cCP"></span><span class="target" id="cpl__conv_8h_1a94eade42e0d1ecc62d3f36de48bb8b2e"></span><em class="property">const</em> char *<code class="descname">CPLGetDirname</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLGetDirnamePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract directory path portion of filename. </p>
<p>Returns a string containing the directory path portion of the passed filename. If there is no path in the passed filename the dot will be returned. It is the only difference from <a class="reference internal" href="#cpl__conv_8h_1a3773ac99e54aaaa6c6210160d0042fec"><span class="std std-ref">CPLGetPath()</span></a>.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. The returned will generally not contain a trailing path separator. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the filename potentially including a path.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLGetFilenamePKc">
<span id="_CPPv314CPLGetFilenamePKc"></span><span id="_CPPv214CPLGetFilenamePKc"></span><span id="CPLGetFilename__cCP"></span><span class="target" id="cpl__conv_8h_1a55105aaa86ceeb6346930ba1e80bf126"></span><em class="property">const</em> char *<code class="descname">CPLGetFilename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFullFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLGetFilenamePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract non-directory portion of filename. </p>
<p>Returns a string containing the bare filename portion of the passed filename. If there is no filename (passed value ends in trailing directory separator) an empty string is returned.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>just the non-directory portion of the path (points back into original string). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFullFilename</span></code>: the full filename potentially including a path.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLGetBasenamePKc">
<span id="_CPPv314CPLGetBasenamePKc"></span><span id="_CPPv214CPLGetBasenamePKc"></span><span id="CPLGetBasename__cCP"></span><span class="target" id="cpl__conv_8h_1a1c55dcd6abf2981f2275842277491ebc"></span><em class="property">const</em> char *<code class="descname">CPLGetBasename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFullFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLGetBasenamePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract basename (non-directory, non-extension) portion of filename. </p>
<p>Returns a string containing the file basename portion of the passed name. If there is no basename (passed value ends in trailing directory separator, or filename starts with a dot) an empty string is returned.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>just the non-directory, non-extension portion of the path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFullFilename</span></code>: the full filename potentially including a path.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLGetExtensionPKc">
<span id="_CPPv315CPLGetExtensionPKc"></span><span id="_CPPv215CPLGetExtensionPKc"></span><span id="CPLGetExtension__cCP"></span><span class="target" id="cpl__conv_8h_1ad7282f4e659cb5f8b5566bec1ed44fe1"></span><em class="property">const</em> char *<code class="descname">CPLGetExtension</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFullFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLGetExtensionPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract filename extension from full filename. </p>
<p>Returns a string containing the extension portion of the passed name. If there is no extension (the filename has no dot) an empty string is returned. The returned extension will not include the period.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>just the extension portion of the path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFullFilename</span></code>: the full filename potentially including a path.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLGetCurrentDirv">
<span id="_CPPv316CPLGetCurrentDirv"></span><span id="_CPPv216CPLGetCurrentDirv"></span><span id="CPLGetCurrentDir__void"></span><span class="target" id="cpl__conv_8h_1afc51f03a3789be8a47b8a753eb897856"></span>char *<code class="descname">CPLGetCurrentDir</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLGetCurrentDirv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the current working directory name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a pointer to buffer, containing current working directory path or NULL in case of error. User is responsible to free that buffer after usage with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> function. If HAVE_GETCWD macro is not defined, the function returns NULL. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLFormFilenamePKcPKcPKc">
<span id="_CPPv315CPLFormFilenamePKcPKcPKc"></span><span id="_CPPv215CPLFormFilenamePKcPKcPKc"></span><span id="CPLFormFilename__cCP.cCP.cCP"></span><span class="target" id="cpl__conv_8h_1aebdb31eaceea3e7ec4186bcd066d4ff3"></span><em class="property">const</em> char *<code class="descname">CPLFormFilename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em>, <em class="property">const</em> char *<em>pszBasename</em>, <em class="property">const</em> char *<em>pszExtension</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLFormFilenamePKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Build a full file path from a passed path, file basename and extension. </p>
<p>The path, and extension are optional. The basename may in fact contain an extension if desired.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a fully formed filename in an internal static string. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: directory path to the directory containing the file. This may be relative or absolute, and may have a trailing path separator or not. May be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszBasename</span></code>: file basename. May optionally have path and/or extension. Must <em>NOT</em> be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszExtension</span></code>: file extension, optionally including the period. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLFormCIFilenamePKcPKcPKc">
<span id="_CPPv317CPLFormCIFilenamePKcPKcPKc"></span><span id="_CPPv217CPLFormCIFilenamePKcPKcPKc"></span><span id="CPLFormCIFilename__cCP.cCP.cCP"></span><span class="target" id="cpl__conv_8h_1a243587e2c9947544c3ca0221483650ef"></span><em class="property">const</em> char *<code class="descname">CPLFormCIFilename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em>, <em class="property">const</em> char *<em>pszBasename</em>, <em class="property">const</em> char *<em>pszExtension</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLFormCIFilenamePKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Case insensitive file searching, returning full path. </p>
<p>This function tries to return the path to a file regardless of whether the file exactly matches the basename, and extension case, or is all upper case, or all lower case. The path is treated as case sensitive. This function is equivalent to <a class="reference internal" href="#cpl__conv_8h_1aebdb31eaceea3e7ec4186bcd066d4ff3"><span class="std std-ref">CPLFormFilename()</span></a> on case insensitive file systems (like Windows).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a fully formed filename in an internal static string. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: directory path to the directory containing the file. This may be relative or absolute, and may have a trailing path separator or not. May be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszBasename</span></code>: file basename. May optionally have path and/or extension. May not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszExtension</span></code>: file extension, optionally including the period. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLResetExtensionPKcPKc">
<span id="_CPPv317CPLResetExtensionPKcPKc"></span><span id="_CPPv217CPLResetExtensionPKcPKc"></span><span id="CPLResetExtension__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1ae1b5155d645dd3d2e2265391903d1a4b"></span><em class="property">const</em> char *<code class="descname">CPLResetExtension</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em>, <em class="property">const</em> char *<em>pszExt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLResetExtensionPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace the extension with the provided one. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an altered filename with the new extension. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the input path, this string is not altered. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszExt</span></code>: the new extension to apply to the given path.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426CPLProjectRelativeFilenamePKcPKc">
<span id="_CPPv326CPLProjectRelativeFilenamePKcPKc"></span><span id="_CPPv226CPLProjectRelativeFilenamePKcPKc"></span><span id="CPLProjectRelativeFilename__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1a0ba3cb8c8dc1c763df874bee6639f56d"></span><em class="property">const</em> char *<code class="descname">CPLProjectRelativeFilename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszProjectDir</em>, <em class="property">const</em> char *<em>pszSecondaryFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426CPLProjectRelativeFilenamePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a file relative to a project file. </p>
<p>Given the path to a “project” directory, and a path to a secondary file referenced from that project, build a path to the secondary file that the current application can use. If the secondary path is already absolute, rather than relative, then it will be returned unaltered.</p>
<p>Examples: </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a composed path to the secondary file. The returned string is internal and should not be altered, freed, or depending on past the next CPL call. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszProjectDir</span></code>: the directory relative to which the secondary files path should be interpreted. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSecondaryFilename</span></code>: the filename (potentially with path) that is to be interpreted relative to the project directory.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421CPLIsFilenameRelativePKc">
<span id="_CPPv321CPLIsFilenameRelativePKc"></span><span id="_CPPv221CPLIsFilenameRelativePKc"></span><span id="CPLIsFilenameRelative__cCP"></span><span class="target" id="cpl__conv_8h_1a0cd8ae8d760125ec5b01958a776691ec"></span>int <code class="descname">CPLIsFilenameRelative</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLIsFilenameRelativePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Is filename relative or absolute? </p>
<p>The test is filesystem convention agnostic. That is it will test for Unix style and windows style path conventions regardless of the actual system in use.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the filename is relative or FALSE if it is absolute. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the filename with path to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLExtractRelativePathPKcPKcPi">
<span id="_CPPv322CPLExtractRelativePathPKcPKcPi"></span><span id="_CPPv222CPLExtractRelativePathPKcPKcPi"></span><span id="CPLExtractRelativePath__cCP.cCP.iP"></span><span class="target" id="cpl__conv_8h_1a689fd90b51dfb0a77c4fec2af5e7088d"></span><em class="property">const</em> char *<code class="descname">CPLExtractRelativePath</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszBaseDir</em>, <em class="property">const</em> char *<em>pszTarget</em>, int *<em>pbGotRelative</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLExtractRelativePathPKcPKcPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get relative path from directory to target file. </p>
<p>Computes a relative path for pszTarget relative to pszBaseDir. Currently this only works if they share a common base path. The returned path is normally into the pszTarget string. It should only be considered valid as long as pszTarget is valid or till the next call to this function, whichever comes first.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an adjusted path or the original if it could not be made relative to the pszBaseFile’s path. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszBaseDir</span></code>: the name of the directory relative to which the path should be computed. pszBaseDir may be NULL in which case the original target is returned without relativizing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszTarget</span></code>: the filename to be changed to be relative to pszBaseDir.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pbGotRelative</span></code>: Pointer to location in which a flag is placed indicating that the returned path is relative to the basename (TRUE) or not (FALSE). This pointer may be NULL if flag is not desired.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421CPLCleanTrailingSlashPKc">
<span id="_CPPv321CPLCleanTrailingSlashPKc"></span><span id="_CPPv221CPLCleanTrailingSlashPKc"></span><span id="CPLCleanTrailingSlash__cCP"></span><span class="target" id="cpl__conv_8h_1a5722f2c363823a83b12ed9d187c0e33f"></span><em class="property">const</em> char *<code class="descname">CPLCleanTrailingSlash</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLCleanTrailingSlashPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove trailing forward/backward slash from the path for UNIX/Windows resp. </p>
<p>Returns a string containing the portion of the passed path string with trailing slash removed. If there is no path in the passed filename an empty string will be returned (not NULL).</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the path to be cleaned up</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421CPLCorrespondingPathsPKcPKcPPc">
<span id="_CPPv321CPLCorrespondingPathsPKcPKcPPc"></span><span id="_CPPv221CPLCorrespondingPathsPKcPKcPPc"></span><span id="CPLCorrespondingPaths__cCP.cCP.cPP"></span><span class="target" id="cpl__conv_8h_1a538936de58c99f26265b166c5b9cac89"></span>char **<code class="descname">CPLCorrespondingPaths</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszOldFilename</em>, <em class="property">const</em> char *<em>pszNewFilename</em>, char **<em>papszFileList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLCorrespondingPathsPKcPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Identify corresponding paths. </p>
<p>Given a prototype old and new filename this function will attempt to determine corresponding names for a set of other old filenames that will rename them in a similar manner. This correspondence assumes there are two possibly kinds of renaming going on. A change of path, and a change of filename stem.</p>
<p>If a consistent renaming cannot be established for all the files this function will return indicating an error.</p>
<p>The returned file list becomes owned by the caller and should be destroyed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a list of files corresponding to papszFileList but renamed to correspond to pszNewFilename. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszOldFilename</span></code>: path to old prototype file. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNewFilename</span></code>: path to new prototype file. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszFileList</span></code>: list of other files associated with pszOldFilename to rename similarly.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLCheckForFilePcPPc">
<span id="_CPPv315CPLCheckForFilePcPPc"></span><span id="_CPPv215CPLCheckForFilePcPPc"></span><span id="CPLCheckForFile__cP.cPP"></span><span class="target" id="cpl__conv_8h_1afa9b8f28ae84d5d898b7a3afc6bb6a4b"></span>int <code class="descname">CPLCheckForFile</code><span class="sig-paren">(</span>char *<em>pszFilename</em>, char **<em>papszSiblingList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLCheckForFilePcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check for file existence. </p>
<p>The function checks if a named file exists in the filesystem, hopefully in an efficient fashion if a sibling file list is available. It exists primarily to do faster file checking for functions like GDAL open methods that get a list of files from the target directory.</p>
<p>If the sibling file list exists (is not NULL) it is assumed to be a list of files in the same directory as the target file, and it will be checked (case insensitively) for a match. If a match is found, pszFilename is updated with the correct case and TRUE is returned.</p>
<p>If papszSiblingFiles is NULL, a <a class="reference internal" href="#cpl__vsi_8h_1a2fc1cc4f2893dc422eb57e430798991a"><span class="std std-ref">VSIStatL()</span></a> is used to test for the files existence, and no case insensitive testing is done.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if a match is found, or FALSE if not. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: name of file to check for - filename case updated in some cases. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszSiblingFiles</span></code>: a list of files in the same directory as pszFilename if available, or NULL. This list should have no path components.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423CPLGenerateTempFilenamePKc">
<span id="_CPPv323CPLGenerateTempFilenamePKc"></span><span id="_CPPv223CPLGenerateTempFilenamePKc"></span><span id="CPLGenerateTempFilename__cCP"></span><span class="target" id="cpl__conv_8h_1a3341f3e510bf9531dac35223a9e69bc8"></span><em class="property">const</em> char *<code class="descname">CPLGenerateTempFilename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszStem</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423CPLGenerateTempFilenamePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Generate temporary file name. </p>
<p>Returns a filename that may be used for a temporary file. The location of the file tries to follow operating system semantics but may be forced via the CPL_TMPDIR configuration option.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a filename which is valid till the next CPL call in this thread. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszStem</span></code>: if non-NULL this will be part of the filename.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLExpandTildePKc">
<span id="_CPPv314CPLExpandTildePKc"></span><span id="_CPPv214CPLExpandTildePKc"></span><span id="CPLExpandTilde__cCP"></span><span class="target" id="cpl__conv_8h_1a99ccbab1d79caa7907714b6e3d1735ed"></span><em class="property">const</em> char *<code class="descname">CPLExpandTilde</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLExpandTildePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Expands ~/ at start of filename. </p>
<p>Assumes that the HOME configuration option is defined.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an expanded filename.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: filename potentially starting with ~/</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLGetHomeDirv">
<span id="_CPPv313CPLGetHomeDirv"></span><span id="_CPPv213CPLGetHomeDirv"></span><span id="CPLGetHomeDir__void"></span><span class="target" id="cpl__conv_8h_1a5f40085d9547a8b40c589f087181decf"></span><em class="property">const</em> char *<code class="descname">CPLGetHomeDir</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLGetHomeDirv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the path to the home directory. </p>
<p>That is the value of the USERPROFILE environment variable on Windows, or HOME on other platforms.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the home directory, or NULL.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421CPLLaunderForFilenamePKcPKc">
<span id="_CPPv321CPLLaunderForFilenamePKcPKc"></span><span id="_CPPv221CPLLaunderForFilenamePKcPKc"></span><span id="CPLLaunderForFilename__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1a601df40472a5f6700937eba9ebe1e54f"></span><em class="property">const</em> char *<code class="descname">CPLLaunderForFilename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em>, <em class="property">const</em> char *<em>pszOutputPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLLaunderForFilenamePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Launder a string to be compatible of a filename. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the laundered name.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: The input string to launder. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszOutputPath</span></code>: The directory where the file would be created. Unused for now. May be NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLFindFilePKcPKc">
<span id="_CPPv311CPLFindFilePKcPKc"></span><span id="_CPPv211CPLFindFilePKcPKc"></span><span id="CPLFindFile__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1a86d703dd3f7f137d1590b55d7a7e4fb8"></span><em class="property">const</em> char *<code class="descname">CPLFindFile</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszClass</em>, <em class="property">const</em> char *<em>pszBasename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLFindFilePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLFindFile. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLDefaultFindFilePKcPKc">
<span id="_CPPv318CPLDefaultFindFilePKcPKc"></span><span id="_CPPv218CPLDefaultFindFilePKcPKc"></span><span id="CPLDefaultFindFile__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1ad36c679ea9121ae1a82f0da9010b89ec"></span><em class="property">const</em> char *<code class="descname">CPLDefaultFindFile</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszClass</em>, <em class="property">const</em> char *<em>pszBasename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLDefaultFindFilePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLDefaultFindFile. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLPushFileFinder13CPLFileFinder">
<span id="_CPPv317CPLPushFileFinder13CPLFileFinder"></span><span id="_CPPv217CPLPushFileFinder13CPLFileFinder"></span><span id="CPLPushFileFinder__CPLFileFinder"></span><span class="target" id="cpl__conv_8h_1a9205b5a0266e9ff0130324016cfe2743"></span>void <code class="descname">CPLPushFileFinder</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLFileFinder" title="CPLFileFinder">CPLFileFinder</a> <em>pfnFinder</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLPushFileFinder13CPLFileFinder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLPushFileFinder. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLPopFileFinderv">
<span id="_CPPv316CPLPopFileFinderv"></span><span id="_CPPv216CPLPopFileFinderv"></span><span id="CPLPopFileFinder__void"></span><span class="target" id="cpl__conv_8h_1af09a216ab0d69b57b528628ef2f9ee51"></span><a class="reference internal" href="#_CPPv413CPLFileFinder" title="CPLFileFinder">CPLFileFinder</a> <code class="descname">CPLPopFileFinder</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLPopFileFinderv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLPopFileFinder. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421CPLPushFinderLocationPKc">
<span id="_CPPv321CPLPushFinderLocationPKc"></span><span id="_CPPv221CPLPushFinderLocationPKc"></span><span id="CPLPushFinderLocation__cCP"></span><span class="target" id="cpl__conv_8h_1a8fb38a901b889d3b0d8a28ede5f97ef5"></span>void <code class="descname">CPLPushFinderLocation</code><span class="sig-paren">(</span><em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLPushFinderLocationPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLPushFinderLocation. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CPLPopFinderLocationv">
<span id="_CPPv320CPLPopFinderLocationv"></span><span id="_CPPv220CPLPopFinderLocationv"></span><span id="CPLPopFinderLocation__void"></span><span class="target" id="cpl__conv_8h_1a9dbfaacc8fd61bcff6c06d5b8061dff4"></span>void <code class="descname">CPLPopFinderLocation</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLPopFinderLocationv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLPopFinderLocation. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLFinderCleanv">
<span id="_CPPv314CPLFinderCleanv"></span><span id="_CPPv214CPLFinderCleanv"></span><span id="CPLFinderClean__void"></span><span class="target" id="cpl__conv_8h_1a5d1735b5f7aeeed289c5dd699da9acb1"></span>void <code class="descname">CPLFinderClean</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLFinderCleanv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLFinderClean. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv47CPLStatPKcP10VSIStatBuf">
<span id="_CPPv37CPLStatPKcP10VSIStatBuf"></span><span id="_CPPv27CPLStatPKcP10VSIStatBuf"></span><span id="CPLStat__cCP.VSIStatBufP"></span><span class="target" id="cpl__conv_8h_1a14c63350aa5f42b5637835c3c06935f4"></span>int <code class="descname">CPLStat</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em>, VSIStatBuf *<em>psStatBuf</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47CPLStatPKcP10VSIStatBuf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as VSIStat() except it works on “C:” as if it were “C:&quot;. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLOpenSharedPKcPKci">
<span id="_CPPv313CPLOpenSharedPKcPKci"></span><span id="_CPPv213CPLOpenSharedPKcPKci"></span><span id="CPLOpenShared__cCP.cCP.i"></span><span class="target" id="cpl__conv_8h_1af47485362aca554e37796c352a77fc71"></span>FILE *<code class="descname">CPLOpenShared</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, <em class="property">const</em> char *<em>pszAccess</em>, int <em>bLargeIn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLOpenSharedPKcPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open a shared file handle. </p>
<p>Some operating systems have limits on the number of file handles that can be open at one time. This function attempts to maintain a registry of already open file handles, and reuse existing ones if the same file is requested by another part of the application.</p>
<p>Note that access is only shared for access types “r”, “rb”, “r+” and “rb+”. All others will just result in direct VSIOpen() calls. Keep in mind that a file is only reused if the file name is exactly the same. Different names referring to the same file will result in different handles.</p>
<p>The VSIFOpen() or <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a> function is used to actually open the file, when an existing file handle can’t be shared.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a file handle or NULL if opening fails. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the name of the file to open. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszAccess</span></code>: the normal fopen()/VSIFOpen() style access string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bLargeIn</span></code>: If TRUE <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a> (for large files) will be used instead of VSIFOpen().</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLCloseSharedP4FILE">
<span id="_CPPv314CPLCloseSharedP4FILE"></span><span id="_CPPv214CPLCloseSharedP4FILE"></span><span id="CPLCloseShared__FILEP"></span><span class="target" id="cpl__conv_8h_1a1afd2c936bbf27a74b02ae6dcadf25a7"></span>void <code class="descname">CPLCloseShared</code><span class="sig-paren">(</span>FILE *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLCloseSharedP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close shared file. </p>
<p>Dereferences the indicated file handle, and closes it if the reference count has dropped to zero. A <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> is issued if the file is not in the shared file list.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle from <a class="reference internal" href="#cpl__conv_8h_1af47485362aca554e37796c352a77fc71"><span class="std std-ref">CPLOpenShared()</span></a> to deaccess. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLGetSharedListPi">
<span id="_CPPv316CPLGetSharedListPi"></span><span id="_CPPv216CPLGetSharedListPi"></span><span id="CPLGetSharedList__iP"></span><span class="target" id="cpl__conv_8h_1ad102985b0ae1672d3d2cf3a4ea8aea4a"></span><a class="reference internal" href="#_CPPv417CPLSharedFileInfo" title="CPLSharedFileInfo">CPLSharedFileInfo</a> *<code class="descname">CPLGetSharedList</code><span class="sig-paren">(</span>int *<em>pnCount</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLGetSharedListPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch list of open shared files. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the pointer to the first in the array of shared file info structures. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pnCount</span></code>: place to put the count of entries.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLDumpSharedListP4FILE">
<span id="_CPPv317CPLDumpSharedListP4FILE"></span><span id="_CPPv217CPLDumpSharedListP4FILE"></span><span id="CPLDumpSharedList__FILEP"></span><span class="target" id="cpl__conv_8h_1aa7709a32d13e10f2c6c28a176b5a8784"></span>void <code class="descname">CPLDumpSharedList</code><span class="sig-paren">(</span>FILE *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLDumpSharedListP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report open shared files. </p>
<p>Dumps all open shared files to the indicated file handle. If the file handle is NULL information is sent via the <a class="reference internal" href="#cpl__error_8h_1ad0c5d3481dd34c1f3a0f7775ebf74817"><span class="std std-ref">CPLDebug()</span></a> call.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: File handle to write to. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLDMSToDecPKc">
<span id="_CPPv311CPLDMSToDecPKc"></span><span id="_CPPv211CPLDMSToDecPKc"></span><span id="CPLDMSToDec__cCP"></span><span class="target" id="cpl__conv_8h_1a7f693923cfd3d171adb34420f09f7891"></span>double <code class="descname">CPLDMSToDec</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>is</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLDMSToDecPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPLDMSToDec. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLDecToDMSdPKci">
<span id="_CPPv311CPLDecToDMSdPKci"></span><span id="_CPPv211CPLDecToDMSdPKci"></span><span id="CPLDecToDMS__double.cCP.i"></span><span class="target" id="cpl__conv_8h_1a679f0d2bbc965bcc8d29b56f5210f16b"></span><em class="property">const</em> char *<code class="descname">CPLDecToDMS</code><span class="sig-paren">(</span>double <em>dfAngle</em>, <em class="property">const</em> char *<em>pszAxis</em>, int <em>nPrecision</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLDecToDMSdPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Translate a decimal degrees value to a DMS string with hemisphere. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLPackedDMSToDecd">
<span id="_CPPv317CPLPackedDMSToDecd"></span><span id="_CPPv217CPLPackedDMSToDecd"></span><span id="CPLPackedDMSToDec__double"></span><span class="target" id="cpl__conv_8h_1aa4ffc8fd25881635e18d1a53e177a8e1"></span>double <code class="descname">CPLPackedDMSToDec</code><span class="sig-paren">(</span>double <em>dfPacked</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLPackedDMSToDecd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a packed DMS value (DDDMMMSSS.SS) into decimal degrees. </p>
<p>This function converts a packed DMS angle to seconds. The standard packed DMS format is:</p>
<p>degrees * 1000000 + minutes * 1000 + seconds</p>
<p>Example: angle = 120025045.25 yields deg = 120 min = 25 sec = 45.25</p>
<p>The algorithm used for the conversion is as follows:</p>
<p><ol class="arabic simple">
<li><p>The absolute value of the angle is used.</p></li>
<li><p>The degrees are separated out: deg = angle/1000000 (fractional portion truncated)</p></li>
<li><p>The minutes are separated out: min = (angle - deg * 1000000) / 1000 (fractional portion truncated)</p></li>
<li><p>The seconds are then computed: sec = angle - deg * 1000000 - min * 1000</p></li>
<li><p>The total angle in seconds is computed: sec = deg * 3600.0 + min * 60.0 + sec</p></li>
<li><p>The sign of sec is set to that of the input angle.</p></li>
</ol>
</p>
<p>Packed DMS values used by the USGS GCTP package and probably by other software.</p>
<p>NOTE: This code does not validate input value. If you give the wrong value, you will get the wrong result.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Angle in decimal degrees. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dfPacked</span></code>: Angle in packed DMS format.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLDecToPackedDMSd">
<span id="_CPPv317CPLDecToPackedDMSd"></span><span id="_CPPv217CPLDecToPackedDMSd"></span><span id="CPLDecToPackedDMS__double"></span><span class="target" id="cpl__conv_8h_1a97b69cc886a1a5c9618612d8205600e4"></span>double <code class="descname">CPLDecToPackedDMS</code><span class="sig-paren">(</span>double <em>dfDec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLDecToPackedDMSd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert decimal degrees into packed DMS value (DDDMMMSSS.SS). </p>
<p>This function converts a value, specified in decimal degrees into packed DMS angle. The standard packed DMS format is:</p>
<p>degrees * 1000000 + minutes * 1000 + seconds</p>
<p>See also <a class="reference internal" href="#cpl__conv_8h_1aa4ffc8fd25881635e18d1a53e177a8e1"><span class="std std-ref">CPLPackedDMSToDec()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Angle in packed DMS format. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dfDec</span></code>: Angle in decimal degrees.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLStringToComplexPKcPdPd">
<span id="_CPPv318CPLStringToComplexPKcPdPd"></span><span id="_CPPv218CPLStringToComplexPKcPdPd"></span><span id="CPLStringToComplex__cCP.doubleP.doubleP"></span><span class="target" id="cpl__conv_8h_1af4d09dcf679de60fdc2262a3a864fae7"></span>void <code class="descname">CPLStringToComplex</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, double *<em>pdfReal</em>, double *<em>pdfImag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLStringToComplexPKcPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the real and imaginary part of a serialized complex number. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLUnlinkTreePKc">
<span id="_CPPv313CPLUnlinkTreePKc"></span><span id="_CPPv213CPLUnlinkTreePKc"></span><span id="CPLUnlinkTree__cCP"></span><span class="target" id="cpl__conv_8h_1aa786ff8dd95ea5b2b641de9ed53cb277"></span>int <code class="descname">CPLUnlinkTree</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLUnlinkTreePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Recursively unlink a directory. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on successful completion, -1 if function fails. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLCopyFilePKcPKc">
<span id="_CPPv311CPLCopyFilePKcPKc"></span><span id="_CPPv211CPLCopyFilePKcPKc"></span><span id="CPLCopyFile__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1ad357816a8e3713a7070e299764b236f7"></span>int <code class="descname">CPLCopyFile</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszNewPath</em>, <em class="property">const</em> char *<em>pszOldPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLCopyFilePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLCopyTreePKcPKc">
<span id="_CPPv311CPLCopyTreePKcPKc"></span><span id="_CPPv211CPLCopyTreePKcPKc"></span><span id="CPLCopyTree__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1a16a1cab8e3bdd45d27016a162e5237ce"></span>int <code class="descname">CPLCopyTree</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszNewPath</em>, <em class="property">const</em> char *<em>pszOldPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLCopyTreePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Recursively copy a tree. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLMoveFilePKcPKc">
<span id="_CPPv311CPLMoveFilePKcPKc"></span><span id="_CPPv211CPLMoveFilePKcPKc"></span><span id="CPLMoveFile__cCP.cCP"></span><span class="target" id="cpl__conv_8h_1a2802d9321457b38b3318955c4042f3b9"></span>int <code class="descname">CPLMoveFile</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszNewPath</em>, <em class="property">const</em> char *<em>pszOldPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLMoveFilePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move a file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLSymlinkPKcPKc12CSLConstList">
<span id="_CPPv310CPLSymlinkPKcPKc12CSLConstList"></span><span id="_CPPv210CPLSymlinkPKcPKc12CSLConstList"></span><span id="CPLSymlink__cCP.cCP.CSLConstList"></span><span class="target" id="cpl__conv_8h_1a3eed238c33fd3d88831750bdfa3c972f"></span>int <code class="descname">CPLSymlink</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszOldPath</em>, <em class="property">const</em> char *<em>pszNewPath</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLSymlinkPKcPKc12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a symbolic link. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLCreateZipPKcPPc">
<span id="_CPPv312CPLCreateZipPKcPPc"></span><span id="_CPPv212CPLCreateZipPKcPPc"></span><span id="CPLCreateZip__cCP.cPP"></span><span class="target" id="cpl__conv_8h_1a39ca7f6cf51ae51594458fe6e337aabe"></span>void *<code class="descname">CPLCreateZip</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszZipFilename</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLCreateZipPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create ZIP file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLCreateFileInZipPvPKcPPc">
<span id="_CPPv318CPLCreateFileInZipPvPKcPPc"></span><span id="_CPPv218CPLCreateFileInZipPvPKcPPc"></span><span id="CPLCreateFileInZip__voidP.cCP.cPP"></span><span class="target" id="cpl__conv_8h_1a71a598d868cd731429e0bbd829e901b2"></span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">CPLCreateFileInZip</code><span class="sig-paren">(</span>void *<em>hZip</em>, <em class="property">const</em> char *<em>pszFilename</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLCreateFileInZipPvPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a file in a ZIP file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLWriteFileInZipPvPKvi">
<span id="_CPPv317CPLWriteFileInZipPvPKvi"></span><span id="_CPPv217CPLWriteFileInZipPvPKvi"></span><span id="CPLWriteFileInZip__voidP.voidCP.i"></span><span class="target" id="cpl__conv_8h_1aed2172d84e3d7b71191935cc8b3a50c6"></span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">CPLWriteFileInZip</code><span class="sig-paren">(</span>void *<em>hZip</em>, <em class="property">const</em> void *<em>pBuffer</em>, int <em>nBufferSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLWriteFileInZipPvPKvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write in current file inside a ZIP file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLCloseFileInZipPv">
<span id="_CPPv317CPLCloseFileInZipPv"></span><span id="_CPPv217CPLCloseFileInZipPv"></span><span id="CPLCloseFileInZip__voidP"></span><span class="target" id="cpl__conv_8h_1ae2c084e52d88f873c2a070c51941ce19"></span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">CPLCloseFileInZip</code><span class="sig-paren">(</span>void *<em>hZip</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLCloseFileInZipPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close current file inside ZIP file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLCloseZipPv">
<span id="_CPPv311CPLCloseZipPv"></span><span id="_CPPv211CPLCloseZipPv"></span><span id="CPLCloseZip__voidP"></span><span class="target" id="cpl__conv_8h_1a84f8b89602f661237a45545b25b25a05"></span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">CPLCloseZip</code><span class="sig-paren">(</span>void *<em>hZip</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLCloseZipPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close ZIP file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLZLibDeflatePKv6size_tiPv6size_tP6size_t">
<span id="_CPPv314CPLZLibDeflatePKv6size_tiPv6size_tP6size_t"></span><span id="_CPPv214CPLZLibDeflatePKv6size_tiPv6size_tP6size_t"></span><span id="CPLZLibDeflate__voidCP.s.i.voidP.s.sP"></span><span class="target" id="cpl__conv_8h_1a09f1dd41a8fa1ebc36bc6c34c7c224a3"></span>void *<code class="descname">CPLZLibDeflate</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>ptr</em>, size_t <em>nBytes</em>, int <em>nLevel</em>, void *<em>outptr</em>, size_t <em>nOutAvailableBytes</em>, size_t *<em>pnOutBytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLZLibDeflatePKv6size_tiPv6size_tP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compress a buffer with ZLib DEFLATE compression. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the output buffer (to be freed with <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> if not provided) or NULL in case of error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.10.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: input buffer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBytes</span></code>: size of input buffer in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLevel</span></code>: ZLib compression level (-1 for default). Currently unused </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">outptr</span></code>: output buffer, or NULL to let the function allocate it. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOutAvailableBytes</span></code>: size of output buffer if provided, or ignored. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnOutBytes</span></code>: pointer to a size_t, where to store the size of the output buffer.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLZLibInflatePKv6size_tPv6size_tP6size_t">
<span id="_CPPv314CPLZLibInflatePKv6size_tPv6size_tP6size_t"></span><span id="_CPPv214CPLZLibInflatePKv6size_tPv6size_tP6size_t"></span><span id="CPLZLibInflate__voidCP.s.voidP.s.sP"></span><span class="target" id="cpl__conv_8h_1a066abbb8471f29f521d19f2252e9959a"></span>void *<code class="descname">CPLZLibInflate</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>ptr</em>, size_t <em>nBytes</em>, void *<em>outptr</em>, size_t <em>nOutAvailableBytes</em>, size_t *<em>pnOutBytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLZLibInflatePKv6size_tPv6size_tP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Uncompress a buffer compressed with ZLib DEFLATE compression. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the output buffer (to be freed with <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> if not provided) or NULL in case of error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.10.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: input buffer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBytes</span></code>: size of input buffer in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">outptr</span></code>: output buffer, or NULL to let the function allocate it. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOutAvailableBytes</span></code>: size of output buffer if provided, or ignored. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnOutBytes</span></code>: pointer to a size_t, where to store the size of the output buffer.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLValidateXMLPKcPKc12CSLConstList">
<span id="_CPPv314CPLValidateXMLPKcPKc12CSLConstList"></span><span id="_CPPv214CPLValidateXMLPKcPKc12CSLConstList"></span><span id="CPLValidateXML__cCP.cCP.CSLConstList"></span><span class="target" id="cpl__conv_8h_1a8468c798dfe1396f5ff6da798e1f7091"></span>int <code class="descname">CPLValidateXML</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszXMLFilename</em>, <em class="property">const</em> char *<em>pszXSDFilename</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLValidateXMLPKcPKc12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Validate a XML file against a XML schema. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the XML file validates against the XML schema.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.10.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszXMLFilename</span></code>: the filename of the XML file to validate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszXSDFilename</span></code>: the filename of the XSD schema. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: unused for now. Set to NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLsetlocaleiPKc">
<span id="_CPPv312CPLsetlocaleiPKc"></span><span id="_CPPv212CPLsetlocaleiPKc"></span><span id="CPLsetlocale__i.cCP"></span><span class="target" id="cpl__conv_8h_1a7e7dc242d58045315d7672e252e62e7d"></span>char *<code class="descname">CPLsetlocale</code><span class="sig-paren">(</span>int <em>category</em>, <em class="property">const</em> char *<em>locale</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLsetlocaleiPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Prevents parallel executions of setlocale(). </p>
<p>Calling setlocale() concurrently from two or more threads is a potential data race. A mutex is used to provide a critical region so that only one thread at a time can be executing setlocale().</p>
<p>The return should not be freed, and copied quickly as it may be invalidated by a following next call to <a class="reference internal" href="#cpl__conv_8h_1a7e7dc242d58045315d7672e252e62e7d"><span class="std std-ref">CPLsetlocale()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>See your compiler’s documentation on setlocale. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code>: See your compiler’s documentation on setlocale. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">locale</span></code>: See your compiler’s documentation on setlocale.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLIsPowerOfTwoj">
<span id="_CPPv315CPLIsPowerOfTwoj"></span><span id="_CPPv215CPLIsPowerOfTwoj"></span><span id="CPLIsPowerOfTwo__unsigned-i"></span><span class="target" id="cpl__conv_8h_1abced14d191c873be24e9d365cbf26cd9"></span>int <code class="descname">CPLIsPowerOfTwo</code><span class="sig-paren">(</span>unsigned int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLIsPowerOfTwoj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#cpl__conv_8h_1abced14d191c873be24e9d365cbf26cd9"><span class="std std-ref">CPLIsPowerOfTwo()</span></a> <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if i is power of two otherwise return FALSE </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: - tested number </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv417CPLSharedFileInfo">
<span id="_CPPv317CPLSharedFileInfo"></span><span id="_CPPv217CPLSharedFileInfo"></span><span id="CPLSharedFileInfo"></span><span class="target" id="structCPLSharedFileInfo"></span><em class="property">struct </em><code class="descname">CPLSharedFileInfo</code><a class="headerlink" href="#_CPPv417CPLSharedFileInfo" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_conv.h&gt;</em><p>Information on a shared file. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N17CPLSharedFileInfo2fpE">
<span id="_CPPv3N17CPLSharedFileInfo2fpE"></span><span id="_CPPv2N17CPLSharedFileInfo2fpE"></span><span id="CPLSharedFileInfo::fp__FILEP"></span><span class="target" id="structCPLSharedFileInfo_1a47792925fc79475db728bc911ace28e4"></span>FILE *<code class="descname">fp</code><a class="headerlink" href="#_CPPv4N17CPLSharedFileInfo2fpE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>File pointer. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17CPLSharedFileInfo9nRefCountE">
<span id="_CPPv3N17CPLSharedFileInfo9nRefCountE"></span><span id="_CPPv2N17CPLSharedFileInfo9nRefCountE"></span><span id="CPLSharedFileInfo::nRefCount__i"></span><span class="target" id="structCPLSharedFileInfo_1a5579640f409b4cba29d37ea5a041b14d"></span>int <code class="descname">nRefCount</code><a class="headerlink" href="#_CPPv4N17CPLSharedFileInfo9nRefCountE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reference counter. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17CPLSharedFileInfo6bLargeE">
<span id="_CPPv3N17CPLSharedFileInfo6bLargeE"></span><span id="_CPPv2N17CPLSharedFileInfo6bLargeE"></span><span id="CPLSharedFileInfo::bLarge__i"></span><span class="target" id="structCPLSharedFileInfo_1ab6b8c11104bc00f1502b17b0ebd6d346"></span>int <code class="descname">bLarge</code><a class="headerlink" href="#_CPPv4N17CPLSharedFileInfo6bLargeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether fp must be interpreted as VSIFILE*. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17CPLSharedFileInfo11pszFilenameE">
<span id="_CPPv3N17CPLSharedFileInfo11pszFilenameE"></span><span id="_CPPv2N17CPLSharedFileInfo11pszFilenameE"></span><span id="CPLSharedFileInfo::pszFilename__cP"></span><span class="target" id="structCPLSharedFileInfo_1ab513abf6e93be37037dc2607304beb1e"></span>char *<code class="descname">pszFilename</code><a class="headerlink" href="#_CPPv4N17CPLSharedFileInfo11pszFilenameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Filename. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17CPLSharedFileInfo9pszAccessE">
<span id="_CPPv3N17CPLSharedFileInfo9pszAccessE"></span><span id="_CPPv2N17CPLSharedFileInfo9pszAccessE"></span><span id="CPLSharedFileInfo::pszAccess__cP"></span><span class="target" id="structCPLSharedFileInfo_1a25373398649d1b2b5bbe3c24d3554b25"></span>char *<code class="descname">pszAccess</code><a class="headerlink" href="#_CPPv4N17CPLSharedFileInfo9pszAccessE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Access mode. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv43cpl">
<span id="_CPPv33cpl"></span><span id="_CPPv23cpl"></span><span id="cpl"></span><span class="target" id="namespacecpl"></span><em class="property">namespace </em><code class="descname">cpl</code><a class="headerlink" href="#_CPPv43cpl" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv4I00EN3cpl9down_castE2ToP4From">
<span id="_CPPv3I00EN3cpl9down_castEP4From"></span><span id="_CPPv2I00EN3cpl9down_castEP4From"></span><span class="target" id="cpl__conv_8h_1acf57353cbad5314c2be7e25e766bd570"></span>template&lt;typename <code class="descname">To</code>, typename <code class="descname">From</code>&gt;<br /><a class="reference internal" href="#_CPPv4I00EN3cpl9down_castE2ToP4From" title="cpl::down_cast::To">To</a> <code class="descname">down_cast</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN3cpl9down_castE2ToP4From" title="cpl::down_cast::From">From</a> *<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3cpl9down_castE2ToP4From" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Use cpl::down_cast&lt;Derived*&gt;(pointer_to_base) as equivalent of static_cast&lt;Derived*&gt;(pointer_to_base) with safe checking in debug mode. </p>
<p>Only works if no virtual inheritance is involved.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to a derived class </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code>: pointer to a base class </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cpl-csv-h">
<h2>cpl_csv.h<a class="headerlink" href="#cpl-csv-h" title="Permalink to this headline">¶</a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv418CSVCompareCriteria">
<span id="_CPPv318CSVCompareCriteria"></span><span id="_CPPv218CSVCompareCriteria"></span><span class="target" id="cpl__csv_8h_1ae11d24eb94de9d714893500d45865a22"></span><em class="property">enum </em><code class="descname">CSVCompareCriteria</code><a class="headerlink" href="#_CPPv418CSVCompareCriteria" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv414CC_ExactString">
<span id="_CPPv314CC_ExactString"></span><span id="_CPPv214CC_ExactString"></span><span class="target" id="cpl__csv_8h_1ae11d24eb94de9d714893500d45865a22a5dfa8312bd86cee48398a2d250f99319"></span><code class="descname">CC_ExactString</code><a class="headerlink" href="#_CPPv414CC_ExactString" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv415CC_ApproxString">
<span id="_CPPv315CC_ApproxString"></span><span id="_CPPv215CC_ApproxString"></span><span class="target" id="cpl__csv_8h_1ae11d24eb94de9d714893500d45865a22ad74f9857095798d35e5f32049f645314"></span><code class="descname">CC_ApproxString</code><a class="headerlink" href="#_CPPv415CC_ApproxString" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv410CC_Integer">
<span id="_CPPv310CC_Integer"></span><span id="_CPPv210CC_Integer"></span><span class="target" id="cpl__csv_8h_1ae11d24eb94de9d714893500d45865a22a4fb9eb94d83659cbc4436cd9e615740c"></span><code class="descname">CC_Integer</code><a class="headerlink" href="#_CPPv410CC_Integer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv411CSVFilenamePKc">
<span id="_CPPv311CSVFilenamePKc"></span><span id="_CPPv211CSVFilenamePKc"></span><span id="CSVFilename__cCP"></span><span class="target" id="cpl__csv_8h_1a26ed016a871c1c9a0f78fbad84f793ac"></span><em class="property">const</em> char *<code class="descname">CSVFilename</code><span class="sig-paren">(</span><em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CSVFilenamePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv418CSVDetectSeperatorPKc">
<span id="_CPPv318CSVDetectSeperatorPKc"></span><span id="_CPPv218CSVDetectSeperatorPKc"></span><span id="CSVDetectSeperator__cCP"></span><span class="target" id="cpl__csv_8h_1aedaf54ba197b0124705fb9da330e3c24"></span>char <code class="descname">CSVDetectSeperator</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CSVDetectSeperatorPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Detect which field separator is used. </p>
<p>Currently, it can detect comma, semicolon, space or tabulation. In case of ambiguity or no separator found, comma will be considered as the separator.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>’,’, ‘;’, ‘ ‘ or ‘’ </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CSVReadParseLineP4FILE">
<span id="_CPPv316CSVReadParseLineP4FILE"></span><span id="_CPPv216CSVReadParseLineP4FILE"></span><span id="CSVReadParseLine__FILEP"></span><span class="target" id="cpl__csv_8h_1a57044efb4d43526aab35aaf38193466c"></span>char **<code class="descname">CSVReadParseLine</code><span class="sig-paren">(</span>FILE *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CSVReadParseLineP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv417CSVReadParseLine2P4FILEc">
<span id="_CPPv317CSVReadParseLine2P4FILEc"></span><span id="_CPPv217CSVReadParseLine2P4FILEc"></span><span id="CSVReadParseLine2__FILEP.c"></span><span class="target" id="cpl__csv_8h_1abab22fc39055571705ba71a7083ec8b2"></span>char **<code class="descname">CSVReadParseLine2</code><span class="sig-paren">(</span>FILE *<em>fp</em>, char <em>chDelimiter</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CSVReadParseLine2P4FILEc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv417CSVReadParseLineLP8VSILFILE">
<span id="_CPPv317CSVReadParseLineLP8VSILFILE"></span><span id="_CPPv217CSVReadParseLineLP8VSILFILE"></span><span id="CSVReadParseLineL__VSILFILEP"></span><span class="target" id="cpl__csv_8h_1a00f52fdf17acc1b53e8673c8a1a7e156"></span>char **<code class="descname">CSVReadParseLineL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CSVReadParseLineLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv418CSVReadParseLine2LP8VSILFILEc">
<span id="_CPPv318CSVReadParseLine2LP8VSILFILEc"></span><span id="_CPPv218CSVReadParseLine2LP8VSILFILEc"></span><span id="CSVReadParseLine2L__VSILFILEP.c"></span><span class="target" id="cpl__csv_8h_1a7c5fb032765c5310b9d474cfe9c1b40b"></span>char **<code class="descname">CSVReadParseLine2L</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, char <em>chDelimiter</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CSVReadParseLine2LP8VSILFILEc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv412CSVScanLinesP4FILEiPKc18CSVCompareCriteria">
<span id="_CPPv312CSVScanLinesP4FILEiPKc18CSVCompareCriteria"></span><span id="_CPPv212CSVScanLinesP4FILEiPKc18CSVCompareCriteria"></span><span id="CSVScanLines__FILEP.i.cCP.CSVCompareCriteria"></span><span class="target" id="cpl__csv_8h_1a8441c6b05517dced623293aab84770d6"></span>char **<code class="descname">CSVScanLines</code><span class="sig-paren">(</span>FILE *, int, <em class="property">const</em> char *, <a class="reference internal" href="#_CPPv418CSVCompareCriteria" title="CSVCompareCriteria">CSVCompareCriteria</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CSVScanLinesP4FILEiPKc18CSVCompareCriteria" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CSVScanLinesLP8VSILFILEiPKc18CSVCompareCriteria">
<span id="_CPPv313CSVScanLinesLP8VSILFILEiPKc18CSVCompareCriteria"></span><span id="_CPPv213CSVScanLinesLP8VSILFILEiPKc18CSVCompareCriteria"></span><span id="CSVScanLinesL__VSILFILEP.i.cCP.CSVCompareCriteria"></span><span class="target" id="cpl__csv_8h_1a7c434698ce34802c34cb8115a05afe8e"></span>char **<code class="descname">CSVScanLinesL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *, int, <em class="property">const</em> char *, <a class="reference internal" href="#_CPPv418CSVCompareCriteria" title="CSVCompareCriteria">CSVCompareCriteria</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CSVScanLinesLP8VSILFILEiPKc18CSVCompareCriteria" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411CSVScanFilePKciPKc18CSVCompareCriteria">
<span id="_CPPv311CSVScanFilePKciPKc18CSVCompareCriteria"></span><span id="_CPPv211CSVScanFilePKciPKc18CSVCompareCriteria"></span><span id="CSVScanFile__cCP.i.cCP.CSVCompareCriteria"></span><span class="target" id="cpl__csv_8h_1a81768aff945ee26aa2be9d400c03bb95"></span>char **<code class="descname">CSVScanFile</code><span class="sig-paren">(</span><em class="property">const</em> char *, int, <em class="property">const</em> char *, <a class="reference internal" href="#_CPPv418CSVCompareCriteria" title="CSVCompareCriteria">CSVCompareCriteria</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CSVScanFilePKciPKc18CSVCompareCriteria" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv417CSVScanFileByNamePKcPKcPKc18CSVCompareCriteria">
<span id="_CPPv317CSVScanFileByNamePKcPKcPKc18CSVCompareCriteria"></span><span id="_CPPv217CSVScanFileByNamePKcPKcPKc18CSVCompareCriteria"></span><span id="CSVScanFileByName__cCP.cCP.cCP.CSVCompareCriteria"></span><span class="target" id="cpl__csv_8h_1ab6b49c63b3723476589a959ba539ddef"></span>char **<code class="descname">CSVScanFileByName</code><span class="sig-paren">(</span><em class="property">const</em> char *, <em class="property">const</em> char *, <em class="property">const</em> char *, <a class="reference internal" href="#_CPPv418CSVCompareCriteria" title="CSVCompareCriteria">CSVCompareCriteria</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CSVScanFileByNamePKcPKcPKc18CSVCompareCriteria" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv414CSVGetNextLinePKc">
<span id="_CPPv314CSVGetNextLinePKc"></span><span id="_CPPv214CSVGetNextLinePKc"></span><span id="CSVGetNextLine__cCP"></span><span class="target" id="cpl__csv_8h_1a9974411f4d5d264f5f90eaf7cb3c70dc"></span>char **<code class="descname">CSVGetNextLine</code><span class="sig-paren">(</span><em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CSVGetNextLinePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CSVGetFieldIdP4FILEPKc">
<span id="_CPPv313CSVGetFieldIdP4FILEPKc"></span><span id="_CPPv213CSVGetFieldIdP4FILEPKc"></span><span id="CSVGetFieldId__FILEP.cCP"></span><span class="target" id="cpl__csv_8h_1a1e83f30107fa9638f1d20fc0f8d39168"></span>int <code class="descname">CSVGetFieldId</code><span class="sig-paren">(</span>FILE *, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CSVGetFieldIdP4FILEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv414CSVGetFieldIdLP8VSILFILEPKc">
<span id="_CPPv314CSVGetFieldIdLP8VSILFILEPKc"></span><span id="_CPPv214CSVGetFieldIdLP8VSILFILEPKc"></span><span id="CSVGetFieldIdL__VSILFILEP.cCP"></span><span class="target" id="cpl__csv_8h_1aa8911d0ef33ec9a8f5963618c5379610"></span>int <code class="descname">CSVGetFieldIdL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CSVGetFieldIdLP8VSILFILEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv417CSVGetFileFieldIdPKcPKc">
<span id="_CPPv317CSVGetFileFieldIdPKcPKc"></span><span id="_CPPv217CSVGetFileFieldIdPKcPKc"></span><span id="CSVGetFileFieldId__cCP.cCP"></span><span class="target" id="cpl__csv_8h_1afec5829d297087742d27969a1490d9a7"></span>int <code class="descname">CSVGetFileFieldId</code><span class="sig-paren">(</span><em class="property">const</em> char *, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CSVGetFileFieldIdPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411CSVDeaccessPKc">
<span id="_CPPv311CSVDeaccessPKc"></span><span id="_CPPv211CSVDeaccessPKc"></span><span id="CSVDeaccess__cCP"></span><span class="target" id="cpl__csv_8h_1afa3e6d59a86797ca8b0d6d66fa34722f"></span>void <code class="descname">CSVDeaccess</code><span class="sig-paren">(</span><em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CSVDeaccessPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411CSVGetFieldPKcPKcPKc18CSVCompareCriteriaPKc">
<span id="_CPPv311CSVGetFieldPKcPKcPKc18CSVCompareCriteriaPKc"></span><span id="_CPPv211CSVGetFieldPKcPKcPKc18CSVCompareCriteriaPKc"></span><span id="CSVGetField__cCP.cCP.cCP.CSVCompareCriteria.cCP"></span><span class="target" id="cpl__csv_8h_1afe2a63b39437b941158d4fa66891de5e"></span><em class="property">const</em> char *<code class="descname">CSVGetField</code><span class="sig-paren">(</span><em class="property">const</em> char *, <em class="property">const</em> char *, <em class="property">const</em> char *, <a class="reference internal" href="#_CPPv418CSVCompareCriteria" title="CSVCompareCriteria">CSVCompareCriteria</a>, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CSVGetFieldPKcPKcPKc18CSVCompareCriteriaPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="cpl-error-h">
<h2>cpl_error.h<a class="headerlink" href="#cpl-error-h" title="Permalink to this headline">¶</a></h2>
<p>CPL error handling services. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.CPLE_None">
<span class="target" id="cpl__error_8h_1a231a41d3e8f2522f477435ee1232512f"></span><code class="descname">CPLE_None</code><a class="headerlink" href="#c.CPLE_None" title="Permalink to this definition">¶</a></dt>
<dd><p>No error. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AppDefined">
<span class="target" id="cpl__error_8h_1a7151d0699caa1372a8566562390ff113"></span><code class="descname">CPLE_AppDefined</code><a class="headerlink" href="#c.CPLE_AppDefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Application defined error. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_OutOfMemory">
<span class="target" id="cpl__error_8h_1aec7dba1acbad288d224d52a2b3ef990c"></span><code class="descname">CPLE_OutOfMemory</code><a class="headerlink" href="#c.CPLE_OutOfMemory" title="Permalink to this definition">¶</a></dt>
<dd><p>Out of memory error. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_FileIO">
<span class="target" id="cpl__error_8h_1a4930c3e715b2dd2899e38ebb52e60d9f"></span><code class="descname">CPLE_FileIO</code><a class="headerlink" href="#c.CPLE_FileIO" title="Permalink to this definition">¶</a></dt>
<dd><p>File I/O error. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_OpenFailed">
<span class="target" id="cpl__error_8h_1a730735f3bab3514071f6a8642910ea75"></span><code class="descname">CPLE_OpenFailed</code><a class="headerlink" href="#c.CPLE_OpenFailed" title="Permalink to this definition">¶</a></dt>
<dd><p>Open failed. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_IllegalArg">
<span class="target" id="cpl__error_8h_1a07b0e6c2d300ba2d03743024b6fe109d"></span><code class="descname">CPLE_IllegalArg</code><a class="headerlink" href="#c.CPLE_IllegalArg" title="Permalink to this definition">¶</a></dt>
<dd><p>Illegal argument. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_NotSupported">
<span class="target" id="cpl__error_8h_1a3a532186d9f9e2699aee57aab0648b5e"></span><code class="descname">CPLE_NotSupported</code><a class="headerlink" href="#c.CPLE_NotSupported" title="Permalink to this definition">¶</a></dt>
<dd><p>Not supported. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AssertionFailed">
<span class="target" id="cpl__error_8h_1a13990dad8417da7119ef2ca2f324d582"></span><code class="descname">CPLE_AssertionFailed</code><a class="headerlink" href="#c.CPLE_AssertionFailed" title="Permalink to this definition">¶</a></dt>
<dd><p>Assertion failed. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_NoWriteAccess">
<span class="target" id="cpl__error_8h_1ada4b0a770e1eaef3d23a55c760a3f4a0"></span><code class="descname">CPLE_NoWriteAccess</code><a class="headerlink" href="#c.CPLE_NoWriteAccess" title="Permalink to this definition">¶</a></dt>
<dd><p>No write access. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_UserInterrupt">
<span class="target" id="cpl__error_8h_1adea9ed24efa030e441e087db671f3fae"></span><code class="descname">CPLE_UserInterrupt</code><a class="headerlink" href="#c.CPLE_UserInterrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>User interrupted. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_ObjectNull">
<span class="target" id="cpl__error_8h_1a8aa83034499fe5f18b9c77622d924d60"></span><code class="descname">CPLE_ObjectNull</code><a class="headerlink" href="#c.CPLE_ObjectNull" title="Permalink to this definition">¶</a></dt>
<dd><p>NULL object. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_HttpResponse">
<span class="target" id="cpl__error_8h_1ab4a45f07d2dc11317cb94653fbc0e3ce"></span><code class="descname">CPLE_HttpResponse</code><a class="headerlink" href="#c.CPLE_HttpResponse" title="Permalink to this definition">¶</a></dt>
<dd><p>HTTP response. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AWSBucketNotFound">
<span class="target" id="cpl__error_8h_1abbfc07831d7169c515e934d4828ff0ee"></span><code class="descname">CPLE_AWSBucketNotFound</code><a class="headerlink" href="#c.CPLE_AWSBucketNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>AWSBucketNotFound. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AWSObjectNotFound">
<span class="target" id="cpl__error_8h_1a127ee0c813428761867e6950ac3de130"></span><code class="descname">CPLE_AWSObjectNotFound</code><a class="headerlink" href="#c.CPLE_AWSObjectNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>AWSObjectNotFound. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AWSAccessDenied">
<span class="target" id="cpl__error_8h_1a891cca84f7948739d39b5de7d30f98a3"></span><code class="descname">CPLE_AWSAccessDenied</code><a class="headerlink" href="#c.CPLE_AWSAccessDenied" title="Permalink to this definition">¶</a></dt>
<dd><p>AWSAccessDenied. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AWSInvalidCredentials">
<span class="target" id="cpl__error_8h_1a3abd9dbe62ff7916b69c6c4dea1d2938"></span><code class="descname">CPLE_AWSInvalidCredentials</code><a class="headerlink" href="#c.CPLE_AWSInvalidCredentials" title="Permalink to this definition">¶</a></dt>
<dd><p>AWSInvalidCredentials. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AWSSignatureDoesNotMatch">
<span class="target" id="cpl__error_8h_1a1fa2980c67ffca18f0455ca97bfa50af"></span><code class="descname">CPLE_AWSSignatureDoesNotMatch</code><a class="headerlink" href="#c.CPLE_AWSSignatureDoesNotMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>AWSSignatureDoesNotMatch. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLE_AWSError">
<span class="target" id="cpl__error_8h_1a05148be4771c4e42244abbda445cdf35"></span><code class="descname">CPLE_AWSError</code><a class="headerlink" href="#c.CPLE_AWSError" title="Permalink to this definition">¶</a></dt>
<dd><p>VSIE_AWSError. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLAssert">
<span class="target" id="cpl__error_8h_1a40ae27078f2a969a445daa022405cf72"></span><code class="descname">CPLAssert</code><span class="sig-paren">(</span>expr<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLAssert" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert on an expression. </p>
<p>Only enabled in DEBUG mode </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLAssertAlwaysEval">
<span class="target" id="cpl__error_8h_1a71fda76dc5bff7a9a6df9ab74c38b4eb"></span><code class="descname">CPLAssertAlwaysEval</code><span class="sig-paren">(</span>expr<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLAssertAlwaysEval" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert on an expression in DEBUG mode. </p>
<p>Evaluate it also in non-DEBUG mode (useful to ‘consume’ a error return variable) </p>
</dd></dl>

<dl class="macro">
<dt id="c.VALIDATE_POINTER0">
<span class="target" id="cpl__error_8h_1a6386ea331961c83a66801f245bd80da4"></span><code class="descname">VALIDATE_POINTER0</code><span class="sig-paren">(</span>ptr, func<span class="sig-paren">)</span><a class="headerlink" href="#c.VALIDATE_POINTER0" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate that a pointer is not NULL. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VALIDATE_POINTER1">
<span class="target" id="cpl__error_8h_1ab66c9b684f5dc1576d9cd68c2a288246"></span><code class="descname">VALIDATE_POINTER1</code><span class="sig-paren">(</span>ptr, func, rc<span class="sig-paren">)</span><a class="headerlink" href="#c.VALIDATE_POINTER1" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate that a pointer is not NULL, and return rc if it is NULL. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv411CPLErrorNum">
<span id="_CPPv311CPLErrorNum"></span><span id="_CPPv211CPLErrorNum"></span><span id="CPLErrorNum"></span><span class="target" id="cpl__error_8h_1a8e00ec3cc02d37a201babfed063b2e3b"></span><em class="property">typedef </em>int <code class="descname">CPLErrorNum</code><a class="headerlink" href="#_CPPv411CPLErrorNum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Error number. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv415CPLErrorHandler">
<span id="_CPPv315CPLErrorHandler"></span><span id="_CPPv215CPLErrorHandler"></span><span id="CPLErrorHandler"></span><span class="target" id="cpl__error_8h_1aad034113e72fbaacadad15842de94ca2"></span><em class="property">typedef </em>void (*<code class="descname">CPLErrorHandler</code>)<span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a>, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLErrorHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback for a custom error handler. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv46CPLErr">
<span id="_CPPv36CPLErr"></span><span id="_CPPv26CPLErr"></span><span class="target" id="cpl__error_8h_1a463ba7c7202a505416ff95b1aeefa2de"></span><em class="property">enum </em><code class="descname">CPLErr</code><a class="headerlink" href="#_CPPv46CPLErr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Error category. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv47CE_None">
<span id="_CPPv37CE_None"></span><span id="_CPPv27CE_None"></span><span class="target" id="cpl__error_8h_1a463ba7c7202a505416ff95b1aeefa2deabced339e79faa909621adebb9102cf76"></span><code class="descname">CE_None</code> = 0<a class="headerlink" href="#_CPPv47CE_None" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv48CE_Debug">
<span id="_CPPv38CE_Debug"></span><span id="_CPPv28CE_Debug"></span><span class="target" id="cpl__error_8h_1a463ba7c7202a505416ff95b1aeefa2dea89b41551b1adaeb8dfba08ca6e624f8b"></span><code class="descname">CE_Debug</code> = 1<a class="headerlink" href="#_CPPv48CE_Debug" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv410CE_Warning">
<span id="_CPPv310CE_Warning"></span><span id="_CPPv210CE_Warning"></span><span class="target" id="cpl__error_8h_1a463ba7c7202a505416ff95b1aeefa2dea637dda3d90408081ca3a7cc1c5463b1c"></span><code class="descname">CE_Warning</code> = 2<a class="headerlink" href="#_CPPv410CE_Warning" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv410CE_Failure">
<span id="_CPPv310CE_Failure"></span><span id="_CPPv210CE_Failure"></span><span class="target" id="cpl__error_8h_1a463ba7c7202a505416ff95b1aeefa2deaed0954f58a39af5d4ab8585b7531c0b3"></span><code class="descname">CE_Failure</code> = 3<a class="headerlink" href="#_CPPv410CE_Failure" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv48CE_Fatal">
<span id="_CPPv38CE_Fatal"></span><span id="_CPPv28CE_Fatal"></span><span class="target" id="cpl__error_8h_1a463ba7c7202a505416ff95b1aeefa2dead341a06531e4de83b7a4cff66dd22165"></span><code class="descname">CE_Fatal</code> = 4<a class="headerlink" href="#_CPPv48CE_Fatal" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv48CPLError6CPLErr11CPLErrorNumPKcz">
<span id="_CPPv38CPLError6CPLErr11CPLErrorNumPKcz"></span><span id="_CPPv28CPLError6CPLErr11CPLErrorNumPKcz"></span><span id="CPLError__CPLErr.CPLErrorNum.cCP.z"></span><span class="target" id="cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"></span>void <code class="descname">CPLError</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <em>eErrClass</em>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a> <em>err_no</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CPLError6CPLErr11CPLErrorNumPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report an error. </p>
<p>This function reports an error in a manner that can be hooked and reported appropriate by different applications.</p>
<p>The effect of this function can be altered by applications by installing a custom error handling using <a class="reference internal" href="#cpl__error_8h_1a74d0e649d58180e621540bf73b58e4a2"><span class="std std-ref">CPLSetErrorHandler()</span></a>.</p>
<p>The eErrClass argument can have the value CE_Warning indicating that the message is an informational warning, CE_Failure indicating that the action failed, but that normal recover mechanisms will be used or CE_Fatal meaning that a fatal error has occurred, and that <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> should not return.</p>
<p>The default behaviour of <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> is to report errors to stderr, and to abort() after reporting a CE_Fatal error. It is expected that some applications will want to suppress error reporting, and will want to install a C++ exception, or longjmp() approach to no local fatal error recovery.</p>
<p>Regardless of how application error handlers or the default error handler choose to handle an error, the error number, and message will be stored for recovery with <a class="reference internal" href="#cpl__error_8h_1a4a583fe987b8f1a7b2468805578fa8d4"><span class="std std-ref">CPLGetLastErrorNo()</span></a> and <a class="reference internal" href="#cpl__error_8h_1a7f71ade3bb0a0e9e45802975ec59ff5e"><span class="std std-ref">CPLGetLastErrorMsg()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eErrClass</span></code>: one of CE_Warning, CE_Failure or CE_Fatal. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">err_no</span></code>: the error number (CPLE_*) from cpl_error.h. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fmt</span></code>: a printf() style format string. Any additional arguments will be treated as arguments to fill in this format in a manner similar to printf(). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLErrorV6CPLErr11CPLErrorNumPKc7va_list">
<span id="_CPPv39CPLErrorV6CPLErr11CPLErrorNumPKc7va_list"></span><span id="_CPPv29CPLErrorV6CPLErr11CPLErrorNumPKc7va_list"></span><span id="CPLErrorV__CPLErr.CPLErrorNum.cCP.va_list"></span><span class="target" id="cpl__error_8h_1aded38bc0cf62c13aede48c2121b9f4c4"></span>void <code class="descname">CPLErrorV</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a>, <em class="property">const</em> char *, va_list<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLErrorV6CPLErr11CPLErrorNumPKc7va_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> but with a va_list. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLEmergencyErrorPKc">
<span id="_CPPv317CPLEmergencyErrorPKc"></span><span id="_CPPv217CPLEmergencyErrorPKc"></span><span id="CPLEmergencyError__cCP"></span><span class="target" id="cpl__error_8h_1a808000831d71958e9718073dae1cec27"></span>void <code class="descname">CPLEmergencyError</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszMessage</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLEmergencyErrorPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fatal error when things are bad. </p>
<p>This function should be called in an emergency situation where it is unlikely that a regular error report would work. This would include in the case of heap exhaustion for even small allocations, or any failure in the process of reporting an error (such as TLS allocations).</p>
<p>This function should never return. After the error message has been reported as best possible, the application will abort() similarly to how <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> aborts on CE_Fatal class errors.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszMessage</span></code>: the error message to report. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLErrorResetv">
<span id="_CPPv313CPLErrorResetv"></span><span id="_CPPv213CPLErrorResetv"></span><span id="CPLErrorReset__void"></span><span class="target" id="cpl__error_8h_1a29626fd8fdb658b19439beeb73a59560"></span>void <code class="descname">CPLErrorReset</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLErrorResetv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Erase any traces of previous errors. </p>
<p>This is normally used to ensure that an error which has been recovered from does not appear to be still in play with high level functions. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLGetLastErrorNov">
<span id="_CPPv317CPLGetLastErrorNov"></span><span id="_CPPv217CPLGetLastErrorNov"></span><span id="CPLGetLastErrorNo__void"></span><span class="target" id="cpl__error_8h_1a4a583fe987b8f1a7b2468805578fa8d4"></span><a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a> <code class="descname">CPLGetLastErrorNo</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLGetLastErrorNov" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the last error number. </p>
<p>Fetches the last error number posted with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>, that hasn’t been cleared by <a class="reference internal" href="#cpl__error_8h_1a29626fd8fdb658b19439beeb73a59560"><span class="std std-ref">CPLErrorReset()</span></a>. This is the error number, not the error class.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the error number of the last error to occur, or CPLE_None (0) if there are no posted errors. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CPLGetLastErrorTypev">
<span id="_CPPv319CPLGetLastErrorTypev"></span><span id="_CPPv219CPLGetLastErrorTypev"></span><span id="CPLGetLastErrorType__void"></span><span class="target" id="cpl__error_8h_1a8df0d4e01034cf79202314c92251e920"></span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">CPLGetLastErrorType</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLGetLastErrorTypev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the last error type. </p>
<p>Fetches the last error type posted with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>, that hasn’t been cleared by <a class="reference internal" href="#cpl__error_8h_1a29626fd8fdb658b19439beeb73a59560"><span class="std std-ref">CPLErrorReset()</span></a>. This is the error class, not the error number.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the error type of the last error to occur, or CE_None (0) if there are no posted errors. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLGetLastErrorMsgv">
<span id="_CPPv318CPLGetLastErrorMsgv"></span><span id="_CPPv218CPLGetLastErrorMsgv"></span><span id="CPLGetLastErrorMsg__void"></span><span class="target" id="cpl__error_8h_1a7f71ade3bb0a0e9e45802975ec59ff5e"></span><em class="property">const</em> char *<code class="descname">CPLGetLastErrorMsg</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLGetLastErrorMsgv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the last error message. </p>
<p>Fetches the last error message posted with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>, that hasn’t been cleared by <a class="reference internal" href="#cpl__error_8h_1a29626fd8fdb658b19439beeb73a59560"><span class="std std-ref">CPLErrorReset()</span></a>. The returned pointer is to an internal string that should not be altered or freed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the last error message, or NULL if there is no posted error message. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLGetErrorCounterv">
<span id="_CPPv318CPLGetErrorCounterv"></span><span id="_CPPv218CPLGetErrorCounterv"></span><span id="CPLGetErrorCounter__void"></span><span class="target" id="cpl__error_8h_1a1063e3041b1941c456eae4d45da2e14d"></span><a class="reference internal" href="#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <code class="descname">CPLGetErrorCounter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLGetErrorCounterv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the error counter. </p>
<p>Fetches the number of errors emitted in the current error context, since the last call to <a class="reference internal" href="#cpl__error_8h_1a29626fd8fdb658b19439beeb73a59560"><span class="std std-ref">CPLErrorReset()</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the error counter. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426CPLGetErrorHandlerUserDatav">
<span id="_CPPv326CPLGetErrorHandlerUserDatav"></span><span id="_CPPv226CPLGetErrorHandlerUserDatav"></span><span id="CPLGetErrorHandlerUserData__void"></span><span class="target" id="cpl__error_8h_1a1a266cc4d3b63c575e57840cdea4e1fe"></span>void *<code class="descname">CPLGetErrorHandlerUserData</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426CPLGetErrorHandlerUserDatav" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the user data for the error context. </p>
<p>Fetches the user data for the current error context. You can set the user data for the error context when you add your handler by issuing <a class="reference internal" href="#cpl__error_8h_1af21ae76c97853786ed32b9e3885d29ef"><span class="std std-ref">CPLSetErrorHandlerEx()</span></a> and <a class="reference internal" href="#cpl__error_8h_1a1ae5394e1e4249228d868a36127f70ab"><span class="std std-ref">CPLPushErrorHandlerEx()</span></a>. Note that user data is primarily intended for providing context within error handlers themselves, but they could potentially be abused in other useful ways with the usual caveat emptor understanding.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the user data pointer for the error context </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLErrorSetState6CPLErr11CPLErrorNumPKc">
<span id="_CPPv316CPLErrorSetState6CPLErr11CPLErrorNumPKc"></span><span id="_CPPv216CPLErrorSetState6CPLErr11CPLErrorNumPKc"></span><span id="CPLErrorSetState__CPLErr.CPLErrorNum.cCP"></span><span class="target" id="cpl__error_8h_1a0b1414b824dd6766cd393faa8da17970"></span>void <code class="descname">CPLErrorSetState</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <em>eErrClass</em>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a> <em>err_no</em>, <em class="property">const</em> char *<em>pszMsg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLErrorSetState6CPLErr11CPLErrorNumPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Restore an error state, without emitting an error. </p>
<p>Can be useful if a routine might call <a class="reference internal" href="#cpl__error_8h_1a29626fd8fdb658b19439beeb73a59560"><span class="std std-ref">CPLErrorReset()</span></a> and one wants to preserve the previous error state.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLLoggingErrorHandler6CPLErr11CPLErrorNumPKc">
<span id="_CPPv322CPLLoggingErrorHandler6CPLErr11CPLErrorNumPKc"></span><span id="_CPPv222CPLLoggingErrorHandler6CPLErr11CPLErrorNumPKc"></span><span id="CPLLoggingErrorHandler__CPLErr.CPLErrorNum.cCP"></span><span class="target" id="cpl__error_8h_1a30a2e5b4f25e0a169f1dc8d1a1564ad0"></span>void <code class="descname">CPLLoggingErrorHandler</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a>, <em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLLoggingErrorHandler6CPLErr11CPLErrorNumPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Error handler that logs into the file defined by the CPL_LOG configuration option, or stderr otherwise. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLDefaultErrorHandler6CPLErr11CPLErrorNumPKc">
<span id="_CPPv322CPLDefaultErrorHandler6CPLErr11CPLErrorNumPKc"></span><span id="_CPPv222CPLDefaultErrorHandler6CPLErr11CPLErrorNumPKc"></span><span id="CPLDefaultErrorHandler__CPLErr.CPLErrorNum.cCP"></span><span class="target" id="cpl__error_8h_1a8c59fe583fca85c275d4ff2531a42409"></span>void <code class="descname">CPLDefaultErrorHandler</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <em>eErrClass</em>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a> <em>nError</em>, <em class="property">const</em> char *<em>pszErrorMsg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLDefaultErrorHandler6CPLErr11CPLErrorNumPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default error handler. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CPLQuietErrorHandler6CPLErr11CPLErrorNumPKc">
<span id="_CPPv320CPLQuietErrorHandler6CPLErr11CPLErrorNumPKc"></span><span id="_CPPv220CPLQuietErrorHandler6CPLErr11CPLErrorNumPKc"></span><span id="CPLQuietErrorHandler__CPLErr.CPLErrorNum.cCP"></span><span class="target" id="cpl__error_8h_1adf8bbff86c116624fb84e8b0e7dfc156"></span>void <code class="descname">CPLQuietErrorHandler</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <em>eErrClass</em>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a> <em>nError</em>, <em class="property">const</em> char *<em>pszErrorMsg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLQuietErrorHandler6CPLErr11CPLErrorNumPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Error handler that does not do anything, except for debug messages. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425CPLTurnFailureIntoWarningi">
<span id="_CPPv325CPLTurnFailureIntoWarningi"></span><span id="_CPPv225CPLTurnFailureIntoWarningi"></span><span id="CPLTurnFailureIntoWarning__i"></span><span class="target" id="cpl__error_8h_1a9110b6d0e50f3468987d1acf0974334d"></span>void <code class="descname">CPLTurnFailureIntoWarning</code><span class="sig-paren">(</span>int <em>bOn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CPLTurnFailureIntoWarningi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether failures should be turned into warnings. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLSetErrorHandler15CPLErrorHandler">
<span id="_CPPv318CPLSetErrorHandler15CPLErrorHandler"></span><span id="_CPPv218CPLSetErrorHandler15CPLErrorHandler"></span><span id="CPLSetErrorHandler__CPLErrorHandler"></span><span class="target" id="cpl__error_8h_1a74d0e649d58180e621540bf73b58e4a2"></span><a class="reference internal" href="#_CPPv415CPLErrorHandler" title="CPLErrorHandler">CPLErrorHandler</a> <code class="descname">CPLSetErrorHandler</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415CPLErrorHandler" title="CPLErrorHandler">CPLErrorHandler</a> <em>pfnErrorHandlerNew</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLSetErrorHandler15CPLErrorHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install custom error handler. </p>
<p>Allow the library’s user to specify an error handler function. A valid error handler is a C function with the following prototype:</p>
<p></p>
<p>Pass NULL to come back to the default behavior. The default behaviour (<a class="reference internal" href="#cpl__error_8h_1a8c59fe583fca85c275d4ff2531a42409"><span class="std std-ref">CPLDefaultErrorHandler()</span></a>) is to write the message to stderr.</p>
<p>The msg will be a partially formatted error message not containing the “ERROR %d:” portion emitted by the default handler. Message formatting is handled by <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> before calling the handler. If the error handler function is passed a CE_Fatal class error and returns, then <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> will call abort(). Applications wanting to interrupt this fatal behaviour will have to use longjmp(), or a C++ exception to indirectly exit the function.</p>
<p>Another standard error handler is <a class="reference internal" href="#cpl__error_8h_1adf8bbff86c116624fb84e8b0e7dfc156"><span class="std std-ref">CPLQuietErrorHandler()</span></a> which doesn’t make any attempt to report the passed error or warning messages but will process debug messages via CPLDefaultErrorHandler.</p>
<p>Note that error handlers set with <a class="reference internal" href="#cpl__error_8h_1a74d0e649d58180e621540bf73b58e4a2"><span class="std std-ref">CPLSetErrorHandler()</span></a> apply to all threads in an application, while error handlers set with CPLPushErrorHandler are thread-local. However, any error handlers pushed with CPLPushErrorHandler (and not removed with CPLPopErrorHandler) take precedence over the global error handlers set with <a class="reference internal" href="#cpl__error_8h_1a74d0e649d58180e621540bf73b58e4a2"><span class="std std-ref">CPLSetErrorHandler()</span></a>. Generally speaking <a class="reference internal" href="#cpl__error_8h_1a74d0e649d58180e621540bf73b58e4a2"><span class="std std-ref">CPLSetErrorHandler()</span></a> would be used to set a desired global error handler, while <a class="reference internal" href="#cpl__error_8h_1ad13c9c8f2037ddfd566c2a197f7b2537"><span class="std std-ref">CPLPushErrorHandler()</span></a> would be used to install a temporary local error handler, such as <a class="reference internal" href="#cpl__error_8h_1adf8bbff86c116624fb84e8b0e7dfc156"><span class="std std-ref">CPLQuietErrorHandler()</span></a> to suppress error reporting in a limited segment of code.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>returns the previously installed error handler. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pfnErrorHandlerNew</span></code>: new error handler function. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CPLSetErrorHandlerEx15CPLErrorHandlerPv">
<span id="_CPPv320CPLSetErrorHandlerEx15CPLErrorHandlerPv"></span><span id="_CPPv220CPLSetErrorHandlerEx15CPLErrorHandlerPv"></span><span id="CPLSetErrorHandlerEx__CPLErrorHandler.voidP"></span><span class="target" id="cpl__error_8h_1af21ae76c97853786ed32b9e3885d29ef"></span><a class="reference internal" href="#_CPPv415CPLErrorHandler" title="CPLErrorHandler">CPLErrorHandler</a> <code class="descname">CPLSetErrorHandlerEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415CPLErrorHandler" title="CPLErrorHandler">CPLErrorHandler</a> <em>pfnErrorHandlerNew</em>, void *<em>pUserData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLSetErrorHandlerEx15CPLErrorHandlerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install custom error handle with user’s data. </p>
<p>This method is essentially CPLSetErrorHandler with an added pointer to pUserData. The pUserData is not returned in the CPLErrorHandler, however, and must be fetched via CPLGetErrorHandlerUserData.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>returns the previously installed error handler. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pfnErrorHandlerNew</span></code>: new error handler function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pUserData</span></code>: User data to carry along with the error context. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CPLPushErrorHandler15CPLErrorHandler">
<span id="_CPPv319CPLPushErrorHandler15CPLErrorHandler"></span><span id="_CPPv219CPLPushErrorHandler15CPLErrorHandler"></span><span id="CPLPushErrorHandler__CPLErrorHandler"></span><span class="target" id="cpl__error_8h_1ad13c9c8f2037ddfd566c2a197f7b2537"></span>void <code class="descname">CPLPushErrorHandler</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415CPLErrorHandler" title="CPLErrorHandler">CPLErrorHandler</a> <em>pfnErrorHandlerNew</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLPushErrorHandler15CPLErrorHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Push a new CPLError handler. </p>
<p>This pushes a new error handler on the thread-local error handler stack. This handler will be used until removed with <a class="reference internal" href="#cpl__error_8h_1ac6c7c393c94b210e4be999f34fcb6680"><span class="std std-ref">CPLPopErrorHandler()</span></a>.</p>
<p>The <a class="reference internal" href="#cpl__error_8h_1a74d0e649d58180e621540bf73b58e4a2"><span class="std std-ref">CPLSetErrorHandler()</span></a> docs have further information on how CPLError handlers work.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pfnErrorHandlerNew</span></code>: new error handler function. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421CPLPushErrorHandlerEx15CPLErrorHandlerPv">
<span id="_CPPv321CPLPushErrorHandlerEx15CPLErrorHandlerPv"></span><span id="_CPPv221CPLPushErrorHandlerEx15CPLErrorHandlerPv"></span><span id="CPLPushErrorHandlerEx__CPLErrorHandler.voidP"></span><span class="target" id="cpl__error_8h_1a1ae5394e1e4249228d868a36127f70ab"></span>void <code class="descname">CPLPushErrorHandlerEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415CPLErrorHandler" title="CPLErrorHandler">CPLErrorHandler</a> <em>pfnErrorHandlerNew</em>, void *<em>pUserData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLPushErrorHandlerEx15CPLErrorHandlerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Push a new CPLError handler with user data on the error context. </p>
<p>This pushes a new error handler on the thread-local error handler stack. This handler will be used until removed with <a class="reference internal" href="#cpl__error_8h_1ac6c7c393c94b210e4be999f34fcb6680"><span class="std std-ref">CPLPopErrorHandler()</span></a>. Obtain the user data back by using CPLGetErrorContext().</p>
<p>The <a class="reference internal" href="#cpl__error_8h_1a74d0e649d58180e621540bf73b58e4a2"><span class="std std-ref">CPLSetErrorHandler()</span></a> docs have further information on how CPLError handlers work.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pfnErrorHandlerNew</span></code>: new error handler function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pUserData</span></code>: User data to put on the error context. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv435CPLSetCurrentErrorHandlerCatchDebugi">
<span id="_CPPv335CPLSetCurrentErrorHandlerCatchDebugi"></span><span id="_CPPv235CPLSetCurrentErrorHandlerCatchDebugi"></span><span id="CPLSetCurrentErrorHandlerCatchDebug__i"></span><span class="target" id="cpl__error_8h_1af3ffe7346fddc2e9ad4c62a49788edc4"></span>void <code class="descname">CPLSetCurrentErrorHandlerCatchDebug</code><span class="sig-paren">(</span>int <em>bCatchDebug</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435CPLSetCurrentErrorHandlerCatchDebugi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set if the current error handler should intercept debug messages, or if they should be processed by the previous handler. </p>
<p>By default when installing a custom error handler, this one intercepts debug messages. In some cases, this might not be desirable and the user would prefer that the previous installed handler (or the default one if no previous installed handler exists in the stack) deal with it. In which case, this function should be called with bCatchDebug = FALSE.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bCatchDebug</span></code>: FALSE if the current error handler should not intercept debug messages </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLPopErrorHandlerv">
<span id="_CPPv318CPLPopErrorHandlerv"></span><span id="_CPPv218CPLPopErrorHandlerv"></span><span id="CPLPopErrorHandler__void"></span><span class="target" id="cpl__error_8h_1ac6c7c393c94b210e4be999f34fcb6680"></span>void <code class="descname">CPLPopErrorHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLPopErrorHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pop error handler off stack. </p>
<p>Discards the current error handler on the error handler stack, and restores the one in use before the last <a class="reference internal" href="#cpl__error_8h_1ad13c9c8f2037ddfd566c2a197f7b2537"><span class="std std-ref">CPLPushErrorHandler()</span></a> call. This method has no effect if there are no error handlers on the current threads error handler stack. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48CPLDebugPKcPKcz">
<span id="_CPPv38CPLDebugPKcPKcz"></span><span id="_CPPv28CPLDebugPKcPKcz"></span><span id="CPLDebug__cCP.cCP.z"></span><span class="target" id="cpl__error_8h_1ad0c5d3481dd34c1f3a0f7775ebf74817"></span>void <code class="descname">CPLDebug</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszCategory</em>, <em class="property">const</em> char *<em>pszFormat</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CPLDebugPKcPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Display a debugging message. </p>
<p>The category argument is used in conjunction with the CPL_DEBUG environment variable to establish if the message should be displayed. If the CPL_DEBUG environment variable is not set, no debug messages are emitted (use CPLError(CE_Warning, …) to ensure messages are displayed). If CPL_DEBUG is set, but is an empty string or the word “ON” then all debug messages are shown. Otherwise only messages whose category appears somewhere within the CPL_DEBUG value are displayed (as determined by strstr()).</p>
<p>Categories are usually an identifier for the subsystem producing the error. For instance “GDAL” might be used for the GDAL core, and “TIFF” for messages from the TIFF translator.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszCategory</span></code>: name of the debugging message category. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFormat</span></code>: printf() style format string for message to display. Remaining arguments are assumed to be for format. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410_CPLAssertPKcPKci">
<span id="_CPPv310_CPLAssertPKcPKci"></span><span id="_CPPv210_CPLAssertPKcPKci"></span><span id="_CPLAssert__cCP.cCP.i"></span><span class="target" id="cpl__error_8h_1a2ac4c18f1224f05211a076ee7b1af33d"></span>void <code class="descname">_CPLAssert</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszExpression</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>iLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410_CPLAssertPKcPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report failure of a logical assertion. </p>
<p>Applications would normally use the <a class="reference internal" href="#cpl__error_8h_1a40ae27078f2a969a445daa022405cf72"><span class="std std-ref">CPLAssert()</span></a> macro which expands into code calling <a class="reference internal" href="#cpl__error_8h_1a2ac4c18f1224f05211a076ee7b1af33d"><span class="std std-ref">_CPLAssert()</span></a> only if the condition fails. <a class="reference internal" href="#cpl__error_8h_1a2ac4c18f1224f05211a076ee7b1af33d"><span class="std std-ref">_CPLAssert()</span></a> will generate a CE_Fatal error call to <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>, indicating the file name, and line number of the failed assertion, as well as containing the assertion itself.</p>
<p>There is no reason for application code to call <a class="reference internal" href="#cpl__error_8h_1a2ac4c18f1224f05211a076ee7b1af33d"><span class="std std-ref">_CPLAssert()</span></a> directly. </p>
</dd></dl>

</div>
</div>
<div class="section" id="cpl-http-h">
<h2>cpl_http.h<a class="headerlink" href="#cpl-http-h" title="Permalink to this headline">¶</a></h2>
<p>Interface for downloading HTTP, FTP documents. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv414CPLHTTPEnabledv">
<span id="_CPPv314CPLHTTPEnabledv"></span><span id="_CPPv214CPLHTTPEnabledv"></span><span id="CPLHTTPEnabled__void"></span><span class="target" id="cpl__http_8h_1aa024615adc5369c42efc07dbd05596a9"></span>int <code class="descname">CPLHTTPEnabled</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLHTTPEnabledv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if CPLHTTP services can be useful. </p>
<p>Those services depend on GDAL being build with libcurl support.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if libcurl support is enabled </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLHTTPFetchPKc12CSLConstList">
<span id="_CPPv312CPLHTTPFetchPKc12CSLConstList"></span><span id="_CPPv212CPLHTTPFetchPKc12CSLConstList"></span><span id="CPLHTTPFetch__cCP.CSLConstList"></span><span class="target" id="cpl__http_8h_1a578662ddc6557b028fecc36e302aed41"></span><a class="reference internal" href="#_CPPv413CPLHTTPResult" title="CPLHTTPResult">CPLHTTPResult</a> *<code class="descname">CPLHTTPFetch</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszURL</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLHTTPFetchPKc12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a document from an url and return in a string. </p>
<p><p>Alternatively, if not defined in the papszOptions arguments, the CONNECTTIMEOUT, TIMEOUT, LOW_SPEED_TIME, LOW_SPEED_LIMIT, USERPWD, PROXY, HTTPS_PROXY, PROXYUSERPWD, PROXYAUTH, NETRC, MAX_RETRY and RETRY_DELAY, HEADER_FILE, HTTP_VERSION, SSL_VERIFYSTATUS, USE_CAPI_STORE values are searched in the configuration options respectively named GDAL_HTTP_CONNECTTIMEOUT, GDAL_HTTP_TIMEOUT, GDAL_HTTP_LOW_SPEED_TIME, GDAL_HTTP_LOW_SPEED_LIMIT, GDAL_HTTP_USERPWD, GDAL_HTTP_PROXY, GDAL_HTTPS_PROXY, GDAL_HTTP_PROXYUSERPWD, GDAL_PROXY_AUTH, GDAL_HTTP_NETRC, GDAL_HTTP_MAX_RETRY, GDAL_HTTP_RETRY_DELAY, GDAL_HTTP_HEADER_FILE, GDAL_HTTP_VERSION, GDAL_HTTP_SSL_VERIFYSTATUS, GDAL_HTTP_USE_CAPI_STORE</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszURL</span></code>: valid URL recognized by underlying download library (libcurl) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: option list as a NULL-terminated array of strings. May be NULL. The following options are handled : <ul>
<li><p>CONNECTTIMEOUT=val, where val is in seconds (possibly with decimals). This is the maximum delay for the connection to be established before being aborted (GDAL &gt;= 2.2). </p></li>
<li><p>TIMEOUT=val, where val is in seconds. This is the maximum delay for the whole request to complete before being aborted. </p></li>
<li><p>LOW_SPEED_TIME=val, where val is in seconds. This is the maximum time where the transfer speed should be below the LOW_SPEED_LIMIT (if not specified 1b/s), before the transfer to be considered too slow and aborted. (GDAL &gt;= 2.1) </p></li>
<li><p>LOW_SPEED_LIMIT=val, where val is in bytes/second. See LOW_SPEED_TIME. Has only effect if LOW_SPEED_TIME is specified too. (GDAL &gt;= 2.1) </p></li>
<li><p>HEADERS=val, where val is an extra header to use when getting a web page. For example “Accept: application/x-ogcwkt” </p></li>
<li><p>HEADER_FILE=filename: filename of a text file with “key: value” headers. (GDAL &gt;= 2.2) </p></li>
<li><p>HTTPAUTH=[BASIC/NTLM/GSSNEGOTIATE/ANY] to specify an authentication scheme to use. </p></li>
<li><p>USERPWD=userid:password to specify a user and password for authentication </p></li>
<li><p>POSTFIELDS=val, where val is a nul-terminated string to be passed to the server with a POST request. </p></li>
<li><p>PROXY=val, to make requests go through a proxy server, where val is of the form proxy.server.com:port_number. This option affects both HTTP and HTTPS URLs. </p></li>
<li><p>HTTPS_PROXY=val (GDAL &gt;= 2.4), the same meaning as PROXY, but this option is taken into account only for HTTPS URLs. </p></li>
<li><p>PROXYUSERPWD=val, where val is of the form username:password </p></li>
<li><p>PROXYAUTH=[BASIC/NTLM/DIGEST/ANY] to specify an proxy authentication scheme to use. </p></li>
<li><p>NETRC=[YES/NO] to enable or disable use of $HOME/.netrc, default YES. </p></li>
<li><p>CUSTOMREQUEST=val, where val is GET, PUT, POST, DELETE, etc.. (GDAL &gt;= 1.9.0) </p></li>
<li><p>FORM_FILE_NAME=val, where val is upload file name. If this option and FORM_FILE_PATH present, request type will set to POST. </p></li>
<li><p>FORM_FILE_PATH=val, where val is upload file path. </p></li>
<li><p>FORM_KEY_0=val…FORM_KEY_N, where val is name of form item. </p></li>
<li><p>FORM_VALUE_0=val…FORM_VALUE_N, where val is value of the form item. </p></li>
<li><p>FORM_ITEM_COUNT=val, where val is count of form items. </p></li>
<li><p>COOKIE=val, where val is formatted as COOKIE1=VALUE1; COOKIE2=VALUE2; … </p></li>
<li><p>COOKIEFILE=val, where val is file name to read cookies from (GDAL &gt;= 2.4) </p></li>
<li><p>COOKIEJAR=val, where val is file name to store cookies to (GDAL &gt;= 2.4) </p></li>
<li><p>MAX_RETRY=val, where val is the maximum number of retry attempts if a 429, 502, 503 or 504 HTTP error occurs. Default is 0. (GDAL &gt;= 2.0) </p></li>
<li><p>RETRY_DELAY=val, where val is the number of seconds between retry attempts. Default is 30. (GDAL &gt;= 2.0) </p></li>
<li><p>MAX_FILE_SIZE=val, where val is a number of bytes (GDAL &gt;= 2.2) </p></li>
<li><p>CAINFO=/path/to/bundle.crt. This is path to Certificate Authority (CA) bundle file. By default, it will be looked in a system location. If the CAINFO options is not defined, GDAL will also look if the CURL_CA_BUNDLE environment variable is defined to use it as the CAINFO value, and as a fallback to the SSL_CERT_FILE environment variable. (GDAL &gt;= 2.1.3) </p></li>
<li><p>HTTP_VERSION=1.0/1.1/2/2TLS (GDAL &gt;= 2.3). Specify HTTP version to use. Will default to 1.1 generally (except on some controlled environments, like Google Compute Engine VMs, where 2TLS will be the default). Support for HTTP/2 requires curl 7.33 or later, built against nghttp2. “2TLS” means that HTTP/2 will be attempted for HTTPS connections only. Whereas “2” means that HTTP/2 will be attempted for HTTP or HTTPS. </p></li>
<li><p>SSL_VERIFYSTATUS=YES/NO (GDAL &gt;= 2.3, and curl &gt;= 7.41): determines whether the status of the server cert using the “Certificate Status Request” TLS extension (aka. OCSP stapling) should be checked. If this option is enabled but the server does not support the TLS extension, the verification will fail. Default to NO. </p></li>
<li><p>USE_CAPI_STORE=YES/NO (GDAL &gt;= 2.3, Windows only): whether CA certificates from the Windows certificate store. Defaults to NO. </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a CPLHTTPResult* structure that must be freed by <a class="reference internal" href="#cpl__http_8h_1ab9a9077d09a1ebd94fb2bf4c80efb240"><span class="std std-ref">CPLHTTPDestroyResult()</span></a>, or NULL if libcurl support is disabled </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLHTTPFetchExPKc12CSLConstList16GDALProgressFuncPv21CPLHTTPFetchWriteFuncPv">
<span id="_CPPv314CPLHTTPFetchExPKc12CSLConstList16GDALProgressFuncPv21CPLHTTPFetchWriteFuncPv"></span><span id="_CPPv214CPLHTTPFetchExPKc12CSLConstList16GDALProgressFuncPv21CPLHTTPFetchWriteFuncPv"></span><span id="CPLHTTPFetchEx__cCP.CSLConstList.GDALProgressFunc.voidP.CPLHTTPFetchWriteFunc.voidP"></span><span class="target" id="cpl__http_8h_1a6ba7a6c5f4186c0fbe3645690995be8a"></span><a class="reference internal" href="#_CPPv413CPLHTTPResult" title="CPLHTTPResult">CPLHTTPResult</a> *<code class="descname">CPLHTTPFetchEx</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszURL</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em>, <a class="reference internal" href="#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em>, CPLHTTPFetchWriteFunc <em>pfnWrite</em>, void *<em>pWriteArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLHTTPFetchExPKc12CSLConstList16GDALProgressFuncPv21CPLHTTPFetchWriteFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a document from an url and return in a string. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A CPLHTTPResult* structure that must be freed by <a class="reference internal" href="#cpl__http_8h_1ab9a9077d09a1ebd94fb2bf4c80efb240"><span class="std std-ref">CPLHTTPDestroyResult()</span></a>, or NULL if libcurl support is disabled. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszURL</span></code>: Url to fetch document from web. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: Option list as a NULL-terminated array of strings. Available keys see in CPLHTTPFetch. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: Callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: Callback argument passed to pfnProgress. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnWrite</span></code>: Write function pointer matching the CPLHTTPWriteFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pWriteArg</span></code>: Argument which will pass to a write function. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLHTTPMultiFetchPPCKcii12CSLConstList">
<span id="_CPPv317CPLHTTPMultiFetchPPCKcii12CSLConstList"></span><span id="_CPPv217CPLHTTPMultiFetchPPCKcii12CSLConstList"></span><span id="CPLHTTPMultiFetch__cCPCP.i.i.CSLConstList"></span><span class="target" id="cpl__http_8h_1a79571a3cef163828f1534bfabd678a52"></span><a class="reference internal" href="#_CPPv413CPLHTTPResult" title="CPLHTTPResult">CPLHTTPResult</a> **<code class="descname">CPLHTTPMultiFetch</code><span class="sig-paren">(</span><em class="property">const</em> char *<em class="property">const</em> *<em>papszURL</em>, int <em>nURLCount</em>, int <em>nMaxSimultaneous</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLHTTPMultiFetchPPCKcii12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch several documents at once. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an array of CPLHTTPResult* structures that must be freed by <a class="reference internal" href="#cpl__http_8h_1acd729c2f33acf75e9a364ac1c90941b6"><span class="std std-ref">CPLHTTPDestroyMultiResult()</span></a> or NULL if libcurl support is disabled</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszURL</span></code>: array of valid URLs recognized by underlying download library (libcurl) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nURLCount</span></code>: number of URLs of papszURL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxSimultaneous</span></code>: maximum number of downloads to issue simultaneously. Any negative or zer value means unlimited. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: option list as a NULL-terminated array of strings. May be NULL. Refer to <a class="reference internal" href="#cpl__http_8h_1a578662ddc6557b028fecc36e302aed41"><span class="std std-ref">CPLHTTPFetch()</span></a> for valid options. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLHTTPCleanupv">
<span id="_CPPv314CPLHTTPCleanupv"></span><span id="_CPPv214CPLHTTPCleanupv"></span><span id="CPLHTTPCleanup__void"></span><span class="target" id="cpl__http_8h_1a3a6f247c254d96cc4e3bf0357b6f475b"></span>void <code class="descname">CPLHTTPCleanup</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLHTTPCleanupv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cleanup function to call at application termination. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CPLHTTPDestroyResultP13CPLHTTPResult">
<span id="_CPPv320CPLHTTPDestroyResultP13CPLHTTPResult"></span><span id="_CPPv220CPLHTTPDestroyResultP13CPLHTTPResult"></span><span id="CPLHTTPDestroyResult__CPLHTTPResultP"></span><span class="target" id="cpl__http_8h_1ab9a9077d09a1ebd94fb2bf4c80efb240"></span>void <code class="descname">CPLHTTPDestroyResult</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLHTTPResult" title="CPLHTTPResult">CPLHTTPResult</a> *<em>psResult</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLHTTPDestroyResultP13CPLHTTPResult" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean the memory associated with the return value of <a class="reference internal" href="#cpl__http_8h_1a578662ddc6557b028fecc36e302aed41"><span class="std std-ref">CPLHTTPFetch()</span></a> </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psResult</span></code>: pointer to the return value of <a class="reference internal" href="#cpl__http_8h_1a578662ddc6557b028fecc36e302aed41"><span class="std std-ref">CPLHTTPFetch()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425CPLHTTPDestroyMultiResultPP13CPLHTTPResulti">
<span id="_CPPv325CPLHTTPDestroyMultiResultPP13CPLHTTPResulti"></span><span id="_CPPv225CPLHTTPDestroyMultiResultPP13CPLHTTPResulti"></span><span id="CPLHTTPDestroyMultiResult__CPLHTTPResultPP.i"></span><span class="target" id="cpl__http_8h_1acd729c2f33acf75e9a364ac1c90941b6"></span>void <code class="descname">CPLHTTPDestroyMultiResult</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLHTTPResult" title="CPLHTTPResult">CPLHTTPResult</a> **<em>papsResults</em>, int <em>nCount</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CPLHTTPDestroyMultiResultPP13CPLHTTPResulti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean the memory associated with the return value of <a class="reference internal" href="#cpl__http_8h_1a79571a3cef163828f1534bfabd678a52"><span class="std std-ref">CPLHTTPMultiFetch()</span></a> </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papsResults</span></code>: pointer to the return value of <a class="reference internal" href="#cpl__http_8h_1a79571a3cef163828f1534bfabd678a52"><span class="std std-ref">CPLHTTPMultiFetch()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: value of the nURLCount parameter passed to <a class="reference internal" href="#cpl__http_8h_1a79571a3cef163828f1534bfabd678a52"><span class="std std-ref">CPLHTTPMultiFetch()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425CPLHTTPParseMultipartMimeP13CPLHTTPResult">
<span id="_CPPv325CPLHTTPParseMultipartMimeP13CPLHTTPResult"></span><span id="_CPPv225CPLHTTPParseMultipartMimeP13CPLHTTPResult"></span><span id="CPLHTTPParseMultipartMime__CPLHTTPResultP"></span><span class="target" id="cpl__http_8h_1aea965c9ff390520fa3b6c99971b8bef2"></span>int <code class="descname">CPLHTTPParseMultipartMime</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLHTTPResult" title="CPLHTTPResult">CPLHTTPResult</a> *<em>psResult</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CPLHTTPParseMultipartMimeP13CPLHTTPResult" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parses a MIME multipart message. </p>
<p>This function will iterate over each part and put it in a separate element of the pasMimePart array of the provided psResult structure.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the message contains MIME multipart message. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psResult</span></code>: pointer to the return value of <a class="reference internal" href="#cpl__http_8h_1a578662ddc6557b028fecc36e302aed41"><span class="std std-ref">CPLHTTPFetch()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423GOA2GetAuthorizationURLPKc">
<span id="_CPPv323GOA2GetAuthorizationURLPKc"></span><span id="_CPPv223GOA2GetAuthorizationURLPKc"></span><span id="GOA2GetAuthorizationURL__cCP"></span><span class="target" id="cpl__http_8h_1a8793ce5fc5402ad4d353a713703995c6"></span>char *<code class="descname">GOA2GetAuthorizationURL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszScope</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423GOA2GetAuthorizationURLPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return authorization url for a given scope. </p>
<p>Returns the URL that a user should visit, and use for authentication in order to get an “auth token” indicating their willingness to use a service.</p>
<p><p>Note that when the user visits this url they will be asked to login (using a google/gmail/etc) account, and to authorize use of the requested scope for the application “GDAL/OGR”. Once they have done so, they will be presented with a lengthy string they should “enter</p>
<p>into their application”. This is the “auth token” to be passed to </p>
<a class="reference internal" href="#cpl__http_8h_1aa75528c90727da832400f0b9c88e77ab"><span class="std std-ref">GOA2GetRefreshToken()</span></a>. The “auth token” can only be used once.</p>
<p>This function should never fail.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the URL to visit - should be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszScope</span></code>: the service being requested, not yet URL encoded, such as “https://www.googleapis.com/auth/fusiontables”.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419GOA2GetRefreshTokenPKcPKc">
<span id="_CPPv319GOA2GetRefreshTokenPKcPKc"></span><span id="_CPPv219GOA2GetRefreshTokenPKcPKc"></span><span id="GOA2GetRefreshToken__cCP.cCP"></span><span class="target" id="cpl__http_8h_1aa75528c90727da832400f0b9c88e77ab"></span>char *<code class="descname">GOA2GetRefreshToken</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszAuthToken</em>, <em class="property">const</em> char *<em>pszScope</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GOA2GetRefreshTokenPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Turn Auth Token into a Refresh Token. </p>
<p>A one time “auth token” provided by the user is turned into a reusable “refresh token” using a google oauth2 web service.</p>
<p>A CPLError will be reported if the translation fails for some reason. Common reasons include the auth token already having been used before, it not being appropriate for the passed scope and configured client api or http connection problems. NULL is returned on error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>refresh token, to be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>, null on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszAuthToken</span></code>: the authorization token from the user. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszScope</span></code>: the scope for which it is valid.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418GOA2GetAccessTokenPKcPKc">
<span id="_CPPv318GOA2GetAccessTokenPKcPKc"></span><span id="_CPPv218GOA2GetAccessTokenPKcPKc"></span><span id="GOA2GetAccessToken__cCP.cCP"></span><span class="target" id="cpl__http_8h_1aa97c9ff3bd3ad4d0d0f8a68bff4f30e9"></span>char *<code class="descname">GOA2GetAccessToken</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszRefreshToken</em>, <em class="property">const</em> char *<em>pszScope</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418GOA2GetAccessTokenPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch access token using refresh token. </p>
<p>The permanent refresh token is used to fetch a temporary (usually one hour) access token using Google OAuth2 web services.</p>
<p>A CPLError will be reported if the request fails for some reason. Common reasons include the refresh token having been revoked by the user or http connection problems.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>access token, to be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>, null on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszRefreshToken</span></code>: the refresh token from <a class="reference internal" href="#cpl__http_8h_1aa75528c90727da832400f0b9c88e77ab"><span class="std std-ref">GOA2GetRefreshToken()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszScope</span></code>: the scope for which it is valid. Currently unused</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv436GOA2GetAccessTokenFromServiceAccountPKcPKcPKc12CSLConstList12CSLConstList">
<span id="_CPPv336GOA2GetAccessTokenFromServiceAccountPKcPKcPKc12CSLConstList12CSLConstList"></span><span id="_CPPv236GOA2GetAccessTokenFromServiceAccountPKcPKcPKc12CSLConstList12CSLConstList"></span><span id="GOA2GetAccessTokenFromServiceAccount__cCP.cCP.cCP.CSLConstList.CSLConstList"></span><span class="target" id="cpl__http_8h_1a024dade12326523167239e0dfdfe8c2f"></span>char **<code class="descname">GOA2GetAccessTokenFromServiceAccount</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPrivateKey</em>, <em class="property">const</em> char *<em>pszClientEmail</em>, <em class="property">const</em> char *<em>pszScope</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszAdditionalClaims</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436GOA2GetAccessTokenFromServiceAccountPKcPKcPKc12CSLConstList12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch access token using Service Account OAuth2. </p>
<p>See <a class="reference external" href="https://developers.google.com/identity/protocols/OAuth2ServiceAccount">https://developers.google.com/identity/protocols/OAuth2ServiceAccount</a></p>
<p>A CPLError will be reported if the request fails for some reason.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a list of key=value pairs, including a access_token and expires_in </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPrivateKey</span></code>: Private key as a RSA private key </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszClientEmail</span></code>: Client email </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszScope</span></code>: the service being requested </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszAdditionalClaims</span></code>: additional claims, or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options. None currently</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv435GOA2GetAccessTokenFromCloudEngineVM12CSLConstList">
<span id="_CPPv335GOA2GetAccessTokenFromCloudEngineVM12CSLConstList"></span><span id="_CPPv235GOA2GetAccessTokenFromCloudEngineVM12CSLConstList"></span><span id="GOA2GetAccessTokenFromCloudEngineVM__CSLConstList"></span><span class="target" id="cpl__http_8h_1a6f466baa17351444f6e71101ee375612"></span>char **<code class="descname">GOA2GetAccessTokenFromCloudEngineVM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435GOA2GetAccessTokenFromCloudEngineVM12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch access token using Cloud Engine internal REST API. </p>
<p>The default service accounts bound to the current Google Cloud Engine VM is used for OAuth2 authentication</p>
<p>A CPLError will be reported if the request fails for some reason. Common reasons include the refresh token having been revoked by the user or http connection problems.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a list of key=value pairs, including a access_token and expires_in </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options. None currently</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv434CPLIsMachinePotentiallyGCEInstancev">
<span id="_CPPv334CPLIsMachinePotentiallyGCEInstancev"></span><span id="_CPPv234CPLIsMachinePotentiallyGCEInstancev"></span><span id="CPLIsMachinePotentiallyGCEInstance"></span><span class="target" id="cpl__http_8h_1a462c5d4ed50580fc5877de48eb6426d3"></span>bool <code class="descname">CPLIsMachinePotentiallyGCEInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434CPLIsMachinePotentiallyGCEInstancev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the current machine is potentially a Google Compute Engine instance. </p>
<p>This does a very quick check without network access. To confirm if the machine is effectively a GCE instance, metadata.google.internal must be queried.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the current machine is potentially a GCE instance. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430CPLIsMachineForSureGCEInstancev">
<span id="_CPPv330CPLIsMachineForSureGCEInstancev"></span><span id="_CPPv230CPLIsMachineForSureGCEInstancev"></span><span id="CPLIsMachineForSureGCEInstance"></span><span class="target" id="cpl__http_8h_1a5e67d6cef042a4f542679d17413e4ad1"></span>bool <code class="descname">CPLIsMachineForSureGCEInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430CPLIsMachineForSureGCEInstancev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the current machine is surely a Google Compute Engine instance. </p>
<p>This does a very quick check without network access. Note: only works for Linux GCE instances.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the current machine is surely a GCE instance. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv411CPLMimePart">
<span id="_CPPv311CPLMimePart"></span><span id="_CPPv211CPLMimePart"></span><span id="CPLMimePart"></span><span class="target" id="structCPLMimePart"></span><em class="property">struct </em><code class="descname">CPLMimePart</code><a class="headerlink" href="#_CPPv411CPLMimePart" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_http.h&gt;</em><p>Describe a part of a multipart message </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N11CPLMimePart12papszHeadersE">
<span id="_CPPv3N11CPLMimePart12papszHeadersE"></span><span id="_CPPv2N11CPLMimePart12papszHeadersE"></span><span id="CPLMimePart::papszHeaders__cPP"></span><span class="target" id="structCPLMimePart_1a0367a54d84f5164d542a4afc71414819"></span>char **<code class="descname">papszHeaders</code><a class="headerlink" href="#_CPPv4N11CPLMimePart12papszHeadersE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>NULL terminated array of headers </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11CPLMimePart8pabyDataE">
<span id="_CPPv3N11CPLMimePart8pabyDataE"></span><span id="_CPPv2N11CPLMimePart8pabyDataE"></span><span id="CPLMimePart::pabyData__GByteP"></span><span class="target" id="structCPLMimePart_1a6e934c417190b093d1f5547dd315ca83"></span><a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<code class="descname">pabyData</code><a class="headerlink" href="#_CPPv4N11CPLMimePart8pabyDataE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Buffer with data of the part </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11CPLMimePart8nDataLenE">
<span id="_CPPv3N11CPLMimePart8nDataLenE"></span><span id="_CPPv2N11CPLMimePart8nDataLenE"></span><span id="CPLMimePart::nDataLen__i"></span><span class="target" id="structCPLMimePart_1a57e3cadf6df58d374b6721273d6810ab"></span>int <code class="descname">nDataLen</code><a class="headerlink" href="#_CPPv4N11CPLMimePart8nDataLenE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Buffer length </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv413CPLHTTPResult">
<span id="_CPPv313CPLHTTPResult"></span><span id="_CPPv213CPLHTTPResult"></span><span id="CPLHTTPResult"></span><span class="target" id="structCPLHTTPResult"></span><em class="property">struct </em><code class="descname">CPLHTTPResult</code><a class="headerlink" href="#_CPPv413CPLHTTPResult" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_http.h&gt;</em><p>Describe the result of a <a class="reference internal" href="#cpl__http_8h_1a578662ddc6557b028fecc36e302aed41"><span class="std std-ref">CPLHTTPFetch()</span></a> call </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult7nStatusE">
<span id="_CPPv3N13CPLHTTPResult7nStatusE"></span><span id="_CPPv2N13CPLHTTPResult7nStatusE"></span><span id="CPLHTTPResult::nStatus__i"></span><span class="target" id="structCPLHTTPResult_1a166662b7a348b3e009669a7bef9277f7"></span>int <code class="descname">nStatus</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult7nStatusE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cURL error code : 0=success, non-zero if request failed </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult14pszContentTypeE">
<span id="_CPPv3N13CPLHTTPResult14pszContentTypeE"></span><span id="_CPPv2N13CPLHTTPResult14pszContentTypeE"></span><span id="CPLHTTPResult::pszContentType__cP"></span><span class="target" id="structCPLHTTPResult_1a990bea42d93cdd41391e44d21f5547d2"></span>char *<code class="descname">pszContentType</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult14pszContentTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Content-Type of the response </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult9pszErrBufE">
<span id="_CPPv3N13CPLHTTPResult9pszErrBufE"></span><span id="_CPPv2N13CPLHTTPResult9pszErrBufE"></span><span id="CPLHTTPResult::pszErrBuf__cP"></span><span class="target" id="structCPLHTTPResult_1ab12ef4fe5ff02f4ba459bd09e3481996"></span>char *<code class="descname">pszErrBuf</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult9pszErrBufE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Error message from curl, or NULL </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult8nDataLenE">
<span id="_CPPv3N13CPLHTTPResult8nDataLenE"></span><span id="_CPPv2N13CPLHTTPResult8nDataLenE"></span><span id="CPLHTTPResult::nDataLen__i"></span><span class="target" id="structCPLHTTPResult_1adc164db6153c5e4b7e5ae831abe17cdd"></span>int <code class="descname">nDataLen</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult8nDataLenE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Length of the pabyData buffer </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult10nDataAllocE">
<span id="_CPPv3N13CPLHTTPResult10nDataAllocE"></span><span id="_CPPv2N13CPLHTTPResult10nDataAllocE"></span><span id="CPLHTTPResult::nDataAlloc__i"></span><span class="target" id="structCPLHTTPResult_1a997d309c8defac22fec207b7b3c63ef1"></span>int <code class="descname">nDataAlloc</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult10nDataAllocE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocated size of the pabyData buffer </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult8pabyDataE">
<span id="_CPPv3N13CPLHTTPResult8pabyDataE"></span><span id="_CPPv2N13CPLHTTPResult8pabyDataE"></span><span id="CPLHTTPResult::pabyData__GByteP"></span><span class="target" id="structCPLHTTPResult_1a036fe44623bd4fbfb0d745e3d8061dd3"></span><a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<code class="descname">pabyData</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult8pabyDataE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Buffer with downloaded data </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult12papszHeadersE">
<span id="_CPPv3N13CPLHTTPResult12papszHeadersE"></span><span id="_CPPv2N13CPLHTTPResult12papszHeadersE"></span><span id="CPLHTTPResult::papszHeaders__cPP"></span><span class="target" id="structCPLHTTPResult_1a9e4030d7c1fc15ed3a16e5d81657b04a"></span>char **<code class="descname">papszHeaders</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult12papszHeadersE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Headers returned </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult14nMimePartCountE">
<span id="_CPPv3N13CPLHTTPResult14nMimePartCountE"></span><span id="_CPPv2N13CPLHTTPResult14nMimePartCountE"></span><span id="CPLHTTPResult::nMimePartCount__i"></span><span class="target" id="structCPLHTTPResult_1abfc73d0ee8dcecafbc6e146c3de35e20"></span>int <code class="descname">nMimePartCount</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult14nMimePartCountE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Number of parts in a multipart message </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLHTTPResult11pasMimePartE">
<span id="_CPPv3N13CPLHTTPResult11pasMimePartE"></span><span id="_CPPv2N13CPLHTTPResult11pasMimePartE"></span><span id="CPLHTTPResult::pasMimePart__CPLMimePartP"></span><span class="target" id="structCPLHTTPResult_1a6f2a684692f0d76f12b87e1c74e1122a"></span><a class="reference internal" href="#_CPPv411CPLMimePart" title="CPLMimePart">CPLMimePart</a> *<code class="descname">pasMimePart</code><a class="headerlink" href="#_CPPv4N13CPLHTTPResult11pasMimePartE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Array of parts (resolved by <a class="reference internal" href="#cpl__http_8h_1aea965c9ff390520fa3b6c99971b8bef2"><span class="std std-ref">CPLHTTPParseMultipartMime()</span></a>) </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv411GOA2Manager">
<span id="_CPPv311GOA2Manager"></span><span id="_CPPv211GOA2Manager"></span><span id="GOA2Manager"></span><span class="target" id="classGOA2Manager"></span><em class="property">class </em><code class="descname">GOA2Manager</code><a class="headerlink" href="#_CPPv411GOA2Manager" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_http.h&gt;</em><p>Manager of Google OAuth2 authentication. </p>
<p>This class handles different authentication methods and handles renewal of access token.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="enum">
<dt id="_CPPv410AuthMethod">
<span id="_CPPv310AuthMethod"></span><span id="_CPPv210AuthMethod"></span><span class="target" id="classGOA2Manager_1aecaa4fc4398575379124084b3a0ff068"></span><em class="property">enum </em><code class="descname">AuthMethod</code><a class="headerlink" href="#_CPPv410AuthMethod" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Authentication method. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv44NONE">
<span id="_CPPv34NONE"></span><span id="_CPPv24NONE"></span><span class="target" id="classGOA2Manager_1aecaa4fc4398575379124084b3a0ff068adf71d799877acece6dc5934a8f11a36b"></span><code class="descname">NONE</code><a class="headerlink" href="#_CPPv44NONE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv43GCE">
<span id="_CPPv33GCE"></span><span id="_CPPv23GCE"></span><span class="target" id="classGOA2Manager_1aecaa4fc4398575379124084b3a0ff068adb8fde8f1ee26d286fd53db84617a3a1"></span><code class="descname">GCE</code><a class="headerlink" href="#_CPPv43GCE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv425ACCESS_TOKEN_FROM_REFRESH">
<span id="_CPPv325ACCESS_TOKEN_FROM_REFRESH"></span><span id="_CPPv225ACCESS_TOKEN_FROM_REFRESH"></span><span class="target" id="classGOA2Manager_1aecaa4fc4398575379124084b3a0ff068a81365b250ac9686c284d2173f66b550e"></span><code class="descname">ACCESS_TOKEN_FROM_REFRESH</code><a class="headerlink" href="#_CPPv425ACCESS_TOKEN_FROM_REFRESH" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv415SERVICE_ACCOUNT">
<span id="_CPPv315SERVICE_ACCOUNT"></span><span id="_CPPv215SERVICE_ACCOUNT"></span><span class="target" id="classGOA2Manager_1aecaa4fc4398575379124084b3a0ff068a1f01f6c1f4e2d676a96d0449e2eccd1c"></span><code class="descname">SERVICE_ACCOUNT</code><a class="headerlink" href="#_CPPv415SERVICE_ACCOUNT" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N11GOA2Manager11GOA2ManagerEv">
<span id="_CPPv3N11GOA2Manager11GOA2ManagerEv"></span><span id="_CPPv2N11GOA2Manager11GOA2ManagerEv"></span><span id="GOA2Manager::GOA2Manager"></span><span class="target" id="classGOA2Manager_1a3c58e1b1195e3458f44bebcce9db2bef"></span><code class="descname">GOA2Manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11GOA2Manager11GOA2ManagerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11GOA2Manager14SetAuthFromGCEE12CSLConstList">
<span id="_CPPv3N11GOA2Manager14SetAuthFromGCEE12CSLConstList"></span><span id="_CPPv2N11GOA2Manager14SetAuthFromGCEE12CSLConstList"></span><span id="GOA2Manager::SetAuthFromGCE__CSLConstList"></span><span class="target" id="classGOA2Manager_1ac8d05dc92869f097b190217f62cd6df1"></span>bool <code class="descname">SetAuthFromGCE</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11GOA2Manager14SetAuthFromGCEE12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specifies that the authentication will be done using the local credentials of the current Google Compute Engine VM. </p>
<p>This queries <a class="reference external" href="http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token">http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token</a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true in case of success (no network access is done at this stage) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11GOA2Manager23SetAuthFromRefreshTokenEPKcPKcPKc12CSLConstList">
<span id="_CPPv3N11GOA2Manager23SetAuthFromRefreshTokenEPKcPKcPKc12CSLConstList"></span><span id="_CPPv2N11GOA2Manager23SetAuthFromRefreshTokenEPKcPKcPKc12CSLConstList"></span><span id="GOA2Manager::SetAuthFromRefreshToken__cCP.cCP.cCP.CSLConstList"></span><span class="target" id="classGOA2Manager_1a6b4387e7fd6d034abf37cb973aa28c77"></span>bool <code class="descname">SetAuthFromRefreshToken</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszRefreshToken</em>, <em class="property">const</em> char *<em>pszClientId</em>, <em class="property">const</em> char *<em>pszClientSecret</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11GOA2Manager23SetAuthFromRefreshTokenEPKcPKcPKc12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specifies that the authentication will be done using the OAuth2 client id method. </p>
<p>See <a class="reference external" href="http://code.google.com/apis/accounts/docs/OAuth2.html">http://code.google.com/apis/accounts/docs/OAuth2.html</a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true in case of success (no network access is done at this stage) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszRefreshToken</span></code>: refresh token. Must be non NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszClientId</span></code>: client id (may be NULL, in which case the GOA2_CLIENT_ID configuration option is used) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszClientSecret</span></code>: client secret (may be NULL, in which case the GOA2_CLIENT_SECRET configuration option is used) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options, or NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11GOA2Manager25SetAuthFromServiceAccountEPKcPKcPKc12CSLConstList12CSLConstList">
<span id="_CPPv3N11GOA2Manager25SetAuthFromServiceAccountEPKcPKcPKc12CSLConstList12CSLConstList"></span><span id="_CPPv2N11GOA2Manager25SetAuthFromServiceAccountEPKcPKcPKc12CSLConstList12CSLConstList"></span><span id="GOA2Manager::SetAuthFromServiceAccount__cCP.cCP.cCP.CSLConstList.CSLConstList"></span><span class="target" id="classGOA2Manager_1a82f4a181c385b7f97e8457c808059414"></span>bool <code class="descname">SetAuthFromServiceAccount</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPrivateKey</em>, <em class="property">const</em> char *<em>pszClientEmail</em>, <em class="property">const</em> char *<em>pszScope</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszAdditionalClaims</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11GOA2Manager25SetAuthFromServiceAccountEPKcPKcPKc12CSLConstList12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specifies that the authentication will be done using the OAuth2 service account method. </p>
<p>See <a class="reference external" href="https://developers.google.com/identity/protocols/OAuth2ServiceAccount">https://developers.google.com/identity/protocols/OAuth2ServiceAccount</a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true in case of success (no network access is done at this stage) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPrivateKey</span></code>: RSA private key. Must be non NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszClientEmail</span></code>: client email. Must be non NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszScope</span></code>: authorization scope. Must be non NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszAdditionalClaims</span></code>: NULL terminate list of additional claims, or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options, or NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK11GOA2Manager13GetAuthMethodEv">
<span id="_CPPv3NK11GOA2Manager13GetAuthMethodEv"></span><span id="_CPPv2NK11GOA2Manager13GetAuthMethodEv"></span><span id="GOA2Manager::GetAuthMethodC"></span><span class="target" id="classGOA2Manager_1a45452d2a9c9cb139983f6e7476583375"></span><a class="reference internal" href="#_CPPv410AuthMethod" title="AuthMethod">AuthMethod</a> <code class="descname">GetAuthMethod</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK11GOA2Manager13GetAuthMethodEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the authentication method. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK11GOA2Manager9GetBearerEv">
<span id="_CPPv3NK11GOA2Manager9GetBearerEv"></span><span id="_CPPv2NK11GOA2Manager9GetBearerEv"></span><span id="GOA2Manager::GetBearerC"></span><span class="target" id="classGOA2Manager_1ac4fda23c7b26108238d1d12c4da3f21b"></span><em class="property">const</em> char *<code class="descname">GetBearer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK11GOA2Manager9GetBearerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the access token. </p>
<p>This is the value to append to a “Authorization: Bearer ” HTTP header.</p>
<p>A network request is issued only if no access token has been yet queried, or if its expiration delay has been reached.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the access token, or NULL in case of error. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK11GOA2Manager13GetPrivateKeyEv">
<span id="_CPPv3NK11GOA2Manager13GetPrivateKeyEv"></span><span id="_CPPv2NK11GOA2Manager13GetPrivateKeyEv"></span><span id="GOA2Manager::GetPrivateKeyC"></span><span class="target" id="classGOA2Manager_1a89349e4a3a30394cfc74186f43fa36f6"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">GetPrivateKey</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK11GOA2Manager13GetPrivateKeyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns private key for SERVICE_ACCOUNT method. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK11GOA2Manager14GetClientEmailEv">
<span id="_CPPv3NK11GOA2Manager14GetClientEmailEv"></span><span id="_CPPv2NK11GOA2Manager14GetClientEmailEv"></span><span id="GOA2Manager::GetClientEmailC"></span><span class="target" id="classGOA2Manager_1a79f10e15801ce59e8558f3f9bca439f5"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">GetClientEmail</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK11GOA2Manager14GetClientEmailEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns client email for SERVICE_ACCOUNT method. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N11GOA2Manager17m_osCurrentBearerE">
<span id="_CPPv3N11GOA2Manager17m_osCurrentBearerE"></span><span id="_CPPv2N11GOA2Manager17m_osCurrentBearerE"></span><span id="GOA2Manager::m_osCurrentBearer__CPLString"></span><span class="target" id="classGOA2Manager_1ac84d7193b8973c4b389a7e34f43efbb0"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osCurrentBearer</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager17m_osCurrentBearerE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager17m_nExpirationTimeE">
<span id="_CPPv3N11GOA2Manager17m_nExpirationTimeE"></span><span id="_CPPv2N11GOA2Manager17m_nExpirationTimeE"></span><span id="GOA2Manager::m_nExpirationTime__time_t"></span><span class="target" id="classGOA2Manager_1a7d0d6601c7ca75d4f8c09030699db358"></span>time_t <code class="descname">m_nExpirationTime</code> = 0<a class="headerlink" href="#_CPPv4N11GOA2Manager17m_nExpirationTimeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager9m_eMethodE">
<span id="_CPPv3N11GOA2Manager9m_eMethodE"></span><span id="_CPPv2N11GOA2Manager9m_eMethodE"></span><span id="GOA2Manager::m_eMethod__AuthMethod"></span><span class="target" id="classGOA2Manager_1a80ea27a7b732107565026da7b5629cd1"></span><a class="reference internal" href="#_CPPv410AuthMethod" title="AuthMethod">AuthMethod</a> <code class="descname">m_eMethod</code> = <a class="reference internal" href="#_CPPv44NONE" title="NONE">NONE</a><a class="headerlink" href="#_CPPv4N11GOA2Manager9m_eMethodE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager12m_osClientIdE">
<span id="_CPPv3N11GOA2Manager12m_osClientIdE"></span><span id="_CPPv2N11GOA2Manager12m_osClientIdE"></span><span id="GOA2Manager::m_osClientId__CPLString"></span><span class="target" id="classGOA2Manager_1ab362662b178644d7a413e0e698d8735b"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osClientId</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager12m_osClientIdE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager16m_osClientSecretE">
<span id="_CPPv3N11GOA2Manager16m_osClientSecretE"></span><span id="_CPPv2N11GOA2Manager16m_osClientSecretE"></span><span id="GOA2Manager::m_osClientSecret__CPLString"></span><span class="target" id="classGOA2Manager_1af459a90aec7afff7a0215c16e2bdc71b"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osClientSecret</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager16m_osClientSecretE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager16m_osRefreshTokenE">
<span id="_CPPv3N11GOA2Manager16m_osRefreshTokenE"></span><span id="_CPPv2N11GOA2Manager16m_osRefreshTokenE"></span><span id="GOA2Manager::m_osRefreshToken__CPLString"></span><span class="target" id="classGOA2Manager_1ae7c503f9c1c8313a061eb99eb16ba974"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osRefreshToken</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager16m_osRefreshTokenE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager14m_osPrivateKeyE">
<span id="_CPPv3N11GOA2Manager14m_osPrivateKeyE"></span><span id="_CPPv2N11GOA2Manager14m_osPrivateKeyE"></span><span id="GOA2Manager::m_osPrivateKey__CPLString"></span><span class="target" id="classGOA2Manager_1a688ed2849a8c34c0aef989f18cb8e427"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osPrivateKey</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager14m_osPrivateKeyE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager15m_osClientEmailE">
<span id="_CPPv3N11GOA2Manager15m_osClientEmailE"></span><span id="_CPPv2N11GOA2Manager15m_osClientEmailE"></span><span id="GOA2Manager::m_osClientEmail__CPLString"></span><span class="target" id="classGOA2Manager_1ae74ebab030f829faa25480a767ffd68b"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osClientEmail</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager15m_osClientEmailE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager9m_osScopeE">
<span id="_CPPv3N11GOA2Manager9m_osScopeE"></span><span id="_CPPv2N11GOA2Manager9m_osScopeE"></span><span id="GOA2Manager::m_osScope__CPLString"></span><span class="target" id="classGOA2Manager_1a0221ebf8ce52d4a9d983de688b6aa749"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osScope</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager9m_osScopeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager21m_aosAdditionalClaimsE">
<span id="_CPPv3N11GOA2Manager21m_aosAdditionalClaimsE"></span><span id="_CPPv2N11GOA2Manager21m_aosAdditionalClaimsE"></span><span id="GOA2Manager::m_aosAdditionalClaims__CPLStringList"></span><span class="target" id="classGOA2Manager_1ac9f41078fa6c126e67633798352e3eb9"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> <code class="descname">m_aosAdditionalClaims</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager21m_aosAdditionalClaimsE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N11GOA2Manager12m_aosOptionsE">
<span id="_CPPv3N11GOA2Manager12m_aosOptionsE"></span><span id="_CPPv2N11GOA2Manager12m_aosOptionsE"></span><span id="GOA2Manager::m_aosOptions__CPLStringList"></span><span class="target" id="classGOA2Manager_1a3f3a267717ee7c7b06c3cd26c4f65c90"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> <code class="descname">m_aosOptions</code> = {}<a class="headerlink" href="#_CPPv4N11GOA2Manager12m_aosOptionsE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cpl-minixml-h">
<h2>cpl_minixml.h<a class="headerlink" href="#cpl-minixml-h" title="Permalink to this headline">¶</a></h2>
<p>Definitions for CPL mini XML Parser/Serializer. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv414CPLXMLNodeType">
<span id="_CPPv314CPLXMLNodeType"></span><span id="_CPPv214CPLXMLNodeType"></span><span class="target" id="cpl__minixml_8h_1ae2767267ad31c092d81a2380ee3474a1"></span><em class="property">enum </em><code class="descname">CPLXMLNodeType</code><a class="headerlink" href="#_CPPv414CPLXMLNodeType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>XML node type. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv411CXT_Element">
<span id="_CPPv311CXT_Element"></span><span id="_CPPv211CXT_Element"></span><span class="target" id="cpl__minixml_8h_1ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e"></span><code class="descname">CXT_Element</code> = 0<a class="headerlink" href="#_CPPv411CXT_Element" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node is an element </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48CXT_Text">
<span id="_CPPv38CXT_Text"></span><span id="_CPPv28CXT_Text"></span><span class="target" id="cpl__minixml_8h_1ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1"></span><code class="descname">CXT_Text</code> = 1<a class="headerlink" href="#_CPPv48CXT_Text" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node is a raw text value </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413CXT_Attribute">
<span id="_CPPv313CXT_Attribute"></span><span id="_CPPv213CXT_Attribute"></span><span class="target" id="cpl__minixml_8h_1ae2767267ad31c092d81a2380ee3474a1ad4a32b8961ea4b6caa7a471fd5c1412d"></span><code class="descname">CXT_Attribute</code> = 2<a class="headerlink" href="#_CPPv413CXT_Attribute" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node is attribute </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411CXT_Comment">
<span id="_CPPv311CXT_Comment"></span><span id="_CPPv211CXT_Comment"></span><span class="target" id="cpl__minixml_8h_1ae2767267ad31c092d81a2380ee3474a1ab3bea14871a8fa6136365aaef2d6ff15"></span><code class="descname">CXT_Comment</code> = 3<a class="headerlink" href="#_CPPv411CXT_Comment" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node is an XML comment. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411CXT_Literal">
<span id="_CPPv311CXT_Literal"></span><span id="_CPPv211CXT_Literal"></span><span class="target" id="cpl__minixml_8h_1ae2767267ad31c092d81a2380ee3474a1a0e4a04d69bb7e75b6955a282475867f4"></span><code class="descname">CXT_Literal</code> = 4<a class="headerlink" href="#_CPPv411CXT_Literal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node is a special literal </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv417CPLParseXMLStringPKc">
<span id="_CPPv317CPLParseXMLStringPKc"></span><span id="_CPPv217CPLParseXMLStringPKc"></span><span id="CPLParseXMLString__cCP"></span><span class="target" id="cpl__minixml_8h_1ad2770716fe2b8dac4969df728e274c9b"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">CPLParseXMLString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLParseXMLStringPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse an XML string into tree form. </p>
<p>The passed document is parsed into a <a class="reference internal" href="#structCPLXMLNode"><span class="std std-ref">CPLXMLNode</span></a> tree representation. If the document is not well formed XML then NULL is returned, and errors are reported via <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>. No validation beyond wellformedness is done. The <a class="reference internal" href="#cpl__minixml_8h_1aebe69e0041052c5bf04f5ba90ad77234"><span class="std std-ref">CPLParseXMLFile()</span></a> convenience function can be used to parse from a file.</p>
<p>The returned document tree is owned by the caller and should be freed with <a class="reference internal" href="#cpl__minixml_8h_1a9e05eabc54728fb3266576404200da40"><span class="std std-ref">CPLDestroyXMLNode()</span></a> when no longer needed.</p>
<p>If the document has more than one “root level” element then those after the first will be attached to the first as siblings (via the psNext pointers) even though there is no common parent. A document with no XML structure (no angle brackets for instance) would be considered well formed, and returned as a single CXT_Text node.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>parsed tree or NULL on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: the document to parse.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLDestroyXMLNodeP10CPLXMLNode">
<span id="_CPPv317CPLDestroyXMLNodeP10CPLXMLNode"></span><span id="_CPPv217CPLDestroyXMLNodeP10CPLXMLNode"></span><span id="CPLDestroyXMLNode__CPLXMLNodeP"></span><span class="target" id="cpl__minixml_8h_1a9e05eabc54728fb3266576404200da40"></span>void <code class="descname">CPLDestroyXMLNode</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psNode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLDestroyXMLNodeP10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy a tree. </p>
<p>This function frees resources associated with a <a class="reference internal" href="#structCPLXMLNode"><span class="std std-ref">CPLXMLNode</span></a> and all its children nodes.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psNode</span></code>: the tree to free. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLGetXMLNodeP10CPLXMLNodePKc">
<span id="_CPPv313CPLGetXMLNodeP10CPLXMLNodePKc"></span><span id="_CPPv213CPLGetXMLNodeP10CPLXMLNodePKc"></span><span id="CPLGetXMLNode__CPLXMLNodeP.cCP"></span><span class="target" id="cpl__minixml_8h_1acb137728b61e42765ea7e5188a24f90e"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">CPLGetXMLNode</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>poRoot</em>, <em class="property">const</em> char *<em>pszPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLGetXMLNodeP10CPLXMLNodePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find node by path. </p>
<p>Searches the document or subdocument indicated by psRoot for an element (or attribute) with the given path. The path should consist of a set of element names separated by dots, not including the name of the root element (psRoot). If the requested element is not found NULL is returned.</p>
<p>Attribute names may only appear as the last item in the path.</p>
<p>The search is done from the root nodes children, but all intermediate nodes in the path must be specified. Searching for “name” would only find a name element or attribute if it is a direct child of the root, not at any level in the subdocument.</p>
<p>If the pszPath is prefixed by “=” then the search will begin with the root node, and its siblings, instead of the root nodes children. This is particularly useful when searching within a whole document which is often prefixed by one or more “junk” nodes like the &lt;?xml&gt; declaration.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the requested element node, or NULL if not found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psRoot</span></code>: the subtree in which to search. This should be a node of type CXT_Element. NULL is safe.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the list of element names in the path (dot separated).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLSearchXMLNodeP10CPLXMLNodePKc">
<span id="_CPPv316CPLSearchXMLNodeP10CPLXMLNodePKc"></span><span id="_CPPv216CPLSearchXMLNodeP10CPLXMLNodePKc"></span><span id="CPLSearchXMLNode__CPLXMLNodeP.cCP"></span><span class="target" id="cpl__minixml_8h_1aa1d07b7ebe279176dafa455a70043680"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">CPLSearchXMLNode</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>poRoot</em>, <em class="property">const</em> char *<em>pszTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLSearchXMLNodeP10CPLXMLNodePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Search for a node in document. </p>
<p>Searches the children (and potentially siblings) of the documented passed in for the named element or attribute. To search following siblings as well as children, prefix the pszElement name with an equal sign. This function does an in-order traversal of the document tree. So it will first match against the current node, then its first child, that child’s first child, and so on.</p>
<p>Use <a class="reference internal" href="#cpl__minixml_8h_1acb137728b61e42765ea7e5188a24f90e"><span class="std std-ref">CPLGetXMLNode()</span></a> to find a specific child, or along a specific node path.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The matching node or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psRoot</span></code>: the subtree to search. This should be a node of type CXT_Element. NULL is safe.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszElement</span></code>: the name of the element or attribute to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLGetXMLValuePK10CPLXMLNodePKcPKc">
<span id="_CPPv314CPLGetXMLValuePK10CPLXMLNodePKcPKc"></span><span id="_CPPv214CPLGetXMLValuePK10CPLXMLNodePKcPKc"></span><span id="CPLGetXMLValue__CPLXMLNodeCP.cCP.cCP"></span><span class="target" id="cpl__minixml_8h_1ab837bc73eaa55ae1363ae30a5f2a2019"></span><em class="property">const</em> char *<code class="descname">CPLGetXMLValue</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>poRoot</em>, <em class="property">const</em> char *<em>pszPath</em>, <em class="property">const</em> char *<em>pszDefault</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLGetXMLValuePK10CPLXMLNodePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch element/attribute value. </p>
<p>Searches the document for the element/attribute value associated with the path. The corresponding node is internally found with <a class="reference internal" href="#cpl__minixml_8h_1acb137728b61e42765ea7e5188a24f90e"><span class="std std-ref">CPLGetXMLNode()</span></a> (see there for details on path handling). Once found, the value is considered to be the first CXT_Text child of the node.</p>
<p>If the attribute/element search fails, or if the found node has no value then the passed default value is returned.</p>
<p>The returned value points to memory within the document tree, and should not be altered or freed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the requested value or pszDefault if not found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psRoot</span></code>: the subtree in which to search. This should be a node of type CXT_Element. NULL is safe.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the list of element names in the path (dot separated). An empty path means get the value of the psRoot node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDefault</span></code>: the value to return if a corresponding value is not found, may be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLCreateXMLNodeP10CPLXMLNode14CPLXMLNodeTypePKc">
<span id="_CPPv316CPLCreateXMLNodeP10CPLXMLNode14CPLXMLNodeTypePKc"></span><span id="_CPPv216CPLCreateXMLNodeP10CPLXMLNode14CPLXMLNodeTypePKc"></span><span id="CPLCreateXMLNode__CPLXMLNodeP.CPLXMLNodeType.cCP"></span><span class="target" id="cpl__minixml_8h_1a8779ff560dde3b2cd076a16059e66771"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">CPLCreateXMLNode</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>poParent</em>, <a class="reference internal" href="#_CPPv414CPLXMLNodeType" title="CPLXMLNodeType">CPLXMLNodeType</a> <em>eType</em>, <em class="property">const</em> char *<em>pszText</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLCreateXMLNodeP10CPLXMLNode14CPLXMLNodeTypePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an document tree item. </p>
<p>Create a single <a class="reference internal" href="#structCPLXMLNode"><span class="std std-ref">CPLXMLNode</span></a> object with the desired value and type, and attach it as a child of the indicated parent.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the newly created node, now owned by the caller (or parent node). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">poParent</span></code>: the parent to which this node should be attached as a child. May be NULL to keep as free standing. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the type of the newly created node </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszText</span></code>: the value of the newly created node</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CPLSerializeXMLTreePK10CPLXMLNode">
<span id="_CPPv319CPLSerializeXMLTreePK10CPLXMLNode"></span><span id="_CPPv219CPLSerializeXMLTreePK10CPLXMLNode"></span><span id="CPLSerializeXMLTree__CPLXMLNodeCP"></span><span class="target" id="cpl__minixml_8h_1a17562c5f454d236e6749c73f4c93de6e"></span>char *<code class="descname">CPLSerializeXMLTree</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psNode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLSerializeXMLTreePK10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert tree into string document. </p>
<p>This function converts a <a class="reference internal" href="#structCPLXMLNode"><span class="std std-ref">CPLXMLNode</span></a> tree representation of a document into a flat string representation. White space indentation is used visually preserve the tree structure of the document. The returned document becomes owned by the caller and should be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer needed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the document on success or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psNode</span></code>: the node to serialize.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLAddXMLChildP10CPLXMLNodeP10CPLXMLNode">
<span id="_CPPv314CPLAddXMLChildP10CPLXMLNodeP10CPLXMLNode"></span><span id="_CPPv214CPLAddXMLChildP10CPLXMLNodeP10CPLXMLNode"></span><span id="CPLAddXMLChild__CPLXMLNodeP.CPLXMLNodeP"></span><span class="target" id="cpl__minixml_8h_1acf4fd469090f44089221811f1c550742"></span>void <code class="descname">CPLAddXMLChild</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psParent</em>, <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psChild</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLAddXMLChildP10CPLXMLNodeP10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add child node to parent. </p>
<p>The passed child is added to the list of children of the indicated parent. Normally the child is added at the end of the parents child list, but attributes (CXT_Attribute) will be inserted after any other attributes but before any other element type. Ownership of the child node is effectively assumed by the parent node. If the child has siblings (its psNext is not NULL) they will be trimmed, but if the child has children they are carried with it.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psParent</span></code>: the node to attach the child to. May not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psChild</span></code>: the child to add to the parent. May not be NULL. Should not be a child of any other parent. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLRemoveXMLChildP10CPLXMLNodeP10CPLXMLNode">
<span id="_CPPv317CPLRemoveXMLChildP10CPLXMLNodeP10CPLXMLNode"></span><span id="_CPPv217CPLRemoveXMLChildP10CPLXMLNodeP10CPLXMLNode"></span><span id="CPLRemoveXMLChild__CPLXMLNodeP.CPLXMLNodeP"></span><span class="target" id="cpl__minixml_8h_1aabe9f99875faf356b34d2b97a0668ffb"></span>int <code class="descname">CPLRemoveXMLChild</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psParent</em>, <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psChild</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLRemoveXMLChildP10CPLXMLNodeP10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove child node from parent. </p>
<p>The passed child is removed from the child list of the passed parent, but the child is not destroyed. The child retains ownership of its own children, but is cleanly removed from the child list of the parent.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE if the child was not found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psParent</span></code>: the node to the child is attached to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psChild</span></code>: the child to remove.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLAddXMLSiblingP10CPLXMLNodeP10CPLXMLNode">
<span id="_CPPv316CPLAddXMLSiblingP10CPLXMLNodeP10CPLXMLNode"></span><span id="_CPPv216CPLAddXMLSiblingP10CPLXMLNodeP10CPLXMLNode"></span><span id="CPLAddXMLSibling__CPLXMLNodeP.CPLXMLNodeP"></span><span class="target" id="cpl__minixml_8h_1aae812ae18fd78d7f8feb387e8f0fc03c"></span>void <code class="descname">CPLAddXMLSibling</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psOlderSibling</em>, <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psNewSibling</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLAddXMLSiblingP10CPLXMLNodeP10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add new sibling. </p>
<p>The passed psNewSibling is added to the end of siblings of the psOlderSibling node. That is, it is added to the end of the psNext chain. There is no special handling if psNewSibling is an attribute. If this is required, use <a class="reference internal" href="#cpl__minixml_8h_1acf4fd469090f44089221811f1c550742"><span class="std std-ref">CPLAddXMLChild()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psOlderSibling</span></code>: the node to attach the sibling after.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psNewSibling</span></code>: the node to add at the end of psOlderSiblings psNext chain. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427CPLCreateXMLElementAndValueP10CPLXMLNodePKcPKc">
<span id="_CPPv327CPLCreateXMLElementAndValueP10CPLXMLNodePKcPKc"></span><span id="_CPPv227CPLCreateXMLElementAndValueP10CPLXMLNodePKcPKc"></span><span id="CPLCreateXMLElementAndValue__CPLXMLNodeP.cCP.cCP"></span><span class="target" id="cpl__minixml_8h_1afd42dc2352a406a884d77591253e775e"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">CPLCreateXMLElementAndValue</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psParent</em>, <em class="property">const</em> char *<em>pszName</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427CPLCreateXMLElementAndValueP10CPLXMLNodePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an element and text value. </p>
<p>This is function is a convenient short form for:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CPLXMLNode</span> <span class="o">*</span><span class="n">psTextNode</span><span class="p">;</span>
<span class="n">CPLXMLNode</span> <span class="o">*</span><span class="n">psElementNode</span><span class="p">;</span>

<span class="n">psElementNode</span> <span class="o">=</span> <span class="n">CPLCreateXMLNode</span><span class="p">(</span> <span class="n">psParent</span><span class="p">,</span> <span class="n">CXT_Element</span><span class="p">,</span> <span class="n">pszName</span> <span class="p">);</span>
<span class="n">psTextNode</span> <span class="o">=</span> <span class="n">CPLCreateXMLNode</span><span class="p">(</span> <span class="n">psElementNode</span><span class="p">,</span> <span class="n">CXT_Text</span><span class="p">,</span> <span class="n">pszValue</span> <span class="p">);</span>

<span class="k">return</span> <span class="n">psElementNode</span><span class="p">;</span>
</pre></div>
</div>
</p>
<p>It creates a CXT_Element node, with a CXT_Text child, and attaches the element to the passed parent.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the pointer to the new element node. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psParent</span></code>: the parent node to which the resulting node should be attached. May be NULL to keep as freestanding.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the element name to create. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the text to attach to the element. Must not be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426CPLAddXMLAttributeAndValueP10CPLXMLNodePKcPKc">
<span id="_CPPv326CPLAddXMLAttributeAndValueP10CPLXMLNodePKcPKc"></span><span id="_CPPv226CPLAddXMLAttributeAndValueP10CPLXMLNodePKcPKc"></span><span id="CPLAddXMLAttributeAndValue__CPLXMLNodeP.cCP.cCP"></span><span class="target" id="cpl__minixml_8h_1a1192aadcc5f8ad6c7784e7468bada626"></span>void <code class="descname">CPLAddXMLAttributeAndValue</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psParent</em>, <em class="property">const</em> char *<em>pszName</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426CPLAddXMLAttributeAndValueP10CPLXMLNodePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an attribute and text value. </p>
<p>This is function is a convenient short form for:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CPLXMLNode</span> <span class="o">*</span><span class="n">psAttributeNode</span><span class="p">;</span>

<span class="n">psAttributeNode</span> <span class="o">=</span> <span class="n">CPLCreateXMLNode</span><span class="p">(</span> <span class="n">psParent</span><span class="p">,</span> <span class="n">CXT_Attribute</span><span class="p">,</span> <span class="n">pszName</span> <span class="p">);</span>
<span class="n">CPLCreateXMLNode</span><span class="p">(</span> <span class="n">psAttributeNode</span><span class="p">,</span> <span class="n">CXT_Text</span><span class="p">,</span> <span class="n">pszValue</span> <span class="p">);</span>
</pre></div>
</div>
</p>
<p>It creates a CXT_Attribute node, with a CXT_Text child, and attaches the element to the passed parent.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psParent</span></code>: the parent node to which the resulting node should be attached. Must not be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the attribute name to create. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the text to attach to the attribute. Must not be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLCloneXMLTreePK10CPLXMLNode">
<span id="_CPPv315CPLCloneXMLTreePK10CPLXMLNode"></span><span id="_CPPv215CPLCloneXMLTreePK10CPLXMLNode"></span><span id="CPLCloneXMLTree__CPLXMLNodeCP"></span><span class="target" id="cpl__minixml_8h_1ab57871939966b74570294e0cd6a4011f"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">CPLCloneXMLTree</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psTree</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLCloneXMLTreePK10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy tree. </p>
<p>Creates a deep copy of a <a class="reference internal" href="#structCPLXMLNode"><span class="std std-ref">CPLXMLNode</span></a> tree.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a copy of the whole tree. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psTree</span></code>: the tree to duplicate.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLSetXMLValueP10CPLXMLNodePKcPKc">
<span id="_CPPv314CPLSetXMLValueP10CPLXMLNodePKcPKc"></span><span id="_CPPv214CPLSetXMLValueP10CPLXMLNodePKcPKc"></span><span id="CPLSetXMLValue__CPLXMLNodeP.cCP.cCP"></span><span class="target" id="cpl__minixml_8h_1a7abd72304d9ba159c965f5095c97b074"></span>int <code class="descname">CPLSetXMLValue</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psRoot</em>, <em class="property">const</em> char *<em>pszPath</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLSetXMLValueP10CPLXMLNodePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set element value by path. </p>
<p>Find (or create) the target element or attribute specified in the path, and assign it the indicated value.</p>
<p>Any path elements that do not already exist will be created. The target nodes value (the first CXT_Text child) will be replaced with the provided value.</p>
<p>If the target node is an attribute instead of an element, the name should be prefixed with a #.</p>
<p>Example: CPLSetXMLValue( “Citation.Id.Description”, “DOQ dataset” ); CPLSetXMLValue( “Citation.Id.Description.#name”, “doq” );</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psRoot</span></code>: the subdocument to be updated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the dot separated path to the target element/attribute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the text value to assign.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CPLStripXMLNamespaceP10CPLXMLNodePKci">
<span id="_CPPv320CPLStripXMLNamespaceP10CPLXMLNodePKci"></span><span id="_CPPv220CPLStripXMLNamespaceP10CPLXMLNodePKci"></span><span id="CPLStripXMLNamespace__CPLXMLNodeP.cCP.i"></span><span class="target" id="cpl__minixml_8h_1a47c03d9f9d692128d6fa906c17c44bfc"></span>void <code class="descname">CPLStripXMLNamespace</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psRoot</em>, <em class="property">const</em> char *<em>pszNameSpace</em>, int <em>bRecurse</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLStripXMLNamespaceP10CPLXMLNodePKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Strip indicated namespaces. </p>
<p>The subdocument (psRoot) is recursively examined, and any elements with the indicated namespace prefix will have the namespace prefix stripped from the element names. If the passed namespace is NULL, then all namespace prefixes will be stripped.</p>
<p>Nodes other than elements should remain unaffected. The changes are made “in place”, and should not alter any node locations, only the pszValue field of affected nodes.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psRoot</span></code>: the document to operate on. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNamespace</span></code>: the name space prefix (not including colon), or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bRecurse</span></code>: TRUE to recurse over whole document, or FALSE to only operate on the passed node. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLCleanXMLElementNamePc">
<span id="_CPPv322CPLCleanXMLElementNamePc"></span><span id="_CPPv222CPLCleanXMLElementNamePc"></span><span id="CPLCleanXMLElementName__cP"></span><span class="target" id="cpl__minixml_8h_1a50df16661471484493d009bb57a18b88"></span>void <code class="descname">CPLCleanXMLElementName</code><span class="sig-paren">(</span>char *<em>pszTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLCleanXMLElementNamePc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Make string into safe XML token. </p>
<p>Modifies a string in place to try and make it into a legal XML token that can be used as an element name. This is accomplished by changing any characters not legal in a token into an underscore.</p>
<p>NOTE: This function should implement the rules in section 2.3 of <a class="reference external" href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a> but it doesn’t yet do that properly. We only do a rough approximation of that.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszTarget</span></code>: the string to be adjusted. It is altered in place. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLParseXMLFilePKc">
<span id="_CPPv315CPLParseXMLFilePKc"></span><span id="_CPPv215CPLParseXMLFilePKc"></span><span id="CPLParseXMLFile__cCP"></span><span class="target" id="cpl__minixml_8h_1aebe69e0041052c5bf04f5ba90ad77234"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">CPLParseXMLFile</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLParseXMLFilePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse XML file into tree. </p>
<p>The named file is opened, loaded into memory as a big string, and parsed with <a class="reference internal" href="#cpl__minixml_8h_1ad2770716fe2b8dac4969df728e274c9b"><span class="std std-ref">CPLParseXMLString()</span></a>. Errors in reading the file or parsing the XML will be reported by <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>.</p>
<p>The “large file” API is used, so XML files can come from virtualized files.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on failure, or the document tree on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the file to open.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425CPLSerializeXMLTreeToFilePK10CPLXMLNodePKc">
<span id="_CPPv325CPLSerializeXMLTreeToFilePK10CPLXMLNodePKc"></span><span id="_CPPv225CPLSerializeXMLTreeToFilePK10CPLXMLNodePKc"></span><span id="CPLSerializeXMLTreeToFile__CPLXMLNodeCP.cCP"></span><span class="target" id="cpl__minixml_8h_1af44f5b9702a469037e7df18dda8d982c"></span>int <code class="descname">CPLSerializeXMLTreeToFile</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>psTree</em>, <em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CPLSerializeXMLTreeToFilePK10CPLXMLNodePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write document tree to a file. </p>
<p>The passed document tree is converted into one big string (with <a class="reference internal" href="#cpl__minixml_8h_1a17562c5f454d236e6749c73f4c93de6e"><span class="std std-ref">CPLSerializeXMLTree()</span></a>) and then written to the named file. Errors writing the file will be reported by <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>. The source document tree is not altered. If the output file already exists it will be overwritten.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success, FALSE otherwise. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psTree</span></code>: the document tree to write. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the name of the file to write to. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv410CPLXMLNode">
<span id="_CPPv310CPLXMLNode"></span><span id="_CPPv210CPLXMLNode"></span><span id="CPLXMLNode"></span><span class="target" id="structCPLXMLNode"></span><em class="property">struct </em><code class="descname">CPLXMLNode</code><a class="headerlink" href="#_CPPv410CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_minixml.h&gt;</em><p>Document node structure. </p>
<p>This C structure is used to hold a single text fragment representing a component of the document when parsed. It should be allocated with the appropriate CPL function, and freed with <a class="reference internal" href="#cpl__minixml_8h_1a9e05eabc54728fb3266576404200da40"><span class="std std-ref">CPLDestroyXMLNode()</span></a>. The structure contents should not normally be altered by application code, but may be freely examined by application code.</p>
<p>Using the psChild and psNext pointers, a hierarchical tree structure for a document can be represented as a tree of <a class="reference internal" href="#structCPLXMLNode"><span class="std std-ref">CPLXMLNode</span></a> structures. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N10CPLXMLNode5eTypeE">
<span id="_CPPv3N10CPLXMLNode5eTypeE"></span><span id="_CPPv2N10CPLXMLNode5eTypeE"></span><span id="CPLXMLNode::eType__CPLXMLNodeType"></span><span class="target" id="structCPLXMLNode_1a9ff2b585ad97ac6fe6b092390344a052"></span><a class="reference internal" href="#_CPPv414CPLXMLNodeType" title="CPLXMLNodeType">CPLXMLNodeType</a> <code class="descname">eType</code><a class="headerlink" href="#_CPPv4N10CPLXMLNode5eTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node type. </p>
<p>One of CXT_Element, CXT_Text, CXT_Attribute, CXT_Comment, or CXT_Literal. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N10CPLXMLNode8pszValueE">
<span id="_CPPv3N10CPLXMLNode8pszValueE"></span><span id="_CPPv2N10CPLXMLNode8pszValueE"></span><span id="CPLXMLNode::pszValue__cP"></span><span class="target" id="structCPLXMLNode_1ad9f0b3d72570553581a0d26357a8a23b"></span>char *<code class="descname">pszValue</code><a class="headerlink" href="#_CPPv4N10CPLXMLNode8pszValueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node value. </p>
<p>For CXT_Element this is the name of the element, without the angle brackets. Note there is a single CXT_Element even when the document contains a start and end element tag. The node represents the pair. All text or other elements between the start and end tag will appear as children nodes of this CXT_Element node.</p>
<p>For CXT_Attribute the pszValue is the attribute name. The value of the attribute will be a CXT_Text child.</p>
<p>For CXT_Text this is the text itself (value of an attribute, or a text fragment between an element start and end tags.</p>
<p>For CXT_Literal it is all the literal text. Currently this is just used for !DOCTYPE lines, and the value would be the entire line.</p>
<p>For CXT_Comment the value is all the literal text within the comment, but not including the comment start/end indicators (“&lt;–” and “–&gt;”). </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N10CPLXMLNode6psNextE">
<span id="_CPPv3N10CPLXMLNode6psNextE"></span><span id="_CPPv2N10CPLXMLNode6psNextE"></span><span id="CPLXMLNode::psNext__CPLXMLNodeP"></span><span class="target" id="structCPLXMLNode_1aba804dde624b8cdbac66cd6008542629"></span><em class="property">struct</em> <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">psNext</code><a class="headerlink" href="#_CPPv4N10CPLXMLNode6psNextE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Next sibling. </p>
<p>Pointer to next sibling, that is the next node appearing after this one that has the same parent as this node. NULL if this node is the last child of the parent element. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N10CPLXMLNode7psChildE">
<span id="_CPPv3N10CPLXMLNode7psChildE"></span><span id="_CPPv2N10CPLXMLNode7psChildE"></span><span id="CPLXMLNode::psChild__CPLXMLNodeP"></span><span class="target" id="structCPLXMLNode_1a5a62af6962ee5db1b7134b7a70d3e2c9"></span><em class="property">struct</em> <a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">psChild</code><a class="headerlink" href="#_CPPv4N10CPLXMLNode7psChildE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Child node. </p>
<p>Pointer to first child node, if any. Only CXT_Element and CXT_Attribute nodes should have children. For CXT_Attribute it should be a single CXT_Text value node, while CXT_Element can have any kind of child. The full list of children for a node are identified by walking the psNext’s starting with the psChild node. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv416CPLXMLTreeCloser">
<span id="_CPPv316CPLXMLTreeCloser"></span><span id="_CPPv216CPLXMLTreeCloser"></span><span id="CPLXMLTreeCloser"></span><span class="target" id="classCPLXMLTreeCloser"></span><em class="property">class </em><code class="descname">CPLXMLTreeCloser</code> : <em class="property">public</em> std::unique_ptr&lt;<a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a>, CPLXMLTreeCloserDeleter&gt;<a class="headerlink" href="#_CPPv416CPLXMLTreeCloser" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_minixml.h&gt;</em><p>Manage a tree of XML nodes so that all nodes are freed when the instance goes out of scope. </p>
<p>Only the top level node should be in a <a class="reference internal" href="#classCPLXMLTreeCloser"><span class="std std-ref">CPLXMLTreeCloser</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N16CPLXMLTreeCloser16CPLXMLTreeCloserEP10CPLXMLNode">
<span id="_CPPv3N16CPLXMLTreeCloser16CPLXMLTreeCloserEP10CPLXMLNode"></span><span id="_CPPv2N16CPLXMLTreeCloser16CPLXMLTreeCloserEP10CPLXMLNode"></span><span id="CPLXMLTreeCloser::CPLXMLTreeCloser__CPLXMLNodeP"></span><span class="target" id="classCPLXMLTreeCloser_1ac6fe570181213edaeb0e45575f0182c9"></span><code class="descname">CPLXMLTreeCloser</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLXMLTreeCloser16CPLXMLTreeCloserEP10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLXMLTreeCloser18getDocumentElementEv">
<span id="_CPPv3N16CPLXMLTreeCloser18getDocumentElementEv"></span><span id="_CPPv2N16CPLXMLTreeCloser18getDocumentElementEv"></span><span id="CPLXMLTreeCloser::getDocumentElement"></span><span class="target" id="classCPLXMLTreeCloser_1a63a2cd0dbcec66346d5eaad6b33aed84"></span><a class="reference internal" href="#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">getDocumentElement</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLXMLTreeCloser18getDocumentElementEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the document (root) element. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the node pointer </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cpl-multiproc-h">
<h2>cpl_multiproc.h<a class="headerlink" href="#cpl-multiproc-h" title="Permalink to this headline">¶</a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.CPL_MULTIPROC_STUB">
<span class="target" id="cpl__multiproc_8h_1a2db4a5d1ca23b1f6412bec8ac0cefaee"></span><code class="descname">CPL_MULTIPROC_STUB</code><a class="headerlink" href="#c.CPL_MULTIPROC_STUB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLMutex">
<span class="target" id="cpl__multiproc_8h_1a8afa61199ef26c1c912e84f4b0a7bc88"></span><code class="descname">CPLMutex</code><a class="headerlink" href="#c.CPLMutex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLCond">
<span class="target" id="cpl__multiproc_8h_1ad277c017fa68f077d9875d0dffae56d7"></span><code class="descname">CPLCond</code><a class="headerlink" href="#c.CPLCond" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLJoinableThread">
<span class="target" id="cpl__multiproc_8h_1aa0a0b461542ebe703e7a073a749c4090"></span><code class="descname">CPLJoinableThread</code><a class="headerlink" href="#c.CPLJoinableThread" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPL_MUTEX_RECURSIVE">
<span class="target" id="cpl__multiproc_8h_1aaa09673e829b1d19af4143b9863b37e8"></span><code class="descname">CPL_MUTEX_RECURSIVE</code><a class="headerlink" href="#c.CPL_MUTEX_RECURSIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPL_MUTEX_ADAPTIVE">
<span class="target" id="cpl__multiproc_8h_1aafbfb462e385c0e8287409c91a6aeb1c"></span><code class="descname">CPL_MUTEX_ADAPTIVE</code><a class="headerlink" href="#c.CPL_MUTEX_ADAPTIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPL_MUTEX_REGULAR">
<span class="target" id="cpl__multiproc_8h_1a0d792bafc2d8e545bb3f3ac4daaec955"></span><code class="descname">CPL_MUTEX_REGULAR</code><a class="headerlink" href="#c.CPL_MUTEX_REGULAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLMutexHolderD">
<span class="target" id="cpl__multiproc_8h_1ac8ddd863efc04f96c863e1130d40b301"></span><code class="descname">CPLMutexHolderD</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLMutexHolderD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLMutexHolderExD">
<span class="target" id="cpl__multiproc_8h_1af95771a39d5ee10d0c008e8941998bc1"></span><code class="descname">CPLMutexHolderExD</code><span class="sig-paren">(</span>x, nOptions<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLMutexHolderExD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLMutexHolderOptionalLockD">
<span class="target" id="cpl__multiproc_8h_1ae58e726ab3edf55a6697f0b65eabd203"></span><code class="descname">CPLMutexHolderOptionalLockD</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLMutexHolderOptionalLockD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLLockHolderD">
<span class="target" id="cpl__multiproc_8h_1ab9d02d5ec943163db83fb192fdc7a007"></span><code class="descname">CPLLockHolderD</code><span class="sig-paren">(</span>x, eType<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLLockHolderD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CPLLockHolderOptionalLockD">
<span class="target" id="cpl__multiproc_8h_1a34ea48eaacf766587b302b02f905f6db"></span><code class="descname">CPLLockHolderOptionalLockD</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLLockHolderOptionalLockD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_RLBUFFERINFO">
<span class="target" id="cpl__multiproc_8h_1a698ce2b2a92499992d3e3ea17ff7c4fe"></span><code class="descname">CTLS_RLBUFFERINFO</code><a class="headerlink" href="#c.CTLS_RLBUFFERINFO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_WIN32_COND">
<span class="target" id="cpl__multiproc_8h_1a6b41a429f3b163dbe30c12fe08bf13ec"></span><code class="descname">CTLS_WIN32_COND</code><a class="headerlink" href="#c.CTLS_WIN32_COND" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_CSVTABLEPTR">
<span class="target" id="cpl__multiproc_8h_1a1a076f2dfd40fbc9f2c96184b05ff0c4"></span><code class="descname">CTLS_CSVTABLEPTR</code><a class="headerlink" href="#c.CTLS_CSVTABLEPTR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_CSVDEFAULTFILENAME">
<span class="target" id="cpl__multiproc_8h_1af6d6b4009b47a7aefe2d84a01cf297f7"></span><code class="descname">CTLS_CSVDEFAULTFILENAME</code><a class="headerlink" href="#c.CTLS_CSVDEFAULTFILENAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_ERRORCONTEXT">
<span class="target" id="cpl__multiproc_8h_1a0c6688cfdf2c806017da29da720226d5"></span><code class="descname">CTLS_ERRORCONTEXT</code><a class="headerlink" href="#c.CTLS_ERRORCONTEXT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_VSICURL_CACHEDCONNECTION">
<span class="target" id="cpl__multiproc_8h_1a3cfad95a0e7484d89af7f8cb4bd7d1b8"></span><code class="descname">CTLS_VSICURL_CACHEDCONNECTION</code><a class="headerlink" href="#c.CTLS_VSICURL_CACHEDCONNECTION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_PATHBUF">
<span class="target" id="cpl__multiproc_8h_1a0c4f1cc20ee73a86f256ffb2e68c88b3"></span><code class="descname">CTLS_PATHBUF</code><a class="headerlink" href="#c.CTLS_PATHBUF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_ABSTRACTARCHIVE_SPLIT">
<span class="target" id="cpl__multiproc_8h_1a6cba8d05a1412e182c6388b5f1057763"></span><code class="descname">CTLS_ABSTRACTARCHIVE_SPLIT</code><a class="headerlink" href="#c.CTLS_ABSTRACTARCHIVE_SPLIT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_GDALOPEN_ANTIRECURSION">
<span class="target" id="cpl__multiproc_8h_1a93426bbb592e5dfefd61a78725ae63e8"></span><code class="descname">CTLS_GDALOPEN_ANTIRECURSION</code><a class="headerlink" href="#c.CTLS_GDALOPEN_ANTIRECURSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_CPLSPRINTF">
<span class="target" id="cpl__multiproc_8h_1a300249574e62872d997160f09033d1b4"></span><code class="descname">CTLS_CPLSPRINTF</code><a class="headerlink" href="#c.CTLS_CPLSPRINTF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_RESPONSIBLEPID">
<span class="target" id="cpl__multiproc_8h_1a83daef1284f7a5df7f5604596a9c4e62"></span><code class="descname">CTLS_RESPONSIBLEPID</code><a class="headerlink" href="#c.CTLS_RESPONSIBLEPID" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_VERSIONINFO">
<span class="target" id="cpl__multiproc_8h_1ae005b951e49aa205477f9cd86317e5f5"></span><code class="descname">CTLS_VERSIONINFO</code><a class="headerlink" href="#c.CTLS_VERSIONINFO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_VERSIONINFO_LICENCE">
<span class="target" id="cpl__multiproc_8h_1a20e421493ceb14db5c31561e24ca8629"></span><code class="descname">CTLS_VERSIONINFO_LICENCE</code><a class="headerlink" href="#c.CTLS_VERSIONINFO_LICENCE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_CONFIGOPTIONS">
<span class="target" id="cpl__multiproc_8h_1ab18fba448ecbdac8f9545ecc3e257dbf"></span><code class="descname">CTLS_CONFIGOPTIONS</code><a class="headerlink" href="#c.CTLS_CONFIGOPTIONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_FINDFILE">
<span class="target" id="cpl__multiproc_8h_1a8feb5c377210368e10b0dc55b2a02af1"></span><code class="descname">CTLS_FINDFILE</code><a class="headerlink" href="#c.CTLS_FINDFILE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_VSIERRORCONTEXT">
<span class="target" id="cpl__multiproc_8h_1aebebb8f209fee6bdb643c7142e85816e"></span><code class="descname">CTLS_VSIERRORCONTEXT</code><a class="headerlink" href="#c.CTLS_VSIERRORCONTEXT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_ERRORHANDLERACTIVEDATA">
<span class="target" id="cpl__multiproc_8h_1ad87f640a3ca60e5dc095210b9cb71a2c"></span><code class="descname">CTLS_ERRORHANDLERACTIVEDATA</code><a class="headerlink" href="#c.CTLS_ERRORHANDLERACTIVEDATA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_PROJCONTEXTHOLDER">
<span class="target" id="cpl__multiproc_8h_1a920755280f7d60a0cdb73df3dc583e65"></span><code class="descname">CTLS_PROJCONTEXTHOLDER</code><a class="headerlink" href="#c.CTLS_PROJCONTEXTHOLDER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.CTLS_MAX">
<span class="target" id="cpl__multiproc_8h_1ad2c1dd375c9e4bb5c94f26d58952b51e"></span><code class="descname">CTLS_MAX</code><a class="headerlink" href="#c.CTLS_MAX" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv413CPLThreadFunc">
<span id="_CPPv313CPLThreadFunc"></span><span id="_CPPv213CPLThreadFunc"></span><span id="CPLThreadFunc"></span><span class="target" id="cpl__multiproc_8h_1add0271875bc7af6e0a04909007f87b51"></span><em class="property">typedef </em>void (*<code class="descname">CPLThreadFunc</code>)<span class="sig-paren">(</span>void *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLThreadFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv47CPLLock">
<span id="_CPPv37CPLLock"></span><span id="_CPPv27CPLLock"></span><span id="CPLLock"></span><span class="target" id="cpl__multiproc_8h_1aa65eeec2fc0f84d2a0664bc224931c01"></span><em class="property">typedef </em><em class="property">struct</em> _CPLLock <code class="descname">CPLLock</code><a class="headerlink" href="#_CPPv47CPLLock" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv414CPLTLSFreeFunc">
<span id="_CPPv314CPLTLSFreeFunc"></span><span id="_CPPv214CPLTLSFreeFunc"></span><span id="CPLTLSFreeFunc"></span><span class="target" id="cpl__multiproc_8h_1a89f10ee28c9ffd9ea6b0190dad32fe7a"></span><em class="property">typedef </em>void (*<code class="descname">CPLTLSFreeFunc</code>)<span class="sig-paren">(</span>void *pData<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLTLSFreeFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv422CPLCondTimedWaitReason">
<span id="_CPPv322CPLCondTimedWaitReason"></span><span id="_CPPv222CPLCondTimedWaitReason"></span><span class="target" id="cpl__multiproc_8h_1a1e241a6c3329977d15787ae056810cae"></span><em class="property">enum </em><code class="descname">CPLCondTimedWaitReason</code><a class="headerlink" href="#_CPPv422CPLCondTimedWaitReason" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv420COND_TIMED_WAIT_COND">
<span id="_CPPv320COND_TIMED_WAIT_COND"></span><span id="_CPPv220COND_TIMED_WAIT_COND"></span><span class="target" id="cpl__multiproc_8h_1a1e241a6c3329977d15787ae056810caeadd67e0d3356687067005d3c2db36846e"></span><code class="descname">COND_TIMED_WAIT_COND</code><a class="headerlink" href="#_CPPv420COND_TIMED_WAIT_COND" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv424COND_TIMED_WAIT_TIME_OUT">
<span id="_CPPv324COND_TIMED_WAIT_TIME_OUT"></span><span id="_CPPv224COND_TIMED_WAIT_TIME_OUT"></span><span class="target" id="cpl__multiproc_8h_1a1e241a6c3329977d15787ae056810caea0bf9c989bb3293205a1c2e656e27260d"></span><code class="descname">COND_TIMED_WAIT_TIME_OUT</code><a class="headerlink" href="#_CPPv424COND_TIMED_WAIT_TIME_OUT" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv421COND_TIMED_WAIT_OTHER">
<span id="_CPPv321COND_TIMED_WAIT_OTHER"></span><span id="_CPPv221COND_TIMED_WAIT_OTHER"></span><span class="target" id="cpl__multiproc_8h_1a1e241a6c3329977d15787ae056810caea9805b36bdc52f41539ae566e2e7b10f9"></span><code class="descname">COND_TIMED_WAIT_OTHER</code><a class="headerlink" href="#_CPPv421COND_TIMED_WAIT_OTHER" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv411CPLLockType">
<span id="_CPPv311CPLLockType"></span><span id="_CPPv211CPLLockType"></span><span class="target" id="cpl__multiproc_8h_1a341bb5d4d227b519c83004206c69d01a"></span><em class="property">enum </em><code class="descname">CPLLockType</code><a class="headerlink" href="#_CPPv411CPLLockType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv420LOCK_RECURSIVE_MUTEX">
<span id="_CPPv320LOCK_RECURSIVE_MUTEX"></span><span id="_CPPv220LOCK_RECURSIVE_MUTEX"></span><span class="target" id="cpl__multiproc_8h_1a341bb5d4d227b519c83004206c69d01aa788206f4dd672f08aa691813a65f3584"></span><code class="descname">LOCK_RECURSIVE_MUTEX</code><a class="headerlink" href="#_CPPv420LOCK_RECURSIVE_MUTEX" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv419LOCK_ADAPTIVE_MUTEX">
<span id="_CPPv319LOCK_ADAPTIVE_MUTEX"></span><span id="_CPPv219LOCK_ADAPTIVE_MUTEX"></span><span class="target" id="cpl__multiproc_8h_1a341bb5d4d227b519c83004206c69d01aa1ded574dcf56355ccaee2ff97b62f605"></span><code class="descname">LOCK_ADAPTIVE_MUTEX</code><a class="headerlink" href="#_CPPv419LOCK_ADAPTIVE_MUTEX" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv49LOCK_SPIN">
<span id="_CPPv39LOCK_SPIN"></span><span id="_CPPv29LOCK_SPIN"></span><span class="target" id="cpl__multiproc_8h_1a341bb5d4d227b519c83004206c69d01aa4cae4fa6e3bf64f5e3589f3e934158b6"></span><code class="descname">LOCK_SPIN</code><a class="headerlink" href="#_CPPv49LOCK_SPIN" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv411CPLLockFilePKcd">
<span id="_CPPv311CPLLockFilePKcd"></span><span id="_CPPv211CPLLockFilePKcd"></span><span id="CPLLockFile__cCP.double"></span><span class="target" id="cpl__multiproc_8h_1a5299edbebb58869e5cc8dc2ddb8529db"></span>void *<code class="descname">CPLLockFile</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em>, double <em>dfWaitInSeconds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLLockFilePKcd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CPLUnlockFilePv">
<span id="_CPPv313CPLUnlockFilePv"></span><span id="_CPPv213CPLUnlockFilePv"></span><span id="CPLUnlockFile__voidP"></span><span class="target" id="cpl__multiproc_8h_1a9b1929b783db764a047fe4ee363126a8"></span>void <code class="descname">CPLUnlockFile</code><span class="sig-paren">(</span>void *<em>hLock</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLUnlockFilePv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv414CPLCreateMutexv">
<span id="_CPPv314CPLCreateMutexv"></span><span id="_CPPv214CPLCreateMutexv"></span><span id="CPLCreateMutex__void"></span><span class="target" id="cpl__multiproc_8h_1ac65146ca9306b467c0d8479c9c95343a"></span>CPLMutex *<code class="descname">CPLCreateMutex</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLCreateMutexv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv416CPLCreateMutexExi">
<span id="_CPPv316CPLCreateMutexExi"></span><span id="_CPPv216CPLCreateMutexExi"></span><span id="CPLCreateMutexEx__i"></span><span class="target" id="cpl__multiproc_8h_1a9172f82f0e36e64597ad6fb54d26fe47"></span>CPLMutex *<code class="descname">CPLCreateMutexEx</code><span class="sig-paren">(</span>int <em>nOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLCreateMutexExi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv423CPLCreateOrAcquireMutexPP8CPLMutexd">
<span id="_CPPv323CPLCreateOrAcquireMutexPP8CPLMutexd"></span><span id="_CPPv223CPLCreateOrAcquireMutexPP8CPLMutexd"></span><span id="CPLCreateOrAcquireMutex__CPLMutexPP.double"></span><span class="target" id="cpl__multiproc_8h_1ad6db21c6a1faad3e50c7f46ef3d741ef"></span>int <code class="descname">CPLCreateOrAcquireMutex</code><span class="sig-paren">(</span>CPLMutex **, double <em>dfWaitInSeconds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423CPLCreateOrAcquireMutexPP8CPLMutexd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv425CPLCreateOrAcquireMutexExPP8CPLMutexdi">
<span id="_CPPv325CPLCreateOrAcquireMutexExPP8CPLMutexdi"></span><span id="_CPPv225CPLCreateOrAcquireMutexExPP8CPLMutexdi"></span><span id="CPLCreateOrAcquireMutexEx__CPLMutexPP.double.i"></span><span class="target" id="cpl__multiproc_8h_1a0b9c1437e0843588bb90de85b5d0a5c4"></span>int <code class="descname">CPLCreateOrAcquireMutexEx</code><span class="sig-paren">(</span>CPLMutex **, double <em>dfWaitInSeconds</em>, int <em>nOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CPLCreateOrAcquireMutexExPP8CPLMutexdi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv415CPLAcquireMutexP8CPLMutexd">
<span id="_CPPv315CPLAcquireMutexP8CPLMutexd"></span><span id="_CPPv215CPLAcquireMutexP8CPLMutexd"></span><span id="CPLAcquireMutex__CPLMutexP.double"></span><span class="target" id="cpl__multiproc_8h_1aa1bd9e25228761399e2858afd813a981"></span>int <code class="descname">CPLAcquireMutex</code><span class="sig-paren">(</span>CPLMutex *<em>hMutex</em>, double <em>dfWaitInSeconds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLAcquireMutexP8CPLMutexd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv415CPLReleaseMutexP8CPLMutex">
<span id="_CPPv315CPLReleaseMutexP8CPLMutex"></span><span id="_CPPv215CPLReleaseMutexP8CPLMutex"></span><span id="CPLReleaseMutex__CPLMutexP"></span><span class="target" id="cpl__multiproc_8h_1a08a3042674c89be28e1803ba658e4c29"></span>void <code class="descname">CPLReleaseMutex</code><span class="sig-paren">(</span>CPLMutex *<em>hMutex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLReleaseMutexP8CPLMutex" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv415CPLDestroyMutexP8CPLMutex">
<span id="_CPPv315CPLDestroyMutexP8CPLMutex"></span><span id="_CPPv215CPLDestroyMutexP8CPLMutex"></span><span id="CPLDestroyMutex__CPLMutexP"></span><span class="target" id="cpl__multiproc_8h_1a68a75345ac1c0af5eb7db3ffcb091f0c"></span>void <code class="descname">CPLDestroyMutex</code><span class="sig-paren">(</span>CPLMutex *<em>hMutex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLDestroyMutexP8CPLMutex" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv421CPLCleanupMasterMutexv">
<span id="_CPPv321CPLCleanupMasterMutexv"></span><span id="_CPPv221CPLCleanupMasterMutexv"></span><span id="CPLCleanupMasterMutex__void"></span><span class="target" id="cpl__multiproc_8h_1aae0bde16295d475efe5a4de729767ba7"></span>void <code class="descname">CPLCleanupMasterMutex</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLCleanupMasterMutexv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CPLCreateCondv">
<span id="_CPPv313CPLCreateCondv"></span><span id="_CPPv213CPLCreateCondv"></span><span id="CPLCreateCond__void"></span><span class="target" id="cpl__multiproc_8h_1a1d606ee1d71671c3d8b04d95f79c23a0"></span>CPLCond *<code class="descname">CPLCreateCond</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLCreateCondv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411CPLCondWaitP7CPLCondP8CPLMutex">
<span id="_CPPv311CPLCondWaitP7CPLCondP8CPLMutex"></span><span id="_CPPv211CPLCondWaitP7CPLCondP8CPLMutex"></span><span id="CPLCondWait__CPLCondP.CPLMutexP"></span><span class="target" id="cpl__multiproc_8h_1a2d38893491cbfa9d8f1d615d65b4794e"></span>void <code class="descname">CPLCondWait</code><span class="sig-paren">(</span>CPLCond *<em>hCond</em>, CPLMutex *<em>hMutex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLCondWaitP7CPLCondP8CPLMutex" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv416CPLCondTimedWaitP7CPLCondP8CPLMutexd">
<span id="_CPPv316CPLCondTimedWaitP7CPLCondP8CPLMutexd"></span><span id="_CPPv216CPLCondTimedWaitP7CPLCondP8CPLMutexd"></span><span id="CPLCondTimedWait__CPLCondP.CPLMutexP.double"></span><span class="target" id="cpl__multiproc_8h_1a18b4c3a11373abd631881b92b3305dc8"></span><a class="reference internal" href="#_CPPv422CPLCondTimedWaitReason" title="CPLCondTimedWaitReason">CPLCondTimedWaitReason</a> <code class="descname">CPLCondTimedWait</code><span class="sig-paren">(</span>CPLCond *<em>hCond</em>, CPLMutex *<em>hMutex</em>, double <em>dfWaitInSeconds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLCondTimedWaitP7CPLCondP8CPLMutexd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CPLCondSignalP7CPLCond">
<span id="_CPPv313CPLCondSignalP7CPLCond"></span><span id="_CPPv213CPLCondSignalP7CPLCond"></span><span id="CPLCondSignal__CPLCondP"></span><span class="target" id="cpl__multiproc_8h_1a59ba2793bfe70848b83c40b566fe086f"></span>void <code class="descname">CPLCondSignal</code><span class="sig-paren">(</span>CPLCond *<em>hCond</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLCondSignalP7CPLCond" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv416CPLCondBroadcastP7CPLCond">
<span id="_CPPv316CPLCondBroadcastP7CPLCond"></span><span id="_CPPv216CPLCondBroadcastP7CPLCond"></span><span id="CPLCondBroadcast__CPLCondP"></span><span class="target" id="cpl__multiproc_8h_1a6fe215b1fea4612bcd1df4db84bd133a"></span>void <code class="descname">CPLCondBroadcast</code><span class="sig-paren">(</span>CPLCond *<em>hCond</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLCondBroadcastP7CPLCond" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv414CPLDestroyCondP7CPLCond">
<span id="_CPPv314CPLDestroyCondP7CPLCond"></span><span id="_CPPv214CPLDestroyCondP7CPLCond"></span><span id="CPLDestroyCond__CPLCondP"></span><span class="target" id="cpl__multiproc_8h_1a993c1ef36bdb907ccdf0fc97529c4410"></span>void <code class="descname">CPLDestroyCond</code><span class="sig-paren">(</span>CPLCond *<em>hCond</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLDestroyCondP7CPLCond" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv49CPLGetPIDv">
<span id="_CPPv39CPLGetPIDv"></span><span id="_CPPv29CPLGetPIDv"></span><span id="CPLGetPID__void"></span><span class="target" id="cpl__multiproc_8h_1ae83884dbf579c1b3c99b2c3cd657d35d"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">CPLGetPID</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLGetPIDv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Contrary to what its name suggests, CPLGetPID() actually returns the thread id. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLGetCurrentProcessIDv">
<span id="_CPPv322CPLGetCurrentProcessIDv"></span><span id="_CPPv222CPLGetCurrentProcessIDv"></span><span id="CPLGetCurrentProcessID__void"></span><span class="target" id="cpl__multiproc_8h_1a266c031391c3b8acc581d6dff33c35ba"></span>int <code class="descname">CPLGetCurrentProcessID</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLGetCurrentProcessIDv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv415CPLCreateThread13CPLThreadFuncPv">
<span id="_CPPv315CPLCreateThread13CPLThreadFuncPv"></span><span id="_CPPv215CPLCreateThread13CPLThreadFuncPv"></span><span id="CPLCreateThread__CPLThreadFunc.voidP"></span><span class="target" id="cpl__multiproc_8h_1a434089875c4bd10b17cf8cadc2eb021a"></span>int <code class="descname">CPLCreateThread</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLThreadFunc" title="CPLThreadFunc">CPLThreadFunc</a> <em>pfnMain</em>, void *<em>pArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLCreateThread13CPLThreadFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv423CPLCreateJoinableThread13CPLThreadFuncPv">
<span id="_CPPv323CPLCreateJoinableThread13CPLThreadFuncPv"></span><span id="_CPPv223CPLCreateJoinableThread13CPLThreadFuncPv"></span><span id="CPLCreateJoinableThread__CPLThreadFunc.voidP"></span><span class="target" id="cpl__multiproc_8h_1a1c135bb0477ecfe6ce6cd06b5a63bee5"></span>CPLJoinableThread *<code class="descname">CPLCreateJoinableThread</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLThreadFunc" title="CPLThreadFunc">CPLThreadFunc</a> <em>pfnMain</em>, void *<em>pArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423CPLCreateJoinableThread13CPLThreadFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CPLJoinThreadP17CPLJoinableThread">
<span id="_CPPv313CPLJoinThreadP17CPLJoinableThread"></span><span id="_CPPv213CPLJoinThreadP17CPLJoinableThread"></span><span id="CPLJoinThread__CPLJoinableThreadP"></span><span class="target" id="cpl__multiproc_8h_1a9a33180d7bf96f0b092cfb752033c26b"></span>void <code class="descname">CPLJoinThread</code><span class="sig-paren">(</span>CPLJoinableThread *<em>hJoinableThread</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLJoinThreadP17CPLJoinableThread" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv48CPLSleepd">
<span id="_CPPv38CPLSleepd"></span><span id="_CPPv28CPLSleepd"></span><span id="CPLSleep__double"></span><span class="target" id="cpl__multiproc_8h_1a16d49a308b23daf213dbe082f8dbf9d6"></span>void <code class="descname">CPLSleep</code><span class="sig-paren">(</span>double <em>dfWaitInSeconds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CPLSleepd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv420CPLGetThreadingModelv">
<span id="_CPPv320CPLGetThreadingModelv"></span><span id="_CPPv220CPLGetThreadingModelv"></span><span id="CPLGetThreadingModel__void"></span><span class="target" id="cpl__multiproc_8h_1a3b17b9cd15f928be75527140ae01e3b0"></span><em class="property">const</em> char *<code class="descname">CPLGetThreadingModel</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLGetThreadingModelv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CPLGetNumCPUsv">
<span id="_CPPv313CPLGetNumCPUsv"></span><span id="_CPPv213CPLGetNumCPUsv"></span><span id="CPLGetNumCPUs__void"></span><span class="target" id="cpl__multiproc_8h_1a796b75f77aaeed1d48f14aee1f40d0db"></span>int <code class="descname">CPLGetNumCPUs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLGetNumCPUsv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CPLCreateLock11CPLLockType">
<span id="_CPPv313CPLCreateLock11CPLLockType"></span><span id="_CPPv213CPLCreateLock11CPLLockType"></span><span id="CPLCreateLock__CPLLockType"></span><span class="target" id="cpl__multiproc_8h_1a3cd9ce938456411ab878c6a4b0f4106a"></span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> *<code class="descname">CPLCreateLock</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411CPLLockType" title="CPLLockType">CPLLockType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLCreateLock11CPLLockType" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv422CPLCreateOrAcquireLockPP7CPLLock11CPLLockType">
<span id="_CPPv322CPLCreateOrAcquireLockPP7CPLLock11CPLLockType"></span><span id="_CPPv222CPLCreateOrAcquireLockPP7CPLLock11CPLLockType"></span><span id="CPLCreateOrAcquireLock__CPLLockPP.CPLLockType"></span><span class="target" id="cpl__multiproc_8h_1a793436490211698f4754cefaf453690d"></span>int <code class="descname">CPLCreateOrAcquireLock</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> **, <a class="reference internal" href="#_CPPv411CPLLockType" title="CPLLockType">CPLLockType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLCreateOrAcquireLockPP7CPLLock11CPLLockType" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv414CPLAcquireLockP7CPLLock">
<span id="_CPPv314CPLAcquireLockP7CPLLock"></span><span id="_CPPv214CPLAcquireLockP7CPLLock"></span><span id="CPLAcquireLock__CPLLockP"></span><span class="target" id="cpl__multiproc_8h_1ac158f9b2aa642061de5823f5a7771d6b"></span>int <code class="descname">CPLAcquireLock</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLAcquireLockP7CPLLock" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv414CPLReleaseLockP7CPLLock">
<span id="_CPPv314CPLReleaseLockP7CPLLock"></span><span id="_CPPv214CPLReleaseLockP7CPLLock"></span><span id="CPLReleaseLock__CPLLockP"></span><span class="target" id="cpl__multiproc_8h_1a8e33e65a81f98471923d1f157d2d95ab"></span>void <code class="descname">CPLReleaseLock</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLReleaseLockP7CPLLock" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv414CPLDestroyLockP7CPLLock">
<span id="_CPPv314CPLDestroyLockP7CPLLock"></span><span id="_CPPv214CPLDestroyLockP7CPLLock"></span><span id="CPLDestroyLock__CPLLockP"></span><span class="target" id="cpl__multiproc_8h_1a737a00952ed34d50b287c5ae3d83b387"></span>void <code class="descname">CPLDestroyLock</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLDestroyLockP7CPLLock" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv419CPLLockSetDebugPerfP7CPLLocki">
<span id="_CPPv319CPLLockSetDebugPerfP7CPLLocki"></span><span id="_CPPv219CPLLockSetDebugPerfP7CPLLocki"></span><span id="CPLLockSetDebugPerf__CPLLockP.i"></span><span class="target" id="cpl__multiproc_8h_1a131c7b0710809855954db8c93f3393de"></span>void <code class="descname">CPLLockSetDebugPerf</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> *, int <em>bEnableIn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLLockSetDebugPerfP7CPLLocki" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv49CPLGetTLSi">
<span id="_CPPv39CPLGetTLSi"></span><span id="_CPPv29CPLGetTLSi"></span><span id="CPLGetTLS__i"></span><span class="target" id="cpl__multiproc_8h_1a655a7245a76f8cd8f61df7ab20fd56cf"></span>void *<code class="descname">CPLGetTLS</code><span class="sig-paren">(</span>int <em>nIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLGetTLSi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411CPLGetTLSExiPi">
<span id="_CPPv311CPLGetTLSExiPi"></span><span id="_CPPv211CPLGetTLSExiPi"></span><span id="CPLGetTLSEx__i.iP"></span><span class="target" id="cpl__multiproc_8h_1addb2102e2d5fa652761366616f0f6724"></span>void *<code class="descname">CPLGetTLSEx</code><span class="sig-paren">(</span>int <em>nIndex</em>, int *<em>pbMemoryErrorOccurred</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLGetTLSExiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv49CPLSetTLSiPvi">
<span id="_CPPv39CPLSetTLSiPvi"></span><span id="_CPPv29CPLSetTLSiPvi"></span><span id="CPLSetTLS__i.voidP.i"></span><span class="target" id="cpl__multiproc_8h_1a71fb4930bfc52596465dcab64b02652b"></span>void <code class="descname">CPLSetTLS</code><span class="sig-paren">(</span>int <em>nIndex</em>, void *<em>pData</em>, int <em>bFreeOnExit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLSetTLSiPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv421CPLSetTLSWithFreeFunciPv14CPLTLSFreeFunc">
<span id="_CPPv321CPLSetTLSWithFreeFunciPv14CPLTLSFreeFunc"></span><span id="_CPPv221CPLSetTLSWithFreeFunciPv14CPLTLSFreeFunc"></span><span id="CPLSetTLSWithFreeFunc__i.voidP.CPLTLSFreeFunc"></span><span class="target" id="cpl__multiproc_8h_1a048bf1b21b0221be9c746b17c680d923"></span>void <code class="descname">CPLSetTLSWithFreeFunc</code><span class="sig-paren">(</span>int <em>nIndex</em>, void *<em>pData</em>, <a class="reference internal" href="#_CPPv414CPLTLSFreeFunc" title="CPLTLSFreeFunc">CPLTLSFreeFunc</a> <em>pfnFree</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421CPLSetTLSWithFreeFunciPv14CPLTLSFreeFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv423CPLSetTLSWithFreeFuncExiPv14CPLTLSFreeFuncPi">
<span id="_CPPv323CPLSetTLSWithFreeFuncExiPv14CPLTLSFreeFuncPi"></span><span id="_CPPv223CPLSetTLSWithFreeFuncExiPv14CPLTLSFreeFuncPi"></span><span id="CPLSetTLSWithFreeFuncEx__i.voidP.CPLTLSFreeFunc.iP"></span><span class="target" id="cpl__multiproc_8h_1a2070aa2695ae10dd52cf8b5415b85b1f"></span>void <code class="descname">CPLSetTLSWithFreeFuncEx</code><span class="sig-paren">(</span>int <em>nIndex</em>, void *<em>pData</em>, <a class="reference internal" href="#_CPPv414CPLTLSFreeFunc" title="CPLTLSFreeFunc">CPLTLSFreeFunc</a> <em>pfnFree</em>, int *<em>pbMemoryErrorOccurred</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423CPLSetTLSWithFreeFuncExiPv14CPLTLSFreeFuncPi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv413CPLCleanupTLSv">
<span id="_CPPv313CPLCleanupTLSv"></span><span id="_CPPv213CPLCleanupTLSv"></span><span id="CPLCleanupTLS__void"></span><span class="target" id="cpl__multiproc_8h_1ad2d73d05bf563a4d90981cbb2a04be50"></span>void <code class="descname">CPLCleanupTLS</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLCleanupTLSv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<dl class="class">
<dt id="_CPPv414CPLMutexHolder">
<span id="_CPPv314CPLMutexHolder"></span><span id="_CPPv214CPLMutexHolder"></span><span id="CPLMutexHolder"></span><span class="target" id="classCPLMutexHolder"></span><em class="property">class </em><code class="descname">CPLMutexHolder</code><a class="headerlink" href="#_CPPv414CPLMutexHolder" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_multiproc.h&gt;</em><p>Object to hold a mutex. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N14CPLMutexHolder14CPLMutexHolderEPP8CPLMutexdPKcii">
<span id="_CPPv3N14CPLMutexHolder14CPLMutexHolderEPP8CPLMutexdPKcii"></span><span id="_CPPv2N14CPLMutexHolder14CPLMutexHolderEPP8CPLMutexdPKcii"></span><span id="CPLMutexHolder::CPLMutexHolder__CPLMutexPP.double.cCP.i.i"></span><span class="target" id="classCPLMutexHolder_1afe65252b0c93e111600b0e1a07ecf59a"></span><code class="descname">CPLMutexHolder</code><span class="sig-paren">(</span>CPLMutex **<em>phMutex</em>, double <em>dfWaitInSeconds</em> = 1000.0, <em class="property">const</em> char *<em>pszFile</em> = __FILE__, int <em>nLine</em> = __LINE__, int <em>nOptions</em> = CPL_MUTEX_RECURSIVE<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLMutexHolder14CPLMutexHolderEPP8CPLMutexdPKcii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Instantiates the mutex if not already done. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLMutexHolder14CPLMutexHolderEP8CPLMutexdPKci">
<span id="_CPPv3N14CPLMutexHolder14CPLMutexHolderEP8CPLMutexdPKci"></span><span id="_CPPv2N14CPLMutexHolder14CPLMutexHolderEP8CPLMutexdPKci"></span><span id="CPLMutexHolder::CPLMutexHolder__CPLMutexP.double.cCP.i"></span><span class="target" id="classCPLMutexHolder_1a84ae9f2f12585a5c254a1a705f0acb65"></span><code class="descname">CPLMutexHolder</code><span class="sig-paren">(</span>CPLMutex *<em>hMutex</em>, double <em>dfWaitInSeconds</em> = 1000.0, <em class="property">const</em> char *<em>pszFile</em> = __FILE__, int <em>nLine</em> = __LINE__<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLMutexHolder14CPLMutexHolderEP8CPLMutexdPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This variant assumes the mutex has already been created. </p>
<p>If not, it will be a no-op </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLMutexHolderD0Ev">
<span id="_CPPv3N14CPLMutexHolderD0Ev"></span><span id="_CPPv2N14CPLMutexHolderD0Ev"></span><span id="CPLMutexHolder::~CPLMutexHolder"></span><span class="target" id="classCPLMutexHolder_1aaa95b0b2815c6a5cb535cce54973fa1b"></span><code class="descname">~CPLMutexHolder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLMutexHolderD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N14CPLMutexHolder6hMutexE">
<span id="_CPPv3N14CPLMutexHolder6hMutexE"></span><span id="_CPPv2N14CPLMutexHolder6hMutexE"></span><span id="CPLMutexHolder::hMutex__CPLMutexP"></span><span class="target" id="classCPLMutexHolder_1aae8fbfe1b7d7f35c826e9724f6e7059c"></span>CPLMutex *<code class="descname">hMutex</code> = nullptr<a class="headerlink" href="#_CPPv4N14CPLMutexHolder6hMutexE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N14CPLMutexHolder7pszFileE">
<span id="_CPPv3N14CPLMutexHolder7pszFileE"></span><span id="_CPPv2N14CPLMutexHolder7pszFileE"></span><span id="CPLMutexHolder::pszFile__cCP"></span><span class="target" id="classCPLMutexHolder_1a68447d24ae7fd8a81eb9208913b23610"></span><em class="property">const</em> char *<code class="descname">pszFile</code> = nullptr<a class="headerlink" href="#_CPPv4N14CPLMutexHolder7pszFileE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N14CPLMutexHolder5nLineE">
<span id="_CPPv3N14CPLMutexHolder5nLineE"></span><span id="_CPPv2N14CPLMutexHolder5nLineE"></span><span id="CPLMutexHolder::nLine__i"></span><span class="target" id="classCPLMutexHolder_1adb5bad5768bd2be6a6e4976d581a30ce"></span>int <code class="descname">nLine</code> = 0<a class="headerlink" href="#_CPPv4N14CPLMutexHolder5nLineE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv413CPLLockHolder">
<span id="_CPPv313CPLLockHolder"></span><span id="_CPPv213CPLLockHolder"></span><span id="CPLLockHolder"></span><span class="target" id="classCPLLockHolder"></span><em class="property">class </em><code class="descname">CPLLockHolder</code><a class="headerlink" href="#_CPPv413CPLLockHolder" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_multiproc.h&gt;</em><p>Object to hold a lock. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13CPLLockHolder13CPLLockHolderEPP7CPLLock11CPLLockTypePKci">
<span id="_CPPv3N13CPLLockHolder13CPLLockHolderEPP7CPLLock11CPLLockTypePKci"></span><span id="_CPPv2N13CPLLockHolder13CPLLockHolderEPP7CPLLock11CPLLockTypePKci"></span><span id="CPLLockHolder::CPLLockHolder__CPLLockPP.CPLLockType.cCP.i"></span><span class="target" id="classCPLLockHolder_1a50671d5edf9bf597d3487fd41e511333"></span><code class="descname">CPLLockHolder</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> **<em>phSpin</em>, <a class="reference internal" href="#_CPPv411CPLLockType" title="CPLLockType">CPLLockType</a> <em>eType</em>, <em class="property">const</em> char *<em>pszFile</em> = __FILE__, int <em>nLine</em> = __LINE__<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLLockHolder13CPLLockHolderEPP7CPLLock11CPLLockTypePKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Instantiates the lock if not already done. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLLockHolder13CPLLockHolderEP7CPLLockPKci">
<span id="_CPPv3N13CPLLockHolder13CPLLockHolderEP7CPLLockPKci"></span><span id="_CPPv2N13CPLLockHolder13CPLLockHolderEP7CPLLockPKci"></span><span id="CPLLockHolder::CPLLockHolder__CPLLockP.cCP.i"></span><span class="target" id="classCPLLockHolder_1a08453f72c224fe59c020186269d74c7e"></span><code class="descname">CPLLockHolder</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> *<em>hSpin</em>, <em class="property">const</em> char *<em>pszFile</em> = __FILE__, int <em>nLine</em> = __LINE__<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLLockHolder13CPLLockHolderEP7CPLLockPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This variant assumes the lock has already been created. </p>
<p>If not, it will be a no-op </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLLockHolderD0Ev">
<span id="_CPPv3N13CPLLockHolderD0Ev"></span><span id="_CPPv2N13CPLLockHolderD0Ev"></span><span id="CPLLockHolder::~CPLLockHolder"></span><span class="target" id="classCPLLockHolder_1a2ed3e2ca6db317e21b2cb2ab03cace85"></span><code class="descname">~CPLLockHolder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLLockHolderD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13CPLLockHolder5hLockE">
<span id="_CPPv3N13CPLLockHolder5hLockE"></span><span id="_CPPv2N13CPLLockHolder5hLockE"></span><span id="CPLLockHolder::hLock__CPLLockP"></span><span class="target" id="classCPLLockHolder_1ae694784cef839e2ec8b022646cbc88a3"></span><a class="reference internal" href="#_CPPv47CPLLock" title="CPLLock">CPLLock</a> *<code class="descname">hLock</code> = nullptr<a class="headerlink" href="#_CPPv4N13CPLLockHolder5hLockE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLLockHolder7pszFileE">
<span id="_CPPv3N13CPLLockHolder7pszFileE"></span><span id="_CPPv2N13CPLLockHolder7pszFileE"></span><span id="CPLLockHolder::pszFile__cCP"></span><span class="target" id="classCPLLockHolder_1a81c5ec45841af4b8ad8c5435a6286564"></span><em class="property">const</em> char *<code class="descname">pszFile</code> = nullptr<a class="headerlink" href="#_CPPv4N13CPLLockHolder7pszFileE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLLockHolder5nLineE">
<span id="_CPPv3N13CPLLockHolder5nLineE"></span><span id="_CPPv2N13CPLLockHolder5nLineE"></span><span id="CPLLockHolder::nLine__i"></span><span class="target" id="classCPLLockHolder_1a4ab2544a25e9c9bb69d308ee3e476ef9"></span>int <code class="descname">nLine</code> = 0<a class="headerlink" href="#_CPPv4N13CPLLockHolder5nLineE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cpl-odbc-h">
<h2>cpl_odbc.h<a class="headerlink" href="#cpl-odbc-h" title="Permalink to this headline">¶</a></h2>
<p>ODBC Abstraction Layer (C++). </p>
<dl class="class">
<dt id="_CPPv422CPLODBCDriverInstaller">
<span id="_CPPv322CPLODBCDriverInstaller"></span><span id="_CPPv222CPLODBCDriverInstaller"></span><span id="CPLODBCDriverInstaller"></span><span class="target" id="classCPLODBCDriverInstaller"></span><em class="property">class </em><code class="descname">CPLODBCDriverInstaller</code><a class="headerlink" href="#_CPPv422CPLODBCDriverInstaller" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_odbc.h&gt;</em><p>A class providing functions to install or remove ODBC driver. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N22CPLODBCDriverInstaller22CPLODBCDriverInstallerEv">
<span id="_CPPv3N22CPLODBCDriverInstaller22CPLODBCDriverInstallerEv"></span><span id="_CPPv2N22CPLODBCDriverInstaller22CPLODBCDriverInstallerEv"></span><span id="CPLODBCDriverInstaller::CPLODBCDriverInstaller"></span><span class="target" id="classCPLODBCDriverInstaller_1a3190412cd3d1b6bc6b05c55beb7381e6"></span><code class="descname">CPLODBCDriverInstaller</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N22CPLODBCDriverInstaller22CPLODBCDriverInstallerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N22CPLODBCDriverInstaller13InstallDriverEPKcPKc4WORD">
<span id="_CPPv3N22CPLODBCDriverInstaller13InstallDriverEPKcPKc4WORD"></span><span id="_CPPv2N22CPLODBCDriverInstaller13InstallDriverEPKcPKc4WORD"></span><span id="CPLODBCDriverInstaller::InstallDriver__cCP.cCP.WORD"></span><span class="target" id="classCPLODBCDriverInstaller_1a5c28df1aa17c380a53effdb2aa0bd2fb"></span>int <code class="descname">InstallDriver</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszDriver</em>, <em class="property">const</em> char *<em>pszPathIn</em>, WORD <em>fRequest</em> = ODBC_INSTALL_COMPLETE<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N22CPLODBCDriverInstaller13InstallDriverEPKcPKc4WORD" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Installs ODBC driver or updates definition of already installed driver. </p>
<p>Interanally, it calls ODBC’s SQLInstallDriverEx function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE indicates success, FALSE if it fails. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDriver</span></code>: - The driver definition as a list of keyword-value pairs describing the driver (See ODBC API Reference).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszPathIn</span></code>: - Full path of the target directory of the installation, or a null pointer (for unixODBC, NULL is passed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fRequest</span></code>: - The fRequest argument must contain one of the following values: ODBC_INSTALL_COMPLETE - (default) complete the installation request ODBC_INSTALL_INQUIRY - inquire about where a driver can be installed</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N22CPLODBCDriverInstaller12RemoveDriverEPKci">
<span id="_CPPv3N22CPLODBCDriverInstaller12RemoveDriverEPKci"></span><span id="_CPPv2N22CPLODBCDriverInstaller12RemoveDriverEPKci"></span><span id="CPLODBCDriverInstaller::RemoveDriver__cCP.i"></span><span class="target" id="classCPLODBCDriverInstaller_1a79c5738b0b592c05653d79a834bb0b32"></span>int <code class="descname">RemoveDriver</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszDriverName</em>, int <em>fRemoveDSN</em> = FALSE<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N22CPLODBCDriverInstaller12RemoveDriverEPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes or changes information about the driver from the Odbcinst.ini entry in the system information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The function returns TRUE if it is successful, FALSE if it fails. If no entry exists in the system information when this function is called, the function returns FALSE. In order to obtain usage count value, call <a class="reference internal" href="#classCPLODBCDriverInstaller_1a1daae36cb9629cca286ca4a019f961fb"><span class="std std-ref">GetUsageCount()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDriverName</span></code>: - The name of the driver as registered in the Odbcinst.ini key of the system information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fRemoveDSN</span></code>: - TRUE: Remove DSNs associated with the driver specified in lpszDriver. FALSE: Do not remove DSNs associated with the driver specified in lpszDriver.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK22CPLODBCDriverInstaller13GetUsageCountEv">
<span id="_CPPv3NK22CPLODBCDriverInstaller13GetUsageCountEv"></span><span id="_CPPv2NK22CPLODBCDriverInstaller13GetUsageCountEv"></span><span id="CPLODBCDriverInstaller::GetUsageCountC"></span><span class="target" id="classCPLODBCDriverInstaller_1a1daae36cb9629cca286ca4a019f961fb"></span>int <code class="descname">GetUsageCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK22CPLODBCDriverInstaller13GetUsageCountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The usage count of the driver after this function has been called. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK22CPLODBCDriverInstaller10GetPathOutEv">
<span id="_CPPv3NK22CPLODBCDriverInstaller10GetPathOutEv"></span><span id="_CPPv2NK22CPLODBCDriverInstaller10GetPathOutEv"></span><span id="CPLODBCDriverInstaller::GetPathOutC"></span><span class="target" id="classCPLODBCDriverInstaller_1af5cd07b632c608be0e18d79bf97baff0"></span><em class="property">const</em> char *<code class="descname">GetPathOut</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK22CPLODBCDriverInstaller10GetPathOutEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Path of the target directory where the driver should be installed. </p>
<p>For details, see ODBC API Reference and lpszPathOut parameter of SQLInstallDriverEx </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK22CPLODBCDriverInstaller12GetLastErrorEv">
<span id="_CPPv3NK22CPLODBCDriverInstaller12GetLastErrorEv"></span><span id="_CPPv2NK22CPLODBCDriverInstaller12GetLastErrorEv"></span><span id="CPLODBCDriverInstaller::GetLastErrorC"></span><span class="target" id="classCPLODBCDriverInstaller_1ac4e88ade82d80bfdfd443bd4ea6a1749"></span><em class="property">const</em> char *<code class="descname">GetLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK22CPLODBCDriverInstaller12GetLastErrorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>If InstallDriver returns FALSE, then GetLastError then error message can be obtained by calling this function. </p>
<p>Internally, it calls ODBC’s SQLInstallerError function. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK22CPLODBCDriverInstaller16GetLastErrorCodeEv">
<span id="_CPPv3NK22CPLODBCDriverInstaller16GetLastErrorCodeEv"></span><span id="_CPPv2NK22CPLODBCDriverInstaller16GetLastErrorCodeEv"></span><span id="CPLODBCDriverInstaller::GetLastErrorCodeC"></span><span class="target" id="classCPLODBCDriverInstaller_1afec45a97dbdecc79cc3f742bcd017220"></span>DWORD <code class="descname">GetLastErrorCode</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK22CPLODBCDriverInstaller16GetLastErrorCodeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>If InstallDriver returns FALSE, then GetLastErrorCode then error code can be obtained by calling this function. </p>
<p>Internally, it calls ODBC’s SQLInstallerError function. See ODBC API Reference for possible error flags. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N22CPLODBCDriverInstaller11m_szPathOutE">
<span id="_CPPv3N22CPLODBCDriverInstaller11m_szPathOutE"></span><span id="_CPPv2N22CPLODBCDriverInstaller11m_szPathOutE"></span><span id="CPLODBCDriverInstaller::m_szPathOut__cA"></span><span class="target" id="classCPLODBCDriverInstaller_1a7001be147d79fee11d55a4d61fd86b15"></span>char <code class="descname">m_szPathOut</code>[<code class="descname">ODBC_FILENAME_MAX</code>]<a class="headerlink" href="#_CPPv4N22CPLODBCDriverInstaller11m_szPathOutE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N22CPLODBCDriverInstaller9m_szErrorE">
<span id="_CPPv3N22CPLODBCDriverInstaller9m_szErrorE"></span><span id="_CPPv2N22CPLODBCDriverInstaller9m_szErrorE"></span><span id="CPLODBCDriverInstaller::m_szError__cA"></span><span class="target" id="classCPLODBCDriverInstaller_1a2673ab3a5eb38888b3dd807a226ef9cd"></span>char <code class="descname">m_szError</code>[<code class="descname">SQL_MAX_MESSAGE_LENGTH</code>]<a class="headerlink" href="#_CPPv4N22CPLODBCDriverInstaller9m_szErrorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N22CPLODBCDriverInstaller12m_nErrorCodeE">
<span id="_CPPv3N22CPLODBCDriverInstaller12m_nErrorCodeE"></span><span id="_CPPv2N22CPLODBCDriverInstaller12m_nErrorCodeE"></span><span id="CPLODBCDriverInstaller::m_nErrorCode__DWORD"></span><span class="target" id="classCPLODBCDriverInstaller_1a720b96840ede9c77b5a7d1a36f1139a5"></span>DWORD <code class="descname">m_nErrorCode</code><a class="headerlink" href="#_CPPv4N22CPLODBCDriverInstaller12m_nErrorCodeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N22CPLODBCDriverInstaller13m_nUsageCountE">
<span id="_CPPv3N22CPLODBCDriverInstaller13m_nUsageCountE"></span><span id="_CPPv2N22CPLODBCDriverInstaller13m_nUsageCountE"></span><span id="CPLODBCDriverInstaller::m_nUsageCount__DWORD"></span><span class="target" id="classCPLODBCDriverInstaller_1ab150b9ae5c68904605ce99d5953a3bbe"></span>DWORD <code class="descname">m_nUsageCount</code><a class="headerlink" href="#_CPPv4N22CPLODBCDriverInstaller13m_nUsageCountE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv414CPLODBCSession">
<span id="_CPPv314CPLODBCSession"></span><span id="_CPPv214CPLODBCSession"></span><span id="CPLODBCSession"></span><span class="target" id="classCPLODBCSession"></span><em class="property">class </em><code class="descname">CPLODBCSession</code><a class="headerlink" href="#_CPPv414CPLODBCSession" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_odbc.h&gt;</em><p>A class representing an ODBC database session. </p>
<p>Includes error collection services. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N14CPLODBCSession14CPLODBCSessionEv">
<span id="_CPPv3N14CPLODBCSession14CPLODBCSessionEv"></span><span id="_CPPv2N14CPLODBCSession14CPLODBCSessionEv"></span><span id="CPLODBCSession::CPLODBCSession"></span><span class="target" id="classCPLODBCSession_1ae720f606a1cdbe412a009e17dc51d39d"></span><code class="descname">CPLODBCSession</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession14CPLODBCSessionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSessionD0Ev">
<span id="_CPPv3N14CPLODBCSessionD0Ev"></span><span id="_CPPv2N14CPLODBCSessionD0Ev"></span><span id="CPLODBCSession::~CPLODBCSession"></span><span class="target" id="classCPLODBCSession_1ac802962a10b2677e3321bb241d7d8baa"></span><code class="descname">~CPLODBCSession</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSessionD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession16EstablishSessionEPKcPKcPKc">
<span id="_CPPv3N14CPLODBCSession16EstablishSessionEPKcPKcPKc"></span><span id="_CPPv2N14CPLODBCSession16EstablishSessionEPKcPKcPKc"></span><span id="CPLODBCSession::EstablishSession__cCP.cCP.cCP"></span><span class="target" id="classCPLODBCSession_1aa25f8f6b0370dafc0e1fb3435388fdef"></span>int <code class="descname">EstablishSession</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszDSN</em>, <em class="property">const</em> char *<em>pszUserid</em>, <em class="property">const</em> char *<em>pszPassword</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession16EstablishSessionEPKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Connect to database and logon. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE on failure. Call <a class="reference internal" href="#classCPLODBCSession_1a3a7f6353e992d35569c6a963c40a0cbb"><span class="std std-ref">GetLastError()</span></a> to get details on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDSN</span></code>: The name of the DSN being used to connect. This is not optional.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszUserid</span></code>: the userid to logon as, may be NULL if not not required, or provided by the DSN.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszPassword</span></code>: the password to logon with. May be NULL if not required or provided by the DSN.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession12GetLastErrorEv">
<span id="_CPPv3N14CPLODBCSession12GetLastErrorEv"></span><span id="_CPPv2N14CPLODBCSession12GetLastErrorEv"></span><span id="CPLODBCSession::GetLastError"></span><span class="target" id="classCPLODBCSession_1a3a7f6353e992d35569c6a963c40a0cbb"></span><em class="property">const</em> char *<code class="descname">GetLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession12GetLastErrorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the last ODBC error message. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to an internal buffer with the error message in it. Do not free or alter. Will be an empty (but not NULL) string if there is no pending error info. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession16ClearTransactionEv">
<span id="_CPPv3N14CPLODBCSession16ClearTransactionEv"></span><span id="_CPPv2N14CPLODBCSession16ClearTransactionEv"></span><span id="CPLODBCSession::ClearTransaction"></span><span class="target" id="classCPLODBCSession_1aa2eb7cf0a477cf12d9fb72d61d244dca"></span>int <code class="descname">ClearTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession16ClearTransactionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear transaction. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession16BeginTransactionEv">
<span id="_CPPv3N14CPLODBCSession16BeginTransactionEv"></span><span id="_CPPv2N14CPLODBCSession16BeginTransactionEv"></span><span id="CPLODBCSession::BeginTransaction"></span><span class="target" id="classCPLODBCSession_1ae9246dd84aa8d0362bff1bde049d722f"></span>int <code class="descname">BeginTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession16BeginTransactionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Begin transaction. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession17CommitTransactionEv">
<span id="_CPPv3N14CPLODBCSession17CommitTransactionEv"></span><span id="_CPPv2N14CPLODBCSession17CommitTransactionEv"></span><span id="CPLODBCSession::CommitTransaction"></span><span class="target" id="classCPLODBCSession_1af581a96ecb2ceb24c573fca164ac6396"></span>int <code class="descname">CommitTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession17CommitTransactionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Commit transaction. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession19RollbackTransactionEv">
<span id="_CPPv3N14CPLODBCSession19RollbackTransactionEv"></span><span id="_CPPv2N14CPLODBCSession19RollbackTransactionEv"></span><span id="CPLODBCSession::RollbackTransaction"></span><span class="target" id="classCPLODBCSession_1ad9550aa9d5faad39110d7d273d792b26"></span>int <code class="descname">RollbackTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession19RollbackTransactionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Rollback transaction. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession15IsInTransactionEv">
<span id="_CPPv3N14CPLODBCSession15IsInTransactionEv"></span><span id="_CPPv2N14CPLODBCSession15IsInTransactionEv"></span><span id="CPLODBCSession::IsInTransaction"></span><span class="target" id="classCPLODBCSession_1a0ec277504d4393bbc92a2fc0d4a6a15b"></span>int <code class="descname">IsInTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession15IsInTransactionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether a transaction is active. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession12CloseSessionEv">
<span id="_CPPv3N14CPLODBCSession12CloseSessionEv"></span><span id="_CPPv2N14CPLODBCSession12CloseSessionEv"></span><span id="CPLODBCSession::CloseSession"></span><span class="target" id="classCPLODBCSession_1ad2e9a403fa56f1d9781ceceb5c494b31"></span>int <code class="descname">CloseSession</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession12CloseSessionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close session. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession6FailedEi5HSTMT">
<span id="_CPPv3N14CPLODBCSession6FailedEi5HSTMT"></span><span id="_CPPv2N14CPLODBCSession6FailedEi5HSTMT"></span><span id="CPLODBCSession::Failed__i.HSTMT"></span><span class="target" id="classCPLODBCSession_1a296fa1c306c95293cd1c7c8327317e81"></span>int <code class="descname">Failed</code><span class="sig-paren">(</span>int <em>nRetCode</em>, HSTMT <em>hStmt</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession6FailedEi5HSTMT" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if a return code indicates failure, return TRUE if that is the case. </p>
<p>Also update error text.</p>
<p>ODBC error messages are reported in the following format: [SQLState]ErrorMessage(NativeErrorCode)</p>
<p>Multiple error messages are delimeted by “,”. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession13GetConnectionEv">
<span id="_CPPv3N14CPLODBCSession13GetConnectionEv"></span><span id="_CPPv2N14CPLODBCSession13GetConnectionEv"></span><span id="CPLODBCSession::GetConnection"></span><span class="target" id="classCPLODBCSession_1a1e5be05aeee3152b5d08e9b9472ab157"></span>HDBC <code class="descname">GetConnection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession13GetConnectionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return connection handle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N14CPLODBCSession14GetEnvironmentEv">
<span id="_CPPv3N14CPLODBCSession14GetEnvironmentEv"></span><span id="_CPPv2N14CPLODBCSession14GetEnvironmentEv"></span><span id="CPLODBCSession::GetEnvironment"></span><span class="target" id="classCPLODBCSession_1ad02872998f4a5ef8ae0d49a4c35e0996"></span>HENV <code class="descname">GetEnvironment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N14CPLODBCSession14GetEnvironmentEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return GetEnvironment handle. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N14CPLODBCSession13m_osLastErrorE">
<span id="_CPPv3N14CPLODBCSession13m_osLastErrorE"></span><span id="_CPPv2N14CPLODBCSession13m_osLastErrorE"></span><span id="CPLODBCSession::m_osLastError__CPLString"></span><span class="target" id="classCPLODBCSession_1aa00be26920ade44da1e3c1641aaac950"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">m_osLastError</code> = {}<a class="headerlink" href="#_CPPv4N14CPLODBCSession13m_osLastErrorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N14CPLODBCSession6m_hEnvE">
<span id="_CPPv3N14CPLODBCSession6m_hEnvE"></span><span id="_CPPv2N14CPLODBCSession6m_hEnvE"></span><span id="CPLODBCSession::m_hEnv__HENV"></span><span class="target" id="classCPLODBCSession_1a3aa67a8f472083ef90f0d0cd99279955"></span>HENV <code class="descname">m_hEnv</code> = nullptr<a class="headerlink" href="#_CPPv4N14CPLODBCSession6m_hEnvE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N14CPLODBCSession6m_hDBCE">
<span id="_CPPv3N14CPLODBCSession6m_hDBCE"></span><span id="_CPPv2N14CPLODBCSession6m_hDBCE"></span><span id="CPLODBCSession::m_hDBC__HDBC"></span><span class="target" id="classCPLODBCSession_1ae7c07019a9ed1d63f38519dfed2008aa"></span>HDBC <code class="descname">m_hDBC</code> = nullptr<a class="headerlink" href="#_CPPv4N14CPLODBCSession6m_hDBCE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N14CPLODBCSession16m_bInTransactionE">
<span id="_CPPv3N14CPLODBCSession16m_bInTransactionE"></span><span id="_CPPv2N14CPLODBCSession16m_bInTransactionE"></span><span id="CPLODBCSession::m_bInTransaction__i"></span><span class="target" id="classCPLODBCSession_1a9074831bf77eec07da9bf11f4ca30e96"></span>int <code class="descname">m_bInTransaction</code> = false<a class="headerlink" href="#_CPPv4N14CPLODBCSession16m_bInTransactionE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N14CPLODBCSession13m_bAutoCommitE">
<span id="_CPPv3N14CPLODBCSession13m_bAutoCommitE"></span><span id="_CPPv2N14CPLODBCSession13m_bAutoCommitE"></span><span id="CPLODBCSession::m_bAutoCommit__i"></span><span class="target" id="classCPLODBCSession_1acfd2aab5a28de8834913ccd7398ea7fa"></span>int <code class="descname">m_bAutoCommit</code> = true<a class="headerlink" href="#_CPPv4N14CPLODBCSession13m_bAutoCommitE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv416CPLODBCStatement">
<span id="_CPPv316CPLODBCStatement"></span><span id="_CPPv216CPLODBCStatement"></span><span id="CPLODBCStatement"></span><span class="target" id="classCPLODBCStatement"></span><em class="property">class </em><code class="descname">CPLODBCStatement</code><a class="headerlink" href="#_CPPv416CPLODBCStatement" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_odbc.h&gt;</em><p>Abstraction for statement, and resultset. </p>
<p>Includes methods for executing an SQL statement, and for accessing the resultset from that statement. Also provides for executing other ODBC requests that produce results sets such as SQLColumns() and SQLTables() requests. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement16CPLODBCStatementEP14CPLODBCSession">
<span id="_CPPv3N16CPLODBCStatement16CPLODBCStatementEP14CPLODBCSession"></span><span id="_CPPv2N16CPLODBCStatement16CPLODBCStatementEP14CPLODBCSession"></span><span id="CPLODBCStatement::CPLODBCStatement__CPLODBCSessionP"></span><span class="target" id="classCPLODBCStatement_1aab606aaea30a350fe91ab0e3f1da3647"></span><code class="descname">CPLODBCStatement</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414CPLODBCSession" title="CPLODBCSession">CPLODBCSession</a> *<em>poSession</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement16CPLODBCStatementEP14CPLODBCSession" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatementD0Ev">
<span id="_CPPv3N16CPLODBCStatementD0Ev"></span><span id="_CPPv2N16CPLODBCStatementD0Ev"></span><span id="CPLODBCStatement::~CPLODBCStatement"></span><span class="target" id="classCPLODBCStatement_1adf7db3e0d3a9417416efd2e8d2953f6e"></span><code class="descname">~CPLODBCStatement</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatementD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement12GetStatementEv">
<span id="_CPPv3N16CPLODBCStatement12GetStatementEv"></span><span id="_CPPv2N16CPLODBCStatement12GetStatementEv"></span><span id="CPLODBCStatement::GetStatement"></span><span class="target" id="classCPLODBCStatement_1a89219d0c93a15333b3d3d68ef732dc7a"></span>HSTMT <code class="descname">GetStatement</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement12GetStatementEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return statement handle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement5ClearEv">
<span id="_CPPv3N16CPLODBCStatement5ClearEv"></span><span id="_CPPv2N16CPLODBCStatement5ClearEv"></span><span id="CPLODBCStatement::Clear"></span><span class="target" id="classCPLODBCStatement_1a3a7e1f605839b4bb73d676ea162682e7"></span>void <code class="descname">Clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement5ClearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear internal command text and result set definitions. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement13AppendEscapedEPKc">
<span id="_CPPv3N16CPLODBCStatement13AppendEscapedEPKc"></span><span id="_CPPv2N16CPLODBCStatement13AppendEscapedEPKc"></span><span id="CPLODBCStatement::AppendEscaped__cCP"></span><span class="target" id="classCPLODBCStatement_1ae40599446871e5bec44bd19e62252c02"></span>void <code class="descname">AppendEscaped</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszText</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement13AppendEscapedEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append text to internal command. </p>
<p>The passed text is appended to the internal SQL command text after escaping any special characters so it can be used as a character string in an SQL statement.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszText</span></code>: text to append. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement6AppendEPKc">
<span id="_CPPv3N16CPLODBCStatement6AppendEPKc"></span><span id="_CPPv2N16CPLODBCStatement6AppendEPKc"></span><span id="CPLODBCStatement::Append__cCP"></span><span class="target" id="classCPLODBCStatement_1a3b0f535fc43e327990d97f055bd3d472"></span>void <code class="descname">Append</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszText</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement6AppendEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append text to internal command. </p>
<p>The passed text is appended to the internal SQL command text.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszText</span></code>: text to append. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement6AppendEi">
<span id="_CPPv3N16CPLODBCStatement6AppendEi"></span><span id="_CPPv2N16CPLODBCStatement6AppendEi"></span><span id="CPLODBCStatement::Append__i"></span><span class="target" id="classCPLODBCStatement_1ab8c651da1fa4ce9291ab5f3c079ba423"></span>void <code class="descname">Append</code><span class="sig-paren">(</span>int <em>nValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement6AppendEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append to internal command. </p>
<p>The passed value is formatted and appended to the internal SQL command text.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nValue</span></code>: value to append to the command. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement6AppendEd">
<span id="_CPPv3N16CPLODBCStatement6AppendEd"></span><span id="_CPPv2N16CPLODBCStatement6AppendEd"></span><span id="CPLODBCStatement::Append__double"></span><span class="target" id="classCPLODBCStatement_1a170ea4a7df8f79432efce2cb27117ef2"></span>void <code class="descname">Append</code><span class="sig-paren">(</span>double <em>dfValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement6AppendEd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append to internal command. </p>
<p>The passed value is formatted and appended to the internal SQL command text.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dfValue</span></code>: value to append to the command. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement7AppendfEPKcz">
<span id="_CPPv3N16CPLODBCStatement7AppendfEPKcz"></span><span id="_CPPv2N16CPLODBCStatement7AppendfEPKcz"></span><span id="CPLODBCStatement::Appendf__cCP.z"></span><span class="target" id="classCPLODBCStatement_1abd3c9d8bdd495487e981429199e99f51"></span>int <code class="descname">Appendf</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFormat</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement7AppendfEPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append to internal command. </p>
<p>The passed format is used to format other arguments and the result is appended to the internal command text. Long results may not be formatted properly, and should be appended with the direct <a class="reference internal" href="#classCPLODBCStatement_1a3b0f535fc43e327990d97f055bd3d472"><span class="std std-ref">Append()</span></a> methods.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>FALSE if formatting fails due to result being too large. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFormat</span></code>: printf() style format string.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10GetCommandEv">
<span id="_CPPv3N16CPLODBCStatement10GetCommandEv"></span><span id="_CPPv2N16CPLODBCStatement10GetCommandEv"></span><span id="CPLODBCStatement::GetCommand"></span><span class="target" id="classCPLODBCStatement_1a07625f5463eea76c32b0de5e53a4f0f5"></span><em class="property">const</em> char *<code class="descname">GetCommand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10GetCommandEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return statement string. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10ExecuteSQLEPKc">
<span id="_CPPv3N16CPLODBCStatement10ExecuteSQLEPKc"></span><span id="_CPPv2N16CPLODBCStatement10ExecuteSQLEPKc"></span><span id="CPLODBCStatement::ExecuteSQL__cCP"></span><span class="target" id="classCPLODBCStatement_1a57cc04eb4945587cb3ddddc2838636be"></span>int <code class="descname">ExecuteSQL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszStatement</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10ExecuteSQLEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Execute an SQL statement. </p>
<p>This method will execute the passed (or stored) SQL statement, and initialize information about the resultset if there is one. If a NULL statement is passed, the internal stored statement that has been previously set via <a class="reference internal" href="#classCPLODBCStatement_1a3b0f535fc43e327990d97f055bd3d472"><span class="std std-ref">Append()</span></a> or <a class="reference internal" href="#classCPLODBCStatement_1abd3c9d8bdd495487e981429199e99f51"><span class="std std-ref">Appendf()</span></a> calls will be used.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE if there is an error. Error details can be fetched with OGRODBCSession::GetLastError(). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszStatement</span></code>: the SQL statement to execute, or NULL if the internally saved one should be used.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement5FetchEii">
<span id="_CPPv3N16CPLODBCStatement5FetchEii"></span><span id="_CPPv2N16CPLODBCStatement5FetchEii"></span><span id="CPLODBCStatement::Fetch__i.i"></span><span class="target" id="classCPLODBCStatement_1a2ebf900aec9ed9a635e0b24f838ec00c"></span>int <code class="descname">Fetch</code><span class="sig-paren">(</span>int <em>nOrientation</em> = SQL_FETCH_NEXT, int <em>nOffset</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement5FetchEii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a new record. </p>
<p>Requests the next row in the current resultset using the SQLFetchScroll() call. Note that many ODBC drivers only support the default forward fetching one record at a time. Only SQL_FETCH_NEXT (the default) should be considered reliable on all drivers.</p>
<p>Currently it isn’t clear how to determine whether an error or a normal out of data condition has occurred if <a class="reference internal" href="#classCPLODBCStatement_1a2ebf900aec9ed9a635e0b24f838ec00c"><span class="std std-ref">Fetch()</span></a> fails.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if a new row is successfully fetched, or FALSE if not. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nOrientation</span></code>: One of SQL_FETCH_NEXT, SQL_FETCH_LAST, SQL_FETCH_PRIOR, SQL_FETCH_ABSOLUTE, or SQL_FETCH_RELATIVE (default is SQL_FETCH_NEXT).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: the offset (number of records), ignored for some orientations.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement15ClearColumnDataEv">
<span id="_CPPv3N16CPLODBCStatement15ClearColumnDataEv"></span><span id="_CPPv2N16CPLODBCStatement15ClearColumnDataEv"></span><span id="CPLODBCStatement::ClearColumnData"></span><span class="target" id="classCPLODBCStatement_1af976569c5dc6a5e1d52aeff001fd82c8"></span>void <code class="descname">ClearColumnData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement15ClearColumnDataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ClearColumnData. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement11GetColCountEv">
<span id="_CPPv3N16CPLODBCStatement11GetColCountEv"></span><span id="_CPPv2N16CPLODBCStatement11GetColCountEv"></span><span id="CPLODBCStatement::GetColCount"></span><span class="target" id="classCPLODBCStatement_1a4fdb2a6ed42b2193ec5c668d978c7140"></span>int <code class="descname">GetColCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement11GetColCountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the resultset column count. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the column count, or zero if there is no resultset. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10GetColNameEi">
<span id="_CPPv3N16CPLODBCStatement10GetColNameEi"></span><span id="_CPPv2N16CPLODBCStatement10GetColNameEi"></span><span id="CPLODBCStatement::GetColName__i"></span><span class="target" id="classCPLODBCStatement_1aeb9cf8e5a20abfe6d49f937c8e16bab3"></span><em class="property">const</em> char *<code class="descname">GetColName</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10GetColNameEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a column name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on failure (out of bounds column), or a pointer to an internal copy of the column name. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column index.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10GetColTypeEi">
<span id="_CPPv3N16CPLODBCStatement10GetColTypeEi"></span><span id="_CPPv2N16CPLODBCStatement10GetColTypeEi"></span><span id="CPLODBCStatement::GetColType__i"></span><span class="target" id="classCPLODBCStatement_1acefccc2295341b2ef09e0ad9be5ec9e2"></span>short <code class="descname">GetColType</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10GetColTypeEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a column data type. </p>
<p>The return type code is a an ODBC SQL_ code, one of SQL_UNKNOWN_TYPE, SQL_CHAR, SQL_NUMERIC, SQL_DECIMAL, SQL_INTEGER, SQL_SMALLINT, SQL_FLOAT, SQL_REAL, SQL_DOUBLE, SQL_DATETIME, SQL_VARCHAR, SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMPT.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type code or -1 if the column is illegal. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column index.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement14GetColTypeNameEi">
<span id="_CPPv3N16CPLODBCStatement14GetColTypeNameEi"></span><span id="_CPPv2N16CPLODBCStatement14GetColTypeNameEi"></span><span id="CPLODBCStatement::GetColTypeName__i"></span><span class="target" id="classCPLODBCStatement_1aa727a5ebeb29ce108b01a847de18a8de"></span><em class="property">const</em> char *<code class="descname">GetColTypeName</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement14GetColTypeNameEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a column data type name. </p>
<p>Returns data source-dependent data type name; for example, “CHAR”, “VARCHAR”, “MONEY”, “LONG VARBINAR”, or “CHAR ( ) FOR BIT DATA”.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on failure (out of bounds column), or a pointer to an internal copy of the column dat type name. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column index.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10GetColSizeEi">
<span id="_CPPv3N16CPLODBCStatement10GetColSizeEi"></span><span id="_CPPv2N16CPLODBCStatement10GetColSizeEi"></span><span id="CPLODBCStatement::GetColSize__i"></span><span class="target" id="classCPLODBCStatement_1a3fc9186c6b107cfbedb5677e97c86830"></span>short <code class="descname">GetColSize</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10GetColSizeEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the column width. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>column width, zero for unknown width columns. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column index.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement15GetColPrecisionEi">
<span id="_CPPv3N16CPLODBCStatement15GetColPrecisionEi"></span><span id="_CPPv2N16CPLODBCStatement15GetColPrecisionEi"></span><span id="CPLODBCStatement::GetColPrecision__i"></span><span class="target" id="classCPLODBCStatement_1a2d6c8c2f790c81ce9ad1f067ee26ddfa"></span>short <code class="descname">GetColPrecision</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement15GetColPrecisionEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the column precision. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>column precision, may be zero or the same as column size for columns to which it does not apply. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column index.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement14GetColNullableEi">
<span id="_CPPv3N16CPLODBCStatement14GetColNullableEi"></span><span id="_CPPv2N16CPLODBCStatement14GetColNullableEi"></span><span id="CPLODBCStatement::GetColNullable__i"></span><span class="target" id="classCPLODBCStatement_1a31342f00e8dbbaea08ce7bcab12cad79"></span>short <code class="descname">GetColNullable</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement14GetColNullableEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the column nullability. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the column may contains or FALSE otherwise. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column index.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement15GetColColumnDefEi">
<span id="_CPPv3N16CPLODBCStatement15GetColColumnDefEi"></span><span id="_CPPv2N16CPLODBCStatement15GetColColumnDefEi"></span><span id="CPLODBCStatement::GetColColumnDef__i"></span><span class="target" id="classCPLODBCStatement_1a17714cf4ad617dde4579cf2138d62898"></span><em class="property">const</em> char *<code class="descname">GetColColumnDef</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement15GetColColumnDefEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a column default value. </p>
<p>Returns the default value of a column.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL if the default value is not dpecified or the internal copy of the default value. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column index.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement8GetColIdEPKc">
<span id="_CPPv3N16CPLODBCStatement8GetColIdEPKc"></span><span id="_CPPv2N16CPLODBCStatement8GetColIdEPKc"></span><span id="CPLODBCStatement::GetColId__cCP"></span><span class="target" id="classCPLODBCStatement_1a8d4871f0e005f499b23061c265b8bdda"></span>int <code class="descname">GetColId</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszColName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement8GetColIdEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch column index. </p>
<p>Gets the column index corresponding with the passed name. The name comparisons are case insensitive.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the column index, or -1 if not found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszColName</span></code>: the name to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10GetColDataEiPKc">
<span id="_CPPv3N16CPLODBCStatement10GetColDataEiPKc"></span><span id="_CPPv2N16CPLODBCStatement10GetColDataEiPKc"></span><span id="CPLODBCStatement::GetColData__i.cCP"></span><span class="target" id="classCPLODBCStatement_1aacbb51bfcce309232e1bd852e336660c"></span><em class="property">const</em> char *<code class="descname">GetColData</code><span class="sig-paren">(</span>int <em>iCol</em>, <em class="property">const</em> char *<em>pszDefault</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10GetColDataEiPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch column data. </p>
<p>Fetches the data contents of the requested column for the currently loaded row. The result is returned as a string regardless of the column type. NULL is returned if an illegal column is given, or if the actual column is “NULL”.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to internal column data or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iCol</span></code>: the zero based column to fetch.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDefault</span></code>: the value to return if the column does not exist, or is NULL. Defaults to NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10GetColDataEPKcPKc">
<span id="_CPPv3N16CPLODBCStatement10GetColDataEPKcPKc"></span><span id="_CPPv2N16CPLODBCStatement10GetColDataEPKcPKc"></span><span id="CPLODBCStatement::GetColData__cCP.cCP"></span><span class="target" id="classCPLODBCStatement_1a8213591b8e3032834bb3c2a4f3d37d6c"></span><em class="property">const</em> char *<code class="descname">GetColData</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszColName</em>, <em class="property">const</em> char *<em>pszDefault</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10GetColDataEPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch column data. </p>
<p>Fetches the data contents of the requested column for the currently loaded row. The result is returned as a string regardless of the column type. NULL is returned if an illegal column is given, or if the actual column is “NULL”.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to internal column data or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszColName</span></code>: the name of the column requested.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDefault</span></code>: the value to return if the column does not exist, or is NULL. Defaults to NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement16GetColDataLengthEi">
<span id="_CPPv3N16CPLODBCStatement16GetColDataLengthEi"></span><span id="_CPPv2N16CPLODBCStatement16GetColDataLengthEi"></span><span id="CPLODBCStatement::GetColDataLength__i"></span><span class="target" id="classCPLODBCStatement_1a7e87977f8ce1fc67d3fcd72d143fdf9d"></span>int <code class="descname">GetColDataLength</code><span class="sig-paren">(</span>int <em>iCol</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement16GetColDataLengthEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GetColDataLength. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement19GetRowCountAffectedEv">
<span id="_CPPv3N16CPLODBCStatement19GetRowCountAffectedEv"></span><span id="_CPPv2N16CPLODBCStatement19GetRowCountAffectedEv"></span><span id="CPLODBCStatement::GetRowCountAffected"></span><span class="target" id="classCPLODBCStatement_1a3156d254419e618b6386972b58ca7b22"></span>int <code class="descname">GetRowCountAffected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement19GetRowCountAffectedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GetRowCountAffected. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10GetColumnsEPKcPKcPKc">
<span id="_CPPv3N16CPLODBCStatement10GetColumnsEPKcPKcPKc"></span><span id="_CPPv2N16CPLODBCStatement10GetColumnsEPKcPKcPKc"></span><span id="CPLODBCStatement::GetColumns__cCP.cCP.cCP"></span><span class="target" id="classCPLODBCStatement_1a44b22ff22a945fe9f6e680c7e4577cf1"></span>int <code class="descname">GetColumns</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszTable</em>, <em class="property">const</em> char *<em>pszCatalog</em> = nullptr, <em class="property">const</em> char *<em>pszSchema</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10GetColumnsEPKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch column definitions for a table. </p>
<p>The SQLColumn() method is used to fetch the definitions for the columns of a table (or other queryable object such as a view). The column definitions are digested and used to populate the <a class="reference internal" href="#classCPLODBCStatement"><span class="std std-ref">CPLODBCStatement</span></a> column definitions essentially as if a “SELECT * FROM tablename” had been done; however, no resultset will be available.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszTable</span></code>: the name of the table to query information on. This should not be empty.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszCatalog</span></code>: the catalog to find the table in, use NULL (the default) if no catalog is available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSchema</span></code>: the schema to find the table in, use NULL (the default) if no schema is available.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement14GetPrimaryKeysEPKcPKcPKc">
<span id="_CPPv3N16CPLODBCStatement14GetPrimaryKeysEPKcPKcPKc"></span><span id="_CPPv2N16CPLODBCStatement14GetPrimaryKeysEPKcPKcPKc"></span><span id="CPLODBCStatement::GetPrimaryKeys__cCP.cCP.cCP"></span><span class="target" id="classCPLODBCStatement_1a80984f023b12d6749c8a0b453a68e3b8"></span>int <code class="descname">GetPrimaryKeys</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszTable</em>, <em class="property">const</em> char *<em>pszCatalog</em> = nullptr, <em class="property">const</em> char *<em>pszSchema</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement14GetPrimaryKeysEPKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch primary keys for a table. </p>
<p>The SQLPrimaryKeys() function is used to fetch a list of fields forming the primary key. The result is returned as a result set matching the SQLPrimaryKeys() function result set. The 4th column in the result set is the column name of the key, and if the result set contains only one record then that single field will be the complete primary key.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszTable</span></code>: the name of the table to query information on. This should not be empty.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszCatalog</span></code>: the catalog to find the table in, use NULL (the default) if no catalog is available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSchema</span></code>: the schema to find the table in, use NULL (the default) if no schema is available.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement9GetTablesEPKcPKc">
<span id="_CPPv3N16CPLODBCStatement9GetTablesEPKcPKc"></span><span id="_CPPv2N16CPLODBCStatement9GetTablesEPKcPKc"></span><span id="CPLODBCStatement::GetTables__cCP.cCP"></span><span class="target" id="classCPLODBCStatement_1a2a0e2a9effc0c32bd916398786402bf3"></span>int <code class="descname">GetTables</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszCatalog</em> = nullptr, <em class="property">const</em> char *<em>pszSchema</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement9GetTablesEPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch tables in database. </p>
<p>The SQLTables() function is used to fetch a list tables in the database. The result is returned as a result set matching the SQLTables() function result set. The 3rd column in the result set is the table name. Only tables of type “TABLE” are returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszCatalog</span></code>: the catalog to find the table in, use NULL (the default) if no catalog is available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSchema</span></code>: the schema to find the table in, use NULL (the default) if no schema is available.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement10DumpResultEP4FILEi">
<span id="_CPPv3N16CPLODBCStatement10DumpResultEP4FILEi"></span><span id="_CPPv2N16CPLODBCStatement10DumpResultEP4FILEi"></span><span id="CPLODBCStatement::DumpResult__FILEP.i"></span><span class="target" id="classCPLODBCStatement_1aaac8fabff87844776f9198786fbf8cab"></span>void <code class="descname">DumpResult</code><span class="sig-paren">(</span>FILE *<em>fp</em>, int <em>bShowSchema</em> = FALSE<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement10DumpResultEP4FILEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dump resultset to file. </p>
<p>The contents of the current resultset are dumped in a simply formatted form to the provided file. If requested, the schema definition will be written first.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: the file to write to. stdout or stderr are acceptable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bShowSchema</span></code>: TRUE to force writing schema information for the rowset before the rowset data itself. Default is FALSE. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement18CollectResultsInfoEv">
<span id="_CPPv3N16CPLODBCStatement18CollectResultsInfoEv"></span><span id="_CPPv2N16CPLODBCStatement18CollectResultsInfoEv"></span><span id="CPLODBCStatement::CollectResultsInfo"></span><span class="target" id="classCPLODBCStatement_1ac2f63ad925897e76926340dc5cd1be23"></span>int <code class="descname">CollectResultsInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement18CollectResultsInfoEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CollectResultsInfo. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement11GetTypeNameEi">
<span id="_CPPv3N16CPLODBCStatement11GetTypeNameEi"></span><span id="_CPPv2N16CPLODBCStatement11GetTypeNameEi"></span><span id="CPLODBCStatement::GetTypeName__i"></span><span class="target" id="classCPLODBCStatement_1ae9f475371e9ff2f91e6514668803900b"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">GetTypeName</code><span class="sig-paren">(</span>int <em>nTypeCode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement11GetTypeNameEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get name for SQL column type. </p>
<p>Returns a string name for the indicated type code (as returned from <a class="reference internal" href="#classCPLODBCStatement_1acefccc2295341b2ef09e0ad9be5ec9e2"><span class="std std-ref">CPLODBCStatement::GetColType()</span></a>).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>internal string, “UNKNOWN” if code not recognised. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nTypeCode</span></code>: the SQL_ code, such as SQL_CHAR.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement14GetTypeMappingE11SQLSMALLINT">
<span id="_CPPv3N16CPLODBCStatement14GetTypeMappingE11SQLSMALLINT"></span><span id="_CPPv2N16CPLODBCStatement14GetTypeMappingE11SQLSMALLINT"></span><span id="CPLODBCStatement::GetTypeMapping__SQLSMALLINT"></span><span class="target" id="classCPLODBCStatement_1afe650707128654709da20449ee440f2a"></span>SQLSMALLINT <code class="descname">GetTypeMapping</code><span class="sig-paren">(</span>SQLSMALLINT <em>nTypeCode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement14GetTypeMappingE11SQLSMALLINT" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get appropriate C data type for SQL column type. </p>
<p>Returns a C data type code, corresponding to the indicated SQL data type code (as returned from <a class="reference internal" href="#classCPLODBCStatement_1acefccc2295341b2ef09e0ad9be5ec9e2"><span class="std std-ref">CPLODBCStatement::GetColType()</span></a>).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>data type code. The valid code is always returned. If SQL code is not recognised, SQL_C_BINARY will be returned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nTypeCode</span></code>: the SQL_ code, such as SQL_CHAR.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N16CPLODBCStatement6FailedEi">
<span id="_CPPv3N16CPLODBCStatement6FailedEi"></span><span id="_CPPv2N16CPLODBCStatement6FailedEi"></span><span id="CPLODBCStatement::Failed__i"></span><span class="target" id="classCPLODBCStatement_1a5342297cbfd0ce1fa3e18946a998762d"></span>int <code class="descname">Failed</code><span class="sig-paren">(</span>int <em>nResultCode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16CPLODBCStatement6FailedEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Failed. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement11m_poSessionE">
<span id="_CPPv3N16CPLODBCStatement11m_poSessionE"></span><span id="_CPPv2N16CPLODBCStatement11m_poSessionE"></span><span id="CPLODBCStatement::m_poSession__CPLODBCSessionP"></span><span class="target" id="classCPLODBCStatement_1a92650250d1f25ca4a30cbd5147373bab"></span><a class="reference internal" href="#_CPPv414CPLODBCSession" title="CPLODBCSession">CPLODBCSession</a> *<code class="descname">m_poSession</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement11m_poSessionE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement7m_hStmtE">
<span id="_CPPv3N16CPLODBCStatement7m_hStmtE"></span><span id="_CPPv2N16CPLODBCStatement7m_hStmtE"></span><span id="CPLODBCStatement::m_hStmt__HSTMT"></span><span class="target" id="classCPLODBCStatement_1a138dff4ad5a1a3299469d6a2bf0a0957"></span>HSTMT <code class="descname">m_hStmt</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement7m_hStmtE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement11m_nColCountE">
<span id="_CPPv3N16CPLODBCStatement11m_nColCountE"></span><span id="_CPPv2N16CPLODBCStatement11m_nColCountE"></span><span id="CPLODBCStatement::m_nColCount__SQLSMALLINT"></span><span class="target" id="classCPLODBCStatement_1a6673663b74676989589632c733e04cf5"></span>SQLSMALLINT <code class="descname">m_nColCount</code> = 0<a class="headerlink" href="#_CPPv4N16CPLODBCStatement11m_nColCountE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement15m_papszColNamesE">
<span id="_CPPv3N16CPLODBCStatement15m_papszColNamesE"></span><span id="_CPPv2N16CPLODBCStatement15m_papszColNamesE"></span><span id="CPLODBCStatement::m_papszColNames__cPP"></span><span class="target" id="classCPLODBCStatement_1ac6208e20030afd1da7da517874a20b77"></span>char **<code class="descname">m_papszColNames</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement15m_papszColNamesE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement12m_panColTypeE">
<span id="_CPPv3N16CPLODBCStatement12m_panColTypeE"></span><span id="_CPPv2N16CPLODBCStatement12m_panColTypeE"></span><span id="CPLODBCStatement::m_panColType__SQLSMALLINTP"></span><span class="target" id="classCPLODBCStatement_1aed1ae2d4758a15736b7cee8f5f788209"></span>SQLSMALLINT *<code class="descname">m_panColType</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement12m_panColTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement19m_papszColTypeNamesE">
<span id="_CPPv3N16CPLODBCStatement19m_papszColTypeNamesE"></span><span id="_CPPv2N16CPLODBCStatement19m_papszColTypeNamesE"></span><span id="CPLODBCStatement::m_papszColTypeNames__cPP"></span><span class="target" id="classCPLODBCStatement_1ae19ea25a52b16b06af2b4b3e1a9e53c2"></span>char **<code class="descname">m_papszColTypeNames</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement19m_papszColTypeNamesE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement12m_panColSizeE">
<span id="_CPPv3N16CPLODBCStatement12m_panColSizeE"></span><span id="_CPPv2N16CPLODBCStatement12m_panColSizeE"></span><span id="CPLODBCStatement::m_panColSize__CPL_SQLULENP"></span><span class="target" id="classCPLODBCStatement_1a77473f32a3af87451cf26b72c2fedc5c"></span>CPL_SQLULEN *<code class="descname">m_panColSize</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement12m_panColSizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement17m_panColPrecisionE">
<span id="_CPPv3N16CPLODBCStatement17m_panColPrecisionE"></span><span id="_CPPv2N16CPLODBCStatement17m_panColPrecisionE"></span><span id="CPLODBCStatement::m_panColPrecision__SQLSMALLINTP"></span><span class="target" id="classCPLODBCStatement_1a82db52e407677eaef9e59d3dd1b40054"></span>SQLSMALLINT *<code class="descname">m_panColPrecision</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement17m_panColPrecisionE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement16m_panColNullableE">
<span id="_CPPv3N16CPLODBCStatement16m_panColNullableE"></span><span id="_CPPv2N16CPLODBCStatement16m_panColNullableE"></span><span id="CPLODBCStatement::m_panColNullable__SQLSMALLINTP"></span><span class="target" id="classCPLODBCStatement_1a878d2a8322088298186768dc7929e678"></span>SQLSMALLINT *<code class="descname">m_panColNullable</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement16m_panColNullableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement19m_papszColColumnDefE">
<span id="_CPPv3N16CPLODBCStatement19m_papszColColumnDefE"></span><span id="_CPPv2N16CPLODBCStatement19m_papszColColumnDefE"></span><span id="CPLODBCStatement::m_papszColColumnDef__cPP"></span><span class="target" id="classCPLODBCStatement_1a448b5ba28c181e4e70e91cfa74798372"></span>char **<code class="descname">m_papszColColumnDef</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement19m_papszColColumnDefE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement16m_papszColValuesE">
<span id="_CPPv3N16CPLODBCStatement16m_papszColValuesE"></span><span id="_CPPv2N16CPLODBCStatement16m_papszColValuesE"></span><span id="CPLODBCStatement::m_papszColValues__cPP"></span><span class="target" id="classCPLODBCStatement_1a17e667fabd3c47b3e6d977a464038196"></span>char **<code class="descname">m_papszColValues</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement16m_papszColValuesE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement20m_panColValueLengthsE">
<span id="_CPPv3N16CPLODBCStatement20m_panColValueLengthsE"></span><span id="_CPPv2N16CPLODBCStatement20m_panColValueLengthsE"></span><span id="CPLODBCStatement::m_panColValueLengths__CPL_SQLLENP"></span><span class="target" id="classCPLODBCStatement_1a4240e38f7ccadee88816361fd842ba9e"></span>CPL_SQLLEN *<code class="descname">m_panColValueLengths</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement20m_panColValueLengthsE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement14m_pszStatementE">
<span id="_CPPv3N16CPLODBCStatement14m_pszStatementE"></span><span id="_CPPv2N16CPLODBCStatement14m_pszStatementE"></span><span id="CPLODBCStatement::m_pszStatement__cP"></span><span class="target" id="classCPLODBCStatement_1a52bf9dbc327a7db3381c9a38f29c58e9"></span>char *<code class="descname">m_pszStatement</code> = nullptr<a class="headerlink" href="#_CPPv4N16CPLODBCStatement14m_pszStatementE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement15m_nStatementMaxE">
<span id="_CPPv3N16CPLODBCStatement15m_nStatementMaxE"></span><span id="_CPPv2N16CPLODBCStatement15m_nStatementMaxE"></span><span id="CPLODBCStatement::m_nStatementMax__s"></span><span class="target" id="classCPLODBCStatement_1a529ae136a673229c1b40849190083899"></span>size_t <code class="descname">m_nStatementMax</code> = 0<a class="headerlink" href="#_CPPv4N16CPLODBCStatement15m_nStatementMaxE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N16CPLODBCStatement15m_nStatementLenE">
<span id="_CPPv3N16CPLODBCStatement15m_nStatementLenE"></span><span id="_CPPv2N16CPLODBCStatement15m_nStatementLenE"></span><span id="CPLODBCStatement::m_nStatementLen__s"></span><span class="target" id="classCPLODBCStatement_1acf92cccdf8271c99f58d57e748930148"></span>size_t <code class="descname">m_nStatementLen</code> = 0<a class="headerlink" href="#_CPPv4N16CPLODBCStatement15m_nStatementLenE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cpl-port-h">
<h2>cpl_port.h<a class="headerlink" href="#cpl-port-h" title="Permalink to this headline">¶</a></h2>
<p>Core portability definitions for CPL. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.GINTBIG_MIN">
<span class="target" id="cpl__port_8h_1a946e36839e691e287495c25770903533"></span><code class="descname">GINTBIG_MIN</code><a class="headerlink" href="#c.GINTBIG_MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum GIntBig value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GINTBIG_MAX">
<span class="target" id="cpl__port_8h_1a6b29dcfb3e064bab43874df898e16e20"></span><code class="descname">GINTBIG_MAX</code><a class="headerlink" href="#c.GINTBIG_MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum GIntBig value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GUINTBIG_MAX">
<span class="target" id="cpl__port_8h_1a82bd4992c0362d8addec634ec7d213b8"></span><code class="descname">GUINTBIG_MAX</code><a class="headerlink" href="#c.GUINTBIG_MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum GUIntBig value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GINT64_MIN">
<span class="target" id="cpl__port_8h_1a4083c854011d8e10b9fadcd259c0c536"></span><code class="descname">GINT64_MIN</code><a class="headerlink" href="#c.GINT64_MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum GInt64 value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GINT64_MAX">
<span class="target" id="cpl__port_8h_1a0f061b517687726721bf81d1f4f30a14"></span><code class="descname">GINT64_MAX</code><a class="headerlink" href="#c.GINT64_MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum GInt64 value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GUINT64_MAX">
<span class="target" id="cpl__port_8h_1a417ec42d9c74f1f184e28effd471a7e0"></span><code class="descname">GUINT64_MAX</code><a class="headerlink" href="#c.GUINT64_MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum GUInt64 value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_FRMT_GB_WITHOUT_PREFIX">
<span class="target" id="cpl__port_8h_1a03cccfde5364764db34e2e33b6768b18"></span><code class="descname">CPL_FRMT_GB_WITHOUT_PREFIX</code><a class="headerlink" href="#c.CPL_FRMT_GB_WITHOUT_PREFIX" title="Permalink to this definition">¶</a></dt>
<dd><p>Printf formatting suffix for GIntBig. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_FRMT_GIB">
<span class="target" id="cpl__port_8h_1a68ee33a0dd985971eb7d559685890b1e"></span><code class="descname">CPL_FRMT_GIB</code><a class="headerlink" href="#c.CPL_FRMT_GIB" title="Permalink to this definition">¶</a></dt>
<dd><p>Printf formatting for GIntBig. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_FRMT_GUIB">
<span class="target" id="cpl__port_8h_1a2cd7ccbf5388e3fad5b0854065ed0828"></span><code class="descname">CPL_FRMT_GUIB</code><a class="headerlink" href="#c.CPL_FRMT_GUIB" title="Permalink to this definition">¶</a></dt>
<dd><p>Printf formatting for GUIntBig. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_C_START">
<span class="target" id="cpl__port_8h_1a6b6fab294833d2308743cf5a5e3d774c"></span><code class="descname">CPL_C_START</code><a class="headerlink" href="#c.CPL_C_START" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro to start a block of C symbols. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_C_END">
<span class="target" id="cpl__port_8h_1a5f31d2c123bf9d2eb97744c553383566"></span><code class="descname">CPL_C_END</code><a class="headerlink" href="#c.CPL_C_END" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro to end a block of C symbols. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MIN">
<span class="target" id="cpl__port_8h_1a3acffbd305ee72dcd4593c0d8af64a4f"></span><code class="descname">MIN</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span><a class="headerlink" href="#c.MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro to compute the minimum of 2 values. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MAX">
<span class="target" id="cpl__port_8h_1afa99ec4acc4ecb2dc3c2d05da15d0e3f"></span><code class="descname">MAX</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span><a class="headerlink" href="#c.MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro to compute the maximum of 2 values. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ABS">
<span class="target" id="cpl__port_8h_1a996f7be338ccb40d1a2a5abc1ad61759"></span><code class="descname">ABS</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.ABS" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro to compute the absolute value. </p>
</dd></dl>

<dl class="macro">
<dt id="c.M_PI">
<span class="target" id="cpl__port_8h_1ae71449b1cc6e6250b91f539153a7a0d3"></span><code class="descname">M_PI</code><a class="headerlink" href="#c.M_PI" title="Permalink to this definition">¶</a></dt>
<dd><p>PI definition. </p>
</dd></dl>

<dl class="macro">
<dt id="c.STRCASECMP">
<span class="target" id="cpl__port_8h_1a2b177d06fc42d6b079ed3cb8a633db26"></span><code class="descname">STRCASECMP</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span><a class="headerlink" href="#c.STRCASECMP" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for strcasecmp() </p>
</dd></dl>

<dl class="macro">
<dt id="c.STRNCASECMP">
<span class="target" id="cpl__port_8h_1ac7c2bc44fa233b0d869a6188e51f79ff"></span><code class="descname">STRNCASECMP</code><span class="sig-paren">(</span>a, b, n<span class="sig-paren">)</span><a class="headerlink" href="#c.STRNCASECMP" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for strncasecmp() </p>
</dd></dl>

<dl class="macro">
<dt id="c.EQUALN">
<span class="target" id="cpl__port_8h_1a96b4fe28af61448f5ae7cb219601eee3"></span><code class="descname">EQUALN</code><span class="sig-paren">(</span>a, b, n<span class="sig-paren">)</span><a class="headerlink" href="#c.EQUALN" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for strncasecmp() == 0. </p>
</dd></dl>

<dl class="macro">
<dt id="c.EQUAL">
<span class="target" id="cpl__port_8h_1a8eb7da27bde11ccd5bf0c204ad32fb89"></span><code class="descname">EQUAL</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span><a class="headerlink" href="#c.EQUAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for strcasecmp() == 0. </p>
</dd></dl>

<dl class="macro">
<dt id="c.STARTS_WITH">
<span class="target" id="cpl__port_8h_1a3c0a1863f55de1521f60d97f5731a047"></span><code class="descname">STARTS_WITH</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span><a class="headerlink" href="#c.STARTS_WITH" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether a starts with b. </p>
</dd></dl>

<dl class="macro">
<dt id="c.STARTS_WITH_CI">
<span class="target" id="cpl__port_8h_1afbc02be985c2bb8451a765ad38b9dc8c"></span><code class="descname">STARTS_WITH_CI</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span><a class="headerlink" href="#c.STARTS_WITH_CI" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether a starts with b (case insensitive comparison) </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLIsNan">
<span class="target" id="cpl__port_8h_1aace5f63d46eef1ea5a3f7469b879cd9d"></span><code class="descname">CPLIsNan</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLIsNan" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether a floating-pointer number is NaN. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLIsInf">
<span class="target" id="cpl__port_8h_1a49b2983c9a294c008fc20a57e13eff94"></span><code class="descname">CPLIsInf</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLIsInf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether a floating-pointer number is +/- infinty. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLIsFinite">
<span class="target" id="cpl__port_8h_1af8a9f0a30b551836785d3ffcad30257a"></span><code class="descname">CPLIsFinite</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPLIsFinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether a floating-pointer number is finite. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SWAP16">
<span class="target" id="cpl__port_8h_1a89aa1f2fe53343bac285d174cdb01fcf"></span><code class="descname">CPL_SWAP16</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SWAP16" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap a 16bit unsigned integer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SWAP32">
<span class="target" id="cpl__port_8h_1a9566d5e15283625250737afde23eb993"></span><code class="descname">CPL_SWAP32</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SWAP32" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap a 32bit unsigned integer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SWAP64">
<span class="target" id="cpl__port_8h_1aa98bcfcaff12235b583bc71b350d4c61"></span><code class="descname">CPL_SWAP64</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SWAP64" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap a 64bit unsigned integer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SWAP16PTR">
<span class="target" id="cpl__port_8h_1ae258b3cb94fca3ab38f5c7e2d4f235e2"></span><code class="descname">CPL_SWAP16PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SWAP16PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap a 16 bit pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SWAP32PTR">
<span class="target" id="cpl__port_8h_1a4833afef89c20664ee490ac98d4f13a4"></span><code class="descname">CPL_SWAP32PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SWAP32PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap a 32 bit pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SWAP64PTR">
<span class="target" id="cpl__port_8h_1a449e7c6a7346a23690fcaa1391d1ae2f"></span><code class="descname">CPL_SWAP64PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SWAP64PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap a 64 bit pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SWAPDOUBLE">
<span class="target" id="cpl__port_8h_1ad9b741506a2c1d919f176496c08a4ad1"></span><code class="descname">CPL_SWAPDOUBLE</code><span class="sig-paren">(</span>p<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SWAPDOUBLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap a 64 bit pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBWORD16">
<span class="target" id="cpl__port_8h_1a4a89816534091c9600537e1940d0dad5"></span><code class="descname">CPL_LSBWORD16</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBWORD16" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 16bit word from a originally LSB ordered word. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_MSBWORD16">
<span class="target" id="cpl__port_8h_1ad29139b5adaec56061d0c81a3c785109"></span><code class="descname">CPL_MSBWORD16</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_MSBWORD16" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 16bit word from a originally MSB ordered word. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBWORD32">
<span class="target" id="cpl__port_8h_1acbecf40ecb41dd7f973fbc850bce19e4"></span><code class="descname">CPL_LSBWORD32</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBWORD32" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 32bit word from a originally LSB ordered word. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_MSBWORD32">
<span class="target" id="cpl__port_8h_1ae600e8bab6cf8505c8df950097d7439e"></span><code class="descname">CPL_MSBWORD32</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_MSBWORD32" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 32bit word from a originally MSB ordered word. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBPTR16">
<span class="target" id="cpl__port_8h_1a3b0d44b1367f4e666f879198c2aee852"></span><code class="descname">CPL_LSBPTR16</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBPTR16" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap if necessary a 16bit word at the location pointed from a originally LSB ordered pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_MSBPTR16">
<span class="target" id="cpl__port_8h_1aecf74ba471e460a0ff49c198e327c910"></span><code class="descname">CPL_MSBPTR16</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_MSBPTR16" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap if necessary a 16bit word at the location pointed from a originally MSB ordered pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBPTR32">
<span class="target" id="cpl__port_8h_1a6d4314906e1cb7335752a2495be37181"></span><code class="descname">CPL_LSBPTR32</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBPTR32" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap if necessary a 32bit word at the location pointed from a originally LSB ordered pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_MSBPTR32">
<span class="target" id="cpl__port_8h_1a727af4d9833144fd7a6caff69e0909c2"></span><code class="descname">CPL_MSBPTR32</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_MSBPTR32" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap if necessary a 32bit word at the location pointed from a originally MSB ordered pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBPTR64">
<span class="target" id="cpl__port_8h_1a1626733fe6ccd6bbc1491c8d6025f041"></span><code class="descname">CPL_LSBPTR64</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBPTR64" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap if necessary a 64bit word at the location pointed from a originally LSB ordered pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_MSBPTR64">
<span class="target" id="cpl__port_8h_1a7c0fc135da1ac4a90cd99d02edc45df8"></span><code class="descname">CPL_MSBPTR64</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_MSBPTR64" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte-swap if necessary a 64bit word at the location pointed from a originally MSB ordered pointer. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBINT16PTR">
<span class="target" id="cpl__port_8h_1a755da5fa59538492400a5bd307c031a1"></span><code class="descname">CPL_LSBINT16PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBINT16PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Int16 from the 2 bytes ordered in LSB order at address x. </p>
<p></p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBINT32PTR">
<span class="target" id="cpl__port_8h_1af72e1057b319104ad747034145ec37ec"></span><code class="descname">CPL_LSBINT32PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBINT32PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Int32 from the 4 bytes ordered in LSB order at address x. </p>
<p></p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBSINT16PTR">
<span class="target" id="cpl__port_8h_1a493e0830dd0bc3a7d6a84f474abf521f"></span><code class="descname">CPL_LSBSINT16PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBSINT16PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a signed Int16 from the 2 bytes ordered in LSB order at address x. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBUINT16PTR">
<span class="target" id="cpl__port_8h_1a21c3da7622e0bce9bf21c0da0ad658d7"></span><code class="descname">CPL_LSBUINT16PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBUINT16PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unsigned Int16 from the 2 bytes ordered in LSB order at address x. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBSINT32PTR">
<span class="target" id="cpl__port_8h_1a5e06fcab854466ad12634b8cee3e1af9"></span><code class="descname">CPL_LSBSINT32PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBSINT32PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a signed Int32 from the 4 bytes ordered in LSB order at address x. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_LSBUINT32PTR">
<span class="target" id="cpl__port_8h_1a3751c16dc76af5860719847d1ba29953"></span><code class="descname">CPL_LSBUINT32PTR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_LSBUINT32PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unsigned Int32 from the 4 bytes ordered in LSB order at address x. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_NULL_TERMINATED">
<span class="target" id="cpl__port_8h_1a3181c953b783da525be0a6c1975be31a"></span><code class="descname">CPL_NULL_TERMINATED</code><a class="headerlink" href="#c.CPL_NULL_TERMINATED" title="Permalink to this definition">¶</a></dt>
<dd><p>Null terminated variadic. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_PRINT_FUNC_FORMAT">
<span class="target" id="cpl__port_8h_1aab555219f8d323e6054c93dde4a8b2f8"></span><code class="descname">CPL_PRINT_FUNC_FORMAT</code><span class="sig-paren">(</span>format_idx, arg_idx<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_PRINT_FUNC_FORMAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Tag a function to have printf() formatting. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SCAN_FUNC_FORMAT">
<span class="target" id="cpl__port_8h_1a397a226a22ce11405939ec62346e6a6b"></span><code class="descname">CPL_SCAN_FUNC_FORMAT</code><span class="sig-paren">(</span>format_idx, arg_idx<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SCAN_FUNC_FORMAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Tag a function to have scanf() formatting. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_FORMAT_STRING">
<span class="target" id="cpl__port_8h_1a80b7baa1ca8e010b17ebf44afeff47f3"></span><code class="descname">CPL_FORMAT_STRING</code><span class="sig-paren">(</span>arg<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_FORMAT_STRING" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro into which to wrap the format argument of a printf-like function. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_SCANF_FORMAT_STRING">
<span class="target" id="cpl__port_8h_1ae4bf8d95f05909845211bd1f8ce019e9"></span><code class="descname">CPL_SCANF_FORMAT_STRING</code><span class="sig-paren">(</span>arg<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_SCANF_FORMAT_STRING" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro into which to wrap the format argument of a sscanf-like function. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_WARN_UNUSED_RESULT">
<span class="target" id="cpl__port_8h_1add8bd16e2a1e63d383c4b4a06af268df"></span><code class="descname">CPL_WARN_UNUSED_RESULT</code><a class="headerlink" href="#c.CPL_WARN_UNUSED_RESULT" title="Permalink to this definition">¶</a></dt>
<dd><p>Qualifier to warn when the return value of a function is not used. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_UNUSED">
<span class="target" id="cpl__port_8h_1a60255b7e52d54325540177a96ef155e2"></span><code class="descname">CPL_UNUSED</code><a class="headerlink" href="#c.CPL_UNUSED" title="Permalink to this definition">¶</a></dt>
<dd><p>Qualifier for an argument that is unused. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_NO_RETURN">
<span class="target" id="cpl__port_8h_1a0962647369f6d0e862b2b86393285282"></span><code class="descname">CPL_NO_RETURN</code><a class="headerlink" href="#c.CPL_NO_RETURN" title="Permalink to this definition">¶</a></dt>
<dd><p>Qualifier for a function that does not return at all (terminates the process) </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_RETURNS_NONNULL">
<span class="target" id="cpl__port_8h_1a8b23535f45e528fe93642ea83b7409d1"></span><code class="descname">CPL_RETURNS_NONNULL</code><a class="headerlink" href="#c.CPL_RETURNS_NONNULL" title="Permalink to this definition">¶</a></dt>
<dd><p>Qualifier for a function that does not return NULL. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_RESTRICT">
<span class="target" id="cpl__port_8h_1a4ca48037a2e8fa39529567ce8c146ed2"></span><code class="descname">CPL_RESTRICT</code><a class="headerlink" href="#c.CPL_RESTRICT" title="Permalink to this definition">¶</a></dt>
<dd><p>restrict keyword to declare that pointers do not alias </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_OVERRIDE">
<span class="target" id="cpl__port_8h_1a09794e18ec52f3790adc817aa41feda0"></span><code class="descname">CPL_OVERRIDE</code><a class="headerlink" href="#c.CPL_OVERRIDE" title="Permalink to this definition">¶</a></dt>
<dd><p>To be used in public headers only. </p>
<p>For non-public headers or .cpp files, use override directly. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_FINAL">
<span class="target" id="cpl__port_8h_1abdb5fc5e6b8b48ff70037f597b1eee4e"></span><code class="descname">CPL_FINAL</code><a class="headerlink" href="#c.CPL_FINAL" title="Permalink to this definition">¶</a></dt>
<dd><p>C++11 final qualifier. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_NON_FINAL">
<span class="target" id="cpl__port_8h_1a41115e1f6a11301183200f2661291912"></span><code class="descname">CPL_NON_FINAL</code><a class="headerlink" href="#c.CPL_NON_FINAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark that a class is explicitly recognized as non-final. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_DISALLOW_COPY_ASSIGN">
<span class="target" id="cpl__port_8h_1acd7a0ee36cca7c961eb30f426ab31b0e"></span><code class="descname">CPL_DISALLOW_COPY_ASSIGN</code><span class="sig-paren">(</span>ClassName<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_DISALLOW_COPY_ASSIGN" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to remove the copy and assignment constructors so that the compiler will not generate the default versions. </p>
<p>Must be placed in the private section of a class and should be at the end. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ARRAYSIZE">
<span class="target" id="cpl__port_8h_1ae9341ba904cd96a6eb068ee18a9be963"></span><code class="descname">CPL_ARRAYSIZE</code><span class="sig-paren">(</span>array<span class="sig-paren">)</span><a class="headerlink" href="#c.CPL_ARRAYSIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of C style arrays. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_FALLTHROUGH">
<span class="target" id="cpl__port_8h_1a804cb48971ba17609a823110dd8ce7da"></span><code class="descname">CPL_FALLTHROUGH</code><a class="headerlink" href="#c.CPL_FALLTHROUGH" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro for fallthrough in a switch case construct. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv46GInt32">
<span id="_CPPv36GInt32"></span><span id="_CPPv26GInt32"></span><span id="GInt32"></span><span class="target" id="cpl__port_8h_1af19adaeb9a6dd7c664fc6f79e426854a"></span><em class="property">typedef </em>int <code class="descname">GInt32</code><a class="headerlink" href="#_CPPv46GInt32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Int32 type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv47GUInt32">
<span id="_CPPv37GUInt32"></span><span id="_CPPv27GUInt32"></span><span id="GUInt32"></span><span class="target" id="cpl__port_8h_1aa623244ca15b034795eb015e4dec224d"></span><em class="property">typedef </em>unsigned int <code class="descname">GUInt32</code><a class="headerlink" href="#_CPPv47GUInt32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unsigned int32 type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv46GInt16">
<span id="_CPPv36GInt16"></span><span id="_CPPv26GInt16"></span><span id="GInt16"></span><span class="target" id="cpl__port_8h_1a5908e4f9dfeafe8ffea41b7df0f46401"></span><em class="property">typedef </em>short <code class="descname">GInt16</code><a class="headerlink" href="#_CPPv46GInt16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Int16 type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv47GUInt16">
<span id="_CPPv37GUInt16"></span><span id="_CPPv27GUInt16"></span><span id="GUInt16"></span><span class="target" id="cpl__port_8h_1ae3f75cbefcae55ad473e17f37c9f87aa"></span><em class="property">typedef </em>unsigned short <code class="descname">GUInt16</code><a class="headerlink" href="#_CPPv47GUInt16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unsigned int16 type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv45GByte">
<span id="_CPPv35GByte"></span><span id="_CPPv25GByte"></span><span id="GByte"></span><span class="target" id="cpl__port_8h_1ae7fbc84d3d1f7a40973be07382e28401"></span><em class="property">typedef </em>unsigned char <code class="descname">GByte</code><a class="headerlink" href="#_CPPv45GByte" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unsigned byte type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv45GBool">
<span id="_CPPv35GBool"></span><span id="_CPPv25GBool"></span><span id="GBool"></span><span class="target" id="cpl__port_8h_1a7554474b2a855e1415bb69e72748046a"></span><em class="property">typedef </em>int <code class="descname">GBool</code><a class="headerlink" href="#_CPPv45GBool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type for boolean values (alias to int) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv47GIntBig">
<span id="_CPPv37GIntBig"></span><span id="_CPPv27GIntBig"></span><span id="GIntBig"></span><span class="target" id="cpl__port_8h_1af4f1fd7d2338bb38f28bdf32a0724e83"></span><em class="property">typedef </em>long long <code class="descname">GIntBig</code><a class="headerlink" href="#_CPPv47GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Large signed integer type (generally 64-bit integer type). </p>
<p>Use GInt64 when exactly 64 bit is needed </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv48GUIntBig">
<span id="_CPPv38GUIntBig"></span><span id="_CPPv28GUIntBig"></span><span id="GUIntBig"></span><span class="target" id="cpl__port_8h_1a4f0794a0fb78d55ba284a414191dbc93"></span><em class="property">typedef </em>unsigned long long <code class="descname">GUIntBig</code><a class="headerlink" href="#_CPPv48GUIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Large unsigned integer type (generally 64-bit unsigned integer type). </p>
<p>Use GUInt64 when exactly 64 bit is needed </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv46GInt64">
<span id="_CPPv36GInt64"></span><span id="_CPPv26GInt64"></span><span id="GInt64"></span><span class="target" id="cpl__port_8h_1a6e5dffdc7f562a64c72c486fe3706847"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">GInt64</code><a class="headerlink" href="#_CPPv46GInt64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signed 64 bit integer type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv47GUInt64">
<span id="_CPPv37GUInt64"></span><span id="_CPPv27GUInt64"></span><span id="GUInt64"></span><span class="target" id="cpl__port_8h_1ad88aa21b67fc44326628930c9fa537ce"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv48GUIntBig" title="GUIntBig">GUIntBig</a> <code class="descname">GUInt64</code><a class="headerlink" href="#_CPPv47GUInt64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unsigned 64 bit integer type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv410GPtrDiff_t">
<span id="_CPPv310GPtrDiff_t"></span><span id="_CPPv210GPtrDiff_t"></span><span id="GPtrDiff_t"></span><span class="target" id="cpl__port_8h_1a266f5ca4950b3381e59593912f0f3f9c"></span><em class="property">typedef </em>int <code class="descname">GPtrDiff_t</code><a class="headerlink" href="#_CPPv410GPtrDiff_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Integer type large enough to hold the difference between 2 addresses. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv412CSLConstList">
<span id="_CPPv312CSLConstList"></span><span id="_CPPv212CSLConstList"></span><span id="CSLConstList"></span><span class="target" id="cpl__port_8h_1ad6399986f130f30db93917dd65434a06"></span><em class="property">typedef </em>char **<code class="descname">CSLConstList</code><a class="headerlink" href="#_CPPv412CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type of a constant null-terminated list of nul terminated strings. </p>
<p>Seen as char** from C and const char* const* from C++ </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv4I0E18CPL_IGNORE_RET_VALv1T">
<span id="_CPPv3I0E18CPL_IGNORE_RET_VAL1T"></span><span id="_CPPv2I0E18CPL_IGNORE_RET_VAL1T"></span><span class="target" id="cpl__port_8h_1ac73664cb8dc407ed4718600105cf0705"></span>template&lt;class <code class="descname">T</code>&gt;<br /><em class="property">static</em> void <code class="descname">CPL_IGNORE_RET_VAL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0E18CPL_IGNORE_RET_VALv1T" title="CPL_IGNORE_RET_VAL::T">T</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0E18CPL_IGNORE_RET_VALv1T" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411CPL_TO_BOOLi">
<span id="_CPPv311CPL_TO_BOOLi"></span><span id="_CPPv211CPL_TO_BOOLi"></span><span id="CPL_TO_BOOL__i"></span><span class="target" id="cpl__port_8h_1a7fe37f4aa7edffb0bcc5facb0695689f"></span><em class="property">static</em> bool <code class="descname">CPL_TO_BOOL</code><span class="sig-paren">(</span>int <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPL_TO_BOOLi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="cpl-progress-h">
<h2>cpl_progress.h<a class="headerlink" href="#cpl-progress-h" title="Permalink to this headline">¶</a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv416GDALProgressFunc">
<span id="_CPPv316GDALProgressFunc"></span><span id="_CPPv216GDALProgressFunc"></span><span id="GDALProgressFunc"></span><span class="target" id="cpl__progress_8h_1ae4f86d2009d2a02c76a33e2fd6868c98"></span><em class="property">typedef </em>int (*<code class="descname">GDALProgressFunc</code>)<span class="sig-paren">(</span>double dfComplete, <em class="property">const</em> char *pszMessage, void *pProgressArg<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416GDALProgressFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv417GDALDummyProgressdPKcPv">
<span id="_CPPv317GDALDummyProgressdPKcPv"></span><span id="_CPPv217GDALDummyProgressdPKcPv"></span><span id="GDALDummyProgress__double.cCP.voidP"></span><span class="target" id="cpl__progress_8h_1a8bd69b258d70b9107465ae10431c0caf"></span>int <code class="descname">GDALDummyProgress</code><span class="sig-paren">(</span>double, <em class="property">const</em> char *, void *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417GDALDummyProgressdPKcPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stub progress function. </p>
<p>This is a stub (does nothing) implementation of the GDALProgressFunc() semantics. It is primarily useful for passing to functions that take a GDALProgressFunc() argument but for which the application does not want to use one of the other progress functions that actually do something. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416GDALTermProgressdPKcPv">
<span id="_CPPv316GDALTermProgressdPKcPv"></span><span id="_CPPv216GDALTermProgressdPKcPv"></span><span id="GDALTermProgress__double.cCP.voidP"></span><span class="target" id="cpl__progress_8h_1a00e9838f30867a9dbeb65e454d3bea1e"></span>int <code class="descname">GDALTermProgress</code><span class="sig-paren">(</span>double <em>dfComplete</em>, <em class="property">const</em> char *<em>pszMessage</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416GDALTermProgressdPKcPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simple progress report to terminal. </p>
<p>This progress reporter prints simple progress report to the terminal window. The progress report generally looks something like this:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">0.</span><span class="o">..</span><span class="mf">10.</span><span class="o">..</span><span class="mf">20.</span><span class="o">..</span><span class="mf">30.</span><span class="o">..</span><span class="mf">40.</span><span class="o">..</span><span class="mf">50.</span><span class="o">..</span><span class="mf">60.</span><span class="o">..</span><span class="mf">70.</span><span class="o">..</span><span class="mf">80.</span><span class="o">..</span><span class="mf">90.</span><span class="o">..</span><span class="mi">100</span> <span class="o">-</span> <span class="n">done</span><span class="o">.</span>
</pre></div>
</div>
</p>
<p>Every 2.5% of progress another number or period is emitted. Note that GDALTermProgress() uses internal static data to keep track of the last percentage reported and will get confused if two terminal based progress reportings are active at the same time.</p>
<p>The GDALTermProgress() function maintains an internal memory of the last percentage complete reported in a static variable, and this makes it unsuitable to have multiple GDALTermProgress()’s active either in a single thread or across multiple threads.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Always returns TRUE indicating the process should continue. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dfComplete</span></code>: completion ratio from 0.0 to 1.0. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszMessage</span></code>: optional message. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: ignored callback data argument.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418GDALScaledProgressdPKcPv">
<span id="_CPPv318GDALScaledProgressdPKcPv"></span><span id="_CPPv218GDALScaledProgressdPKcPv"></span><span id="GDALScaledProgress__double.cCP.voidP"></span><span class="target" id="cpl__progress_8h_1a40b9cd9211da36aecaab5be2116e0afa"></span>int <code class="descname">GDALScaledProgress</code><span class="sig-paren">(</span>double <em>dfComplete</em>, <em class="property">const</em> char *<em>pszMessage</em>, void *<em>pData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418GDALScaledProgressdPKcPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scaled progress transformer. </p>
<p>This is the progress function that should be passed along with the callback data returned by GDALCreateScaledProgress(). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424GDALCreateScaledProgressdd16GDALProgressFuncPv">
<span id="_CPPv324GDALCreateScaledProgressdd16GDALProgressFuncPv"></span><span id="_CPPv224GDALCreateScaledProgressdd16GDALProgressFuncPv"></span><span id="GDALCreateScaledProgress__double.double.GDALProgressFunc.voidP"></span><span class="target" id="cpl__progress_8h_1a462c1d7aa414cdacd608d62e1830ef43"></span>void *<code class="descname">GDALCreateScaledProgress</code><span class="sig-paren">(</span>double <em>dfMin</em>, double <em>dfMax</em>, <a class="reference internal" href="#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424GDALCreateScaledProgressdd16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create scaled progress transformer. </p>
<p>Sometimes when an operations wants to report progress it actually invokes several subprocesses which also take GDALProgressFunc()s, and it is desirable to map the progress of each sub operation into a portion of 0.0 to 1.0 progress of the overall process. The scaled progress function can be used for this.</p>
<p>For each subsection a scaled progress function is created and instead of passing the overall progress func down to the sub functions, the GDALScaledProgress() function is passed instead.</p>
<p><p>Example:</p>
<dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to pass as pProgressArg to sub functions. Should be freed with GDALDestroyScaledProgress().</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dfMin</span></code>: the value to which 0.0 in the sub operation is mapped. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMax</span></code>: the value to which 1.0 is the sub operation is mapped. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: the overall progress function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pData</span></code>: the overall progress function callback data.</p></li>
</ul>
</dd>
</dl>
</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">MyOperation</span><span class="p">(</span> <span class="o">...</span><span class="p">,</span> <span class="n">GDALProgressFunc</span> <span class="n">pfnProgress</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">pProgressData</span> <span class="p">);</span>

<span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">pScaledProgress</span><span class="p">;</span>

    <span class="n">pScaledProgress</span> <span class="o">=</span> <span class="n">GDALCreateScaledProgress</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">pfnProgress</span><span class="p">,</span>
                                                <span class="n">pProgressData</span> <span class="p">);</span>
    <span class="n">GDALDoLongSlowOperation</span><span class="p">(</span> <span class="o">...</span><span class="p">,</span> <span class="n">GDALScaledProgress</span><span class="p">,</span> <span class="n">pScaledProgress</span> <span class="p">);</span>
    <span class="n">GDALDestroyScaledProgress</span><span class="p">(</span> <span class="n">pScaledProgress</span> <span class="p">);</span>

    <span class="n">pScaledProgress</span> <span class="o">=</span> <span class="n">GDALCreateScaledProgress</span><span class="p">(</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">pfnProgress</span><span class="p">,</span>
                                                <span class="n">pProgressData</span> <span class="p">);</span>
    <span class="n">GDALDoAnotherOperation</span><span class="p">(</span> <span class="o">...</span><span class="p">,</span> <span class="n">GDALScaledProgress</span><span class="p">,</span> <span class="n">pScaledProgress</span> <span class="p">);</span>
    <span class="n">GDALDestroyScaledProgress</span><span class="p">(</span> <span class="n">pScaledProgress</span> <span class="p">);</span>

    <span class="k">return</span> <span class="o">...</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALDestroyScaledProgressPv">
<span id="_CPPv325GDALDestroyScaledProgressPv"></span><span id="_CPPv225GDALDestroyScaledProgressPv"></span><span id="GDALDestroyScaledProgress__voidP"></span><span class="target" id="cpl__progress_8h_1af1ac4100ae77f94983d45a33fc1b6fcd"></span>void <code class="descname">GDALDestroyScaledProgress</code><span class="sig-paren">(</span>void *<em>pData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALDestroyScaledProgressPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cleanup scaled progress handle. </p>
<p>This function cleans up the data associated with a scaled progress function as returned by GADLCreateScaledProgress().</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pData</span></code>: scaled progress handle returned by GDALCreateScaledProgress(). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="cpl-string-h">
<h2>cpl_string.h<a class="headerlink" href="#cpl-string-h" title="Permalink to this headline">¶</a></h2>
<p>Various convenience functions for working with strings and string lists. </p>
<p>A StringList is just an array of strings with the last pointer being NULL. An empty StringList may be either a NULL pointer, or a pointer to a pointer memory location with a NULL value.</p>
<p>A common convention for StringLists is to use them to store name/value lists. In this case the contents are treated like a dictionary of name/value pairs. The actual data is formatted with each string having the format “&lt;name&gt;:&lt;value&gt;” (though “=” is also an acceptable separator). A number of the functions in the file operate on name/value style string lists (such as <a class="reference internal" href="#cpl__string_8h_1aa1a048471042e6fcf4e01faf11774867"><span class="std std-ref">CSLSetNameValue()</span></a>, and <a class="reference internal" href="#cpl__string_8h_1a94ca3f1c515330277c31b06d2a061ccd"><span class="std std-ref">CSLFetchNameValue()</span></a>).</p>
<p>To some extent the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> C++ class can be used to abstract managing string lists a bit but still be able to return them from C functions. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.CSLT_HONOURSTRINGS">
<span class="target" id="cpl__string_8h_1a2338aada58f9282979f68e527f5aeb03"></span><code class="descname">CSLT_HONOURSTRINGS</code><a class="headerlink" href="#c.CSLT_HONOURSTRINGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag for <a class="reference internal" href="#cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"><span class="std std-ref">CSLTokenizeString2()</span></a> to honour strings. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CSLT_ALLOWEMPTYTOKENS">
<span class="target" id="cpl__string_8h_1a2cf4a54c9dc07fb312ff0f0d143048cc"></span><code class="descname">CSLT_ALLOWEMPTYTOKENS</code><a class="headerlink" href="#c.CSLT_ALLOWEMPTYTOKENS" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag for <a class="reference internal" href="#cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"><span class="std std-ref">CSLTokenizeString2()</span></a> to allow empty tokens. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CSLT_PRESERVEQUOTES">
<span class="target" id="cpl__string_8h_1ada6b937d227431e8076ec35294a3cb56"></span><code class="descname">CSLT_PRESERVEQUOTES</code><a class="headerlink" href="#c.CSLT_PRESERVEQUOTES" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag for <a class="reference internal" href="#cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"><span class="std std-ref">CSLTokenizeString2()</span></a> to preserve quotes. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CSLT_PRESERVEESCAPES">
<span class="target" id="cpl__string_8h_1a8aace221e37b023221866198770ffe50"></span><code class="descname">CSLT_PRESERVEESCAPES</code><a class="headerlink" href="#c.CSLT_PRESERVEESCAPES" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag for <a class="reference internal" href="#cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"><span class="std std-ref">CSLTokenizeString2()</span></a> to preserve escape characters. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CSLT_STRIPLEADSPACES">
<span class="target" id="cpl__string_8h_1a3abb7b31dfa10f4480f4ada48db2cd5b"></span><code class="descname">CSLT_STRIPLEADSPACES</code><a class="headerlink" href="#c.CSLT_STRIPLEADSPACES" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag for <a class="reference internal" href="#cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"><span class="std std-ref">CSLTokenizeString2()</span></a> to strip leading spaces. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CSLT_STRIPENDSPACES">
<span class="target" id="cpl__string_8h_1af45f2f4c3d953ab2bf6594ac042a265b"></span><code class="descname">CSLT_STRIPENDSPACES</code><a class="headerlink" href="#c.CSLT_STRIPENDSPACES" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag for <a class="reference internal" href="#cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"><span class="std std-ref">CSLTokenizeString2()</span></a> to strip trailaing spaces. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_BackslashQuotable">
<span class="target" id="cpl__string_8h_1a4d69daceff916c28ef0c65506d89d6d3"></span><code class="descname">CPLES_BackslashQuotable</code><a class="headerlink" href="#c.CPLES_BackslashQuotable" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for backlash quoting. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_XML">
<span class="target" id="cpl__string_8h_1a7f5479acb68fb882fed8bada7b92db15"></span><code class="descname">CPLES_XML</code><a class="headerlink" href="#c.CPLES_XML" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for XML. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_URL">
<span class="target" id="cpl__string_8h_1a88296f14572ad5a724fb512357fddb03"></span><code class="descname">CPLES_URL</code><a class="headerlink" href="#c.CPLES_URL" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for URL. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_SQL">
<span class="target" id="cpl__string_8h_1a90614c3cf4cdd748e063f9c2cf669246"></span><code class="descname">CPLES_SQL</code><a class="headerlink" href="#c.CPLES_SQL" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for SQL. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_CSV">
<span class="target" id="cpl__string_8h_1aa3347d20cc965ec42e25bc285a763ea9"></span><code class="descname">CPLES_CSV</code><a class="headerlink" href="#c.CPLES_CSV" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for CSV. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_XML_BUT_QUOTES">
<span class="target" id="cpl__string_8h_1abbabb77330e2927fafb93b568735ccd6"></span><code class="descname">CPLES_XML_BUT_QUOTES</code><a class="headerlink" href="#c.CPLES_XML_BUT_QUOTES" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for XML (preserves quotes) </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_CSV_FORCE_QUOTING">
<span class="target" id="cpl__string_8h_1a04305ab1c7d63b320aa876708f772d87"></span><code class="descname">CPLES_CSV_FORCE_QUOTING</code><a class="headerlink" href="#c.CPLES_CSV_FORCE_QUOTING" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for CSV (forced quoting) </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLES_SQLI">
<span class="target" id="cpl__string_8h_1a97b06de69ccbf6c0f6127a8f033fd056"></span><code class="descname">CPLES_SQLI</code><a class="headerlink" href="#c.CPLES_SQLI" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheme for <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>/CPLUnescapeString() for SQL identifiers. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ENC_LOCALE">
<span class="target" id="cpl__string_8h_1a87d8ea35a911bef8e5bd3e851043d959"></span><code class="descname">CPL_ENC_LOCALE</code><a class="headerlink" href="#c.CPL_ENC_LOCALE" title="Permalink to this definition">¶</a></dt>
<dd><p>Encoding of the current locale. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ENC_UTF8">
<span class="target" id="cpl__string_8h_1a26d8bd24304461e94dd5a407576c6f42"></span><code class="descname">CPL_ENC_UTF8</code><a class="headerlink" href="#c.CPL_ENC_UTF8" title="Permalink to this definition">¶</a></dt>
<dd><p>UTF-8 encoding. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ENC_UTF16">
<span class="target" id="cpl__string_8h_1a8bc6144aae9925e22d6476e8df3ae937"></span><code class="descname">CPL_ENC_UTF16</code><a class="headerlink" href="#c.CPL_ENC_UTF16" title="Permalink to this definition">¶</a></dt>
<dd><p>UTF-16 encoding. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ENC_UCS2">
<span class="target" id="cpl__string_8h_1a04aab58c768a810389f63c3de7867b50"></span><code class="descname">CPL_ENC_UCS2</code><a class="headerlink" href="#c.CPL_ENC_UCS2" title="Permalink to this definition">¶</a></dt>
<dd><p>UCS-2 encoding. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ENC_UCS4">
<span class="target" id="cpl__string_8h_1a134294ed95e8c77931dc817146449aa7"></span><code class="descname">CPL_ENC_UCS4</code><a class="headerlink" href="#c.CPL_ENC_UCS4" title="Permalink to this definition">¶</a></dt>
<dd><p>UCS-4 encoding. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ENC_ASCII">
<span class="target" id="cpl__string_8h_1adcc150659994a7c7d66a5ed64ed4ff9b"></span><code class="descname">CPL_ENC_ASCII</code><a class="headerlink" href="#c.CPL_ENC_ASCII" title="Permalink to this definition">¶</a></dt>
<dd><p>ASCII encoding. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPL_ENC_ISO8859_1">
<span class="target" id="cpl__string_8h_1a82b2de9456d43c67ba3eeeb9e2ca239b"></span><code class="descname">CPL_ENC_ISO8859_1</code><a class="headerlink" href="#c.CPL_ENC_ISO8859_1" title="Permalink to this definition">¶</a></dt>
<dd><p>ISO-8859-1 (LATIN1) encoding. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv412CPLValueType">
<span id="_CPPv312CPLValueType"></span><span id="_CPPv212CPLValueType"></span><span class="target" id="cpl__string_8h_1a58696cad4b2dc09a3190fa5f64486bf3"></span><em class="property">enum </em><code class="descname">CPLValueType</code><a class="headerlink" href="#_CPPv412CPLValueType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type of value. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv416CPL_VALUE_STRING">
<span id="_CPPv316CPL_VALUE_STRING"></span><span id="_CPPv216CPL_VALUE_STRING"></span><span class="target" id="cpl__string_8h_1a58696cad4b2dc09a3190fa5f64486bf3a64b8a3bba9771a99925907adf8b8d580"></span><code class="descname">CPL_VALUE_STRING</code><a class="headerlink" href="#_CPPv416CPL_VALUE_STRING" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>String. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414CPL_VALUE_REAL">
<span id="_CPPv314CPL_VALUE_REAL"></span><span id="_CPPv214CPL_VALUE_REAL"></span><span class="target" id="cpl__string_8h_1a58696cad4b2dc09a3190fa5f64486bf3ad528bf096c3066deec561c7a8d79eac9"></span><code class="descname">CPL_VALUE_REAL</code><a class="headerlink" href="#_CPPv414CPL_VALUE_REAL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Real number. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417CPL_VALUE_INTEGER">
<span id="_CPPv317CPL_VALUE_INTEGER"></span><span id="_CPPv217CPL_VALUE_INTEGER"></span><span class="target" id="cpl__string_8h_1a58696cad4b2dc09a3190fa5f64486bf3a10b62ee4d5c309a03a6d0e1a1ccd53c9"></span><code class="descname">CPL_VALUE_INTEGER</code><a class="headerlink" href="#_CPPv417CPL_VALUE_INTEGER" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Integer. </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv412CSLAddStringPPcPKc">
<span id="_CPPv312CSLAddStringPPcPKc"></span><span id="_CPPv212CSLAddStringPPcPKc"></span><span id="CSLAddString__cPP.cCP"></span><span class="target" id="cpl__string_8h_1ae84fb70e547d924b925556b2105714d5"></span>char **<code class="descname">CSLAddString</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, <em class="property">const</em> char *<em>pszNewString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CSLAddStringPPcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append a string to a StringList and return a pointer to the modified StringList. </p>
<p>If the input StringList is NULL, then a new StringList is created. Note that CSLAddString performance when building a list is in O(n^2) which can cause noticeable slow down when n &gt; 10000. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CSLAddStringMayFailPPcPKc">
<span id="_CPPv319CSLAddStringMayFailPPcPKc"></span><span id="_CPPv219CSLAddStringMayFailPPcPKc"></span><span id="CSLAddStringMayFail__cPP.cCP"></span><span class="target" id="cpl__string_8h_1a99c0ad43e9198bb0b5d544e988f5b1b3"></span>char **<code class="descname">CSLAddStringMayFail</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, <em class="property">const</em> char *<em>pszNewString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CSLAddStringMayFailPPcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#cpl__string_8h_1ae84fb70e547d924b925556b2105714d5"><span class="std std-ref">CSLAddString()</span></a> but may return NULL in case of (memory) failure. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48CSLCount12CSLConstList">
<span id="_CPPv38CSLCount12CSLConstList"></span><span id="_CPPv28CSLCount12CSLConstList"></span><span id="CSLCount__CSLConstList"></span><span class="target" id="cpl__string_8h_1a827f21b7a67d16059c131d0946482bb1"></span>int <code class="descname">CSLCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CSLCount12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return number of items in a string list. </p>
<p>Returns the number of items in a string list, not counting the terminating NULL. Passing in NULL is safe, and will result in a count of zero.</p>
<p>Lists are counted by iterating through them so long lists will take more time than short lists. Care should be taken to avoid using <a class="reference internal" href="#cpl__string_8h_1a827f21b7a67d16059c131d0946482bb1"><span class="std std-ref">CSLCount()</span></a> as an end condition for loops as it will result in O(n^2) behavior.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of entries. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszStrList</span></code>: the string list to count.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CSLGetField12CSLConstListi">
<span id="_CPPv311CSLGetField12CSLConstListi"></span><span id="_CPPv211CSLGetField12CSLConstListi"></span><span id="CSLGetField__CSLConstList.i"></span><span class="target" id="cpl__string_8h_1ade8916c450792a9197807da60bf94037"></span><em class="property">const</em> char *<code class="descname">CSLGetField</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CSLGetField12CSLConstListi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetches the indicated field, being careful not to crash if the field doesn’t exist within this string list. </p>
<p>The returned pointer should not be freed, and doesn’t necessarily last long. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CSLDestroyPPc">
<span id="_CPPv310CSLDestroyPPc"></span><span id="_CPPv210CSLDestroyPPc"></span><span id="CSLDestroy__cPP"></span><span class="target" id="cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"></span>void <code class="descname">CSLDestroy</code><span class="sig-paren">(</span>char **<em>papszStrList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CSLDestroyPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free string list. </p>
<p>Frees the passed string list (null terminated array of strings). It is safe to pass NULL.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszStrList</span></code>: the list to free. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CSLDuplicate12CSLConstList">
<span id="_CPPv312CSLDuplicate12CSLConstList"></span><span id="_CPPv212CSLDuplicate12CSLConstList"></span><span id="CSLDuplicate__CSLConstList"></span><span class="target" id="cpl__string_8h_1a35bb1bc2e81c5df5fd251d29b7e772ce"></span>char **<code class="descname">CSLDuplicate</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CSLDuplicate12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clone a string list. </p>
<p>Efficiently allocates a copy of a string list. The returned list is owned by the caller and should be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>newly allocated copy. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszStrList</span></code>: the input string list.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48CSLMergePPc12CSLConstList">
<span id="_CPPv38CSLMergePPc12CSLConstList"></span><span id="_CPPv28CSLMergePPc12CSLConstList"></span><span id="CSLMerge__cPP.CSLConstList"></span><span class="target" id="cpl__string_8h_1adfd90ab41fe0647f98a9692857b44004"></span>char **<code class="descname">CSLMerge</code><span class="sig-paren">(</span>char **<em>papszOrig</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOverride</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CSLMergePPc12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merge two lists. </p>
<p>The two lists are merged, ensuring that if any keys appear in both that the value from the second (papszOverride) list take precedence.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>updated list. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszOrig</span></code>: the original list, being modified. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOverride</span></code>: the list of items being merged in. This list is unaltered and remains owned by the caller.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CSLTokenizeStringPKc">
<span id="_CPPv317CSLTokenizeStringPKc"></span><span id="_CPPv217CSLTokenizeStringPKc"></span><span id="CSLTokenizeString__cCP"></span><span class="target" id="cpl__string_8h_1aecb31aecf3160c0a323604283dacea48"></span>char **<code class="descname">CSLTokenizeString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CSLTokenizeStringPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tokenizes a string and returns a StringList with one string for each token. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424CSLTokenizeStringComplexPKcPKcii">
<span id="_CPPv324CSLTokenizeStringComplexPKcPKcii"></span><span id="_CPPv224CSLTokenizeStringComplexPKcPKcii"></span><span id="CSLTokenizeStringComplex__cCP.cCP.i.i"></span><span class="target" id="cpl__string_8h_1ad9e47dd0a8f812e510426bdc9a653aab"></span>char **<code class="descname">CSLTokenizeStringComplex</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, <em class="property">const</em> char *<em>pszDelimiter</em>, int <em>bHonourStrings</em>, int <em>bAllowEmptyTokens</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424CSLTokenizeStringComplexPKcPKcii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obsolete tokenizing api. </p>
<p>Use <a class="reference internal" href="#cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"><span class="std std-ref">CSLTokenizeString2()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CSLTokenizeString2PKcPKci">
<span id="_CPPv318CSLTokenizeString2PKcPKci"></span><span id="_CPPv218CSLTokenizeString2PKcPKci"></span><span id="CSLTokenizeString2__cCP.cCP.i"></span><span class="target" id="cpl__string_8h_1abea9d982d1db1730f866191cff2c2ad8"></span>char **<code class="descname">CSLTokenizeString2</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, <em class="property">const</em> char *<em>pszDelimiter</em>, int <em>nCSLTFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CSLTokenizeString2PKcPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tokenize a string. </p>
<p>This function will split a string into tokens based on specified’ delimiter(s) with a variety of options. The returned result is a string list that should be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a> when no longer needed.</p>
<p>The available parsing options are:</p>
<p><ul class="simple">
<li><p>CSLT_ALLOWEMPTYTOKENS: allow the return of empty tokens when two delimiters in a row occur with no other text between them. If not set, empty tokens will be discarded;</p></li>
<li><p>CSLT_STRIPLEADSPACES: strip leading space characters from the token (as reported by isspace());</p></li>
<li><p>CSLT_STRIPENDSPACES: strip ending space characters from the token (as reported by isspace());</p></li>
<li><p>CSLT_HONOURSTRINGS: double quotes can be used to hold values that should not be broken into multiple tokens;</p></li>
<li><p>CSLT_PRESERVEQUOTES: string quotes are carried into the tokens when this is set, otherwise they are removed;</p></li>
<li><p>CSLT_PRESERVEESCAPES: if set backslash escapes (for backslash itself, and for literal double quotes) will be preserved in the tokens, otherwise the backslashes will be removed in processing.</p></li>
</ul>
</p>
<p><strong>Example:</strong> </p>
<p>Parse a string into tokens based on various white space (space, newline, tab) and then print out results and cleanup. Quotes may be used to hold white space in tokens.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="o">**</span><span class="n">papszTokens</span> <span class="o">=</span>
    <span class="n">CSLTokenizeString2</span><span class="p">(</span> <span class="n">pszCommand</span><span class="p">,</span> <span class="s2">&quot; </span><span class="se">\t\n</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">CSLT_HONOURSTRINGS</span> <span class="o">|</span> <span class="n">CSLT_ALLOWEMPTYTOKENS</span> <span class="p">);</span>

<span class="k">for</span><span class="p">(</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">papszTokens</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">papszTokens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s2">&quot;arg </span><span class="si">%d</span><span class="s2">: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="n">papszTokens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>  <span class="o">//</span> <span class="n">ok</span>

<span class="n">CSLDestroy</span><span class="p">(</span> <span class="n">papszTokens</span> <span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a string list of tokens owned by the caller. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszString</span></code>: the string to be split into tokens. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDelimiters</span></code>: one or more characters to be used as token delimiters. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCSLTFlags</span></code>: an ORing of one or more of the CSLT_ flag values.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48CSLPrint12CSLConstListP4FILE">
<span id="_CPPv38CSLPrint12CSLConstListP4FILE"></span><span id="_CPPv28CSLPrint12CSLConstListP4FILE"></span><span id="CSLPrint__CSLConstList.FILEP"></span><span class="target" id="cpl__string_8h_1a3baf50b494941fe28c65b4d43d2ce36f"></span>int <code class="descname">CSLPrint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, FILE *<em>fpOut</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CSLPrint12CSLConstListP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print a StringList to fpOut. </p>
<p>If fpOut==NULL, then output is sent to stdout.</p>
<p>Returns the number of lines printed. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv47CSLLoadPKc">
<span id="_CPPv37CSLLoadPKc"></span><span id="_CPPv27CSLLoadPKc"></span><span id="CSLLoad__cCP"></span><span class="target" id="cpl__string_8h_1a560db09ab00ff8e68ae3d9dba7f19643"></span>char **<code class="descname">CSLLoad</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFname</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47CSLLoadPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Load a text file into a string list. </p>
<p>The VSI*L API is used, so <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a> supported objects that aren’t physical files can also be accessed. Files are returned as a string list, with one item in the string list per line. End of line markers are stripped (by <a class="reference internal" href="#cpl__conv_8h_1af049d0b413b82ac770d33cc76f525825"><span class="std std-ref">CPLReadLineL()</span></a>).</p>
<p>If reading the file fails a <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> will be issued and NULL returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a string list with the files lines, now owned by caller. To be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFname</span></code>: the name of the file to read.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48CSLLoad2PKcii12CSLConstList">
<span id="_CPPv38CSLLoad2PKcii12CSLConstList"></span><span id="_CPPv28CSLLoad2PKcii12CSLConstList"></span><span id="CSLLoad2__cCP.i.i.CSLConstList"></span><span class="target" id="cpl__string_8h_1ad9f9fbb9d070f63dc03d43d8a7a95ef4"></span>char **<code class="descname">CSLLoad2</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFname</em>, int <em>nMaxLines</em>, int <em>nMaxCols</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48CSLLoad2PKcii12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Load a text file into a string list. </p>
<p>The VSI*L API is used, so <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a> supported objects that aren’t physical files can also be accessed. Files are returned as a string list, with one item in the string list per line. End of line markers are stripped (by <a class="reference internal" href="#cpl__conv_8h_1af049d0b413b82ac770d33cc76f525825"><span class="std std-ref">CPLReadLineL()</span></a>).</p>
<p>If reading the file fails a <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> will be issued and NULL returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a string list with the files lines, now owned by caller. To be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.7.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFname</span></code>: the name of the file to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLines</span></code>: maximum number of lines to read before stopping, or -1 for no limit. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxCols</span></code>: maximum number of characters in a line before stopping, or -1 for no limit. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL-terminated array of options. Unused for now.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv47CSLSave12CSLConstListPKc">
<span id="_CPPv37CSLSave12CSLConstListPKc"></span><span id="_CPPv27CSLSave12CSLConstListPKc"></span><span id="CSLSave__CSLConstList.cCP"></span><span class="target" id="cpl__string_8h_1a75750c97bdcf1ccf13ffaae6a30a07a6"></span>int <code class="descname">CSLSave</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, <em class="property">const</em> char *<em>pszFname</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47CSLSave12CSLConstListPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a StringList to a text file. </p>
<p>Returns the number of lines written, or 0 if the file could not be written. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CSLInsertStringsPPci12CSLConstList">
<span id="_CPPv316CSLInsertStringsPPci12CSLConstList"></span><span id="_CPPv216CSLInsertStringsPPci12CSLConstList"></span><span id="CSLInsertStrings__cPP.i.CSLConstList"></span><span class="target" id="cpl__string_8h_1a82db6e95a6cb17d00bf9336c4716573d"></span>char **<code class="descname">CSLInsertStrings</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, int <em>nInsertAtLineNo</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszNewLines</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CSLInsertStringsPPci12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the contents of a StringList inside another StringList before the specified line. </p>
<p>nInsertAtLineNo is a 0-based line index before which the new strings should be inserted. If this value is -1 or is larger than the actual number of strings in the list then the strings are added at the end of the source StringList.</p>
<p>Returns the modified StringList. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CSLInsertStringPPciPKc">
<span id="_CPPv315CSLInsertStringPPciPKc"></span><span id="_CPPv215CSLInsertStringPPciPKc"></span><span id="CSLInsertString__cPP.i.cCP"></span><span class="target" id="cpl__string_8h_1ad37de0106feb1ed8b6662861ce62920a"></span>char **<code class="descname">CSLInsertString</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, int <em>nInsertAtLineNo</em>, <em class="property">const</em> char *<em>pszNewLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CSLInsertStringPPciPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert a string at a given line number inside a StringList. </p>
<p>nInsertAtLineNo is a 0-based line index before which the new string should be inserted. If this value is -1 or is larger than the actual number of strings in the list then the string is added at the end of the source StringList.</p>
<p>Returns the modified StringList. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CSLRemoveStringsPPciiPPPc">
<span id="_CPPv316CSLRemoveStringsPPciiPPPc"></span><span id="_CPPv216CSLRemoveStringsPPciiPPPc"></span><span id="CSLRemoveStrings__cPP.i.i.cPPP"></span><span class="target" id="cpl__string_8h_1aa2c2f791fe007de3a0417c61eb270f8d"></span>char **<code class="descname">CSLRemoveStrings</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, int <em>nFirstLineToDelete</em>, int <em>nNumToRemove</em>, char ***<em>ppapszRetStrings</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CSLRemoveStringsPPciiPPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove strings inside a StringList. </p>
<p>nFirstLineToDelete is the 0-based line index of the first line to remove. If this value is -1 or is larger than the actual number of strings in list then the nNumToRemove last strings are removed.</p>
<p>If ppapszRetStrings != NULL then the deleted strings won’t be free’d, they will be stored in a new StringList and the pointer to this new list will be returned in *ppapszRetStrings.</p>
<p>Returns the modified StringList. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CSLFindString12CSLConstListPKc">
<span id="_CPPv313CSLFindString12CSLConstListPKc"></span><span id="_CPPv213CSLFindString12CSLConstListPKc"></span><span id="CSLFindString__CSLConstList.cCP"></span><span class="target" id="cpl__string_8h_1a74e2f4bc3bbf2cca1a8bf9954fae5174"></span>int <code class="descname">CSLFindString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszList</em>, <em class="property">const</em> char *<em>pszTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CSLFindString12CSLConstListPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a string within a string list (case insensitive). </p>
<p>Returns the index of the entry in the string list that contains the target string. The string in the string list must be a full match for the target, but the search is case insensitive.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the index of the string within the list or -1 on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszList</span></code>: the string list to be searched. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszTarget</span></code>: the string to be searched for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426CSLFindStringCaseSensitive12CSLConstListPKc">
<span id="_CPPv326CSLFindStringCaseSensitive12CSLConstListPKc"></span><span id="_CPPv226CSLFindStringCaseSensitive12CSLConstListPKc"></span><span id="CSLFindStringCaseSensitive__CSLConstList.cCP"></span><span class="target" id="cpl__string_8h_1a0716feff9a1b9f40e14226c8a7a127c5"></span>int <code class="descname">CSLFindStringCaseSensitive</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszList</em>, <em class="property">const</em> char *<em>pszTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426CSLFindStringCaseSensitive12CSLConstListPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a string within a string list(case sensitive) </p>
<p>Returns the index of the entry in the string list that contains the target string. The string in the string list must be a full match for the target.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the index of the string within the list or -1 on failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszList</span></code>: the string list to be searched. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszTarget</span></code>: the string to be searched for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CSLPartialFindString12CSLConstListPKc">
<span id="_CPPv320CSLPartialFindString12CSLConstListPKc"></span><span id="_CPPv220CSLPartialFindString12CSLConstListPKc"></span><span id="CSLPartialFindString__CSLConstList.cCP"></span><span class="target" id="cpl__string_8h_1a9f36efd8180e51959d075fe759d8c7be"></span>int <code class="descname">CSLPartialFindString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszHaystack</em>, <em class="property">const</em> char *<em>pszNeedle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CSLPartialFindString12CSLConstListPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a substring within a string list. </p>
<p>Returns the index of the entry in the string list that contains the target string as a substring. The search is case sensitive (unlike <a class="reference internal" href="#cpl__string_8h_1a74e2f4bc3bbf2cca1a8bf9954fae5174"><span class="std std-ref">CSLFindString()</span></a>).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the index of the string within the list or -1 on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszHaystack</span></code>: the string list to be searched. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNeedle</span></code>: the substring to be searched for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CSLFindName12CSLConstListPKc">
<span id="_CPPv311CSLFindName12CSLConstListPKc"></span><span id="_CPPv211CSLFindName12CSLConstListPKc"></span><span id="CSLFindName__CSLConstList.cCP"></span><span class="target" id="cpl__string_8h_1a5ba908f3bf572c87dadeade7e8cbc260"></span>int <code class="descname">CSLFindName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CSLFindName12CSLConstListPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find StringList entry with given key name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>-1 on failure or the list index of the first occurrence matching the given key. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszStrList</span></code>: the string list to search. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the key value to look for (case insensitive).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CSLFetchBoolean12CSLConstListPKci">
<span id="_CPPv315CSLFetchBoolean12CSLConstListPKci"></span><span id="_CPPv215CSLFetchBoolean12CSLConstListPKci"></span><span id="CSLFetchBoolean__CSLConstList.cCP.i"></span><span class="target" id="cpl__string_8h_1ac8d4157385a06d3d1cc905fda008cd75"></span>int <code class="descname">CSLFetchBoolean</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, <em class="property">const</em> char *<em>pszKey</em>, int <em>bDefault</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CSLFetchBoolean12CSLConstListPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DEPRECATED. </p>
<p>Check for boolean key value.</p>
<p>In a StringList of “Name=Value” pairs, look to see if there is a key with the given name, and if it can be interpreted as being TRUE. If the key appears without any “=Value” portion it will be considered true. If the value is NO, FALSE or 0 it will be considered FALSE otherwise if the key appears in the list it will be considered TRUE. If the key doesn’t appear at all, the indicated default value will be returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE or FALSE </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszStrList</span></code>: the string list to search. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key value to look for (case insensitive). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDefault</span></code>: the value to return if the key isn’t found at all.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CSLTestBooleanPKc">
<span id="_CPPv314CSLTestBooleanPKc"></span><span id="_CPPv214CSLTestBooleanPKc"></span><span id="CSLTestBoolean__cCP"></span><span class="target" id="cpl__string_8h_1ada798bb0fafd08c7908d0f3716f341b3"></span>int <code class="descname">CSLTestBoolean</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CSLTestBooleanPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test what boolean value contained in the string. </p>
<p>If pszValue is “NO”, “FALSE”, “OFF” or “0” will be returned FALSE. Otherwise, TRUE will be returned.</p>
<p>Deprecated. Removed in GDAL 3.x.</p>
<p>Use <a class="reference internal" href="#cpl__string_8h_1af8206b42cbbc7d96b2c3aaf093a00de1"><span class="std std-ref">CPLTestBoolean()</span></a> for C and <a class="reference internal" href="#cpl__string_8h_1a7e6873dfd5c12d0b24e561ce65b4266d"><span class="std std-ref">CPLTestBool()</span></a> for C++.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE or FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the string should be tested.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLTestBooleanPKc">
<span id="_CPPv314CPLTestBooleanPKc"></span><span id="_CPPv214CPLTestBooleanPKc"></span><span id="CPLTestBoolean__cCP"></span><span class="target" id="cpl__string_8h_1af8206b42cbbc7d96b2c3aaf093a00de1"></span>int <code class="descname">CPLTestBoolean</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLTestBooleanPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test what boolean value contained in the string. </p>
<p>If pszValue is “NO”, “FALSE”, “OFF” or “0” will be returned FALSE. Otherwise, TRUE will be returned.</p>
<p>Use this only in C code. In C++, prefer <a class="reference internal" href="#cpl__string_8h_1a7e6873dfd5c12d0b24e561ce65b4266d"><span class="std std-ref">CPLTestBool()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE or FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the string should be tested.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLTestBoolPKc">
<span id="_CPPv311CPLTestBoolPKc"></span><span id="_CPPv211CPLTestBoolPKc"></span><span id="CPLTestBool__cCP"></span><span class="target" id="cpl__string_8h_1a7e6873dfd5c12d0b24e561ce65b4266d"></span>bool <code class="descname">CPLTestBool</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLTestBoolPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test what boolean value contained in the string. </p>
<p>If pszValue is “NO”, “FALSE”, “OFF” or “0” will be returned false. Otherwise, true will be returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true or false. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the string should be tested.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLFetchBool12CSLConstListPKcb">
<span id="_CPPv312CPLFetchBool12CSLConstListPKcb"></span><span id="_CPPv212CPLFetchBool12CSLConstListPKcb"></span><span id="CPLFetchBool__CSLConstList.cCP.b"></span><span class="target" id="cpl__string_8h_1a5ac8be2978f873873dbb1ad47f8d9319"></span>bool <code class="descname">CPLFetchBool</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, <em class="property">const</em> char *<em>pszKey</em>, bool <em>bDefault</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLFetchBool12CSLConstListPKcb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check for boolean key value. </p>
<p>In a StringList of “Name=Value” pairs, look to see if there is a key with the given name, and if it can be interpreted as being TRUE. If the key appears without any “=Value” portion it will be considered true. If the value is NO, FALSE or 0 it will be considered FALSE otherwise if the key appears in the list it will be considered TRUE. If the key doesn’t appear at all, the indicated default value will be returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true or false </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszStrList</span></code>: the string list to search. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key value to look for (case insensitive). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDefault</span></code>: the value to return if the key isn’t found at all.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLParseNameValuePKcPPc">
<span id="_CPPv317CPLParseNameValuePKcPPc"></span><span id="_CPPv217CPLParseNameValuePKcPPc"></span><span id="CPLParseNameValue__cCP.cPP"></span><span class="target" id="cpl__string_8h_1a40ff577b83aca84a603414183e6903d3"></span><em class="property">const</em> char *<code class="descname">CPLParseNameValue</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszNameValue</em>, char **<em>ppszKey</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLParseNameValuePKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse NAME=VALUE string into name and value components. </p>
<p>Note that if ppszKey is non-NULL, the key (or name) portion will be allocated using <a class="reference internal" href="#cpl__conv_8h_1a9a806de98fbddb1337efdb18651aa0f7"><span class="std std-ref">CPLMalloc()</span></a>, and returned in that pointer. It is the applications responsibility to free this string, but the application should not modify or free the returned value portion.</p>
<p>This function also support “NAME:VALUE” strings and will strip white space from around the delimiter when forming name and value strings.</p>
<p>Eventually <a class="reference internal" href="#cpl__string_8h_1a94ca3f1c515330277c31b06d2a061ccd"><span class="std std-ref">CSLFetchNameValue()</span></a> and friends may be modified to use <a class="reference internal" href="#cpl__string_8h_1a40ff577b83aca84a603414183e6903d3"><span class="std std-ref">CPLParseNameValue()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the value portion (pointing into original string). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszNameValue</span></code>: string in “NAME=VALUE” format. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppszKey</span></code>: optional pointer though which to return the name portion.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CSLFetchNameValue12CSLConstListPKc">
<span id="_CPPv317CSLFetchNameValue12CSLConstListPKc"></span><span id="_CPPv217CSLFetchNameValue12CSLConstListPKc"></span><span id="CSLFetchNameValue__CSLConstList.cCP"></span><span class="target" id="cpl__string_8h_1a94ca3f1c515330277c31b06d2a061ccd"></span><em class="property">const</em> char *<code class="descname">CSLFetchNameValue</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CSLFetchNameValue12CSLConstListPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In a StringList of “Name=Value” pairs, look for the first value associated with the specified name. </p>
<p>The search is not case sensitive. (“Name:Value” pairs are also supported for backward compatibility with older stuff.)</p>
<p>Returns a reference to the value in the StringList that the caller should not attempt to free.</p>
<p>Returns NULL if the name is not found. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CSLFetchNameValueDef12CSLConstListPKcPKc">
<span id="_CPPv320CSLFetchNameValueDef12CSLConstListPKcPKc"></span><span id="_CPPv220CSLFetchNameValueDef12CSLConstListPKcPKc"></span><span id="CSLFetchNameValueDef__CSLConstList.cCP.cCP"></span><span class="target" id="cpl__string_8h_1a73e7b7a38322de06a7b5ee8a90447613"></span><em class="property">const</em> char *<code class="descname">CSLFetchNameValueDef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, <em class="property">const</em> char *<em>pszName</em>, <em class="property">const</em> char *<em>pszDefault</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CSLFetchNameValueDef12CSLConstListPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#cpl__string_8h_1a94ca3f1c515330277c31b06d2a061ccd"><span class="std std-ref">CSLFetchNameValue()</span></a> but return pszDefault in case of no match. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425CSLFetchNameValueMultiple12CSLConstListPKc">
<span id="_CPPv325CSLFetchNameValueMultiple12CSLConstListPKc"></span><span id="_CPPv225CSLFetchNameValueMultiple12CSLConstListPKc"></span><span id="CSLFetchNameValueMultiple__CSLConstList.cCP"></span><span class="target" id="cpl__string_8h_1ac4b9ded921799303618b0ff0b852a37e"></span>char **<code class="descname">CSLFetchNameValueMultiple</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszStrList</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CSLFetchNameValueMultiple12CSLConstListPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In a StringList of “Name=Value” pairs, look for all the values with the specified name. </p>
<p>The search is not case sensitive. (“Name:Value” pairs are also supported for backward compatibility with older stuff.)</p>
<p>Returns StringList with one entry for each occurrence of the specified name. The StringList should eventually be destroyed by calling <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a>.</p>
<p>Returns NULL if the name is not found. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CSLAddNameValuePPcPKcPKc">
<span id="_CPPv315CSLAddNameValuePPcPKcPKc"></span><span id="_CPPv215CSLAddNameValuePPcPKcPKc"></span><span id="CSLAddNameValue__cPP.cCP.cCP"></span><span class="target" id="cpl__string_8h_1a140315b0903d52c438c143894f0d9847"></span>char **<code class="descname">CSLAddNameValue</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, <em class="property">const</em> char *<em>pszName</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CSLAddNameValuePPcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a new entry to a StringList of “Name=Value” pairs, (“Name:Value” pairs are also supported for backward compatibility with older stuff.) </p>
<p>This function does not check if a “Name=Value” pair already exists for that name and can generate multiple entries for the same name. Use <a class="reference internal" href="#cpl__string_8h_1aa1a048471042e6fcf4e01faf11774867"><span class="std std-ref">CSLSetNameValue()</span></a> if you want each name to have only one value.</p>
<p>Returns the modified StringList. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CSLSetNameValuePPcPKcPKc">
<span id="_CPPv315CSLSetNameValuePPcPKcPKc"></span><span id="_CPPv215CSLSetNameValuePPcPKcPKc"></span><span id="CSLSetNameValue__cPP.cCP.cCP"></span><span class="target" id="cpl__string_8h_1aa1a048471042e6fcf4e01faf11774867"></span>char **<code class="descname">CSLSetNameValue</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, <em class="property">const</em> char *<em>pszName</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CSLSetNameValuePPcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign value to name in StringList. </p>
<p>Set the value for a given name in a StringList of “Name=Value” pairs (“Name:Value” pairs are also supported for backward compatibility with older stuff.)</p>
<p>If there is already a value for that name in the list then the value is changed, otherwise a new “Name=Value” pair is added.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>modified StringList. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszList</span></code>: the original list, the modified version is returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name to be assigned a value. This should be a well formed token (no spaces or very special characters). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the value to assign to the name. This should not contain any newlines (CR or LF) but is otherwise pretty much unconstrained. If NULL any corresponding value will be removed.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424CSLSetNameValueSeparatorPPcPKc">
<span id="_CPPv324CSLSetNameValueSeparatorPPcPKc"></span><span id="_CPPv224CSLSetNameValueSeparatorPPcPKc"></span><span id="CSLSetNameValueSeparator__cPP.cCP"></span><span class="target" id="cpl__string_8h_1a97b38f55a35f3c1d66ba343692ab9ec0"></span>void <code class="descname">CSLSetNameValueSeparator</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, <em class="property">const</em> char *<em>pszSeparator</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424CSLSetNameValueSeparatorPPcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace the default separator (“:” or “=”) with the passed separator in the given name/value list. </p>
<p>Note that if a separator other than “:” or “=” is used, the resulting list will not be manipulable by the CSL name/value functions any more.</p>
<p>The <a class="reference internal" href="#cpl__string_8h_1a40ff577b83aca84a603414183e6903d3"><span class="std std-ref">CPLParseNameValue()</span></a> function is used to break the existing lines, and it also strips white space from around the existing delimiter, thus the old separator, and any white space will be replaced by the new separator. For formatting purposes it may be desirable to include some white space in the new separator. e.g. “: ” or ” = “.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszList</span></code>: the list to update. Component strings may be freed but the list array will remain at the same location.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSeparator</span></code>: the new separator string to insert. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CSLParseCommandLinePKc">
<span id="_CPPv319CSLParseCommandLinePKc"></span><span id="_CPPv219CSLParseCommandLinePKc"></span><span id="CSLParseCommandLine__cCP"></span><span class="target" id="cpl__string_8h_1a9b5b56fffa0e83d08d3f9bb176c2be03"></span>char **<code class="descname">CSLParseCommandLine</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszCommandLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CSLParseCommandLinePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tokenize command line arguments in a list of strings. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL terminated list of strings to free with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszCommandLine</span></code>: command line</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLEscapeStringPKcii">
<span id="_CPPv315CPLEscapeStringPKcii"></span><span id="_CPPv215CPLEscapeStringPKcii"></span><span id="CPLEscapeString__cCP.i.i"></span><span class="target" id="cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"></span>char *<code class="descname">CPLEscapeString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int <em>nLength</em>, int <em>nScheme</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLEscapeStringPKcii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply escaping to string to preserve special characters. </p>
<p>This function will “escape” a variety of special characters to make the string suitable to embed within a string constant or to write within a text stream but in a form that can be reconstituted to its original form. The escaping will even preserve zero bytes allowing preservation of raw binary data.</p>
<p><a class="reference internal" href="#cpl__string_8h_1a4d69daceff916c28ef0c65506d89d6d3"><span class="std std-ref">CPLES_BackslashQuotable(0)</span></a>: This scheme turns a binary string into a form suitable to be placed within double quotes as a string constant. The backslash, quote, ‘\0’ and newline characters are all escaped in the usual C style.</p>
<p><a class="reference internal" href="#cpl__string_8h_1a7f5479acb68fb882fed8bada7b92db15"><span class="std std-ref">CPLES_XML(1)</span></a>: This scheme converts the ‘&lt;’, ‘&gt;’, ‘”’ and ‘&amp;’ characters into their XML/HTML equivalent (&lt;, &gt;, ” and &amp;) making a string safe to embed as CDATA within an XML element. The ‘\0’ is not escaped and should not be included in the input.</p>
<p><a class="reference internal" href="#cpl__string_8h_1a88296f14572ad5a724fb512357fddb03"><span class="std std-ref">CPLES_URL(2)</span></a>: Everything except alphanumerics and the characters ‘$’, ‘-‘, ‘_’, ‘.’, ‘+’, ‘!’, ‘*’, ‘’‘, ‘(‘, ‘)’ and ‘,’ (see RFC1738) are converted to a percent followed by a two digit hex encoding of the character (leading zero supplied if needed). This is the mechanism used for encoding values to be passed in URLs.</p>
<p><a class="reference internal" href="#cpl__string_8h_1a90614c3cf4cdd748e063f9c2cf669246"><span class="std std-ref">CPLES_SQL(3)</span></a>: All single quotes are replaced with two single quotes. Suitable for use when constructing literal values for SQL commands where the literal will be enclosed in single quotes.</p>
<p><a class="reference internal" href="#cpl__string_8h_1aa3347d20cc965ec42e25bc285a763ea9"><span class="std std-ref">CPLES_CSV(4)</span></a>: If the values contains commas, semicolons, tabs, double quotes, or newlines it placed in double quotes, and double quotes in the value are doubled. Suitable for use when constructing field values for .csv files. Note that <a class="reference internal" href="#cpl__string_8h_1a7c195cd00775e84f59a05b8f418638bb"><span class="std std-ref">CPLUnescapeString()</span></a> currently does not support this format, only <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>. See cpl_csv.cpp for CSV parsing support.</p>
<p><a class="reference internal" href="#cpl__string_8h_1a97b06de69ccbf6c0f6127a8f033fd056"><span class="std std-ref">CPLES_SQLI(7)</span></a>: All double quotes are replaced with two double quotes. Suitable for use when constructing identifiers for SQL commands where the literal will be enclosed in double quotes.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an escaped, zero terminated string that should be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer needed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszInput</span></code>: the string to escape. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLength</span></code>: The number of bytes of data to preserve. If this is -1 the strlen(pszString) function will be used to compute the length. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nScheme</span></code>: the encoding scheme to use.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLUnescapeStringPKcPii">
<span id="_CPPv317CPLUnescapeStringPKcPii"></span><span id="_CPPv217CPLUnescapeStringPKcPii"></span><span id="CPLUnescapeString__cCP.iP.i"></span><span class="target" id="cpl__string_8h_1a7c195cd00775e84f59a05b8f418638bb"></span>char *<code class="descname">CPLUnescapeString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em>, int *<em>pnLength</em>, int <em>nScheme</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLUnescapeStringPKcPii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unescape a string. </p>
<p>This function does the opposite of <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a>. Given a string with special values escaped according to some scheme, it will return a new copy of the string returned to its original form.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a copy of the unescaped string that should be freed by the application using <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer needed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszInput</span></code>: the input string. This is a zero terminated string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnLength</span></code>: location to return the length of the unescaped string, which may in some cases include embedded ‘\0’ characters. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nScheme</span></code>: the escaped scheme to undo (see <a class="reference internal" href="#cpl__string_8h_1a16aea67513d2c1e2616c5fbb0971514f"><span class="std std-ref">CPLEscapeString()</span></a> for a list). Does not yet support CSV.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLBinaryToHexiPK5GByte">
<span id="_CPPv314CPLBinaryToHexiPK5GByte"></span><span id="_CPPv214CPLBinaryToHexiPK5GByte"></span><span id="CPLBinaryToHex__i.GByteCP"></span><span class="target" id="cpl__string_8h_1a96f749fe885982c5d0817404aa55c6bb"></span>char *<code class="descname">CPLBinaryToHex</code><span class="sig-paren">(</span>int <em>nBytes</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<em>pabyData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLBinaryToHexiPK5GByte" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Binary to hexadecimal translation. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>hexadecimal translation, zero terminated. Free with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nBytes</span></code>: number of bytes of binary data in pabyData. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyData</span></code>: array of data bytes to translate.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLHexToBinaryPKcPi">
<span id="_CPPv314CPLHexToBinaryPKcPi"></span><span id="_CPPv214CPLHexToBinaryPKcPi"></span><span id="CPLHexToBinary__cCP.iP"></span><span class="target" id="cpl__string_8h_1aacebe6c728f39757db5f7251dfcca0ba"></span><a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<code class="descname">CPLHexToBinary</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszHex</em>, int *<em>pnBytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLHexToBinaryPKcPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Hexadecimal to binary translation. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>returns binary buffer of data - free with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszHex</span></code>: the input hex encoded string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnBytes</span></code>: the returned count of decoded bytes placed here.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLBase64EncodeiPK5GByte">
<span id="_CPPv315CPLBase64EncodeiPK5GByte"></span><span id="_CPPv215CPLBase64EncodeiPK5GByte"></span><span id="CPLBase64Encode__i.GByteCP"></span><span class="target" id="cpl__string_8h_1ab34ab4c4f9306f5b710a22fb6ff599b1"></span>char *<code class="descname">CPLBase64Encode</code><span class="sig-paren">(</span>int <em>nBytes</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<em>pabyData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLBase64EncodeiPK5GByte" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base64 encode a buffer. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLBase64DecodeInPlaceP5GByte">
<span id="_CPPv322CPLBase64DecodeInPlaceP5GByte"></span><span id="_CPPv222CPLBase64DecodeInPlaceP5GByte"></span><span id="CPLBase64DecodeInPlace__GByteP"></span><span class="target" id="cpl__string_8h_1aad53388b3ad1c906a11663e7c5564d17"></span>int <code class="descname">CPLBase64DecodeInPlace</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<em>pszBase64</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLBase64DecodeInPlaceP5GByte" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decode base64 string “pszBase64” (null terminated) in place. </p>
<p>Returns length of decoded array or 0 on failure. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLGetValueTypePKc">
<span id="_CPPv315CPLGetValueTypePKc"></span><span id="_CPPv215CPLGetValueTypePKc"></span><span id="CPLGetValueType__cCP"></span><span class="target" id="cpl__string_8h_1aafb0188f43b0848407f5e6e7c3cfdbb8"></span><a class="reference internal" href="#_CPPv412CPLValueType" title="CPLValueType">CPLValueType</a> <code class="descname">CPLGetValueType</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLGetValueTypePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Detect the type of the value contained in a string, whether it is a real, an integer or a string Leading and trailing spaces are skipped in the analysis. </p>
<p>Note: in the context of this function, integer must be understood in a broad sense. It does not mean that the value can fit into a 32 bit integer for example. It might be larger.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>returns the type of the value contained in the string. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the string to analyze</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLStrlcpyPcPKc6size_t">
<span id="_CPPv310CPLStrlcpyPcPKc6size_t"></span><span id="_CPPv210CPLStrlcpyPcPKc6size_t"></span><span id="CPLStrlcpy__cP.cCP.s"></span><span class="target" id="cpl__string_8h_1a4dee6db43b3ce18912ee45fbfc83e747"></span>size_t <code class="descname">CPLStrlcpy</code><span class="sig-paren">(</span>char *<em>pszDest</em>, <em class="property">const</em> char *<em>pszSrc</em>, size_t <em>nDestSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLStrlcpyPcPKc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy source string to a destination buffer. </p>
<p>This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1).</p>
<p>This function is designed to be a safer, more consistent, and less error prone replacement for strncpy. Its contract is identical to libbsd’s strlcpy.</p>
<p>Truncation can be detected by testing if the return value of CPLStrlcpy is greater or equal to nDestSize.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="n">szDest</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
<span class="k">if</span><span class="p">(</span> <span class="n">CPLStrlcpy</span><span class="p">(</span><span class="n">szDest</span><span class="p">,</span> <span class="s2">&quot;abcde&quot;</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">szDest</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">szDest</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;truncation occurred !</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the length of the source string (=strlen(pszSrc))</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.7.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDest</span></code>: destination buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrc</span></code>: source string. Must be NUL terminated </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nDestSize</span></code>: size of destination buffer (including space for the NUL terminator character)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLStrlcatPcPKc6size_t">
<span id="_CPPv310CPLStrlcatPcPKc6size_t"></span><span id="_CPPv210CPLStrlcatPcPKc6size_t"></span><span id="CPLStrlcat__cP.cCP.s"></span><span class="target" id="cpl__string_8h_1a35417428994b5306ca08df7899f9703c"></span>size_t <code class="descname">CPLStrlcat</code><span class="sig-paren">(</span>char *<em>pszDest</em>, <em class="property">const</em> char *<em>pszSrc</em>, size_t <em>nDestSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLStrlcatPcPKc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Appends a source string to a destination buffer. </p>
<p>This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1 and that there is at least one byte free in pszDest, that is to say strlen(pszDest_before) &lt; nDestSize)</p>
<p>This function is designed to be a safer, more consistent, and less error prone replacement for strncat. Its contract is identical to libbsd’s strlcat.</p>
<p>Truncation can be detected by testing if the return value of CPLStrlcat is greater or equal to nDestSize.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="n">szDest</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">CPLStrlcpy</span><span class="p">(</span><span class="n">szDest</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">szDest</span><span class="p">));</span>
<span class="k">if</span><span class="p">(</span> <span class="n">CPLStrlcat</span><span class="p">(</span><span class="n">szDest</span><span class="p">,</span> <span class="s2">&quot;cde&quot;</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">szDest</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">szDest</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;truncation occurred !</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the theoretical length of the destination string after concatenation (=strlen(pszDest_before) + strlen(pszSrc)). If strlen(pszDest_before) &gt;= nDestSize, then it returns nDestSize + strlen(pszSrc)</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.7.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDest</span></code>: destination buffer. Must be NUL terminated before running CPLStrlcat </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrc</span></code>: source string. Must be NUL terminated </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nDestSize</span></code>: size of destination buffer (including space for the NUL terminator character)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLStrnlenPKc6size_t">
<span id="_CPPv310CPLStrnlenPKc6size_t"></span><span id="_CPPv210CPLStrnlenPKc6size_t"></span><span id="CPLStrnlen__cCP.s"></span><span class="target" id="cpl__string_8h_1a8d45dc0510e8e8f4e58f3cb70e341732"></span>size_t <code class="descname">CPLStrnlen</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszStr</em>, size_t <em>nMaxLen</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLStrnlenPKc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the length of a NUL terminated string by reading at most the specified number of bytes. </p>
<p>The <a class="reference internal" href="#cpl__string_8h_1a8d45dc0510e8e8f4e58f3cb70e341732"><span class="std std-ref">CPLStrnlen()</span></a> function returns min(strlen(pszStr), nMaxLen). Only the first nMaxLen bytes of the string will be read. Useful to test if a string contains at least nMaxLen characters without reading the full string up to the NUL terminating character.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>strlen(pszStr) if the length is lesser than nMaxLen, otherwise nMaxLen if the NUL character has not been found in the first nMaxLen bytes.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.7.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszStr</span></code>: a NUL terminated string </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxLen</span></code>: maximum number of bytes to read in pszStr</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLvsnprintfPc6size_tPKc7va_list">
<span id="_CPPv312CPLvsnprintfPc6size_tPKc7va_list"></span><span id="_CPPv212CPLvsnprintfPc6size_tPKc7va_list"></span><span id="CPLvsnprintf__cP.s.cCP.va_list"></span><span class="target" id="cpl__string_8h_1a07bbf9c41f4ae994e2bd4e1466d4ed0b"></span>int <code class="descname">CPLvsnprintf</code><span class="sig-paren">(</span>char *<em>str</em>, size_t <em>size</em>, <em class="property">const</em> char *<em>fmt</em>, va_list <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLvsnprintfPc6size_tPKc7va_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>vsnprintf() wrapper that is not sensitive to LC_NUMERIC settings. </p>
<p>This function has the same contract as standard vsnprintf(), except that formatting of floating-point numbers will use decimal point, whatever the current locale is set.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of characters (excluding terminating nul) that would be written if size is big enough. Or potentially -1 with Microsoft C runtime for Visual Studio &lt; 2015. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: output buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of the output buffer (including space for terminating nul) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fmt</span></code>: formatting string </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code>: arguments </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLsnprintfPc6size_tPKcz">
<span id="_CPPv311CPLsnprintfPc6size_tPKcz"></span><span id="_CPPv211CPLsnprintfPc6size_tPKcz"></span><span id="CPLsnprintf__cP.s.cCP.z"></span><span class="target" id="cpl__string_8h_1a52bc998139a3664bb33f03848e1cf08a"></span>int <code class="descname">CPLsnprintf</code><span class="sig-paren">(</span>char *<em>str</em>, size_t <em>size</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLsnprintfPc6size_tPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>snprintf() wrapper that is not sensitive to LC_NUMERIC settings. </p>
<p>This function has the same contract as standard snprintf(), except that formatting of floating-point numbers will use decimal point, whatever the current locale is set.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of characters (excluding terminating nul) that would be written if size is big enough. Or potentially -1 with Microsoft C runtime for Visual Studio &lt; 2015. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: output buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of the output buffer (including space for terminating nul) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fmt</span></code>: formatting string </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">...</span></code>: arguments </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLprintfPKcz">
<span id="_CPPv39CPLprintfPKcz"></span><span id="_CPPv29CPLprintfPKcz"></span><span id="CPLprintf__cCP.z"></span><span class="target" id="cpl__string_8h_1a125dbe90534c2688426bb518b81d262e"></span>int <code class="descname">CPLprintf</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLprintfPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>printf() wrapper that is not sensitive to LC_NUMERIC settings. </p>
<p>This function has the same contract as standard printf(), except that formatting of floating-point numbers will use decimal point, whatever the current locale is set.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of characters (excluding terminating nul) written in output buffer. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fmt</span></code>: formatting string </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">...</span></code>: arguments </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLSPrintfPKcz">
<span id="_CPPv310CPLSPrintfPKcz"></span><span id="_CPPv210CPLSPrintfPKcz"></span><span id="CPLSPrintf__cCP.z"></span><span class="target" id="cpl__string_8h_1a56df213d324883008cd2d0f6349d2386"></span><em class="property">const</em> char *<code class="descname">CPLSPrintf</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLSPrintfPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#cpl__string_8h_1a56df213d324883008cd2d0f6349d2386"><span class="std std-ref">CPLSPrintf()</span></a> that works with 10 static buffer. </p>
<p>It returns a ref. to a static buffer that should not be freed and is valid only until the next call to <a class="reference internal" href="#cpl__string_8h_1a56df213d324883008cd2d0f6349d2386"><span class="std std-ref">CPLSPrintf()</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CSLAppendPrintfPPcPKcz">
<span id="_CPPv315CSLAppendPrintfPPcPKcz"></span><span id="_CPPv215CSLAppendPrintfPPcPKcz"></span><span id="CSLAppendPrintf__cPP.cCP.z"></span><span class="target" id="cpl__string_8h_1ac5ddbde1bb0dde4b334aac5d64bd3fa9"></span>char **<code class="descname">CSLAppendPrintf</code><span class="sig-paren">(</span>char **<em>papszStrList</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CSLAppendPrintfPPcPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Use <a class="reference internal" href="#cpl__string_8h_1a56df213d324883008cd2d0f6349d2386"><span class="std std-ref">CPLSPrintf()</span></a> to append a new line at the end of a StringList. </p>
<p>Returns the modified StringList. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLVASPrintfPPcPKc7va_list">
<span id="_CPPv312CPLVASPrintfPPcPKc7va_list"></span><span id="_CPPv212CPLVASPrintfPPcPKc7va_list"></span><span id="CPLVASPrintf__cPP.cCP.va_list"></span><span class="target" id="cpl__string_8h_1a6394d3ee8e57452cd7d4207b031e75bd"></span>int <code class="descname">CPLVASPrintf</code><span class="sig-paren">(</span>char **<em>buf</em>, <em class="property">const</em> char *<em>fmt</em>, va_list <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLVASPrintfPPcPKc7va_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This is intended to serve as an easy to use C callable vasprintf() alternative. </p>
<p>Used in the GeoJSON library for instance </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CPLEncodingCharSizePKc">
<span id="_CPPv319CPLEncodingCharSizePKc"></span><span id="_CPPv219CPLEncodingCharSizePKc"></span><span id="CPLEncodingCharSize__cCP"></span><span class="target" id="cpl__string_8h_1aed4d78cf4a6db43d07129a89af6fd45d"></span>int <code class="descname">CPLEncodingCharSize</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszEncoding</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLEncodingCharSizePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return bytes per character for encoding. </p>
<p>This function returns the size in bytes of the smallest character in this encoding. For fixed width encodings (ASCII, UCS-2, UCS-4) this is straight forward. For encodings like UTF8 and UTF16 which represent some characters as a sequence of atomic character sizes the function still returns the atomic character size (1 for UTF8, 2 for UTF16).</p>
<p>This function will return the correct value for well known encodings with corresponding CPL_ENC_ values. It may not return the correct value for other encodings even if they are supported by the underlying iconv or windows transliteration services. Hopefully it will improve over time.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the size of a minimal character in bytes or -1 if the size is unknown. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszEncoding</span></code>: the name of the encoding.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLRecodePKcPKcPKc">
<span id="_CPPv39CPLRecodePKcPKcPKc"></span><span id="_CPPv29CPLRecodePKcPKcPKc"></span><span id="CPLRecode__cCP.cCP.cCP"></span><span class="target" id="cpl__string_8h_1a119556ed36daa850a9c9b1bb14dbb1ad"></span>char *<code class="descname">CPLRecode</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszSource</em>, <em class="property">const</em> char *<em>pszSrcEncoding</em>, <em class="property">const</em> char *<em>pszDstEncoding</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLRecodePKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a string from a source encoding to a destination encoding. </p>
<p>The only guaranteed supported encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8859_1. Currently, the following conversions are supported : <ul class="simple">
<li><p>CPL_ENC_ASCII -&gt; CPL_ENC_UTF8 or CPL_ENC_ISO8859_1 (no conversion in fact) </p></li>
<li><p>CPL_ENC_ISO8859_1 -&gt; CPL_ENC_UTF8 </p></li>
<li><p>CPL_ENC_UTF8 -&gt; CPL_ENC_ISO8859_1 </p></li>
</ul>
</p>
<p>If an error occurs an error may, or may not be posted with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a NULL terminated string which should be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.6.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszSource</span></code>: a NULL terminated string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrcEncoding</span></code>: the source encoding. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstEncoding</span></code>: the destination encoding.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418CPLRecodeFromWCharPKwPKcPKc">
<span id="_CPPv318CPLRecodeFromWCharPKwPKcPKc"></span><span id="_CPPv218CPLRecodeFromWCharPKwPKcPKc"></span><span id="CPLRecodeFromWChar__wchar_tCP.cCP.cCP"></span><span class="target" id="cpl__string_8h_1a15eb417d3e51b8cee98e1b8061b92d07"></span>char *<code class="descname">CPLRecodeFromWChar</code><span class="sig-paren">(</span><em class="property">const</em> wchar_t *<em>pwszSource</em>, <em class="property">const</em> char *<em>pszSrcEncoding</em>, <em class="property">const</em> char *<em>pszDstEncoding</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418CPLRecodeFromWCharPKwPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert wchar_t string to UTF-8. </p>
<p>Convert a wchar_t string into a multibyte utf-8 string. The only guaranteed supported source encoding is CPL_ENC_UCS2, and the only guaranteed supported destination encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8859_1. In some cases (i.e. using iconv()) other encodings may also be supported.</p>
<p>Note that the wchar_t type varies in size on different systems. On win32 it is normally 2 bytes, and on UNIX 4 bytes.</p>
<p>If an error occurs an error may, or may not be posted with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a zero terminated multi-byte string which should be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>, or NULL if an error occurs.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.6.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pwszSource</span></code>: the source wchar_t string, terminated with a 0 wchar_t. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrcEncoding</span></code>: the source encoding, typically CPL_ENC_UCS2. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstEncoding</span></code>: the destination encoding, typically CPL_ENC_UTF8.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLRecodeToWCharPKcPKcPKc">
<span id="_CPPv316CPLRecodeToWCharPKcPKcPKc"></span><span id="_CPPv216CPLRecodeToWCharPKcPKcPKc"></span><span id="CPLRecodeToWChar__cCP.cCP.cCP"></span><span class="target" id="cpl__string_8h_1a09ee81edb69d5445fd1e234aaca0dc45"></span>wchar_t *<code class="descname">CPLRecodeToWChar</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszSource</em>, <em class="property">const</em> char *<em>pszSrcEncoding</em>, <em class="property">const</em> char *<em>pszDstEncoding</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLRecodeToWCharPKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert UTF-8 string to a wchar_t string. </p>
<p>Convert a 8bit, multi-byte per character input string into a wide character (wchar_t) string. The only guaranteed supported source encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8869_1 (LATIN1). The only guaranteed supported destination encoding is CPL_ENC_UCS2. Other source and destination encodings may be supported depending on the underlying implementation.</p>
<p>Note that the wchar_t type varies in size on different systems. On win32 it is normally 2 bytes, and on UNIX 4 bytes.</p>
<p>If an error occurs an error may, or may not be posted with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the zero terminated wchar_t string (to be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>) or NULL on error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.6.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszSource</span></code>: input multi-byte character string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrcEncoding</span></code>: source encoding, typically CPL_ENC_UTF8. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstEncoding</span></code>: destination encoding, typically CPL_ENC_UCS2.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49CPLIsUTF8PKci">
<span id="_CPPv39CPLIsUTF8PKci"></span><span id="_CPPv29CPLIsUTF8PKci"></span><span id="CPLIsUTF8__cCP.i"></span><span class="target" id="cpl__string_8h_1a9b56be2f17e4c2300af2f0357d32baec"></span>int <code class="descname">CPLIsUTF8</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pabyData</em>, int <em>nLen</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49CPLIsUTF8PKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if a string is encoded as UTF-8. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the string is encoded as UTF-8. FALSE otherwise</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.7.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pabyData</span></code>: input string to test </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLen</span></code>: length of the input string, or -1 if the function must compute the string length. In which case it must be null terminated. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415CPLForceToASCIIPKcic">
<span id="_CPPv315CPLForceToASCIIPKcic"></span><span id="_CPPv215CPLForceToASCIIPKcic"></span><span id="CPLForceToASCII__cCP.i.c"></span><span class="target" id="cpl__string_8h_1a68dc66882ea4ff82cebf2ae0433e9ae3"></span>char *<code class="descname">CPLForceToASCII</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pabyData</em>, int <em>nLen</em>, char <em>chReplacementChar</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415CPLForceToASCIIPKcic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a new string that is made only of ASCII characters. </p>
<p>If non-ASCII characters are found in the input string, they will be replaced by the provided replacement character.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new string that must be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.7.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pabyData</span></code>: input string to test </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLen</span></code>: length of the input string, or -1 if the function must compute the string length. In which case it must be null terminated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chReplacementChar</span></code>: character which will be used when the input stream contains a non ASCII character. Must be valid ASCII!</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413CPLStrlenUTF8PKc">
<span id="_CPPv313CPLStrlenUTF8PKc"></span><span id="_CPPv213CPLStrlenUTF8PKc"></span><span id="CPLStrlenUTF8__cCP"></span><span class="target" id="cpl__string_8h_1acc8e4b09f4437d7ef0cc09b5e3ab93cb"></span>int <code class="descname">CPLStrlenUTF8</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszUTF8Str</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413CPLStrlenUTF8PKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of UTF-8 characters of a nul-terminated string. </p>
<p>This is different from strlen() which returns the number of bytes.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of UTF-8 characters. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszUTF8Str</span></code>: a nul-terminated UTF-8 string</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLCanRecodePKcPKcPKc">
<span id="_CPPv312CPLCanRecodePKcPKcPKc"></span><span id="_CPPv212CPLCanRecodePKcPKcPKc"></span><span id="CPLCanRecode__cCP.cCP.cCP"></span><span class="target" id="cpl__string_8h_1aa4459bb51a376d28b659a34a200b2880"></span>int <code class="descname">CPLCanRecode</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszTestStr</em>, <em class="property">const</em> char *<em>pszSrcEncoding</em>, <em class="property">const</em> char *<em>pszDstEncoding</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLCanRecodePKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if it is possible to recode a string from one encoding to another. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a TRUE if recode is possible.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszTestStr</span></code>: a NULL terminated string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrcEncoding</span></code>: the source encoding. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstEncoding</span></code>: the destination encoding.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410CPLOPrintfPKcz">
<span id="_CPPv310CPLOPrintfPKcz"></span><span id="_CPPv210CPLOPrintfPKcz"></span><span id="CPLOPrintf__cCP.z"></span><span class="target" id="cpl__string_8h_1a2e4abb2f061361ee535ec483a5342469"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">CPLOPrintf</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFormat</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410CPLOPrintfPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classCPLString"><span class="std std-ref">CPLString</span></a> with the content of sprintf() </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411CPLOvPrintfPKc7va_list">
<span id="_CPPv311CPLOvPrintfPKc7va_list"></span><span id="_CPPv211CPLOvPrintfPKc7va_list"></span><span id="CPLOvPrintf__cCP.va_list"></span><span class="target" id="cpl__string_8h_1ad2f34d382627c37ce414188e679389a8"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">CPLOvPrintf</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFormat</em>, va_list <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411CPLOvPrintfPKc7va_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classCPLString"><span class="std std-ref">CPLString</span></a> with the content of vsprintf() </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLQuotedSQLIdentifierPKc">
<span id="_CPPv322CPLQuotedSQLIdentifierPKc"></span><span id="_CPPv222CPLQuotedSQLIdentifierPKc"></span><span id="CPLQuotedSQLIdentifier__cCP"></span><span class="target" id="cpl__string_8h_1a2e3e2a3a5717d890a1f5e4fb7f089dc7"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">CPLQuotedSQLIdentifier</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszIdent</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLQuotedSQLIdentifierPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classCPLString"><span class="std std-ref">CPLString</span></a> of the SQL quoted identifier. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414CPLURLGetValuePKcPKc">
<span id="_CPPv314CPLURLGetValuePKcPKc"></span><span id="_CPPv214CPLURLGetValuePKcPKc"></span><span id="CPLURLGetValue__cCP.cCP"></span><span class="target" id="cpl__string_8h_1a49550245214ac079518c5fcd5084ecd0"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">CPLURLGetValue</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszURL</em>, <em class="property">const</em> char *<em>pszKey</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLURLGetValuePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the value matching a key from a key=value pair in a URL. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the value of empty string if not found. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszURL</span></code>: the URL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key to find. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412CPLURLAddKVPPKcPKcPKc">
<span id="_CPPv312CPLURLAddKVPPKcPKcPKc"></span><span id="_CPPv212CPLURLAddKVPPKcPKcPKc"></span><span id="CPLURLAddKVP__cCP.cCP.cCP"></span><span class="target" id="cpl__string_8h_1ac45405998f4df728887be28a1a6d4b6e"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> <code class="descname">CPLURLAddKVP</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszURL</em>, <em class="property">const</em> char *<em>pszKey</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412CPLURLAddKVPPKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a new URL with a new key=value pair. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the modified URL. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszURL</span></code>: the URL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key to find. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the value of the key (may be NULL to unset an existing KVP). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv49CPLString">
<span id="_CPPv39CPLString"></span><span id="_CPPv29CPLString"></span><span id="CPLString"></span><span class="target" id="classCPLString"></span><em class="property">class </em><code class="descname">CPLString</code> : <em class="property">public</em> string<a class="headerlink" href="#_CPPv49CPLString" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_string.h&gt;</em><p>Convenient string class based on std::string. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N9CPLString9CPLStringEv">
<span id="_CPPv3N9CPLString9CPLStringEv"></span><span id="_CPPv2N9CPLString9CPLStringEv"></span><span id="CPLString::CPLString__void"></span><span class="target" id="classCPLString_1a1c553b7e283d2d3bb18c1946be7597b8"></span><code class="descname">CPLString</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString9CPLStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString9CPLStringERKNSt6stringE">
<span id="_CPPv3N9CPLString9CPLStringERKNSt6stringE"></span><span id="_CPPv2N9CPLString9CPLStringERKNSt6stringE"></span><span id="CPLString::CPLString__ssCR"></span><span class="target" id="classCPLString_1a4048ce43e8fa55b9c783a437471ccb4c"></span><code class="descname">CPLString</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>oStr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString9CPLStringERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString9CPLStringEPKc">
<span id="_CPPv3N9CPLString9CPLStringEPKc"></span><span id="_CPPv2N9CPLString9CPLStringEPKc"></span><span id="CPLString::CPLString__cCP"></span><span class="target" id="classCPLString_1afd967f74726740a3fc4eec8d6ad9369f"></span><code class="descname">CPLString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszStr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString9CPLStringEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString9CPLStringEPKc6size_t">
<span id="_CPPv3N9CPLString9CPLStringEPKc6size_t"></span><span id="_CPPv2N9CPLString9CPLStringEPKc6size_t"></span><span id="CPLString::CPLString__cCP.s"></span><span class="target" id="classCPLString_1afd203d487969a682a689d5ba00765fc1"></span><code class="descname">CPLString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszStr</em>, size_t <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString9CPLStringEPKc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK9CPLStringcvPKcEv">
<span id="_CPPv3NK9CPLStringcvPKcEv"></span><span id="_CPPv2NK9CPLStringcvPKcEv"></span><span id="CPLString::castto-cCP-operator__voidC"></span><span class="target" id="classCPLString_1a1512ca2d33362e11e5bf261953bc7b9f"></span><code class="descname">operator const char *</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK9CPLStringcvPKcEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return string as zero terminated character array. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLStringixENSt6string9size_typeE">
<span id="_CPPv3N9CPLStringixENSt6string9size_typeE"></span><span id="_CPPv2N9CPLStringixENSt6string9size_typeE"></span><span id="CPLString::subscript-operator__std::string::size_type"></span><span class="target" id="classCPLString_1a1154af41eea1db1d0a9822842f3cc077"></span>char &amp;<code class="descname">operator[]</code><span class="sig-paren">(</span>std::string::size_type <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLStringixENSt6string9size_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return character at specified index. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK9CPLStringixENSt6string9size_typeE">
<span id="_CPPv3NK9CPLStringixENSt6string9size_typeE"></span><span id="_CPPv2NK9CPLStringixENSt6string9size_typeE"></span><span id="CPLString::subscript-operator__std::string::size_typeC"></span><span class="target" id="classCPLString_1a8071fa8418133b585d7fb02345bcf600"></span><em class="property">const</em> char &amp;<code class="descname">operator[]</code><span class="sig-paren">(</span>std::string::size_type <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK9CPLStringixENSt6string9size_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return character at specified index. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLStringixEi">
<span id="_CPPv3N9CPLStringixEi"></span><span id="_CPPv2N9CPLStringixEi"></span><span id="CPLString::subscript-operator__i"></span><span class="target" id="classCPLString_1a04b4b396648d01e7df5b8ed04f6337cd"></span>char &amp;<code class="descname">operator[]</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLStringixEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return character at specified index. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK9CPLStringixEi">
<span id="_CPPv3NK9CPLStringixEi"></span><span id="_CPPv2NK9CPLStringixEi"></span><span id="CPLString::subscript-operator__iC"></span><span class="target" id="classCPLString_1af21576f701373844a1648aa20a5b766d"></span><em class="property">const</em> char &amp;<code class="descname">operator[]</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK9CPLStringixEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return character at specified index. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString5ClearEv">
<span id="_CPPv3N9CPLString5ClearEv"></span><span id="_CPPv2N9CPLString5ClearEv"></span><span id="CPLString::Clear"></span><span class="target" id="classCPLString_1a0df5a9aa02ed66cd20512fe0e5f1da45"></span>void <code class="descname">Clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString5ClearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear the string. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString5SeizeEPc">
<span id="_CPPv3N9CPLString5SeizeEPc"></span><span id="_CPPv2N9CPLString5SeizeEPc"></span><span id="CPLString::Seize__cP"></span><span class="target" id="classCPLString_1a8bd09ab0ec85b31a169de6309f27a744"></span>void <code class="descname">Seize</code><span class="sig-paren">(</span>char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString5SeizeEPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign specified string and take ownership of it (assumed to be allocated with <a class="reference internal" href="#cpl__conv_8h_1a9a806de98fbddb1337efdb18651aa0f7"><span class="std std-ref">CPLMalloc()</span></a>). </p>
<p>NULL can be safely passed to clear the string. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString6PrintfEPKcz">
<span id="_CPPv3N9CPLString6PrintfEPKcz"></span><span id="_CPPv2N9CPLString6PrintfEPKcz"></span><span id="CPLString::Printf__cCP.z"></span><span class="target" id="classCPLString_1aff450f2a74c59408627a6b2e17bacdf3"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">Printf</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFormat</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString6PrintfEPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign the content of the string using sprintf() </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString7vPrintfEPKc7va_list">
<span id="_CPPv3N9CPLString7vPrintfEPKc7va_list"></span><span id="_CPPv2N9CPLString7vPrintfEPKc7va_list"></span><span id="CPLString::vPrintf__cCP.va_list"></span><span class="target" id="classCPLString_1afee36b31c4bed3eae88cb502beca3099"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">vPrintf</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFormat</em>, va_list <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString7vPrintfEPKc7va_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign the content of the string using vsprintf() </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString7FormatCEdPKc">
<span id="_CPPv3N9CPLString7FormatCEdPKc"></span><span id="_CPPv2N9CPLString7FormatCEdPKc"></span><span id="CPLString::FormatC__double.cCP"></span><span class="target" id="classCPLString_1aec5282968fee6fac0306e38d653e10d7"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">FormatC</code><span class="sig-paren">(</span>double <em>dfValue</em>, <em class="property">const</em> char *<em>pszFormat</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString7FormatCEdPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format double in C locale. </p>
<p>The passed value is formatted using the C locale (period as decimal separator) and appended to the target <a class="reference internal" href="#classCPLString"><span class="std std-ref">CPLString</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a reference to the <a class="reference internal" href="#classCPLString"><span class="std std-ref">CPLString</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dfValue</span></code>: the value to format. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFormat</span></code>: the sprintf() style format to use or omit for default. Note that this format string should only include one substitution argument and it must be for a double (f or g).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString4TrimEv">
<span id="_CPPv3N9CPLString4TrimEv"></span><span id="_CPPv2N9CPLString4TrimEv"></span><span id="CPLString::Trim"></span><span class="target" id="classCPLString_1a6e13df1ae008043a7118382ec9883e0d"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">Trim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString4TrimEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trim white space. </p>
<p>Trims white space off the let and right of the string. White space is any of a space, a tab, a newline (‘\n’) or a carriage control (‘\r’).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a reference to the <a class="reference internal" href="#classCPLString"><span class="std std-ref">CPLString</span></a>. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString6RecodeEPKcPKc">
<span id="_CPPv3N9CPLString6RecodeEPKcPKc"></span><span id="_CPPv2N9CPLString6RecodeEPKcPKc"></span><span id="CPLString::Recode__cCP.cCP"></span><span class="target" id="classCPLString_1a6a092e19f977f1f294d3799fecd1e401"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">Recode</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszSrcEncoding</em>, <em class="property">const</em> char *<em>pszDstEncoding</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString6RecodeEPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Recode the string. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString10replaceAllERKNSt6stringERKNSt6stringE">
<span id="_CPPv3N9CPLString10replaceAllERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2N9CPLString10replaceAllERKNSt6stringERKNSt6stringE"></span><span id="CPLString::replaceAll__ssCR.ssCR"></span><span class="target" id="classCPLString_1acb24e78abf593312037386704640782b"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">replaceAll</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>osBefore</em>, <em class="property">const</em> std::string &amp;<em>osAfter</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString10replaceAllERKNSt6stringERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace all occurrences of osBefore with osAfter. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString10replaceAllERKNSt6stringEc">
<span id="_CPPv3N9CPLString10replaceAllERKNSt6stringEc"></span><span id="_CPPv2N9CPLString10replaceAllERKNSt6stringEc"></span><span id="CPLString::replaceAll__ssCR.c"></span><span class="target" id="classCPLString_1a683bb5061c27bb69119883db397d668d"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">replaceAll</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>osBefore</em>, char <em>chAfter</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString10replaceAllERKNSt6stringEc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace all occurrences of osBefore with chAfter. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString10replaceAllEcRKNSt6stringE">
<span id="_CPPv3N9CPLString10replaceAllEcRKNSt6stringE"></span><span id="_CPPv2N9CPLString10replaceAllEcRKNSt6stringE"></span><span id="CPLString::replaceAll__c.ssCR"></span><span class="target" id="classCPLString_1abb65f4613e16ed515f63a42bb3bd5dcf"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">replaceAll</code><span class="sig-paren">(</span>char <em>chBefore</em>, <em class="property">const</em> std::string &amp;<em>osAfter</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString10replaceAllEcRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace all occurrences of chBefore with osAfter. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString10replaceAllEcc">
<span id="_CPPv3N9CPLString10replaceAllEcc"></span><span id="_CPPv2N9CPLString10replaceAllEcc"></span><span id="CPLString::replaceAll__c.c"></span><span class="target" id="classCPLString_1a06416d4d2750effcabfa4581603698d4"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">replaceAll</code><span class="sig-paren">(</span>char <em>chBefore</em>, char <em>chAfter</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString10replaceAllEcc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace all occurrences of chBefore with chAfter. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK9CPLString5ifindERKNSt6stringE6size_t">
<span id="_CPPv3NK9CPLString5ifindERKNSt6stringE6size_t"></span><span id="_CPPv2NK9CPLString5ifindERKNSt6stringE6size_t"></span><span id="CPLString::ifind__ssCR.sC"></span><span class="target" id="classCPLString_1a94098fc975330f924c599a06a23e05f4"></span>size_t <code class="descname">ifind</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>str</em>, size_t <em>pos</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK9CPLString5ifindERKNSt6stringE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Case insensitive find() alternative. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the position of substring in the string or std::string::npos if not found. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: substring to find. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code>: offset in the string at which the search starts. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK9CPLString5ifindEPKc6size_t">
<span id="_CPPv3NK9CPLString5ifindEPKc6size_t"></span><span id="_CPPv2NK9CPLString5ifindEPKc6size_t"></span><span id="CPLString::ifind__cCP.sC"></span><span class="target" id="classCPLString_1afce906a26d955853b2c12ddb3069aee6"></span>size_t <code class="descname">ifind</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>s</em>, size_t <em>pos</em> = 0<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK9CPLString5ifindEPKc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Case insensitive find() alternative. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the position of the substring in the string or std::string::npos if not found. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code>: substring to find. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPos</span></code>: offset in the string at which the search starts. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString7toupperEv">
<span id="_CPPv3N9CPLString7toupperEv"></span><span id="_CPPv2N9CPLString7toupperEv"></span><span id="CPLString::toupper__void"></span><span class="target" id="classCPLString_1a0d98a06bdb42be5b1d9b298191e32c32"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">toupper</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString7toupperEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to upper case in place. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N9CPLString7tolowerEv">
<span id="_CPPv3N9CPLString7tolowerEv"></span><span id="_CPPv2N9CPLString7tolowerEv"></span><span id="CPLString::tolower__void"></span><span class="target" id="classCPLString_1a36e9dc5e41eea93bebece60404c9454c"></span><a class="reference internal" href="#_CPPv49CPLString" title="CPLString">CPLString</a> &amp;<code class="descname">tolower</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9CPLString7tolowerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to lower case in place. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK9CPLString8endsWithERKNSt6stringE">
<span id="_CPPv3NK9CPLString8endsWithERKNSt6stringE"></span><span id="_CPPv2NK9CPLString8endsWithERKNSt6stringE"></span><span id="CPLString::endsWith__ssCRC"></span><span class="target" id="classCPLString_1a97e13871693096072d9465de71123ba4"></span>bool <code class="descname">endsWith</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>osStr</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK9CPLString8endsWithERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the string ends with another string. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the string ends wit osStr. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">osStr</span></code>: other string. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv413CPLStringList">
<span id="_CPPv313CPLStringList"></span><span id="_CPPv213CPLStringList"></span><span id="CPLStringList"></span><span class="target" id="classCPLStringList"></span><em class="property">class </em><code class="descname">CPLStringList</code><a class="headerlink" href="#_CPPv413CPLStringList" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_string.h&gt;</em><p>String list class designed around our use of C “char**” string lists. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13CPLStringList13CPLStringListEv">
<span id="_CPPv3N13CPLStringList13CPLStringListEv"></span><span id="_CPPv2N13CPLStringList13CPLStringListEv"></span><span id="CPLStringList::CPLStringList"></span><span class="target" id="classCPLStringList_1ab089f611866406b8ca87515ba49a36b5"></span><code class="descname">CPLStringList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList13CPLStringListEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList13CPLStringListEPPci">
<span id="_CPPv3N13CPLStringList13CPLStringListEPPci"></span><span id="_CPPv2N13CPLStringList13CPLStringListEPPci"></span><span id="CPLStringList::CPLStringList__cPP.i"></span><span class="target" id="classCPLStringList_1ac74e823e5583ef09d46d9d9d4d7d00fc"></span><code class="descname">CPLStringList</code><span class="sig-paren">(</span>char **<em>papszList</em>, int <em>bTakeOwnership</em> = TRUE<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList13CPLStringListEPPci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszListIn</span></code>: the NULL terminated list of strings to consume. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bTakeOwnership</span></code>: TRUE if the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> should take ownership of the list of strings which implies responsibility to free them. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList13CPLStringListE12CSLConstList">
<span id="_CPPv3N13CPLStringList13CPLStringListE12CSLConstList"></span><span id="_CPPv2N13CPLStringList13CPLStringListE12CSLConstList"></span><span id="CPLStringList::CPLStringList__CSLConstList"></span><span class="target" id="classCPLStringList_1a7e1a6439059677935d46ac61d50f366a"></span><code class="descname">CPLStringList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList13CPLStringListE12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> constructor. </p>
<p>The input list is copied.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszListIn</span></code>: the NULL terminated list of strings to ingest. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList13CPLStringListERK13CPLStringList">
<span id="_CPPv3N13CPLStringList13CPLStringListERK13CPLStringList"></span><span id="_CPPv2N13CPLStringList13CPLStringListERK13CPLStringList"></span><span id="CPLStringList::CPLStringList__CPLStringListCR"></span><span class="target" id="classCPLStringList_1a9ed465b7de02087af145a983f6943d8b"></span><code class="descname">CPLStringList</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N13CPLStringList13CPLStringListEv" title="CPLStringList::CPLStringList">CPLStringList</a> &amp;<em>oOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList13CPLStringListERK13CPLStringList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListD0Ev">
<span id="_CPPv3N13CPLStringListD0Ev"></span><span id="_CPPv2N13CPLStringListD0Ev"></span><span id="CPLStringList::~CPLStringList"></span><span class="target" id="classCPLStringList_1aa5e9f1b31aff8dbeba777d87614adffb"></span><code class="descname">~CPLStringList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList5ClearEv">
<span id="_CPPv3N13CPLStringList5ClearEv"></span><span id="_CPPv2N13CPLStringList5ClearEv"></span><span id="CPLStringList::Clear"></span><span class="target" id="classCPLStringList_1adac28f965497aec39e6cfb371ca69925"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">Clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList5ClearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear the string list. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList4sizeEv">
<span id="_CPPv3NK13CPLStringList4sizeEv"></span><span id="_CPPv2NK13CPLStringList4sizeEv"></span><span id="CPLStringList::sizeC"></span><span class="target" id="classCPLStringList_1ab27d6c1fba14ed4fcdaebabdabbe7ea3"></span>int <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return size of list. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList5CountEv">
<span id="_CPPv3NK13CPLStringList5CountEv"></span><span id="_CPPv2NK13CPLStringList5CountEv"></span><span id="CPLStringList::CountC"></span><span class="target" id="classCPLStringList_1a7813fe5966db7caeb9de5dff74c3005c"></span>int <code class="descname">Count</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList5CountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>count of strings in the list, zero if empty. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList5emptyEv">
<span id="_CPPv3NK13CPLStringList5emptyEv"></span><span id="_CPPv2NK13CPLStringList5emptyEv"></span><span id="CPLStringList::emptyC"></span><span class="target" id="classCPLStringList_1a1bcfabcdb18d279c7812e08ede69b684"></span>bool <code class="descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList5emptyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether the list is empty. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList9AddStringEPKc">
<span id="_CPPv3N13CPLStringList9AddStringEPKc"></span><span id="_CPPv2N13CPLStringList9AddStringEPKc"></span><span id="CPLStringList::AddString__cCP"></span><span class="target" id="classCPLStringList_1afb284d82f71198fa175f6656cd8ca328"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">AddString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszNewString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList9AddStringEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a string to the list. </p>
<p>A copy of the passed in string is made and inserted in the list.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszNewString</span></code>: the string to add to the list. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList17AddStringDirectlyEPc">
<span id="_CPPv3N13CPLStringList17AddStringDirectlyEPc"></span><span id="_CPPv2N13CPLStringList17AddStringDirectlyEPc"></span><span id="CPLStringList::AddStringDirectly__cP"></span><span class="target" id="classCPLStringList_1a81ff0aad056292f55d68e48c064dd0ec"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">AddStringDirectly</code><span class="sig-paren">(</span>char *<em>pszNewString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList17AddStringDirectlyEPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a string to the list. </p>
<p>This method is similar to <a class="reference internal" href="#classCPLStringList_1afb284d82f71198fa175f6656cd8ca328"><span class="std std-ref">AddString()</span></a>, but ownership of the pszNewString is transferred to the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> class.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszNewString</span></code>: the string to add to the list. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList12InsertStringEiPKc">
<span id="_CPPv3N13CPLStringList12InsertStringEiPKc"></span><span id="_CPPv2N13CPLStringList12InsertStringEiPKc"></span><span id="CPLStringList::InsertString__i.cCP"></span><span class="target" id="classCPLStringList_1a749cc0686e54bcbf890144a1374d2dde"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> *<code class="descname">InsertString</code><span class="sig-paren">(</span>int <em>nInsertAtLineNo</em>, <em class="property">const</em> char *<em>pszNewLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList12InsertStringEiPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert into the list at identified location. </p>
<p>This method will insert a string into the list at the identified location. The insertion point must be within or at the end of the list. The following entries are pushed down to make space.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nInsertAtLineNo</span></code>: the line to insert at, zero to insert at front. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNewLine</span></code>: to the line to insert. This string will be copied. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList20InsertStringDirectlyEiPc">
<span id="_CPPv3N13CPLStringList20InsertStringDirectlyEiPc"></span><span id="_CPPv2N13CPLStringList20InsertStringDirectlyEiPc"></span><span id="CPLStringList::InsertStringDirectly__i.cP"></span><span class="target" id="classCPLStringList_1a9d30fe949d5e89027a3ad2cb8c0957e8"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">InsertStringDirectly</code><span class="sig-paren">(</span>int <em>nInsertAtLineNo</em>, char *<em>pszNewLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList20InsertStringDirectlyEiPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert into the list at identified location. </p>
<p>This method will insert a string into the list at the identified location. The insertion point must be within or at the end of the list. The following entries are pushed down to make space.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nInsertAtLineNo</span></code>: the line to insert at, zero to insert at front. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNewLine</span></code>: to the line to insert, the ownership of this string will be taken over the by the object. It must have been allocated on the heap. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList10FindStringEPKc">
<span id="_CPPv3NK13CPLStringList10FindStringEPKc"></span><span id="_CPPv2NK13CPLStringList10FindStringEPKc"></span><span id="CPLStringList::FindString__cCPC"></span><span class="target" id="classCPLStringList_1aeb72db1722f1a65ec2a1f02e27d0a3e5"></span>int <code class="descname">FindString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszTarget</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList10FindStringEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return index of pszTarget in the list, or -1. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList17PartialFindStringEPKc">
<span id="_CPPv3NK13CPLStringList17PartialFindStringEPKc"></span><span id="_CPPv2NK13CPLStringList17PartialFindStringEPKc"></span><span id="CPLStringList::PartialFindString__cCPC"></span><span class="target" id="classCPLStringList_1af48843042abf40761102a8a92a92eccc"></span>int <code class="descname">PartialFindString</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszNeedle</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList17PartialFindStringEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return index of pszTarget in the list (using partial search), or -1. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList8FindNameEPKc">
<span id="_CPPv3NK13CPLStringList8FindNameEPKc"></span><span id="_CPPv2NK13CPLStringList8FindNameEPKc"></span><span id="CPLStringList::FindName__cCPC"></span><span class="target" id="classCPLStringList_1a5246a349c3356ac81d90e93d4cc2d8ac"></span>int <code class="descname">FindName</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList8FindNameEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get index of given name/value keyword. </p>
<p>Note that this search is for a line in the form name=value or name:value. Use <a class="reference internal" href="#classCPLStringList_1aeb72db1722f1a65ec2a1f02e27d0a3e5"><span class="std std-ref">FindString()</span></a> or <a class="reference internal" href="#classCPLStringList_1af48843042abf40761102a8a92a92eccc"><span class="std std-ref">PartialFindString()</span></a> for searches not based on name=value pairs.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the string list index of this name, or -1 on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the name to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList9FetchBoolEPKcb">
<span id="_CPPv3NK13CPLStringList9FetchBoolEPKcb"></span><span id="_CPPv2NK13CPLStringList9FetchBoolEPKcb"></span><span id="CPLStringList::FetchBool__cCP.bC"></span><span class="target" id="classCPLStringList_1a3a0f0700ba2a1880843d77ac3735a528"></span>bool <code class="descname">FetchBool</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, bool <em>bDefault</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList9FetchBoolEPKcb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check for boolean key value. </p>
<p>In a <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> of “Name=Value” pairs, look to see if there is a key with the given name, and if it can be interpreted as being TRUE. If the key appears without any “=Value” portion it will be considered true. If the value is NO, FALSE or 0 it will be considered FALSE otherwise if the key appears in the list it will be considered TRUE. If the key doesn’t appear at all, the indicated default value will be returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true or false </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key value to look for (case insensitive). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDefault</span></code>: the value to return if the key isn’t found at all.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList12FetchBooleanEPKci">
<span id="_CPPv3NK13CPLStringList12FetchBooleanEPKci"></span><span id="_CPPv2NK13CPLStringList12FetchBooleanEPKci"></span><span id="CPLStringList::FetchBoolean__cCP.iC"></span><span class="target" id="classCPLStringList_1a4035ae542df99f2028816e77c499c934"></span>int <code class="descname">FetchBoolean</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, int <em>bDefault</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList12FetchBooleanEPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DEPRECATED: Check for boolean key value. </p>
<p>In a <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> of “Name=Value” pairs, look to see if there is a key with the given name, and if it can be interpreted as being TRUE. If the key appears without any “=Value” portion it will be considered true. If the value is NO, FALSE or 0 it will be considered FALSE otherwise if the key appears in the list it will be considered TRUE. If the key doesn’t appear at all, the indicated default value will be returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE or FALSE </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key value to look for (case insensitive). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDefault</span></code>: the value to return if the key isn’t found at all.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList14FetchNameValueEPKc">
<span id="_CPPv3NK13CPLStringList14FetchNameValueEPKc"></span><span id="_CPPv2NK13CPLStringList14FetchNameValueEPKc"></span><span id="CPLStringList::FetchNameValue__cCPC"></span><span class="target" id="classCPLStringList_1aa3cd56dcc04c10e19f044807513373a5"></span><em class="property">const</em> char *<code class="descname">FetchNameValue</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList14FetchNameValueEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch value associated with this key name. </p>
<p>If this list sorted, a fast binary search is done, otherwise a linear scan is done. Name lookup is case insensitive.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the corresponding value or NULL if not found. The returned string should not be modified and points into internal object state that may change on future calls. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the key name to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList17FetchNameValueDefEPKcPKc">
<span id="_CPPv3NK13CPLStringList17FetchNameValueDefEPKcPKc"></span><span id="_CPPv2NK13CPLStringList17FetchNameValueDefEPKcPKc"></span><span id="CPLStringList::FetchNameValueDef__cCP.cCPC"></span><span class="target" id="classCPLStringList_1a262a5afb738275e8936902dba03ddc7c"></span><em class="property">const</em> char *<code class="descname">FetchNameValueDef</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, <em class="property">const</em> char *<em>pszDefault</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList17FetchNameValueDefEPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch value associated with this key name. </p>
<p>If this list sorted, a fast binary search is done, otherwise a linear scan is done. Name lookup is case insensitive.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the corresponding value or the passed default if not found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the key name to search for. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDefault</span></code>: the default value returned if the named entry isn’t found.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList12AddNameValueEPKcPKc">
<span id="_CPPv3N13CPLStringList12AddNameValueEPKcPKc"></span><span id="_CPPv2N13CPLStringList12AddNameValueEPKcPKc"></span><span id="CPLStringList::AddNameValue__cCP.cCP"></span><span class="target" id="classCPLStringList_1a5d692adf11d198bd5d167ea4974c00ac"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">AddNameValue</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList12AddNameValueEPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a name=value entry to the list. </p>
<p>A key=value string is prepared and appended to the list. There is no check for other values for the same key in the list.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key name to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the key value to add. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList12SetNameValueEPKcPKc">
<span id="_CPPv3N13CPLStringList12SetNameValueEPKcPKc"></span><span id="_CPPv2N13CPLStringList12SetNameValueEPKcPKc"></span><span id="CPLStringList::SetNameValue__cCP.cCP"></span><span class="target" id="classCPLStringList_1ac11da61a2087512ea01c0d834f27daf1"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">SetNameValue</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList12SetNameValueEPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set name=value entry in the list. </p>
<p>Similar to <a class="reference internal" href="#classCPLStringList_1a5d692adf11d198bd5d167ea4974c00ac"><span class="std std-ref">AddNameValue()</span></a>, except if there is already a value for the key in the list it is replaced instead of adding a new entry to the list. If pszValue is NULL any existing key entry is removed.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszKey</span></code>: the key name to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the key value to add. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList6AssignEPPci">
<span id="_CPPv3N13CPLStringList6AssignEPPci"></span><span id="_CPPv2N13CPLStringList6AssignEPPci"></span><span id="CPLStringList::Assign__cPP.i"></span><span class="target" id="classCPLStringList_1a00ea004ec035a943fa098e753f0a849c"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">Assign</code><span class="sig-paren">(</span>char **<em>papszListIn</em>, int <em>bTakeOwnership</em> = TRUE<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList6AssignEPPci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign a list of strings. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a reference to the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> on which it was invoked. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszListIn</span></code>: the NULL terminated list of strings to consume. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bTakeOwnership</span></code>: TRUE if the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> should take ownership of the list of strings which implies responsibility to free them.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListaSEPPc">
<span id="_CPPv3N13CPLStringListaSEPPc"></span><span id="_CPPv2N13CPLStringListaSEPPc"></span><span id="CPLStringList::assign-operator__cPP"></span><span class="target" id="classCPLStringList_1a95c774827a98cb1ac3781dd4c9c342a2"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span>char **<em>papszListIn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListaSEPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListaSERK13CPLStringList">
<span id="_CPPv3N13CPLStringListaSERK13CPLStringList"></span><span id="_CPPv2N13CPLStringListaSERK13CPLStringList"></span><span id="CPLStringList::assign-operator__CPLStringListCR"></span><span class="target" id="classCPLStringList_1a7d53263901c1d3aa3a8f41133ecccbdf"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<em>oOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListaSERK13CPLStringList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListaSE12CSLConstList">
<span id="_CPPv3N13CPLStringListaSE12CSLConstList"></span><span id="_CPPv2N13CPLStringListaSE12CSLConstList"></span><span id="CPLStringList::assign-operator__CSLConstList"></span><span class="target" id="classCPLStringList_1a5d0d5defa523a8b800ab8b5045b5dea8"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszListIn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListaSE12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListaSERR13CPLStringList">
<span id="_CPPv3N13CPLStringListaSERR13CPLStringList"></span><span id="_CPPv2N13CPLStringListaSERR13CPLStringList"></span><span id="CPLStringList::assign-operator__CPLStringListRR"></span><span class="target" id="classCPLStringList_1aafca36167eac0b6f09fdec17351d296f"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;&amp;<em>oOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListaSERR13CPLStringList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListixEi">
<span id="_CPPv3N13CPLStringListixEi"></span><span id="_CPPv2N13CPLStringListixEi"></span><span id="CPLStringList::subscript-operator__i"></span><span class="target" id="classCPLStringList_1aa1065761ce5482354a9494a236e21ab4"></span>char *<code class="descname">operator[]</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListixEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return string at specified index. </p>
<p>Fetch entry “i”.</p>
<p>Fetches the requested item in the list. Note that the returned string remains owned by the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a>. If “i” is out of range NULL is returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>selected entry in the list. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the index of the list item to return. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListixE6size_t">
<span id="_CPPv3N13CPLStringListixE6size_t"></span><span id="_CPPv2N13CPLStringListixE6size_t"></span><span id="CPLStringList::subscript-operator__s"></span><span class="target" id="classCPLStringList_1a4891263f74088e4a57a70fa3790545de"></span>char *<code class="descname">operator[]</code><span class="sig-paren">(</span>size_t <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListixE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return string at specified index. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringListixEi">
<span id="_CPPv3NK13CPLStringListixEi"></span><span id="_CPPv2NK13CPLStringListixEi"></span><span id="CPLStringList::subscript-operator__iC"></span><span class="target" id="classCPLStringList_1a47a0630cc8a6d188f79e0b2d8aad0bdb"></span><em class="property">const</em> char *<code class="descname">operator[]</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringListixEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return string at specified index. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringListixE6size_t">
<span id="_CPPv3NK13CPLStringListixE6size_t"></span><span id="_CPPv2NK13CPLStringListixE6size_t"></span><span id="CPLStringList::subscript-operator__sC"></span><span class="target" id="classCPLStringList_1a784b6dff1bf49fe39619f0ae71d893d1"></span><em class="property">const</em> char *<code class="descname">operator[]</code><span class="sig-paren">(</span>size_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringListixE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return string at specified index. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringListixEPKc">
<span id="_CPPv3NK13CPLStringListixEPKc"></span><span id="_CPPv2NK13CPLStringListixEPKc"></span><span id="CPLStringList::subscript-operator__cCPC"></span><span class="target" id="classCPLStringList_1a4208bfbc6b9bd052b8adf8ddcfe37127"></span><em class="property">const</em> char *<code class="descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszKey</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringListixEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return value corresponding to pszKey, or nullptr. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList4ListEv">
<span id="_CPPv3N13CPLStringList4ListEv"></span><span id="_CPPv2N13CPLStringList4ListEv"></span><span id="CPLStringList::List"></span><span class="target" id="classCPLStringList_1a95e80e45e37f312fdfeb86cd9baafa9e"></span>char **<code class="descname">List</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList4ListEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return list. </p>
<p>Ownership remains to the object </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList4ListEv">
<span id="_CPPv3NK13CPLStringList4ListEv"></span><span id="_CPPv2NK13CPLStringList4ListEv"></span><span id="CPLStringList::ListC"></span><span class="target" id="classCPLStringList_1abd18e29bd91649040f88cbfa035bd2f3"></span><a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <code class="descname">List</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList4ListEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return list. </p>
<p>Ownership remains to the object </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList9StealListEv">
<span id="_CPPv3N13CPLStringList9StealListEv"></span><span id="_CPPv2N13CPLStringList9StealListEv"></span><span id="CPLStringList::StealList"></span><span class="target" id="classCPLStringList_1a4784adc3ae6ad4dbb479496baa90d293"></span>char **<code class="descname">StealList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList9StealListEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Seize ownership of underlying string array. </p>
<p>This method is similar to <a class="reference internal" href="#classCPLStringList_1a95e80e45e37f312fdfeb86cd9baafa9e"><span class="std std-ref">List()</span></a>, except that the returned list is now owned by the caller and the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> is emptied.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the C style string list. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList4SortEv">
<span id="_CPPv3N13CPLStringList4SortEv"></span><span id="_CPPv2N13CPLStringList4SortEv"></span><span id="CPLStringList::Sort"></span><span class="target" id="classCPLStringList_1a4985ce535d9a97bdb7d1787f26361605"></span><a class="reference internal" href="#_CPPv413CPLStringList" title="CPLStringList">CPLStringList</a> &amp;<code class="descname">Sort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList4SortEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sort the entries in the list and mark list sorted. </p>
<p>Note that once put into “sorted” mode, the <a class="reference internal" href="#classCPLStringList"><span class="std std-ref">CPLStringList</span></a> will attempt to keep things in sorted order through calls to <a class="reference internal" href="#classCPLStringList_1afb284d82f71198fa175f6656cd8ca328"><span class="std std-ref">AddString()</span></a>, <a class="reference internal" href="#classCPLStringList_1a81ff0aad056292f55d68e48c064dd0ec"><span class="std std-ref">AddStringDirectly()</span></a>, <a class="reference internal" href="#classCPLStringList_1a5d692adf11d198bd5d167ea4974c00ac"><span class="std std-ref">AddNameValue()</span></a>, <a class="reference internal" href="#classCPLStringList_1ac11da61a2087512ea01c0d834f27daf1"><span class="std std-ref">SetNameValue()</span></a>. Complete list assignments (via <a class="reference internal" href="#classCPLStringList_1a00ea004ec035a943fa098e753f0a849c"><span class="std std-ref">Assign()</span></a> and operator= will clear the sorting state. When in sorted order <a class="reference internal" href="#classCPLStringList_1a5246a349c3356ac81d90e93d4cc2d8ac"><span class="std std-ref">FindName()</span></a>, <a class="reference internal" href="#classCPLStringList_1aa3cd56dcc04c10e19f044807513373a5"><span class="std std-ref">FetchNameValue()</span></a> and <a class="reference internal" href="#classCPLStringList_1a262a5afb738275e8936902dba03ddc7c"><span class="std std-ref">FetchNameValueDef()</span></a> will do a binary search to find the key, substantially improve lookup performance in large lists. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringList8IsSortedEv">
<span id="_CPPv3NK13CPLStringList8IsSortedEv"></span><span id="_CPPv2NK13CPLStringList8IsSortedEv"></span><span id="CPLStringList::IsSortedC"></span><span class="target" id="classCPLStringList_1a136281deb862ff39190d28a25c74a668"></span>int <code class="descname">IsSorted</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringList8IsSortedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the list is sorted. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringListcvPPcEv">
<span id="_CPPv3N13CPLStringListcvPPcEv"></span><span id="_CPPv2N13CPLStringListcvPPcEv"></span><span id="CPLStringList::castto-cPP-operator__void"></span><span class="target" id="classCPLStringList_1adff9209d5d715c682eac459af4381c4e"></span><code class="descname">operator char **</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringListcvPPcEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return lists. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13CPLStringListcv12CSLConstListEv">
<span id="_CPPv3NK13CPLStringListcv12CSLConstListEv"></span><span id="_CPPv2NK13CPLStringListcv12CSLConstListEv"></span><span id="CPLStringList::castto-CSLConstList-operator__voidC"></span><span class="target" id="classCPLStringList_1a1edabb0a456204e3612b8e99c4d2222e"></span><code class="descname">operator CSLConstList</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13CPLStringListcv12CSLConstListEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return lists. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv4N13CPLStringList14MakeOurOwnCopyEv">
<span id="_CPPv3N13CPLStringList14MakeOurOwnCopyEv"></span><span id="_CPPv2N13CPLStringList14MakeOurOwnCopyEv"></span><span id="CPLStringList::MakeOurOwnCopy"></span><span class="target" id="classCPLStringList_1aaba0ab343be5820dc2f860e7df95b7f2"></span>void <code class="descname">MakeOurOwnCopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList14MakeOurOwnCopyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList16EnsureAllocationEi">
<span id="_CPPv3N13CPLStringList16EnsureAllocationEi"></span><span id="_CPPv2N13CPLStringList16EnsureAllocationEi"></span><span id="CPLStringList::EnsureAllocation__i"></span><span class="target" id="classCPLStringList_1a486cffdf1063cc6a9e3ba9abd3901037"></span>void <code class="descname">EnsureAllocation</code><span class="sig-paren">(</span>int <em>nMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList16EnsureAllocationEi" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv4N13CPLStringList24FindSortedInsertionPointEPKc">
<span id="_CPPv3N13CPLStringList24FindSortedInsertionPointEPKc"></span><span id="_CPPv2N13CPLStringList24FindSortedInsertionPointEPKc"></span><span id="CPLStringList::FindSortedInsertionPoint__cCP"></span><span class="target" id="classCPLStringList_1a2360b5359fc7413cc9141c23193600e4"></span>int <code class="descname">FindSortedInsertionPoint</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13CPLStringList24FindSortedInsertionPointEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv4N13CPLStringList9papszListE">
<span id="_CPPv3N13CPLStringList9papszListE"></span><span id="_CPPv2N13CPLStringList9papszListE"></span><span id="CPLStringList::papszList__cPP"></span><span class="target" id="classCPLStringList_1ae723057a4ff5d336e83055a11a5c8f61"></span>char **<code class="descname">papszList</code> = nullptr<a class="headerlink" href="#_CPPv4N13CPLStringList9papszListE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLStringList6nCountE">
<span id="_CPPv3N13CPLStringList6nCountE"></span><span id="_CPPv2N13CPLStringList6nCountE"></span><span id="CPLStringList::nCount__i"></span><span class="target" id="classCPLStringList_1aed72ed184e486e193779b7ffd5260fa6"></span>int <code class="descname">nCount</code> = 0<a class="headerlink" href="#_CPPv4N13CPLStringList6nCountE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLStringList11nAllocationE">
<span id="_CPPv3N13CPLStringList11nAllocationE"></span><span id="_CPPv2N13CPLStringList11nAllocationE"></span><span id="CPLStringList::nAllocation__i"></span><span class="target" id="classCPLStringList_1acd2b2ac05cd34e2d3a41208c3ef477e9"></span>int <code class="descname">nAllocation</code> = 0<a class="headerlink" href="#_CPPv4N13CPLStringList11nAllocationE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLStringList8bOwnListE">
<span id="_CPPv3N13CPLStringList8bOwnListE"></span><span id="_CPPv2N13CPLStringList8bOwnListE"></span><span id="CPLStringList::bOwnList__b"></span><span class="target" id="classCPLStringList_1a197a87c956de7a029bf5e7483da193c9"></span>bool <code class="descname">bOwnList</code> = false<a class="headerlink" href="#_CPPv4N13CPLStringList8bOwnListE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv4N13CPLStringList9bIsSortedE">
<span id="_CPPv3N13CPLStringList9bIsSortedE"></span><span id="_CPPv2N13CPLStringList9bIsSortedE"></span><span id="CPLStringList::bIsSorted__b"></span><span class="target" id="classCPLStringList_1af069f988c458b98537e7583bf0e90fb6"></span>bool <code class="descname">bIsSorted</code> = false<a class="headerlink" href="#_CPPv4N13CPLStringList9bIsSortedE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cpl-time-h">
<h2>cpl_time.h<a class="headerlink" href="#cpl-time-h" title="Permalink to this headline">¶</a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv419CPLUnixTimeToYMDHMS7GIntBigP2tm">
<span id="_CPPv319CPLUnixTimeToYMDHMS7GIntBigP2tm"></span><span id="_CPPv219CPLUnixTimeToYMDHMS7GIntBigP2tm"></span><span id="CPLUnixTimeToYMDHMS__GIntBig.tmP"></span><span class="target" id="cpl__time_8h_1a79596ea0af27bd1605cb22582fff42fc"></span><em class="property">struct</em> tm *<code class="descname">CPLUnixTimeToYMDHMS</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <em>unixTime</em>, <em class="property">struct</em> tm *<em>pRet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLUnixTimeToYMDHMS7GIntBigP2tm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts a time value since the Epoch (aka “unix” time) to a broken-down UTC time. </p>
<p>This function is similar to gmtime_r(). This function will always set tm_isdst to 0.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the structure pointed by pRet filled with a broken-down UTC time. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unixTime</span></code>: number of seconds since the Epoch. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pRet</span></code>: address of the return structure.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419CPLYMDHMSToUnixTimePK2tm">
<span id="_CPPv319CPLYMDHMSToUnixTimePK2tm"></span><span id="_CPPv219CPLYMDHMSToUnixTimePK2tm"></span><span id="CPLYMDHMSToUnixTime__tmCP"></span><span class="target" id="cpl__time_8h_1a370dd1b91bf5c86b2f90bb1ee679298a"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">CPLYMDHMSToUnixTime</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> tm *<em>brokendowntime</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419CPLYMDHMSToUnixTimePK2tm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts a broken-down UTC time into time since the Epoch (aka “unix” time). </p>
<p>This function is similar to mktime(), but the passed structure is not modified. This function ignores the tm_wday, tm_yday and tm_isdst fields of the passed value. No timezone shift will be applied. This function returns 0 for the 1/1/1970 00:00:00</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a number of seconds since the Epoch encoded as a value of type GIntBig, or -1 if the time cannot be represented. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">brokendowntime</span></code>: broken-downtime UTC time.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422CPLParseRFC822DateTimePKcPiPiPiPiPiPiPiPi">
<span id="_CPPv322CPLParseRFC822DateTimePKcPiPiPiPiPiPiPiPi"></span><span id="_CPPv222CPLParseRFC822DateTimePKcPiPiPiPiPiPiPiPi"></span><span id="CPLParseRFC822DateTime__cCP.iP.iP.iP.iP.iP.iP.iP.iP"></span><span class="target" id="cpl__time_8h_1ac1281bd4b897dfb48c619a6d2a882370"></span>int <code class="descname">CPLParseRFC822DateTime</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszRFC822DateTime</em>, int *<em>pnYear</em>, int *<em>pnMonth</em>, int *<em>pnDay</em>, int *<em>pnHour</em>, int *<em>pnMinute</em>, int *<em>pnSecond</em>, int *<em>pnTZFlag</em>, int *<em>pnWeekDay</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422CPLParseRFC822DateTimePKcPiPiPiPiPiPiPiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse a RFC822 formatted date-time string. </p>
<p>Such as [Fri,] 28 Dec 2007 05:24[:17] GMT</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if parsing is successful</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszRFC822DateTime</span></code>: formatted string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnYear</span></code>: pointer to int receiving year (like 1980, 2000, etc…), or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnMonth</span></code>: pointer to int receiving month (between 1 and 12), or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnDay</span></code>: pointer to int receiving day of month (between 1 and 31), or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnHour</span></code>: pointer to int receiving hour of day (between 0 and 23), or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnMinute</span></code>: pointer to int receiving minute (between 0 and 59), or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnSecond</span></code>: pointer to int receiving second (between 0 and 60, or -1 if unknown), or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnTZFlag</span></code>: pointer to int receiving time zone flag (0=unknown, 100=GMT, 101=GMT+15minute, 99=GMT-15minute), or NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnWeekDay</span></code>: pointer to int receiving day of week (between 1 and 7, or 0 if invalid/unset), or NULL </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="cpl-virtualmem-h">
<h2>cpl_virtualmem.h<a class="headerlink" href="#cpl-virtualmem-h" title="Permalink to this headline">¶</a></h2>
<p>Virtual memory management. </p>
<p>This file provides mechanism to define virtual memory mappings, whose content is allocated transparently and filled on-the-fly. Those virtual memory mappings can be much larger than the available RAM, but only parts of the virtual memory mapping, in the limit of the allowed the cache size, will actually be physically allocated.</p>
<p>This exploits low-level mechanisms of the operating system (virtual memory allocation, page protection and handler of virtual memory exceptions).</p>
<p>It is also possible to create a virtual memory mapping from a file or part of a file.</p>
<p>The current implementation is Linux only. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv413CPLVirtualMem">
<span id="_CPPv313CPLVirtualMem"></span><span id="_CPPv213CPLVirtualMem"></span><span id="CPLVirtualMem"></span><span class="target" id="cpl__virtualmem_8h_1aac693188a82d797c5a651f275fddab82"></span><em class="property">typedef </em><em class="property">struct</em> <a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> <code class="descname">CPLVirtualMem</code><a class="headerlink" href="#_CPPv413CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type that represents a virtual memory mapping. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv425CPLVirtualMemCachePageCbk">
<span id="_CPPv325CPLVirtualMemCachePageCbk"></span><span id="_CPPv225CPLVirtualMemCachePageCbk"></span><span id="CPLVirtualMemCachePageCbk"></span><span class="target" id="cpl__virtualmem_8h_1a2eaa49a430d8b44b95caeffd3fa24b28"></span><em class="property">typedef </em>void (*<code class="descname">CPLVirtualMemCachePageCbk</code>)<span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CPLVirtualMemCachePageCbk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback triggered when a still unmapped page of virtual memory is accessed. </p>
<p>The callback has the responsibility of filling the page with relevant values</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: virtual memory handle. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: offset of the page in the memory mapping. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pPageToFill</span></code>: address of the page to fill. Note that the address might be a temporary location, and not at <a class="reference internal" href="#cpl__virtualmem_8h_1a36fbbf1e7a217655fdd19231154a8cfa"><span class="std std-ref">CPLVirtualMemGetAddr()</span></a> + nOffset. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nToFill</span></code>: number of bytes of the page. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pUserData</span></code>: user data that was passed to <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv427CPLVirtualMemUnCachePageCbk">
<span id="_CPPv327CPLVirtualMemUnCachePageCbk"></span><span id="_CPPv227CPLVirtualMemUnCachePageCbk"></span><span id="CPLVirtualMemUnCachePageCbk"></span><span class="target" id="cpl__virtualmem_8h_1a71ad0e765022546be709d8b80bc99632"></span><em class="property">typedef </em>void (*<code class="descname">CPLVirtualMemUnCachePageCbk</code>)<span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *ctxt, size_t nOffset, <em class="property">const</em> void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427CPLVirtualMemUnCachePageCbk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback triggered when a dirty mapped page is going to be freed. </p>
<p>(saturation of cache, or termination of the virtual memory mapping).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: virtual memory handle. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: offset of the page in the memory mapping. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pPageToBeEvicted</span></code>: address of the page that will be flushed. Note that the address might be a temporary location, and not at <a class="reference internal" href="#cpl__virtualmem_8h_1a36fbbf1e7a217655fdd19231154a8cfa"><span class="std std-ref">CPLVirtualMemGetAddr()</span></a> + nOffset. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nToBeEvicted</span></code>: number of bytes of the page. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pUserData</span></code>: user data that was passed to <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv425CPLVirtualMemFreeUserData">
<span id="_CPPv325CPLVirtualMemFreeUserData"></span><span id="_CPPv225CPLVirtualMemFreeUserData"></span><span id="CPLVirtualMemFreeUserData"></span><span class="target" id="cpl__virtualmem_8h_1a7fac15ae099b3328095f663bb69be0a0"></span><em class="property">typedef </em>void (*<code class="descname">CPLVirtualMemFreeUserData</code>)<span class="sig-paren">(</span>void *pUserData<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425CPLVirtualMemFreeUserData" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback triggered when a virtual memory mapping is destroyed. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pUserData</span></code>: user data that was passed to <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv423CPLVirtualMemAccessMode">
<span id="_CPPv323CPLVirtualMemAccessMode"></span><span id="_CPPv223CPLVirtualMemAccessMode"></span><span class="target" id="cpl__virtualmem_8h_1aeba7fc305d946740f9e88513220c73a1"></span><em class="property">enum </em><code class="descname">CPLVirtualMemAccessMode</code><a class="headerlink" href="#_CPPv423CPLVirtualMemAccessMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Access mode of a virtual memory mapping. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv419VIRTUALMEM_READONLY">
<span id="_CPPv319VIRTUALMEM_READONLY"></span><span id="_CPPv219VIRTUALMEM_READONLY"></span><span class="target" id="cpl__virtualmem_8h_1aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79"></span><code class="descname">VIRTUALMEM_READONLY</code><a class="headerlink" href="#_CPPv419VIRTUALMEM_READONLY" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The mapping is meant at being read-only, but writes will not be prevented. Note that any content written will be lost. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv428VIRTUALMEM_READONLY_ENFORCED">
<span id="_CPPv328VIRTUALMEM_READONLY_ENFORCED"></span><span id="_CPPv228VIRTUALMEM_READONLY_ENFORCED"></span><span class="target" id="cpl__virtualmem_8h_1aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97"></span><code class="descname">VIRTUALMEM_READONLY_ENFORCED</code><a class="headerlink" href="#_CPPv428VIRTUALMEM_READONLY_ENFORCED" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The mapping is meant at being read-only, and this will be enforced through the operating system page protection mechanism. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv420VIRTUALMEM_READWRITE">
<span id="_CPPv320VIRTUALMEM_READWRITE"></span><span id="_CPPv220VIRTUALMEM_READWRITE"></span><span class="target" id="cpl__virtualmem_8h_1aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169"></span><code class="descname">VIRTUALMEM_READWRITE</code><a class="headerlink" href="#_CPPv420VIRTUALMEM_READWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The mapping is meant at being read-write, and modified pages can be saved thanks to the pfnUnCachePage callback </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv414CPLGetPageSizev">
<span id="_CPPv314CPLGetPageSizev"></span><span id="_CPPv214CPLGetPageSizev"></span><span id="CPLGetPageSize__void"></span><span class="target" id="cpl__virtualmem_8h_1af7db376bca14d8aeb40dc171b969fbad"></span>size_t <code class="descname">CPLGetPageSize</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414CPLGetPageSizev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the size of a page of virtual memory. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the page size.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLVirtualMemNew6size_t6size_t6size_ti23CPLVirtualMemAccessMode25CPLVirtualMemCachePageCbk27CPLVirtualMemUnCachePageCbk25CPLVirtualMemFreeUserDataPv">
<span id="_CPPv316CPLVirtualMemNew6size_t6size_t6size_ti23CPLVirtualMemAccessMode25CPLVirtualMemCachePageCbk27CPLVirtualMemUnCachePageCbk25CPLVirtualMemFreeUserDataPv"></span><span id="_CPPv216CPLVirtualMemNew6size_t6size_t6size_ti23CPLVirtualMemAccessMode25CPLVirtualMemCachePageCbk27CPLVirtualMemUnCachePageCbk25CPLVirtualMemFreeUserDataPv"></span><span id="CPLVirtualMemNew__s.s.s.i.CPLVirtualMemAccessMode.CPLVirtualMemCachePageCbk.CPLVirtualMemUnCachePageCbk.CPLVirtualMemFreeUserData.voidP"></span><span class="target" id="cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"></span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<code class="descname">CPLVirtualMemNew</code><span class="sig-paren">(</span>size_t <em>nSize</em>, size_t <em>nCacheSize</em>, size_t <em>nPageSizeHint</em>, int <em>bSingleThreadUsage</em>, <a class="reference internal" href="#_CPPv423CPLVirtualMemAccessMode" title="CPLVirtualMemAccessMode">CPLVirtualMemAccessMode</a> <em>eAccessMode</em>, <a class="reference internal" href="#_CPPv425CPLVirtualMemCachePageCbk" title="CPLVirtualMemCachePageCbk">CPLVirtualMemCachePageCbk</a> <em>pfnCachePage</em>, <a class="reference internal" href="#_CPPv427CPLVirtualMemUnCachePageCbk" title="CPLVirtualMemUnCachePageCbk">CPLVirtualMemUnCachePageCbk</a> <em>pfnUnCachePage</em>, <a class="reference internal" href="#_CPPv425CPLVirtualMemFreeUserData" title="CPLVirtualMemFreeUserData">CPLVirtualMemFreeUserData</a> <em>pfnFreeUserData</em>, void *<em>pCbkUserData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLVirtualMemNew6size_t6size_t6size_ti23CPLVirtualMemAccessMode25CPLVirtualMemCachePageCbk27CPLVirtualMemUnCachePageCbk25CPLVirtualMemFreeUserDataPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new virtual memory mapping. </p>
<p>This will reserve an area of virtual memory of size nSize, whose size might be potentially much larger than the physical memory available. Initially, no physical memory will be allocated. As soon as memory pages will be accessed, they will be allocated transparently and filled with the pfnCachePage callback. When the allowed cache size is reached, the least recently used pages will be unallocated.</p>
<p>On Linux AMD64 platforms, the maximum value for nSize is 128 TB. On Linux x86 platforms, the maximum value for nSize is 2 GB.</p>
<p>Only supported on Linux for now.</p>
<p>Note that on Linux, this function will install a SIGSEGV handler. The original handler will be restored by <a class="reference internal" href="#cpl__virtualmem_8h_1a33e690c9c5b7f636cd8c0254eba63cb8"><span class="std std-ref">CPLVirtualMemManagerTerminate()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a virtual memory object that must be freed by <a class="reference internal" href="#cpl__virtualmem_8h_1ac7e397a190759c66d3ee1130a20fb279"><span class="std std-ref">CPLVirtualMemFree()</span></a>, or NULL in case of failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: size in bytes of the virtual memory mapping. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCacheSize</span></code>: size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPageSizeHint</span></code>: hint for the page size. Must be a multiple of the system page size, returned by <a class="reference internal" href="#cpl__virtualmem_8h_1af7db376bca14d8aeb40dc171b969fbad"><span class="std std-ref">CPLGetPageSize()</span></a>. Minimum value is generally 4096. Might be set to 0 to let the function determine a default page size. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bSingleThreadUsage</span></code>: set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eAccessMode</span></code>: permission to use for the virtual memory mapping. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnCachePage</span></code>: callback triggered when a still unmapped page of virtual memory is accessed. The callback has the responsibility of filling the page with relevant values. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnUnCachePage</span></code>: callback triggered when a dirty mapped page is going to be freed (saturation of cache, or termination of the virtual memory mapping). Might be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnFreeUserData</span></code>: callback that can be used to free pCbkUserData. Might be NULL </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pCbkUserData</span></code>: user data passed to pfnCachePage and pfnUnCachePage.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv431CPLIsVirtualMemFileMapAvailablev">
<span id="_CPPv331CPLIsVirtualMemFileMapAvailablev"></span><span id="_CPPv231CPLIsVirtualMemFileMapAvailablev"></span><span id="CPLIsVirtualMemFileMapAvailable__void"></span><span class="target" id="cpl__virtualmem_8h_1a00d1f6e9104464fc2052be91c2a20cd2"></span>int <code class="descname">CPLIsVirtualMemFileMapAvailable</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431CPLIsVirtualMemFileMapAvailablev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if virtual memory mapping of a file is available. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if virtual memory mapping of a file is available. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423CPLVirtualMemFileMapNewP8VSILFILE12vsi_l_offset12vsi_l_offset23CPLVirtualMemAccessMode25CPLVirtualMemFreeUserDataPv">
<span id="_CPPv323CPLVirtualMemFileMapNewP8VSILFILE12vsi_l_offset12vsi_l_offset23CPLVirtualMemAccessMode25CPLVirtualMemFreeUserDataPv"></span><span id="_CPPv223CPLVirtualMemFileMapNewP8VSILFILE12vsi_l_offset12vsi_l_offset23CPLVirtualMemAccessMode25CPLVirtualMemFreeUserDataPv"></span><span id="CPLVirtualMemFileMapNew__VSILFILEP.vsi_l_offset.vsi_l_offset.CPLVirtualMemAccessMode.CPLVirtualMemFreeUserData.voidP"></span><span class="target" id="cpl__virtualmem_8h_1a51a1fc455ba063709c4c7acd3def44ea"></span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<code class="descname">CPLVirtualMemFileMapNew</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nOffset</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nLength</em>, <a class="reference internal" href="#_CPPv423CPLVirtualMemAccessMode" title="CPLVirtualMemAccessMode">CPLVirtualMemAccessMode</a> <em>eAccessMode</em>, <a class="reference internal" href="#_CPPv425CPLVirtualMemFreeUserData" title="CPLVirtualMemFreeUserData">CPLVirtualMemFreeUserData</a> <em>pfnFreeUserData</em>, void *<em>pCbkUserData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423CPLVirtualMemFileMapNewP8VSILFILE12vsi_l_offset12vsi_l_offset23CPLVirtualMemAccessMode25CPLVirtualMemFreeUserDataPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new virtual memory mapping from a file. </p>
<p>The file must be a “real” file recognized by the operating system, and not a VSI extended virtual file.</p>
<p>In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written in the file.</p>
<p>On Linux AMD64 platforms, the maximum value for nLength is 128 TB. On Linux x86 platforms, the maximum value for nLength is 2 GB.</p>
<p>Supported on Linux only in GDAL &lt;= 2.0, and all POSIX systems supporting mmap() in GDAL &gt;= 2.1</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a virtual memory object that must be freed by <a class="reference internal" href="#cpl__virtualmem_8h_1ac7e397a190759c66d3ee1130a20fb279"><span class="std std-ref">CPLVirtualMemFree()</span></a>, or NULL in case of failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: Virtual file handle. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: Offset in the file to start the mapping from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLength</span></code>: Length of the portion of the file to map into memory. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eAccessMode</span></code>: Permission to use for the virtual memory mapping. This must be consistent with how the file has been opened. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnFreeUserData</span></code>: callback that is called when the object is destroyed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pCbkUserData</span></code>: user data passed to pfnFreeUserData. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423CPLVirtualMemDerivedNewP13CPLVirtualMem12vsi_l_offset12vsi_l_offset25CPLVirtualMemFreeUserDataPv">
<span id="_CPPv323CPLVirtualMemDerivedNewP13CPLVirtualMem12vsi_l_offset12vsi_l_offset25CPLVirtualMemFreeUserDataPv"></span><span id="_CPPv223CPLVirtualMemDerivedNewP13CPLVirtualMem12vsi_l_offset12vsi_l_offset25CPLVirtualMemFreeUserDataPv"></span><span id="CPLVirtualMemDerivedNew__CPLVirtualMemP.vsi_l_offset.vsi_l_offset.CPLVirtualMemFreeUserData.voidP"></span><span class="target" id="cpl__virtualmem_8h_1abc5e12022cf50ba82ab31d5d8cba2fa7"></span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<code class="descname">CPLVirtualMemDerivedNew</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>pVMemBase</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nOffset</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nSize</em>, <a class="reference internal" href="#_CPPv425CPLVirtualMemFreeUserData" title="CPLVirtualMemFreeUserData">CPLVirtualMemFreeUserData</a> <em>pfnFreeUserData</em>, void *<em>pCbkUserData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423CPLVirtualMemDerivedNewP13CPLVirtualMem12vsi_l_offset12vsi_l_offset25CPLVirtualMemFreeUserDataPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new virtual memory mapping derived from an other virtual memory mapping. </p>
<p>This may be useful in case of creating mapping for pixel interleaved data.</p>
<p>The new mapping takes a reference on the base mapping.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a virtual memory object that must be freed by <a class="reference internal" href="#cpl__virtualmem_8h_1ac7e397a190759c66d3ee1130a20fb279"><span class="std std-ref">CPLVirtualMemFree()</span></a>, or NULL in case of failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pVMemBase</span></code>: Base virtual memory mapping </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: Offset in the base virtual memory mapping from which to start the new mapping. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: Size of the base virtual memory mapping to expose in the the new mapping. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnFreeUserData</span></code>: callback that is called when the object is destroyed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pCbkUserData</span></code>: user data passed to pfnFreeUserData. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLVirtualMemFreeP13CPLVirtualMem">
<span id="_CPPv317CPLVirtualMemFreeP13CPLVirtualMem"></span><span id="_CPPv217CPLVirtualMemFreeP13CPLVirtualMem"></span><span id="CPLVirtualMemFree__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1ac7e397a190759c66d3ee1130a20fb279"></span>void <code class="descname">CPLVirtualMemFree</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLVirtualMemFreeP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a virtual memory mapping. </p>
<p>The pointer returned by <a class="reference internal" href="#cpl__virtualmem_8h_1a36fbbf1e7a217655fdd19231154a8cfa"><span class="std std-ref">CPLVirtualMemGetAddr()</span></a> will no longer be valid. If the virtual memory mapping was created with read/write permissions and that they are dirty (i.e. modified) pages, they will be flushed through the pfnUnCachePage callback before being freed.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CPLVirtualMemGetAddrP13CPLVirtualMem">
<span id="_CPPv320CPLVirtualMemGetAddrP13CPLVirtualMem"></span><span id="_CPPv220CPLVirtualMemGetAddrP13CPLVirtualMem"></span><span id="CPLVirtualMemGetAddr__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1a36fbbf1e7a217655fdd19231154a8cfa"></span>void *<code class="descname">CPLVirtualMemGetAddr</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLVirtualMemGetAddrP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the pointer to the start of a virtual memory mapping. </p>
<p>The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer returned by this function will be valid, until <a class="reference internal" href="#cpl__virtualmem_8h_1ac7e397a190759c66d3ee1130a20fb279"><span class="std std-ref">CPLVirtualMemFree()</span></a> is called.</p>
<p>Note that if a range of bytes used as an argument of a system call (such as read() or write()) contains pages that have not been “realized”, the system call will fail with EFAULT. <a class="reference internal" href="#cpl__virtualmem_8h_1a4f98d8a992f8bf393719c51c5551c07e"><span class="std std-ref">CPLVirtualMemPin()</span></a> can be used to work around this issue.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the pointer to the start of a virtual memory mapping.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420CPLVirtualMemGetSizeP13CPLVirtualMem">
<span id="_CPPv320CPLVirtualMemGetSizeP13CPLVirtualMem"></span><span id="_CPPv220CPLVirtualMemGetSizeP13CPLVirtualMem"></span><span id="CPLVirtualMemGetSize__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1a0b3e9db855ad1ee7bde1657d91209b72"></span>size_t <code class="descname">CPLVirtualMemGetSize</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420CPLVirtualMemGetSizeP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the size of the virtual memory mapping. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the size of the virtual memory mapping.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426CPLVirtualMemIsFileMappingP13CPLVirtualMem">
<span id="_CPPv326CPLVirtualMemIsFileMappingP13CPLVirtualMem"></span><span id="_CPPv226CPLVirtualMemIsFileMappingP13CPLVirtualMem"></span><span id="CPLVirtualMemIsFileMapping__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1a53512758f6e597b095dcd8a146d7838e"></span>int <code class="descname">CPLVirtualMemIsFileMapping</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426CPLVirtualMemIsFileMappingP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if the virtual memory mapping is a direct file mapping. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the virtual memory mapping is a direct file mapping.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426CPLVirtualMemGetAccessModeP13CPLVirtualMem">
<span id="_CPPv326CPLVirtualMemGetAccessModeP13CPLVirtualMem"></span><span id="_CPPv226CPLVirtualMemGetAccessModeP13CPLVirtualMem"></span><span id="CPLVirtualMemGetAccessMode__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1a8c8d6a1df28c479c9dbb4c1086e570f3"></span><a class="reference internal" href="#_CPPv423CPLVirtualMemAccessMode" title="CPLVirtualMemAccessMode">CPLVirtualMemAccessMode</a> <code class="descname">CPLVirtualMemGetAccessMode</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426CPLVirtualMemGetAccessModeP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the access mode of the virtual memory mapping. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the access mode of the virtual memory mapping.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424CPLVirtualMemGetPageSizeP13CPLVirtualMem">
<span id="_CPPv324CPLVirtualMemGetPageSizeP13CPLVirtualMem"></span><span id="_CPPv224CPLVirtualMemGetPageSizeP13CPLVirtualMem"></span><span id="CPLVirtualMemGetPageSize__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1aee835258a343e77447f54b9e078cddc5"></span>size_t <code class="descname">CPLVirtualMemGetPageSize</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424CPLVirtualMemGetPageSizeP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the page size associated to a virtual memory mapping. </p>
<p>The value returned will be at least <a class="reference internal" href="#cpl__virtualmem_8h_1af7db376bca14d8aeb40dc171b969fbad"><span class="std std-ref">CPLGetPageSize()</span></a>, but potentially larger.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the page size</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv431CPLVirtualMemIsAccessThreadSafeP13CPLVirtualMem">
<span id="_CPPv331CPLVirtualMemIsAccessThreadSafeP13CPLVirtualMem"></span><span id="_CPPv231CPLVirtualMemIsAccessThreadSafeP13CPLVirtualMem"></span><span id="CPLVirtualMemIsAccessThreadSafe__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1abdf17d57f9361d6b71341b96c188e904"></span>int <code class="descname">CPLVirtualMemIsAccessThreadSafe</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431CPLVirtualMemIsAccessThreadSafeP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return TRUE if this memory mapping can be accessed safely from concurrent threads. </p>
<p>The situation that can cause problems is when several threads try to access a page of the mapping that is not yet mapped.</p>
<p>The return value of this function depends on whether bSingleThreadUsage has been set of not in <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a> and/or the implementation.</p>
<p>On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if this memory mapping can be accessed safely from concurrent threads.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426CPLVirtualMemDeclareThreadP13CPLVirtualMem">
<span id="_CPPv326CPLVirtualMemDeclareThreadP13CPLVirtualMem"></span><span id="_CPPv226CPLVirtualMemDeclareThreadP13CPLVirtualMem"></span><span id="CPLVirtualMemDeclareThread__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1aa94d9fee83792450f556ea68f3a27f31"></span>void <code class="descname">CPLVirtualMemDeclareThread</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426CPLVirtualMemDeclareThreadP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Declare that a thread will access a virtual memory mapping. </p>
<p>This function must be called by a thread that wants to access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="reference internal" href="#cpl__virtualmem_8h_1a60a2dba5c24c0c7c478202928fecf93c"><span class="std std-ref">CPLVirtualMemUnDeclareThread()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428CPLVirtualMemUnDeclareThreadP13CPLVirtualMem">
<span id="_CPPv328CPLVirtualMemUnDeclareThreadP13CPLVirtualMem"></span><span id="_CPPv228CPLVirtualMemUnDeclareThreadP13CPLVirtualMem"></span><span id="CPLVirtualMemUnDeclareThread__CPLVirtualMemP"></span><span class="target" id="cpl__virtualmem_8h_1a60a2dba5c24c0c7c478202928fecf93c"></span>void <code class="descname">CPLVirtualMemUnDeclareThread</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428CPLVirtualMemUnDeclareThreadP13CPLVirtualMem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Declare that a thread will stop accessing a virtual memory mapping. </p>
<p>This function must be called by a thread that will no longer access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="reference internal" href="#cpl__virtualmem_8h_1aa94d9fee83792450f556ea68f3a27f31"><span class="std std-ref">CPLVirtualMemDeclareThread()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416CPLVirtualMemPinP13CPLVirtualMemPv6size_ti">
<span id="_CPPv316CPLVirtualMemPinP13CPLVirtualMemPv6size_ti"></span><span id="_CPPv216CPLVirtualMemPinP13CPLVirtualMemPv6size_ti"></span><span id="CPLVirtualMemPin__CPLVirtualMemP.voidP.s.i"></span><span class="target" id="cpl__virtualmem_8h_1a4f98d8a992f8bf393719c51c5551c07e"></span>void <code class="descname">CPLVirtualMemPin</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413CPLVirtualMem" title="CPLVirtualMem">CPLVirtualMem</a> *<em>ctxt</em>, void *<em>pAddr</em>, size_t <em>nSize</em>, int <em>bWriteOp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416CPLVirtualMemPinP13CPLVirtualMemPv6size_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Make sure that a region of virtual memory will be realized. </p>
<p>Calling this function is not required, but might be useful when debugging a process with tools like gdb or valgrind that do not naturally like segmentation fault signals.</p>
<p>It is also needed when wanting to provide part of virtual memory mapping to a system call such as read() or write(). If read() or write() is called on a memory region not yet realized, the call will fail with EFAULT.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ctxt</span></code>: context returned by <a class="reference internal" href="#cpl__virtualmem_8h_1ae3f4f669f48fc2755a43566524725878"><span class="std std-ref">CPLVirtualMemNew()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pAddr</span></code>: the memory region to pin. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: the size of the memory region. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bWriteOp</span></code>: set to TRUE if the memory are will be accessed in write mode.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429CPLVirtualMemManagerTerminatev">
<span id="_CPPv329CPLVirtualMemManagerTerminatev"></span><span id="_CPPv229CPLVirtualMemManagerTerminatev"></span><span id="CPLVirtualMemManagerTerminate__void"></span><span class="target" id="cpl__virtualmem_8h_1a33e690c9c5b7f636cd8c0254eba63cb8"></span>void <code class="descname">CPLVirtualMemManagerTerminate</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429CPLVirtualMemManagerTerminatev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cleanup any resource and handlers related to virtual memory. </p>
<p>This function must be called after the last CPLVirtualMem object has been freed.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="cpl-vsi-error-h">
<h2>cpl_vsi_error.h<a class="headerlink" href="#cpl-vsi-error-h" title="Permalink to this headline">¶</a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.VSIE_None">
<span class="target" id="cpl__vsi__error_8h_1a06e016d719166bd3a88b54ef1af78807"></span><code class="descname">VSIE_None</code><a class="headerlink" href="#c.VSIE_None" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_FileError">
<span class="target" id="cpl__vsi__error_8h_1a1ee19b799bf43bf71e1573f5d49df508"></span><code class="descname">VSIE_FileError</code><a class="headerlink" href="#c.VSIE_FileError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_HttpError">
<span class="target" id="cpl__vsi__error_8h_1adbc24f2efd3e459baff9ad6c2b33a4d0"></span><code class="descname">VSIE_HttpError</code><a class="headerlink" href="#c.VSIE_HttpError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_AWSError">
<span class="target" id="cpl__vsi__error_8h_1aa2097acba6f044ab439ab439f824a580"></span><code class="descname">VSIE_AWSError</code><a class="headerlink" href="#c.VSIE_AWSError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_AWSAccessDenied">
<span class="target" id="cpl__vsi__error_8h_1a96cc49b993ad28be7e89feef97163be8"></span><code class="descname">VSIE_AWSAccessDenied</code><a class="headerlink" href="#c.VSIE_AWSAccessDenied" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_AWSBucketNotFound">
<span class="target" id="cpl__vsi__error_8h_1af53b2bf61887bfb51aeba4e49dbf9503"></span><code class="descname">VSIE_AWSBucketNotFound</code><a class="headerlink" href="#c.VSIE_AWSBucketNotFound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_AWSObjectNotFound">
<span class="target" id="cpl__vsi__error_8h_1aac9c7ef6286aa18223958ee5a069c444"></span><code class="descname">VSIE_AWSObjectNotFound</code><a class="headerlink" href="#c.VSIE_AWSObjectNotFound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_AWSInvalidCredentials">
<span class="target" id="cpl__vsi__error_8h_1af69939fd782f4856315c647181301a96"></span><code class="descname">VSIE_AWSInvalidCredentials</code><a class="headerlink" href="#c.VSIE_AWSInvalidCredentials" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.VSIE_AWSSignatureDoesNotMatch">
<span class="target" id="cpl__vsi__error_8h_1ac4947e71b168407d7aea227dab6d5b82"></span><code class="descname">VSIE_AWSSignatureDoesNotMatch</code><a class="headerlink" href="#c.VSIE_AWSSignatureDoesNotMatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv411VSIErrorNum">
<span id="_CPPv311VSIErrorNum"></span><span id="_CPPv211VSIErrorNum"></span><span id="VSIErrorNum"></span><span class="target" id="cpl__vsi__error_8h_1a2a8f195adf8ece34d9b1b76910b78109"></span><em class="property">typedef </em>int <code class="descname">VSIErrorNum</code><a class="headerlink" href="#_CPPv411VSIErrorNum" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv48VSIError11VSIErrorNumPKcz">
<span id="_CPPv38VSIError11VSIErrorNumPKcz"></span><span id="_CPPv28VSIError11VSIErrorNumPKcz"></span><span id="VSIError__VSIErrorNum.cCP.z"></span><span class="target" id="cpl__vsi__error_8h_1aa6c6cbb5ad1ba5a95908650dee5359bb"></span>void <code class="descname">VSIError</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411VSIErrorNum" title="VSIErrorNum">VSIErrorNum</a> <em>err_no</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48VSIError11VSIErrorNumPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report an VSI filesystem error. </p>
<p>This function records an error in the filesystem that may or may not be used in the future, for example converted into a CPLError. This allows filesystem errors to be available to error handling functionality, but reported only when necessary.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">err_no</span></code>: the error number (VSIE_*) from cpl_vsi_error.h. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fmt</span></code>: a printf() style format string. Any additional arguments will be treated as arguments to fill in this format in a manner similar to printf(). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413VSIErrorResetv">
<span id="_CPPv313VSIErrorResetv"></span><span id="_CPPv213VSIErrorResetv"></span><span id="VSIErrorReset__void"></span><span class="target" id="cpl__vsi__error_8h_1a0646ca31e29f05a043649b725dac4dac"></span>void <code class="descname">VSIErrorReset</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413VSIErrorResetv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Erase any traces of previous errors. </p>
<p>This is used to clear out the latest file system error when it is either translated into a CPLError call or when it is determined to be ignorable. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417VSIGetLastErrorNov">
<span id="_CPPv317VSIGetLastErrorNov"></span><span id="_CPPv217VSIGetLastErrorNov"></span><span id="VSIGetLastErrorNo__void"></span><span class="target" id="cpl__vsi__error_8h_1a45be9db0ebde92dbd1b399f546cfe89c"></span><a class="reference internal" href="#_CPPv411VSIErrorNum" title="VSIErrorNum">VSIErrorNum</a> <code class="descname">VSIGetLastErrorNo</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417VSIGetLastErrorNov" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the last error number. </p>
<p>Fetches the last error number posted with VSIError(), that hasn’t been cleared by VSIErrorReset(). This is the error number, not the error class.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the error number of the last error to occur, or VSIE_None (0) if there are no posted errors. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418VSIGetLastErrorMsgv">
<span id="_CPPv318VSIGetLastErrorMsgv"></span><span id="_CPPv218VSIGetLastErrorMsgv"></span><span id="VSIGetLastErrorMsg__void"></span><span class="target" id="cpl__vsi__error_8h_1aab4db00cfe43afef20b95ac4bd25e0bc"></span><em class="property">const</em> char *<code class="descname">VSIGetLastErrorMsg</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418VSIGetLastErrorMsgv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the last error message. </p>
<p>Fetches the last error message posted with VSIError(), that hasn’t been cleared by VSIErrorReset(). The returned pointer is to an internal string that should not be altered or freed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the last error message, or NULL if there is no posted error message. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413VSIToCPLError6CPLErr11CPLErrorNum">
<span id="_CPPv313VSIToCPLError6CPLErr11CPLErrorNum"></span><span id="_CPPv213VSIToCPLError6CPLErr11CPLErrorNum"></span><span id="VSIToCPLError__CPLErr.CPLErrorNum"></span><span class="target" id="cpl__vsi__error_8h_1aabe3fbf4cac0ef0765ccbcbb31c91a9b"></span>int <code class="descname">VSIToCPLError</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <em>eErrClass</em>, <a class="reference internal" href="#_CPPv411CPLErrorNum" title="CPLErrorNum">CPLErrorNum</a> <em>eDefaultErrorNo</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413VSIToCPLError6CPLErr11CPLErrorNum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Translate the VSI error into a CPLError call. </p>
<p>If there is a VSIError that is set, translate it to a CPLError call with the given CPLErr error class, and either an appropriate CPLErrorNum given the VSIErrorNum, or the given default CPLErrorNum.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if a CPLError was issued, or FALSE if not. </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="cpl-vsi-h">
<h2>cpl_vsi.h<a class="headerlink" href="#cpl-vsi-h" title="Permalink to this headline">¶</a></h2>
<p>Standard C Covers. </p>
<p>The VSI functions are intended to be hookable aliases for Standard C I/O, memory allocation and other system functions. They are intended to allow virtualization of disk I/O so that non file data sources can be made to appear as files, and so that additional error trapping and reporting can be interested. The memory access API is aliased so that special application memory management services can be used.</p>
<p>It is intended that each of these functions retains exactly the same calling pattern as the original Standard C functions they relate to. This means we don’t have to provide custom documentation, and also means that the default implementation is very simple. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.VSI_ISLNK">
<span class="target" id="cpl__vsi_8h_1a7e5cdfef2e52acfa6c2d723934e0d796"></span><code class="descname">VSI_ISLNK</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_ISLNK" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the file is a symbolic link. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_ISREG">
<span class="target" id="cpl__vsi_8h_1a57c4561cb89d1e6d0273c5be2a374777"></span><code class="descname">VSI_ISREG</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_ISREG" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the file is a regular file. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_ISDIR">
<span class="target" id="cpl__vsi_8h_1a13e9ada3d2bb3df2eae358b1037f9a1b"></span><code class="descname">VSI_ISDIR</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_ISDIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the file is a directory. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_L_OFFSET_MAX">
<span class="target" id="cpl__vsi_8h_1a20bb0e8c2fc561600efe533babb577aa"></span><code class="descname">VSI_L_OFFSET_MAX</code><a class="headerlink" href="#c.VSI_L_OFFSET_MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum value for a file offset. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSIStatBufL">
<span class="target" id="cpl__vsi_8h_1a05a9e6a14285f31ad3d34390a3d7ac23"></span><code class="descname">VSIStatBufL</code><a class="headerlink" href="#c.VSIStatBufL" title="Permalink to this definition">¶</a></dt>
<dd><p>Type for <a class="reference internal" href="#cpl__vsi_8h_1a2fc1cc4f2893dc422eb57e430798991a"><span class="std std-ref">VSIStatL()</span></a> </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_STAT_EXISTS_FLAG">
<span class="target" id="cpl__vsi_8h_1a3e3fb3d4a5abff8b360d7b7941397503"></span><code class="descname">VSI_STAT_EXISTS_FLAG</code><a class="headerlink" href="#c.VSI_STAT_EXISTS_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag provided to <a class="reference internal" href="#cpl__vsi_8h_1a9bd744516c08f11f8129261a38a5fd29"><span class="std std-ref">VSIStatExL()</span></a> to test if the file exists. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_STAT_NATURE_FLAG">
<span class="target" id="cpl__vsi_8h_1ae67c44d6a3cae38b33d4b4b6bfb02131"></span><code class="descname">VSI_STAT_NATURE_FLAG</code><a class="headerlink" href="#c.VSI_STAT_NATURE_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag provided to <a class="reference internal" href="#cpl__vsi_8h_1a9bd744516c08f11f8129261a38a5fd29"><span class="std std-ref">VSIStatExL()</span></a> to query the nature (file/dir) of the file. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_STAT_SIZE_FLAG">
<span class="target" id="cpl__vsi_8h_1ac4465858df54d216dbade556b08a5d4d"></span><code class="descname">VSI_STAT_SIZE_FLAG</code><a class="headerlink" href="#c.VSI_STAT_SIZE_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag provided to <a class="reference internal" href="#cpl__vsi_8h_1a9bd744516c08f11f8129261a38a5fd29"><span class="std std-ref">VSIStatExL()</span></a> to query the file size. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_STAT_SET_ERROR_FLAG">
<span class="target" id="cpl__vsi_8h_1a0c624636d6673f91667e8460417495e0"></span><code class="descname">VSI_STAT_SET_ERROR_FLAG</code><a class="headerlink" href="#c.VSI_STAT_SET_ERROR_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag provided to <a class="reference internal" href="#cpl__vsi_8h_1a9bd744516c08f11f8129261a38a5fd29"><span class="std std-ref">VSIStatExL()</span></a> to issue a VSIError in case of failure. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_MALLOC_ALIGNED_AUTO_VERBOSE">
<span class="target" id="cpl__vsi_8h_1a7ab86f661220e57cd07d7bc6818183e1"></span><code class="descname">VSI_MALLOC_ALIGNED_AUTO_VERBOSE</code><span class="sig-paren">(</span>size<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_MALLOC_ALIGNED_AUTO_VERBOSE" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#cpl__vsi_8h_1a2d4eef330cb2ff336bad8d43b1e5cd9d"><span class="std std-ref">VSIMallocAlignedAutoVerbose()</span></a> with FILE and LINE reporting. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_MALLOC_VERBOSE">
<span class="target" id="cpl__vsi_8h_1aade5a8741eb3362f68b2c3ee2d1b3676"></span><code class="descname">VSI_MALLOC_VERBOSE</code><span class="sig-paren">(</span>size<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_MALLOC_VERBOSE" title="Permalink to this definition">¶</a></dt>
<dd><p>VSI_MALLOC_VERBOSE. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_MALLOC2_VERBOSE">
<span class="target" id="cpl__vsi_8h_1ac85b87a2d19d51f10ecce10d4ba53570"></span><code class="descname">VSI_MALLOC2_VERBOSE</code><span class="sig-paren">(</span>nSize1, nSize2<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_MALLOC2_VERBOSE" title="Permalink to this definition">¶</a></dt>
<dd><p>VSI_MALLOC2_VERBOSE. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_MALLOC3_VERBOSE">
<span class="target" id="cpl__vsi_8h_1a7325cdd9f33067256f91301e84b96fa1"></span><code class="descname">VSI_MALLOC3_VERBOSE</code><span class="sig-paren">(</span>nSize1, nSize2, nSize3<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_MALLOC3_VERBOSE" title="Permalink to this definition">¶</a></dt>
<dd><p>VSI_MALLOC3_VERBOSE. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_CALLOC_VERBOSE">
<span class="target" id="cpl__vsi_8h_1a0ef6b56ece448880c45976dab915c89c"></span><code class="descname">VSI_CALLOC_VERBOSE</code><span class="sig-paren">(</span>nCount, nSize<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_CALLOC_VERBOSE" title="Permalink to this definition">¶</a></dt>
<dd><p>VSI_CALLOC_VERBOSE. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_REALLOC_VERBOSE">
<span class="target" id="cpl__vsi_8h_1a17f5ad7c5273fadcb66a4410f18fe0b4"></span><code class="descname">VSI_REALLOC_VERBOSE</code><span class="sig-paren">(</span>pOldPtr, nNewSize<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_REALLOC_VERBOSE" title="Permalink to this definition">¶</a></dt>
<dd><p>VSI_REALLOC_VERBOSE. </p>
</dd></dl>

<dl class="macro">
<dt id="c.VSI_STRDUP_VERBOSE">
<span class="target" id="cpl__vsi_8h_1ad5909c421c6d6bd385f6b702a9e7c693"></span><code class="descname">VSI_STRDUP_VERBOSE</code><span class="sig-paren">(</span>pszStr<span class="sig-paren">)</span><a class="headerlink" href="#c.VSI_STRDUP_VERBOSE" title="Permalink to this definition">¶</a></dt>
<dd><p>VSI_STRDUP_VERBOSE. </p>
</dd></dl>

<dl class="macro">
<dt id="c.CPLReadDir">
<span class="target" id="cpl__vsi_8h_1afdc1dc07ba4fe31933c9b522de783692"></span><code class="descname">CPLReadDir</code><a class="headerlink" href="#c.CPLReadDir" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of <a class="reference internal" href="#cpl__vsi_8h_1a6158d73485d6cf92c75b38e7f26d00c3"><span class="std std-ref">VSIReadDir()</span></a> </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv412vsi_l_offset">
<span id="_CPPv312vsi_l_offset"></span><span id="_CPPv212vsi_l_offset"></span><span id="vsi_l_offset"></span><span class="target" id="cpl__vsi_8h_1af56f9ebab1994e4c2ed3f0a50af787b2"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv48GUIntBig" title="GUIntBig">GUIntBig</a> <code class="descname">vsi_l_offset</code><a class="headerlink" href="#_CPPv412vsi_l_offset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type for a file offset. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv48VSILFILE">
<span id="_CPPv38VSILFILE"></span><span id="_CPPv28VSILFILE"></span><span id="VSILFILE"></span><span class="target" id="cpl__vsi_8h_1af1b1400e402360b38304de2b13d16c14"></span><em class="property">typedef </em>FILE <code class="descname">VSILFILE</code><a class="headerlink" href="#_CPPv48VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a FILE that implements the <a class="reference internal" href="#classVSIVirtualHandle"><span class="std std-ref">VSIVirtualHandle</span></a> API. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv46VSIDIR">
<span id="_CPPv36VSIDIR"></span><span id="_CPPv26VSIDIR"></span><span id="VSIDIR"></span><span class="target" id="cpl__vsi_8h_1a6abfa965a6cceea416b192b38c90f9ad"></span><em class="property">typedef </em><em class="property">struct</em> <a class="reference internal" href="#_CPPv46VSIDIR" title="VSIDIR">VSIDIR</a> <code class="descname">VSIDIR</code><a class="headerlink" href="#_CPPv46VSIDIR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a directory iterator. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv416VSIWriteFunction">
<span id="_CPPv316VSIWriteFunction"></span><span id="_CPPv216VSIWriteFunction"></span><span id="VSIWriteFunction"></span><span class="target" id="cpl__vsi_8h_1a121ccf7fcbd054704350f72be08adec8"></span><em class="property">typedef </em>size_t (*<code class="descname">VSIWriteFunction</code>)<span class="sig-paren">(</span><em class="property">const</em> void *ptr, size_t size, size_t nmemb, FILE *stream<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416VSIWriteFunction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback used by <a class="reference internal" href="#cpl__vsi_8h_1adc4a67cc303d7662c34f506d0bdddd79"><span class="std std-ref">VSIStdoutSetRedirection()</span></a> </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv431VSIFilesystemPluginStatCallback">
<span id="_CPPv331VSIFilesystemPluginStatCallback"></span><span id="_CPPv231VSIFilesystemPluginStatCallback"></span><span id="VSIFilesystemPluginStatCallback"></span><span class="target" id="cpl__vsi_8h_1a94d3d7c93b141ad3947a696dd298781a"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginStatCallback</code>)<span class="sig-paren">(</span>void *pUserData, <em class="property">const</em> char *pszFilename, VSIStatBufL *pStatBuf, int nFlags<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431VSIFilesystemPluginStatCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return information about a handle. </p>
<p>Optional (driver dependent) <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv433VSIFilesystemPluginUnlinkCallback">
<span id="_CPPv333VSIFilesystemPluginUnlinkCallback"></span><span id="_CPPv233VSIFilesystemPluginUnlinkCallback"></span><span id="VSIFilesystemPluginUnlinkCallback"></span><span class="target" id="cpl__vsi_8h_1abfad10f0726010c7b046b2a9153e496b"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginUnlinkCallback</code>)<span class="sig-paren">(</span>void *pUserData, <em class="property">const</em> char *pszFilename<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433VSIFilesystemPluginUnlinkCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove handle by name. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv433VSIFilesystemPluginRenameCallback">
<span id="_CPPv333VSIFilesystemPluginRenameCallback"></span><span id="_CPPv233VSIFilesystemPluginRenameCallback"></span><span id="VSIFilesystemPluginRenameCallback"></span><span class="target" id="cpl__vsi_8h_1a46d7066fe0aadaab4d2be154c100a1b2"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginRenameCallback</code>)<span class="sig-paren">(</span>void *pUserData, <em class="property">const</em> char *oldpath, <em class="property">const</em> char *newpath<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433VSIFilesystemPluginRenameCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Rename handle. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv432VSIFilesystemPluginMkdirCallback">
<span id="_CPPv332VSIFilesystemPluginMkdirCallback"></span><span id="_CPPv232VSIFilesystemPluginMkdirCallback"></span><span id="VSIFilesystemPluginMkdirCallback"></span><span class="target" id="cpl__vsi_8h_1a6f54d817dbcfce03ce9610f3bc76185b"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginMkdirCallback</code>)<span class="sig-paren">(</span>void *pUserData, <em class="property">const</em> char *pszDirname, long nMode<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432VSIFilesystemPluginMkdirCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create Directory. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv432VSIFilesystemPluginRmdirCallback">
<span id="_CPPv332VSIFilesystemPluginRmdirCallback"></span><span id="_CPPv232VSIFilesystemPluginRmdirCallback"></span><span id="VSIFilesystemPluginRmdirCallback"></span><span class="target" id="cpl__vsi_8h_1afdedd1069c545b7fe216a209fd6767a3"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginRmdirCallback</code>)<span class="sig-paren">(</span>void *pUserData, <em class="property">const</em> char *pszDirname<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432VSIFilesystemPluginRmdirCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete Directory. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv434VSIFilesystemPluginReadDirCallback">
<span id="_CPPv334VSIFilesystemPluginReadDirCallback"></span><span id="_CPPv234VSIFilesystemPluginReadDirCallback"></span><span id="VSIFilesystemPluginReadDirCallback"></span><span class="target" id="cpl__vsi_8h_1a5375b18a338bd51e92e3496d23e7c491"></span><em class="property">typedef </em>char **(*<code class="descname">VSIFilesystemPluginReadDirCallback</code>)<span class="sig-paren">(</span>void *pUserData, <em class="property">const</em> char *pszDirname, int nMaxFiles<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434VSIFilesystemPluginReadDirCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List directory content. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv431VSIFilesystemPluginOpenCallback">
<span id="_CPPv331VSIFilesystemPluginOpenCallback"></span><span id="_CPPv231VSIFilesystemPluginOpenCallback"></span><span id="VSIFilesystemPluginOpenCallback"></span><span class="target" id="cpl__vsi_8h_1a5fb10302b47889ece6b19479a81f05bc"></span><em class="property">typedef </em>void *(*<code class="descname">VSIFilesystemPluginOpenCallback</code>)<span class="sig-paren">(</span>void *pUserData, <em class="property">const</em> char *pszFilename, <em class="property">const</em> char *pszAccess<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431VSIFilesystemPluginOpenCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open a handle. </p>
<p>Mandatory. Returns an opaque pointer that will be used in subsequent file I/O calls. Should return null and/or set errno if the handle does not exist or the access mode is incorrect. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv431VSIFilesystemPluginTellCallback">
<span id="_CPPv331VSIFilesystemPluginTellCallback"></span><span id="_CPPv231VSIFilesystemPluginTellCallback"></span><span id="VSIFilesystemPluginTellCallback"></span><span class="target" id="cpl__vsi_8h_1a3522495c9dd6b480828847e06f573781"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> (*<code class="descname">VSIFilesystemPluginTellCallback</code>)<span class="sig-paren">(</span>void *pFile<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431VSIFilesystemPluginTellCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return current position in handle. </p>
<p>Mandatory <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv431VSIFilesystemPluginSeekCallback">
<span id="_CPPv331VSIFilesystemPluginSeekCallback"></span><span id="_CPPv231VSIFilesystemPluginSeekCallback"></span><span id="VSIFilesystemPluginSeekCallback"></span><span class="target" id="cpl__vsi_8h_1a93db78968a0bc9d5b859a5f1ab9d579d"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginSeekCallback</code>)<span class="sig-paren">(</span>void *pFile, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> nOffset, int nWhence<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431VSIFilesystemPluginSeekCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Seek to position in handle. </p>
<p>Mandatory except for write only handles <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv431VSIFilesystemPluginReadCallback">
<span id="_CPPv331VSIFilesystemPluginReadCallback"></span><span id="_CPPv231VSIFilesystemPluginReadCallback"></span><span id="VSIFilesystemPluginReadCallback"></span><span class="target" id="cpl__vsi_8h_1a2bb9bc1c9e4faa76fe1395c5a2ecfc13"></span><em class="property">typedef </em>size_t (*<code class="descname">VSIFilesystemPluginReadCallback</code>)<span class="sig-paren">(</span>void *pFile, void *pBuffer, size_t nSize, size_t nCount<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431VSIFilesystemPluginReadCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read data from current position, returns the number of blocks correctly read. </p>
<p>Mandatory except for write only handles <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv441VSIFilesystemPluginReadMultiRangeCallback">
<span id="_CPPv341VSIFilesystemPluginReadMultiRangeCallback"></span><span id="_CPPv241VSIFilesystemPluginReadMultiRangeCallback"></span><span id="VSIFilesystemPluginReadMultiRangeCallback"></span><span class="target" id="cpl__vsi_8h_1a2253223aadc64bea6904fd485eede527"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginReadMultiRangeCallback</code>)<span class="sig-paren">(</span>void *pFile, int nRanges, void **ppData, <em class="property">const</em> <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> *panOffsets, <em class="property">const</em> size_t *panSizes<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv441VSIFilesystemPluginReadMultiRangeCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read from multiple offsets. </p>
<p>Optional, will be replaced by multiple calls to Read() if not provided <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv441VSIFilesystemPluginGetRangeStatusCallback">
<span id="_CPPv341VSIFilesystemPluginGetRangeStatusCallback"></span><span id="_CPPv241VSIFilesystemPluginGetRangeStatusCallback"></span><span id="VSIFilesystemPluginGetRangeStatusCallback"></span><span class="target" id="cpl__vsi_8h_1a8adeb34e38b0bd646643e18d016fe47d"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv414VSIRangeStatus" title="VSIRangeStatus">VSIRangeStatus</a> (*<code class="descname">VSIFilesystemPluginGetRangeStatusCallback</code>)<span class="sig-paren">(</span>void *pFile, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> nOffset, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> nLength<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv441VSIFilesystemPluginGetRangeStatusCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get empty ranges. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv430VSIFilesystemPluginEofCallback">
<span id="_CPPv330VSIFilesystemPluginEofCallback"></span><span id="_CPPv230VSIFilesystemPluginEofCallback"></span><span id="VSIFilesystemPluginEofCallback"></span><span class="target" id="cpl__vsi_8h_1acff9cabb436bd411346471369bee545d"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginEofCallback</code>)<span class="sig-paren">(</span>void *pFile<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430VSIFilesystemPluginEofCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Has end of file been reached. </p>
<p>Mandatory? for read handles. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv432VSIFilesystemPluginWriteCallback">
<span id="_CPPv332VSIFilesystemPluginWriteCallback"></span><span id="_CPPv232VSIFilesystemPluginWriteCallback"></span><span id="VSIFilesystemPluginWriteCallback"></span><span class="target" id="cpl__vsi_8h_1a7bb9cabc545c740a05dfe0dc2c237834"></span><em class="property">typedef </em>size_t (*<code class="descname">VSIFilesystemPluginWriteCallback</code>)<span class="sig-paren">(</span>void *pFile, <em class="property">const</em> void *pBuffer, size_t nSize, size_t nCount<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432VSIFilesystemPluginWriteCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write bytes at current offset. </p>
<p>Mandatory for writable handles <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv432VSIFilesystemPluginFlushCallback">
<span id="_CPPv332VSIFilesystemPluginFlushCallback"></span><span id="_CPPv232VSIFilesystemPluginFlushCallback"></span><span id="VSIFilesystemPluginFlushCallback"></span><span class="target" id="cpl__vsi_8h_1aed880694c27b9f94fd619c6ba81bf3fe"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginFlushCallback</code>)<span class="sig-paren">(</span>void *pFile<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432VSIFilesystemPluginFlushCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sync written bytes. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv435VSIFilesystemPluginTruncateCallback">
<span id="_CPPv335VSIFilesystemPluginTruncateCallback"></span><span id="_CPPv235VSIFilesystemPluginTruncateCallback"></span><span id="VSIFilesystemPluginTruncateCallback"></span><span class="target" id="cpl__vsi_8h_1a700c550a3f060ef72be35a639fa67775"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginTruncateCallback</code>)<span class="sig-paren">(</span>void *pFile, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> nNewSize<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435VSIFilesystemPluginTruncateCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Truncate handle. </p>
<p>Mandatory (driver dependent?) for write handles </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv432VSIFilesystemPluginCloseCallback">
<span id="_CPPv332VSIFilesystemPluginCloseCallback"></span><span id="_CPPv232VSIFilesystemPluginCloseCallback"></span><span id="VSIFilesystemPluginCloseCallback"></span><span class="target" id="cpl__vsi_8h_1a6a9c46d54ad75e6914322a84ced153f5"></span><em class="property">typedef </em>int (*<code class="descname">VSIFilesystemPluginCloseCallback</code>)<span class="sig-paren">(</span>void *pFile<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432VSIFilesystemPluginCloseCallback" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close file handle. </p>
<p>Optional <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv414VSIRangeStatus">
<span id="_CPPv314VSIRangeStatus"></span><span id="_CPPv214VSIRangeStatus"></span><span class="target" id="cpl__vsi_8h_1a2aa5b80209e71d81a118d647c6a9be66"></span><em class="property">enum </em><code class="descname">VSIRangeStatus</code><a class="headerlink" href="#_CPPv414VSIRangeStatus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Range status. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv424VSI_RANGE_STATUS_UNKNOWN">
<span id="_CPPv324VSI_RANGE_STATUS_UNKNOWN"></span><span id="_CPPv224VSI_RANGE_STATUS_UNKNOWN"></span><span class="target" id="cpl__vsi_8h_1a2aa5b80209e71d81a118d647c6a9be66a68ea00493f4c073e19da9613d1d3d630"></span><code class="descname">VSI_RANGE_STATUS_UNKNOWN</code><a class="headerlink" href="#_CPPv424VSI_RANGE_STATUS_UNKNOWN" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unknown. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv421VSI_RANGE_STATUS_DATA">
<span id="_CPPv321VSI_RANGE_STATUS_DATA"></span><span id="_CPPv221VSI_RANGE_STATUS_DATA"></span><span class="target" id="cpl__vsi_8h_1a2aa5b80209e71d81a118d647c6a9be66a20f1d70259ba20c9c8767fed7b0a7119"></span><code class="descname">VSI_RANGE_STATUS_DATA</code><a class="headerlink" href="#_CPPv421VSI_RANGE_STATUS_DATA" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Data present. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv421VSI_RANGE_STATUS_HOLE">
<span id="_CPPv321VSI_RANGE_STATUS_HOLE"></span><span id="_CPPv221VSI_RANGE_STATUS_HOLE"></span><span class="target" id="cpl__vsi_8h_1a2aa5b80209e71d81a118d647c6a9be66a4518228a517000ca00f132bc67ac6dc7"></span><code class="descname">VSI_RANGE_STATUS_HOLE</code><a class="headerlink" href="#_CPPv421VSI_RANGE_STATUS_HOLE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Hole. </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv49VSIFOpenLPKcPKc">
<span id="_CPPv39VSIFOpenLPKcPKc"></span><span id="_CPPv29VSIFOpenLPKcPKc"></span><span id="VSIFOpenL__cCP.cCP"></span><span class="target" id="cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"></span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<code class="descname">VSIFOpenL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, <em class="property">const</em> char *<em>pszAccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIFOpenLPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open file. </p>
<p>This function opens a file with the desired access. Large files (larger than 2GB) should be supported. Binary access is always implied and the “b” does not need to be included in the pszAccess string.</p>
<p>Note that the “VSILFILE *” returned since GDAL 1.8.0 by this function is <em>NOT</em> a standard C library FILE *, and cannot be used with any functions other than the “VSI*L” family of functions. They aren’t “real” FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, restoring the pre-1.8.0 behavior of <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fopen() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on failure, or the file handle. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the file to open. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszAccess</span></code>: access requested (i.e. “r”, “r+”, “w”)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411VSIFOpenExLPKcPKci">
<span id="_CPPv311VSIFOpenExLPKcPKci"></span><span id="_CPPv211VSIFOpenExLPKcPKci"></span><span id="VSIFOpenExL__cCP.cCP.i"></span><span class="target" id="cpl__vsi_8h_1ace0a2c35f1214c39546192e192d9322f"></span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<code class="descname">VSIFOpenExL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, <em class="property">const</em> char *<em>pszAccess</em>, int <em>bSetError</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411VSIFOpenExLPKcPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open file. </p>
<p>This function opens a file with the desired access. Large files (larger than 2GB) should be supported. Binary access is always implied and the “b” does not need to be included in the pszAccess string.</p>
<p>Note that the “VSILFILE *” returned by this function is <em>NOT</em> a standard C library FILE *, and cannot be used with any functions other than the “VSI*L” family of functions. They aren’t “real” FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, restoring the pre-1.8.0 behavior of <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fopen() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on failure, or the file handle.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the file to open. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszAccess</span></code>: access requested (i.e. “r”, “r+”, “w”) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bSetError</span></code>: flag determining whether or not this open call should set VSIErrors on failure.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIFCloseLP8VSILFILE">
<span id="_CPPv310VSIFCloseLP8VSILFILE"></span><span id="_CPPv210VSIFCloseLP8VSILFILE"></span><span id="VSIFCloseL__VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1ae7fe3eb9b2988c5a3c74889697f87e45"></span>int <code class="descname">VSIFCloseL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIFCloseLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close file. </p>
<p>This function closes the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fclose() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. Passing a nullptr produces undefined behavior.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIFSeekLP8VSILFILE12vsi_l_offseti">
<span id="_CPPv39VSIFSeekLP8VSILFILE12vsi_l_offseti"></span><span id="_CPPv29VSIFSeekLP8VSILFILE12vsi_l_offseti"></span><span id="VSIFSeekL__VSILFILEP.vsi_l_offset.i"></span><span class="target" id="cpl__vsi_8h_1ab32d81e8bf69e8e6e87f0aadf0a490c3"></span>int <code class="descname">VSIFSeekL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nOffset</em>, int <em>nWhence</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIFSeekLP8VSILFILE12vsi_l_offseti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Seek to requested offset. </p>
<p>Seek to the desired offset (nOffset) in the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fseek() call.</p>
<p>Caution: vsi_l_offset is a unsigned type, so SEEK_CUR can only be used for positive seek. If negative seek is needed, use VSIFSeekL( fp, VSIFTellL(fp) + negative_offset, SEEK_SET ).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 one failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: offset in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nWhence</span></code>: one of SEEK_SET, SEEK_CUR or SEEK_END.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIFTellLP8VSILFILE">
<span id="_CPPv39VSIFTellLP8VSILFILE"></span><span id="_CPPv29VSIFTellLP8VSILFILE"></span><span id="VSIFTellL__VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1ad8bacb4bbdbd8474a1ec2236199549e3"></span><a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <code class="descname">VSIFTellL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIFTellLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tell current file offset. </p>
<p>Returns the current file read/write offset in bytes from the beginning of the file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftell() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>file offset in bytes. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIRewindLP8VSILFILE">
<span id="_CPPv310VSIRewindLP8VSILFILE"></span><span id="_CPPv210VSIRewindLP8VSILFILE"></span><span id="VSIRewindL__VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1abbbc227f7c966e95ece4691c3cc1c562"></span>void <code class="descname">VSIRewindL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIRewindLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Rewind the file pointer to the beginning of the file. </p>
<p>This is equivalent to VSIFSeekL( fp, 0, SEEK_SET )</p>
<p>Analog of the POSIX rewind() call.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIFReadLPv6size_t6size_tP8VSILFILE">
<span id="_CPPv39VSIFReadLPv6size_t6size_tP8VSILFILE"></span><span id="_CPPv29VSIFReadLPv6size_t6size_tP8VSILFILE"></span><span id="VSIFReadL__voidP.s.s.VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1a3e64279a239eef70703efc09f43585e9"></span>size_t <code class="descname">VSIFReadL</code><span class="sig-paren">(</span>void *<em>pBuffer</em>, size_t <em>nSize</em>, size_t <em>nCount</em>, <a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIFReadLPv6size_t6size_tP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read bytes from file. </p>
<p>Reads nCount objects of nSize bytes from the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fread() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of objects successfully read. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pBuffer</span></code>: the buffer into which the data should be read (at least nCount * nSize bytes in size. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: size of objects to read in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: number of objects to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419VSIFReadMultiRangeLiPPvPK12vsi_l_offsetPK6size_tP8VSILFILE">
<span id="_CPPv319VSIFReadMultiRangeLiPPvPK12vsi_l_offsetPK6size_tP8VSILFILE"></span><span id="_CPPv219VSIFReadMultiRangeLiPPvPK12vsi_l_offsetPK6size_tP8VSILFILE"></span><span id="VSIFReadMultiRangeL__i.voidPP.vsi_l_offsetCP.sCP.VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1a7637441ad8a51cdc200e926579f48986"></span>int <code class="descname">VSIFReadMultiRangeL</code><span class="sig-paren">(</span>int <em>nRanges</em>, void **<em>ppData</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> *<em>panOffsets</em>, <em class="property">const</em> size_t *<em>panSizes</em>, <a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419VSIFReadMultiRangeLiPPvPK12vsi_l_offsetPK6size_tP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read several ranges of bytes from file. </p>
<p>Reads nRanges objects of panSizes[i] bytes from the indicated file at the offset panOffsets[i] into the buffer ppData[i].</p>
<p>Ranges must be sorted in ascending start offset, and must not overlap each other.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory or /vsicurl/.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 in case of success, -1 otherwise. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nRanges</span></code>: number of ranges to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppData</span></code>: array of nRanges buffer into which the data should be read (ppData[i] must be at list panSizes[i] bytes). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panOffsets</span></code>: array of nRanges offsets at which the data should be read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panSizes</span></code>: array of nRanges sizes of objects to read (in bytes). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIFWriteLPKv6size_t6size_tP8VSILFILE">
<span id="_CPPv310VSIFWriteLPKv6size_t6size_tP8VSILFILE"></span><span id="_CPPv210VSIFWriteLPKv6size_t6size_tP8VSILFILE"></span><span id="VSIFWriteL__voidCP.s.s.VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1a05e59f50d000a7c6ca7dce76ba5946f9"></span>size_t <code class="descname">VSIFWriteL</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>pBuffer</em>, size_t <em>nSize</em>, size_t <em>nCount</em>, <a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIFWriteLPKv6size_t6size_tP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write bytes to file. </p>
<p>Writess nCount objects of nSize bytes to the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fwrite() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of objects successfully written. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pBuffer</span></code>: the buffer from which the data should be written (at least nCount * nSize bytes in size. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: size of objects to read in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: number of objects to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48VSIFEofLP8VSILFILE">
<span id="_CPPv38VSIFEofLP8VSILFILE"></span><span id="_CPPv28VSIFEofLP8VSILFILE"></span><span id="VSIFEofL__VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1a41f16dba458b87271269c8c4cb39ade6"></span>int <code class="descname">VSIFEofL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48VSIFEofLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for end of file. </p>
<p>Returns TRUE (non-zero) if an end-of-file condition occurred during the previous read operation. The end-of-file flag is cleared by a successful <a class="reference internal" href="#cpl__vsi_8h_1ab32d81e8bf69e8e6e87f0aadf0a490c3"><span class="std std-ref">VSIFSeekL()</span></a> call.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX feof() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if at EOF else FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413VSIFTruncateLP8VSILFILE12vsi_l_offset">
<span id="_CPPv313VSIFTruncateLP8VSILFILE12vsi_l_offset"></span><span id="_CPPv213VSIFTruncateLP8VSILFILE12vsi_l_offset"></span><span id="VSIFTruncateL__VSILFILEP.vsi_l_offset"></span><span class="target" id="cpl__vsi_8h_1a2ce7a020522db02f0324734e2b86d84c"></span>int <code class="descname">VSIFTruncateL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nNewSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413VSIFTruncateLP8VSILFILE12vsi_l_offset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Truncate/expand the file to the specified size. </p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftruncate() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nNewSize</span></code>: new size in bytes.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIFFlushLP8VSILFILE">
<span id="_CPPv310VSIFFlushLP8VSILFILE"></span><span id="_CPPv210VSIFFlushLP8VSILFILE"></span><span id="VSIFFlushL__VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1ac52ca4651926531e79e047709c9ea346"></span>int <code class="descname">VSIFFlushL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIFFlushLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush pending writes to disk. </p>
<p>For files in write or update mode and on filesystem types where it is applicable, all pending output on the file is flushed to the physical disk.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fflush() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411VSIFPrintfLP8VSILFILEPKcz">
<span id="_CPPv311VSIFPrintfLP8VSILFILEPKcz"></span><span id="_CPPv211VSIFPrintfLP8VSILFILEPKcz"></span><span id="VSIFPrintfL__VSILFILEP.cCP.z"></span><span class="target" id="cpl__vsi_8h_1a6bb02b3133f6e66a44c1cd6c7a251722"></span>int <code class="descname">VSIFPrintfL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, <em class="property">const</em> char *<em>pszFormat</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411VSIFPrintfLP8VSILFILEPKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Formatted write to file. </p>
<p>Provides fprintf() style formatted output to a VSI*L file. This formats an internal buffer which is written using <a class="reference internal" href="#cpl__vsi_8h_1a05e59f50d000a7c6ca7dce76ba5946f9"><span class="std std-ref">VSIFWriteL()</span></a>.</p>
<p>Analog of the POSIX fprintf() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of bytes written or -1 on an error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFormat</span></code>: the printf() style format string.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIFPutcLiP8VSILFILE">
<span id="_CPPv39VSIFPutcLiP8VSILFILE"></span><span id="_CPPv29VSIFPutcLiP8VSILFILE"></span><span id="VSIFPutcL__i.VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1ac42c63c8266a2adc9ecbe5c8a15efa9f"></span>int <code class="descname">VSIFPutcL</code><span class="sig-paren">(</span>int <em>nChar</em>, <a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIFPutcLiP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a single byte to the file. </p>
<p>Writes the character nChar, cast to an unsigned char, to file.</p>
<p>Almost an analog of the POSIX fputc() call, except that it returns the number of character written (1 or 0), and not the (cast) character itself or EOF.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>1 in case of success, 0 on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nChar</span></code>: character to write. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419VSIFGetRangeStatusLP8VSILFILE12vsi_l_offset12vsi_l_offset">
<span id="_CPPv319VSIFGetRangeStatusLP8VSILFILE12vsi_l_offset12vsi_l_offset"></span><span id="_CPPv219VSIFGetRangeStatusLP8VSILFILE12vsi_l_offset12vsi_l_offset"></span><span id="VSIFGetRangeStatusL__VSILFILEP.vsi_l_offset.vsi_l_offset"></span><span class="target" id="cpl__vsi_8h_1a0e748fc4b8a074da08095bd91fff8fed"></span><a class="reference internal" href="#_CPPv414VSIRangeStatus" title="VSIRangeStatus">VSIRangeStatus</a> <code class="descname">VSIFGetRangeStatusL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nStart</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419VSIFGetRangeStatusLP8VSILFILE12vsi_l_offset12vsi_l_offset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if a given file range contains data or holes filled with zeroes. </p>
<p>This uses the filesystem capabilities of querying which regions of a sparse file are allocated or not. This is currently only implemented for Linux (and no other Unix derivatives) and Windows.</p>
<p><p>Note: A return of VSI_RANGE_STATUS_DATA doesn’t exclude that the extent is filled with zeroes! It must be interpreted as “may</p>
<p>contain non-zero data”.</p>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>extent status: VSI_RANGE_STATUS_UNKNOWN, VSI_RANGE_STATUS_DATA or VSI_RANGE_STATUS_HOLE </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: offset of the start of the extent. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLength</span></code>: extent length.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413VSIIngestFileP8VSILFILEPKcPP5GByteP12vsi_l_offset7GIntBig">
<span id="_CPPv313VSIIngestFileP8VSILFILEPKcPP5GByteP12vsi_l_offset7GIntBig"></span><span id="_CPPv213VSIIngestFileP8VSILFILEPKcPP5GByteP12vsi_l_offset7GIntBig"></span><span id="VSIIngestFile__VSILFILEP.cCP.GBytePP.vsi_l_offsetP.GIntBig"></span><span class="target" id="cpl__vsi_8h_1a9d1d497584c01f156cda57b30de447dc"></span>int <code class="descname">VSIIngestFile</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em>, <em class="property">const</em> char *<em>pszFilename</em>, <a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> **<em>ppabyRet</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> *<em>pnSize</em>, <a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <em>nMaxSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413VSIIngestFileP8VSILFILEPKcPP5GByteP12vsi_l_offset7GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ingest a file into memory. </p>
<p>Read the whole content of a file into a memory buffer.</p>
<p>Either fp or pszFilename can be NULL, but not both at the same time.</p>
<p>If fp is passed non-NULL, it is the responsibility of the caller to close it.</p>
<p>If non-NULL, the returned buffer is guaranteed to be NUL-terminated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE in case of success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: filename. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppabyRet</span></code>: pointer to the target buffer. *ppabyRet must be freed with <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnSize</span></code>: pointer to variable to store the file size. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxSize</span></code>: maximum size of file allowed. If no limit, set to a negative value.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416VSIOverwriteFileP8VSILFILEPKc">
<span id="_CPPv316VSIOverwriteFileP8VSILFILEPKc"></span><span id="_CPPv216VSIOverwriteFileP8VSILFILEPKc"></span><span id="VSIOverwriteFile__VSILFILEP.cCP"></span><span class="target" id="cpl__vsi_8h_1aee0f456d7e6579d15a0cdc5f2d42104d"></span>int <code class="descname">VSIOverwriteFile</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fpTarget</em>, <em class="property">const</em> char *<em>pszSourceFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416VSIOverwriteFileP8VSILFILEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Overwrite an existing file with content from another one. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE in case of success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fpTarget</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a> with “rb+” flag. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSourceFilename</span></code>: source filename</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48VSIStatLPKcP11VSIStatBufL">
<span id="_CPPv38VSIStatLPKcP11VSIStatBufL"></span><span id="_CPPv28VSIStatLPKcP11VSIStatBufL"></span><span id="VSIStatL__cCP.VSIStatBufLP"></span><span class="target" id="cpl__vsi_8h_1a2fc1cc4f2893dc422eb57e430798991a"></span>int <code class="descname">VSIStatL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, VSIStatBufL *<em>psStatBuf</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48VSIStatLPKcP11VSIStatBufL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability, only use the st_size (size in bytes) and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the path of the filesystem object to be queried. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psStatBuf</span></code>: the structure to load with information.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIStatExLPKcP11VSIStatBufLi">
<span id="_CPPv310VSIStatExLPKcP11VSIStatBufLi"></span><span id="_CPPv210VSIStatExLPKcP11VSIStatBufLi"></span><span id="VSIStatExL__cCP.VSIStatBufLP.i"></span><span class="target" id="cpl__vsi_8h_1a9bd744516c08f11f8129261a38a5fd29"></span>int <code class="descname">VSIStatExL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, VSIStatBufL *<em>psStatBuf</em>, int <em>nFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIStatExLPKcP11VSIStatBufLi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability, only use the st_size (size in bytes) and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function, with an extra parameter to specify which information is needed, which offers a potential for speed optimizations on specialized and potentially slow virtual filesystem objects (/vsigzip/, /vsicurl/)</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the path of the filesystem object to be queried. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psStatBuf</span></code>: the structure to load with information. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFlags</span></code>: 0 to get all information, or VSI_STAT_EXISTS_FLAG, VSI_STAT_NATURE_FLAG or VSI_STAT_SIZE_FLAG, or a combination of those to get partial info.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420VSIIsCaseSensitiveFSPKc">
<span id="_CPPv320VSIIsCaseSensitiveFSPKc"></span><span id="_CPPv220VSIIsCaseSensitiveFSPKc"></span><span id="VSIIsCaseSensitiveFS__cCP"></span><span class="target" id="cpl__vsi_8h_1a36737f0cb2949ba2f7bbf23cc6592a04"></span>int <code class="descname">VSIIsCaseSensitiveFS</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420VSIIsCaseSensitiveFSPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns if the filenames of the filesystem are case sensitive. </p>
<p>This method retrieves to which filesystem belongs the passed filename and return TRUE if the filenames of that filesystem are case sensitive.</p>
<p>Currently, this will return FALSE only for Windows real filenames. Other VSI virtual filesystems are case sensitive.</p>
<p>This methods avoid ugly #ifndef WIN32 / #endif code, that is wrong when dealing with virtual filenames.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the filenames of the filesystem are case sensitive.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the path of the filesystem object to be tested. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422VSISupportsSparseFilesPKc">
<span id="_CPPv322VSISupportsSparseFilesPKc"></span><span id="_CPPv222VSISupportsSparseFilesPKc"></span><span id="VSISupportsSparseFiles__cCP"></span><span class="target" id="cpl__vsi_8h_1a6d1bc0831510b6d134fa4d865b2f1328"></span>int <code class="descname">VSISupportsSparseFiles</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422VSISupportsSparseFilesPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns if the filesystem supports sparse files. </p>
<p>Only supported on Linux (and no other Unix derivatives) and Windows. On Linux, the answer depends on a few hardcoded signatures for common filesystems. Other filesystems will be considered as not supporting sparse files.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the file system is known to support sparse files. FALSE may be returned both in cases where it is known to not support them, or when it is unknown.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the path of the filesystem object to be tested. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429VSIHasOptimizedReadMultiRangePKc">
<span id="_CPPv329VSIHasOptimizedReadMultiRangePKc"></span><span id="_CPPv229VSIHasOptimizedReadMultiRangePKc"></span><span id="VSIHasOptimizedReadMultiRange__cCP"></span><span class="target" id="cpl__vsi_8h_1a40f2fd6f6c0676f27eb1bfdec56753a9"></span>int <code class="descname">VSIHasOptimizedReadMultiRange</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429VSIHasOptimizedReadMultiRangePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns if the filesystem supports efficient multi-range reading. </p>
<p>Currently only returns TRUE for /vsicurl/ and derived file systems.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the file system is known to have an efficient multi-range reading.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the path of the filesystem object to be tested. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415VSIGetActualURLPKc">
<span id="_CPPv315VSIGetActualURLPKc"></span><span id="_CPPv215VSIGetActualURLPKc"></span><span id="VSIGetActualURL__cCP"></span><span class="target" id="cpl__vsi_8h_1a0cc60b3e3bf1e892313f2abf0bcfaffd"></span><em class="property">const</em> char *<code class="descname">VSIGetActualURL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415VSIGetActualURLPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the actual URL of a supplied filename. </p>
<p>Currently only returns a non-NULL value for network-based virtual file systems. For example “/vsis3/bucket/filename” will be expanded as “https://bucket.s3.amazon.com/filename”</p>
<p>Note that the lifetime of the returned string, is short, and may be invalidated by any following GDAL functions.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the actual URL corresponding to the supplied filename, or NULL. Should not be freed.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the path of the filesystem object. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415VSIGetSignedURLPKc12CSLConstList">
<span id="_CPPv315VSIGetSignedURLPKc12CSLConstList"></span><span id="_CPPv215VSIGetSignedURLPKc12CSLConstList"></span><span id="VSIGetSignedURL__cCP.CSLConstList"></span><span class="target" id="cpl__vsi_8h_1a9b7d8fe76bc6c58fce962424574f0325"></span>char *<code class="descname">VSIGetSignedURL</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, <a class="reference internal" href="#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415VSIGetSignedURLPKc12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a signed URL of a supplied filename. </p>
<p>Currently only returns a non-NULL value for /vsis3/, /vsigs/, /vsiaz/ and /vsioss/ For example “/vsis3/bucket/filename” will be expanded as “https://bucket.s3.amazon.com/filename?X-Amz-Algorithm=AWS4-HMAC-SHA256…” Configuration options that apply for file opening (typically to provide credentials), and are returned by <a class="reference internal" href="#cpl__vsi_8h_1a85ca54aa40490c9237e9dd2905d9daac"><span class="std std-ref">VSIGetFileSystemOptions()</span></a>, are also valid in that context.</p>
<p><p>/vsiaz/ supports additional options: </p>
<ul class="simple">
<li><p>SIGNEDIDENTIFIER=value: to relate the given shared access signature to a corresponding stored access policy. </p></li>
<li><p>SIGNEDPERMISSIONS=r|w: permissions associated with the shared access signature. Normally deduced from VERB. </p></li>
</ul>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the path of the filesystem object. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: list of options, or NULL. Depend on file system handler. For /vsis3/, /vsigs/, /vsiaz/ and /vsioss/, the following options are supported: <ul>
<li><p>START_DATE=YYMMDDTHHMMSSZ: date and time in UTC following ISO 8601 standard, corresponding to the start of validity of the URL. If not specified, current date time. </p></li>
<li><p>EXPIRATION_DELAY=number_of_seconds: number between 1 and 604800 (seven days) for the validity of the signed URL. Defaults to 3600 (one hour) </p></li>
<li><p>VERB=GET/HEAD/DELETE/PUT/POST: HTTP VERB for which the request will be used. Default to GET. </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a signed URL, or NULL. Should be freed with <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423VSIGetFileSystemOptionsPKc">
<span id="_CPPv323VSIGetFileSystemOptionsPKc"></span><span id="_CPPv223VSIGetFileSystemOptionsPKc"></span><span id="VSIGetFileSystemOptions__cCP"></span><span class="target" id="cpl__vsi_8h_1a85ca54aa40490c9237e9dd2905d9daac"></span><em class="property">const</em> char *<code class="descname">VSIGetFileSystemOptions</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423VSIGetFileSystemOptionsPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of options associated with a virtual file system handler as a serialized XML string. </p>
<p>Those options may be set as configuration options with <a class="reference internal" href="#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a string, which must not be freed, or NULL if no options is declared. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: a filename, or prefix of a virtual file system handler. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425VSIGetFileSystemsPrefixesv">
<span id="_CPPv325VSIGetFileSystemsPrefixesv"></span><span id="_CPPv225VSIGetFileSystemsPrefixesv"></span><span id="VSIGetFileSystemsPrefixes__void"></span><span class="target" id="cpl__vsi_8h_1adfb3d5eb0effa7326ca6d3130b60bc94"></span>char **<code class="descname">VSIGetFileSystemsPrefixes</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425VSIGetFileSystemsPrefixesv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of prefixes for virtual file system handlers currently registered. </p>
<p>Typically: “”, “/vsimem/”, “/vsicurl/”, etc</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a NULL terminated list of prefixes. Must be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a> </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428VSIFGetNativeFileDescriptorLP8VSILFILE">
<span id="_CPPv328VSIFGetNativeFileDescriptorLP8VSILFILE"></span><span id="_CPPv228VSIFGetNativeFileDescriptorLP8VSILFILE"></span><span id="VSIFGetNativeFileDescriptorL__VSILFILEP"></span><span class="target" id="cpl__vsi_8h_1a41fd7388a7491b3430d0abe961dada82"></span>void *<code class="descname">VSIFGetNativeFileDescriptorL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<em>fp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428VSIFGetNativeFileDescriptorLP8VSILFILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the “native” file descriptor for the virtual handle. </p>
<p>This will only return a non-NULL value for “real” files handled by the operating system (to be opposed to GDAL virtual file systems).</p>
<p>On POSIX systems, this will be a integer value (“fd”) cast as a void*. On Windows systems, this will be the HANDLE.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the native file descriptor, or NULL. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: file handle opened with <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSICalloc6size_t6size_t">
<span id="_CPPv39VSICalloc6size_t6size_t"></span><span id="_CPPv29VSICalloc6size_t6size_t"></span><span id="VSICalloc__s.s"></span><span class="target" id="cpl__vsi_8h_1a84892f1a5065294b3e3c400534e6a86c"></span>void *<code class="descname">VSICalloc</code><span class="sig-paren">(</span>size_t <em>nCount</em>, size_t <em>nSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSICalloc6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Analog of calloc(). </p>
<p>Use <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> to free </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIMalloc6size_t">
<span id="_CPPv39VSIMalloc6size_t"></span><span id="_CPPv29VSIMalloc6size_t"></span><span id="VSIMalloc__s"></span><span class="target" id="cpl__vsi_8h_1a3e403f4f7e059d12da468d20d604e13c"></span>void *<code class="descname">VSIMalloc</code><span class="sig-paren">(</span>size_t <em>nSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIMalloc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Analog of malloc(). </p>
<p>Use <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> to free </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv47VSIFreePv">
<span id="_CPPv37VSIFreePv"></span><span id="_CPPv27VSIFreePv"></span><span id="VSIFree__voidP"></span><span class="target" id="cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"></span>void <code class="descname">VSIFree</code><span class="sig-paren">(</span>void *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47VSIFreePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Analog of free() for data allocated with <a class="reference internal" href="#cpl__vsi_8h_1a3e403f4f7e059d12da468d20d604e13c"><span class="std std-ref">VSIMalloc()</span></a>, <a class="reference internal" href="#cpl__vsi_8h_1a84892f1a5065294b3e3c400534e6a86c"><span class="std std-ref">VSICalloc()</span></a>, <a class="reference internal" href="#cpl__vsi_8h_1ac022eb90a80c108cc43c619ccd17792c"><span class="std std-ref">VSIRealloc()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIReallocPv6size_t">
<span id="_CPPv310VSIReallocPv6size_t"></span><span id="_CPPv210VSIReallocPv6size_t"></span><span id="VSIRealloc__voidP.s"></span><span class="target" id="cpl__vsi_8h_1ac022eb90a80c108cc43c619ccd17792c"></span>void *<code class="descname">VSIRealloc</code><span class="sig-paren">(</span>void *<em>pData</em>, size_t <em>nNewSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIReallocPv6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Analog of realloc(). </p>
<p>Use <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> to free </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIStrdupPKc">
<span id="_CPPv39VSIStrdupPKc"></span><span id="_CPPv29VSIStrdupPKc"></span><span id="VSIStrdup__cCP"></span><span class="target" id="cpl__vsi_8h_1ac0500f0dbd6c8c854931c6aa17d6566e"></span>char *<code class="descname">VSIStrdup</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIStrdupPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Analog of strdup(). </p>
<p>Use <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> to free </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416VSIMallocAligned6size_t6size_t">
<span id="_CPPv316VSIMallocAligned6size_t6size_t"></span><span id="_CPPv216VSIMallocAligned6size_t6size_t"></span><span id="VSIMallocAligned__s.s"></span><span class="target" id="cpl__vsi_8h_1a244d29ecd0edf4cf4253ce840733e74e"></span>void *<code class="descname">VSIMallocAligned</code><span class="sig-paren">(</span>size_t <em>nAlignment</em>, size_t <em>nSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416VSIMallocAligned6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocates a buffer with an alignment constraint. </p>
<p>The return value must be freed with <a class="reference internal" href="#cpl__vsi_8h_1ad8fc84461d6ad10524a64ead6af56e33"><span class="std std-ref">VSIFreeAligned()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a buffer aligned on nAlignment and of size nSize, or NULL </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nAlignment</span></code>: Must be a power of 2, multiple of sizeof(void*), and lesser than 256. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: Size of the buffer to allocate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420VSIMallocAlignedAuto6size_t">
<span id="_CPPv320VSIMallocAlignedAuto6size_t"></span><span id="_CPPv220VSIMallocAlignedAuto6size_t"></span><span id="VSIMallocAlignedAuto__s"></span><span class="target" id="cpl__vsi_8h_1a6a7ffacaa79dbd0a8b7df8a43eab4a0c"></span>void *<code class="descname">VSIMallocAlignedAuto</code><span class="sig-paren">(</span>size_t <em>nSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420VSIMallocAlignedAuto6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocates a buffer with an alignment constraint such that it can be used by the most demanding vector instruction set on that platform. </p>
<p>The return value must be freed with <a class="reference internal" href="#cpl__vsi_8h_1ad8fc84461d6ad10524a64ead6af56e33"><span class="std std-ref">VSIFreeAligned()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an aligned buffer of size nSize, or NULL </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: Size of the buffer to allocate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414VSIFreeAlignedPv">
<span id="_CPPv314VSIFreeAlignedPv"></span><span id="_CPPv214VSIFreeAlignedPv"></span><span id="VSIFreeAligned__voidP"></span><span class="target" id="cpl__vsi_8h_1ad8fc84461d6ad10524a64ead6af56e33"></span>void <code class="descname">VSIFreeAligned</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414VSIFreeAlignedPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a buffer allocated with <a class="reference internal" href="#cpl__vsi_8h_1a244d29ecd0edf4cf4253ce840733e74e"><span class="std std-ref">VSIMallocAligned()</span></a>. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Buffer to free. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427VSIMallocAlignedAutoVerbose6size_tPKci">
<span id="_CPPv327VSIMallocAlignedAutoVerbose6size_tPKci"></span><span id="_CPPv227VSIMallocAlignedAutoVerbose6size_tPKci"></span><span id="VSIMallocAlignedAutoVerbose__s.cCP.i"></span><span class="target" id="cpl__vsi_8h_1a2d4eef330cb2ff336bad8d43b1e5cd9d"></span>void *<code class="descname">VSIMallocAlignedAutoVerbose</code><span class="sig-paren">(</span>size_t <em>nSize</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>nLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427VSIMallocAlignedAutoVerbose6size_tPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>See <a class="reference internal" href="#cpl__vsi_8h_1a6a7ffacaa79dbd0a8b7df8a43eab4a0c"><span class="std std-ref">VSIMallocAlignedAuto()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIMalloc26size_t6size_t">
<span id="_CPPv310VSIMalloc26size_t6size_t"></span><span id="_CPPv210VSIMalloc26size_t6size_t"></span><span id="VSIMalloc2__s.s"></span><span class="target" id="cpl__vsi_8h_1a2286902bc6bf22d866e72df2e474d68c"></span>void *<code class="descname">VSIMalloc2</code><span class="sig-paren">(</span>size_t <em>nSize1</em>, size_t <em>nSize2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIMalloc26size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSIMalloc2 allocates (nSize1 * nSize2) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>. If nSize1 == 0 || nSize2 == 0, a NULL pointer will also be returned. <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> or <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> can be used to free memory allocated by this function. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIMalloc36size_t6size_t6size_t">
<span id="_CPPv310VSIMalloc36size_t6size_t6size_t"></span><span id="_CPPv210VSIMalloc36size_t6size_t6size_t"></span><span id="VSIMalloc3__s.s.s"></span><span class="target" id="cpl__vsi_8h_1a5114ce8d68c4f351309805314f3b5063"></span>void *<code class="descname">VSIMalloc3</code><span class="sig-paren">(</span>size_t <em>nSize1</em>, size_t <em>nSize2</em>, size_t <em>nSize3</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIMalloc36size_t6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a>. If nSize1 == 0 || nSize2 == 0 || nSize3 == 0, a NULL pointer will also be returned. <a class="reference internal" href="#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> or <a class="reference internal" href="#cpl__vsi_8h_1af26e15498e19c2a8169db924415ff7ab"><span class="std std-ref">VSIFree()</span></a> can be used to free memory allocated by this function. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416VSIMallocVerbose6size_tPKci">
<span id="_CPPv316VSIMallocVerbose6size_tPKci"></span><span id="_CPPv216VSIMallocVerbose6size_tPKci"></span><span id="VSIMallocVerbose__s.cCP.i"></span><span class="target" id="cpl__vsi_8h_1a8ea742cee644dd5b84648f4bd32889ed"></span>void *<code class="descname">VSIMallocVerbose</code><span class="sig-paren">(</span>size_t <em>nSize</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>nLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416VSIMallocVerbose6size_tPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSIMallocVerbose. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417VSIMalloc2Verbose6size_t6size_tPKci">
<span id="_CPPv317VSIMalloc2Verbose6size_t6size_tPKci"></span><span id="_CPPv217VSIMalloc2Verbose6size_t6size_tPKci"></span><span id="VSIMalloc2Verbose__s.s.cCP.i"></span><span class="target" id="cpl__vsi_8h_1add34d6eae26372407fddf28da423fb59"></span>void *<code class="descname">VSIMalloc2Verbose</code><span class="sig-paren">(</span>size_t <em>nSize1</em>, size_t <em>nSize2</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>nLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417VSIMalloc2Verbose6size_t6size_tPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSIMalloc2Verbose. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417VSIMalloc3Verbose6size_t6size_t6size_tPKci">
<span id="_CPPv317VSIMalloc3Verbose6size_t6size_t6size_tPKci"></span><span id="_CPPv217VSIMalloc3Verbose6size_t6size_t6size_tPKci"></span><span id="VSIMalloc3Verbose__s.s.s.cCP.i"></span><span class="target" id="cpl__vsi_8h_1a864e6bc415881fccb6d3c1d7a7f069bc"></span>void *<code class="descname">VSIMalloc3Verbose</code><span class="sig-paren">(</span>size_t <em>nSize1</em>, size_t <em>nSize2</em>, size_t <em>nSize3</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>nLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417VSIMalloc3Verbose6size_t6size_t6size_tPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSIMalloc3Verbose. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416VSICallocVerbose6size_t6size_tPKci">
<span id="_CPPv316VSICallocVerbose6size_t6size_tPKci"></span><span id="_CPPv216VSICallocVerbose6size_t6size_tPKci"></span><span id="VSICallocVerbose__s.s.cCP.i"></span><span class="target" id="cpl__vsi_8h_1aad053ec87f032f23120fe04493e23b5b"></span>void *<code class="descname">VSICallocVerbose</code><span class="sig-paren">(</span>size_t <em>nCount</em>, size_t <em>nSize</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>nLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416VSICallocVerbose6size_t6size_tPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSICallocVerbose. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417VSIReallocVerbosePv6size_tPKci">
<span id="_CPPv317VSIReallocVerbosePv6size_tPKci"></span><span id="_CPPv217VSIReallocVerbosePv6size_tPKci"></span><span id="VSIReallocVerbose__voidP.s.cCP.i"></span><span class="target" id="cpl__vsi_8h_1a5b5e4051ccf46b071475c0cefbac3cf7"></span>void *<code class="descname">VSIReallocVerbose</code><span class="sig-paren">(</span>void *<em>pOldPtr</em>, size_t <em>nNewSize</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>nLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417VSIReallocVerbosePv6size_tPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSIReallocVerbose. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416VSIStrdupVerbosePKcPKci">
<span id="_CPPv316VSIStrdupVerbosePKcPKci"></span><span id="_CPPv216VSIStrdupVerbosePKcPKci"></span><span id="VSIStrdupVerbose__cCP.cCP.i"></span><span class="target" id="cpl__vsi_8h_1affabf0e9050f86e5ec57cadc40f56f6e"></span>char *<code class="descname">VSIStrdupVerbose</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszStr</em>, <em class="property">const</em> char *<em>pszFile</em>, int <em>nLine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416VSIStrdupVerbosePKcPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VSIStrdupVerbose. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417CPLGetPhysicalRAMv">
<span id="_CPPv317CPLGetPhysicalRAMv"></span><span id="_CPPv217CPLGetPhysicalRAMv"></span><span id="CPLGetPhysicalRAM__void"></span><span class="target" id="cpl__vsi_8h_1a2ef39609553f41d5cb5078302c4b3de2"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">CPLGetPhysicalRAM</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417CPLGetPhysicalRAMv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the total physical RAM in bytes. </p>
<p>In the context of a container using cgroups (typically Docker), this will take into account that limitation (starting with GDAL 2.4.0)</p>
<p>You should generally use <a class="reference internal" href="#cpl__vsi_8h_1ac6eef6b11f21ea4d5c27a62ac265818a"><span class="std std-ref">CPLGetUsablePhysicalRAM()</span></a> instead.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the total physical RAM in bytes (or 0 in case of failure). </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423CPLGetUsablePhysicalRAMv">
<span id="_CPPv323CPLGetUsablePhysicalRAMv"></span><span id="_CPPv223CPLGetUsablePhysicalRAMv"></span><span id="CPLGetUsablePhysicalRAM__void"></span><span class="target" id="cpl__vsi_8h_1ac6eef6b11f21ea4d5c27a62ac265818a"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">CPLGetUsablePhysicalRAM</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423CPLGetUsablePhysicalRAMv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the total physical RAM, usable by a process, in bytes. </p>
<p>This is the same as <a class="reference internal" href="#cpl__vsi_8h_1a2ef39609553f41d5cb5078302c4b3de2"><span class="std std-ref">CPLGetPhysicalRAM()</span></a> except it will limit to 2 GB for 32 bit processes.</p>
<p>Starting with GDAL 2.4.0, it will also take account resource limits on Posix systems.</p>
<p>Note: This memory may already be partly used by other processes.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the total physical RAM, usable by a process, in bytes (or 0 in case of failure). </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIReadDirPKc">
<span id="_CPPv310VSIReadDirPKc"></span><span id="_CPPv210VSIReadDirPKc"></span><span id="VSIReadDir__cCP"></span><span class="target" id="cpl__vsi_8h_1a6158d73485d6cf92c75b38e7f26d00c3"></span>char **<code class="descname">VSIReadDir</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIReadDirPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read names in a directory. </p>
<p>This function abstracts access to directory contains. It returns a list of strings containing the names of files, and directories in this directory. The resulting string list becomes the responsibility of the application and should be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a> when no longer needed.</p>
<p>Note that no error is issued via <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> if the directory path is invalid, though NULL is returned.</p>
<p>This function used to be known as <a class="reference internal" href="#cpl__vsi_8h_1afdc1dc07ba4fe31933c9b522de783692"><span class="std std-ref">CPLReadDir()</span></a>, but the old name is now deprecated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The list of entries in the directory, or NULL if the directory doesn’t exist. Filenames are returned in UTF-8 encoding. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the relative, or absolute path of a directory to read. UTF-8 encoded. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419VSIReadDirRecursivePKc">
<span id="_CPPv319VSIReadDirRecursivePKc"></span><span id="_CPPv219VSIReadDirRecursivePKc"></span><span id="VSIReadDirRecursive__cCP"></span><span class="target" id="cpl__vsi_8h_1a03c473cd78f2dffabf709245a928e6c7"></span>char **<code class="descname">VSIReadDirRecursive</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419VSIReadDirRecursivePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read names in a directory recursively. </p>
<p>This function abstracts access to directory contents and subdirectories. It returns a list of strings containing the names of files and directories in this directory and all subdirectories. The resulting string list becomes the responsibility of the application and should be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a> when no longer needed.</p>
<p>Note that no error is issued via <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> if the directory path is invalid, though NULL is returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The list of entries in the directory and subdirectories or NULL if the directory doesn’t exist. Filenames are returned in UTF-8 encoding. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.10.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPathIn</span></code>: the relative, or absolute path of a directory to read. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412VSIReadDirExPKci">
<span id="_CPPv312VSIReadDirExPKci"></span><span id="_CPPv212VSIReadDirExPKci"></span><span id="VSIReadDirEx__cCP.i"></span><span class="target" id="cpl__vsi_8h_1aab9f5bbeaa3ad170682f130f427930bd"></span>char **<code class="descname">VSIReadDirEx</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em>, int <em>nMaxFiles</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412VSIReadDirExPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read names in a directory. </p>
<p>This function abstracts access to directory contains. It returns a list of strings containing the names of files, and directories in this directory. The resulting string list becomes the responsibility of the application and should be freed with <a class="reference internal" href="#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a> when no longer needed.</p>
<p>Note that no error is issued via <a class="reference internal" href="#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> if the directory path is invalid, though NULL is returned.</p>
<p>If nMaxFiles is set to a positive number, directory listing will stop after that limit has been reached. Note that to indicate truncate, at least one element more than the nMaxFiles limit will be returned. If <a class="reference internal" href="#cpl__string_8h_1a827f21b7a67d16059c131d0946482bb1"><span class="std std-ref">CSLCount()</span></a> on the result is lesser or equal to nMaxFiles, then no truncation occurred.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The list of entries in the directory, or NULL if the directory doesn’t exist. Filenames are returned in UTF-8 encoding. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the relative, or absolute path of a directory to read. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMaxFiles</span></code>: maximum number of files after which to stop, or 0 for no limit. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410VSIOpenDirPKciPPCKc">
<span id="_CPPv310VSIOpenDirPKciPPCKc"></span><span id="_CPPv210VSIOpenDirPKciPPCKc"></span><span id="VSIOpenDir__cCP.i.cCPCP"></span><span class="target" id="cpl__vsi_8h_1a186d32d750cca298ea625c00e8be3f90"></span><a class="reference internal" href="#_CPPv46VSIDIR" title="VSIDIR">VSIDIR</a> *<code class="descname">VSIOpenDir</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPath</em>, int <em>nRecurseDepth</em>, <em class="property">const</em> char *<em class="property">const</em> *<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410VSIOpenDirPKciPPCKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open a directory to read its entries. </p>
<p>This function is close to the POSIX opendir() function.</p>
<p>For /vsis3/, /vsigs/, /vsioss/ and /vsiaz/, this function has an efficient implementation, minimizing the number of network requests, when invoked with nRecurseDepth &lt;= 0.</p>
<p>Entries are read by calling <a class="reference internal" href="#cpl__vsi_8h_1a0ce4131b005b1853a16d4f341d1ba031"><span class="std std-ref">VSIGetNextDirEntry()</span></a> on the handled returned by that function, until it returns NULL. <a class="reference internal" href="#cpl__vsi_8h_1a7e7448bda4230b3d8133a59027c5f02f"><span class="std std-ref">VSICloseDir()</span></a> must be called once done with the returned directory handle.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle, or NULL in case of error </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPath</span></code>: the relative, or absolute path of a directory to read. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nRecurseDepth</span></code>: 0 means do not recurse in subdirectories, 1 means recurse only in the first level of subdirectories, etc. -1 means unlimited recursion level </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options, or NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418VSIGetNextDirEntryP6VSIDIR">
<span id="_CPPv318VSIGetNextDirEntryP6VSIDIR"></span><span id="_CPPv218VSIGetNextDirEntryP6VSIDIR"></span><span id="VSIGetNextDirEntry__VSIDIRP"></span><span class="target" id="cpl__vsi_8h_1a0ce4131b005b1853a16d4f341d1ba031"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv411VSIDIREntry" title="VSIDIREntry">VSIDIREntry</a> *<code class="descname">VSIGetNextDirEntry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46VSIDIR" title="VSIDIR">VSIDIR</a> *<em>dir</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418VSIGetNextDirEntryP6VSIDIR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the next entry of the directory. </p>
<p>This function is close to the POSIX readdir() function. It actually returns more information (file size, last modification time), which on ‘real’ file systems involve one ‘stat’ call per file.</p>
<p>For filesystems that can have both a regular file and a directory name of the same name (typically /vsis3/), when this situation of duplicate happens, the directory name will be suffixed by a slash character. Otherwise directory names are not suffixed by slash.</p>
<p>The returned entry remains valid until the next call to VSINextDirEntry() or <a class="reference internal" href="#cpl__vsi_8h_1a7e7448bda4230b3d8133a59027c5f02f"><span class="std std-ref">VSICloseDir()</span></a> with the same handle.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a entry, or NULL if there is no more entry in the directory. This return value must not be freed. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dir</span></code>: Directory handled returned by <a class="reference internal" href="#cpl__vsi_8h_1a186d32d750cca298ea625c00e8be3f90"><span class="std std-ref">VSIOpenDir()</span></a>. Must not be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411VSICloseDirP6VSIDIR">
<span id="_CPPv311VSICloseDirP6VSIDIR"></span><span id="_CPPv211VSICloseDirP6VSIDIR"></span><span id="VSICloseDir__VSIDIRP"></span><span class="target" id="cpl__vsi_8h_1a7e7448bda4230b3d8133a59027c5f02f"></span>void <code class="descname">VSICloseDir</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46VSIDIR" title="VSIDIR">VSIDIR</a> *<em>dir</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411VSICloseDirP6VSIDIR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close a directory. </p>
<p>This function is close to the POSIX closedir() function.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dir</span></code>: Directory handled returned by <a class="reference internal" href="#cpl__vsi_8h_1a186d32d750cca298ea625c00e8be3f90"><span class="std std-ref">VSIOpenDir()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48VSIMkdirPKcl">
<span id="_CPPv38VSIMkdirPKcl"></span><span id="_CPPv28VSIMkdirPKcl"></span><span id="VSIMkdir__cCP.l"></span><span class="target" id="cpl__vsi_8h_1aaa3e0b14583ca553a29bf163b972c157"></span>int <code class="descname">VSIMkdir</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPathname</em>, long <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48VSIMkdirPKcl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a directory. </p>
<p>Create a new directory with the indicated mode. The mode is ignored on some platforms. A reasonable default mode value would be 0666. This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX mkdir() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPathname</span></code>: the path to the directory to create. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code>: the permissions mode.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417VSIMkdirRecursivePKcl">
<span id="_CPPv317VSIMkdirRecursivePKcl"></span><span id="_CPPv217VSIMkdirRecursivePKcl"></span><span id="VSIMkdirRecursive__cCP.l"></span><span class="target" id="cpl__vsi_8h_1a62018c639ec285ae04afa5799ee6a4d5"></span>int <code class="descname">VSIMkdirRecursive</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPathname</em>, long <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417VSIMkdirRecursivePKcl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a directory and all its ancestors. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszPathname</span></code>: the path to the directory to create. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code>: the permissions mode.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48VSIRmdirPKc">
<span id="_CPPv38VSIRmdirPKc"></span><span id="_CPPv28VSIRmdirPKc"></span><span id="VSIRmdir__cCP"></span><span class="target" id="cpl__vsi_8h_1af12c8873a6ff54d9c1e7f752cada9822"></span>int <code class="descname">VSIRmdir</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszDirname</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48VSIRmdirPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete a directory. </p>
<p>Deletes a directory object from the file system. On some systems the directory must be empty before it can be deleted.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rmdir() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDirname</span></code>: the path of the directory to be deleted. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417VSIRmdirRecursivePKc">
<span id="_CPPv317VSIRmdirRecursivePKc"></span><span id="_CPPv217VSIRmdirRecursivePKc"></span><span id="VSIRmdirRecursive__cCP"></span><span class="target" id="cpl__vsi_8h_1aa5e05f10c591053fa876c9d3417421a5"></span>int <code class="descname">VSIRmdirRecursive</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszDirname</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417VSIRmdirRecursivePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete a directory recursively. </p>
<p>Deletes a directory object and its content from the file system.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIUnlinkPKc">
<span id="_CPPv39VSIUnlinkPKc"></span><span id="_CPPv29VSIUnlinkPKc"></span><span id="VSIUnlink__cCP"></span><span class="target" id="cpl__vsi_8h_1a7ff49d132f70ec46a550c5a51103e394"></span>int <code class="descname">VSIUnlink</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIUnlinkPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete a file. </p>
<p>Deletes a file object from the file system.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX unlink() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the path of the file to be deleted. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49VSIRenamePKcPKc">
<span id="_CPPv39VSIRenamePKcPKc"></span><span id="_CPPv29VSIRenamePKcPKc"></span><span id="VSIRename__cCP.cCP"></span><span class="target" id="cpl__vsi_8h_1a26cae93b5a32e11bef9ec7c118f8cca4"></span>int <code class="descname">VSIRename</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>oldpath</em>, <em class="property">const</em> char *<em>newpath</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49VSIRenamePKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Rename a file. </p>
<p>Renames a file object in the file system. It should be possible to rename a file onto a new filesystem, but it is safest if this function is only used to rename files that remain in the same directory.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rename() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on an error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">oldpath</span></code>: the name of the file to be renamed. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newpath</span></code>: the name the file should be given. UTF-8 encoded.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv47VSISyncPKcPKcPPCKc16GDALProgressFuncPvPPPc">
<span id="_CPPv37VSISyncPKcPKcPPCKc16GDALProgressFuncPvPPPc"></span><span id="_CPPv27VSISyncPKcPKcPPCKc16GDALProgressFuncPvPPPc"></span><span id="VSISync__cCP.cCP.cCPCP.GDALProgressFunc.voidP.cPPP"></span><span class="target" id="cpl__vsi_8h_1a6845a21b2c0491c594dd9deef757db6b"></span>int <code class="descname">VSISync</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszSource</em>, <em class="property">const</em> char *<em>pszTarget</em>, <em class="property">const</em> char *<em class="property">const</em> *<em>papszOptions</em>, <a class="reference internal" href="#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pProgressFunc</em>, void *<em>pProgressData</em>, char ***<em>ppapszOutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47VSISyncPKcPKcPPCKc16GDALProgressFuncPvPPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Synchronize a source file/directory with a target file/directory. </p>
<p>This is a analog of the ‘rsync’ utility. In the current implementation, rsync would be more efficient for local file copying, but <a class="reference internal" href="#cpl__vsi_8h_1a6845a21b2c0491c594dd9deef757db6b"><span class="std std-ref">VSISync()</span></a> main interest is when the source or target is a remote file system like /vsis3/ or /vsigs/, in which case it can take into account the timestamps of the files (or optionally the ETag/MD5Sum) to avoid unneeded copy operations.</p>
<p>Note: currently only implemented efficiently for local filesystem &lt;&gt; remote filesystem.</p>
<p>Similarly to rsync behaviour, if the source filename ends with a slash, it means that the content of the directory must be copied, but not the directory name. For example, assuming “/home/even/foo” contains a file “bar”, VSISync(“/home/even/foo/”, “/mnt/media”, …) will create a “/mnt/media/bar” file. Whereas VSISync(“/home/even/foo”, “/mnt/media”, …) will create a “/mnt/media/foo” directory which contains a bar file.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE on an error. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszSource</span></code>: Source file or directory. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszTarget</span></code>: Target file or direcotry. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: Null terminated list of options, or NULL. Currently accepted options are: <ul>
<li><p>RECURSIVE=NO (the default is YES) </p></li>
<li><p>SYNC_STRATEGY=TIMESTAMP/ETAG. Determines which criterion is used to determine if a target file must be replaced when it already exists and has the same file size as the source. Only applies for a source or target being a network filesystem.</p>
<p>The default is TIMESTAMP (similarly to how ‘aws s3 sync’ works), that is to say that for an upload operation, a remote file is replaced if it has a different size or if it is older than the source. For a download operation, a local file is replaced if it has a different size or if it is newer than the remote file.</p>
<p>The ETAG strategy assumes that the ETag metadata of the remote file is the MD5Sum of the file content, which is only true in the case of /vsis3/ for files not using KMS server side encryption and uploaded in a single PUT operation (so smaller than 50 MB given the default used by GDAL). Only to be used for /vsis3/, /vsigs/ or other filesystems using a MD5Sum as ETAG.  </p>
</li>
</ul>
</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressFunc</span></code>: Progress callback, or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressData</span></code>: User data of progress callback, or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppapszOutputs</span></code>: Unused. Should be set to NULL for now.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411VSIStrerrori">
<span id="_CPPv311VSIStrerrori"></span><span id="_CPPv211VSIStrerrori"></span><span id="VSIStrerror__i"></span><span class="target" id="cpl__vsi_8h_1a312ee85ec9884dc16feda2b81de1cc36"></span>char *<code class="descname">VSIStrerror</code><span class="sig-paren">(</span>int <em>nErrno</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411VSIStrerrori" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the error string corresponding to the error number. </p>
<p>Do not free it </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419VSIGetDiskFreeSpacePKc">
<span id="_CPPv319VSIGetDiskFreeSpacePKc"></span><span id="_CPPv219VSIGetDiskFreeSpacePKc"></span><span id="VSIGetDiskFreeSpace__cCP"></span><span class="target" id="cpl__vsi_8h_1ad4ae557aaaa4cc249cd97080101a8297"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">VSIGetDiskFreeSpace</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszDirname</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419VSIGetDiskFreeSpacePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return free disk space available on the filesystem. </p>
<p>This function returns the free disk space available on the filesystem.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The free space in bytes. Or -1 in case of error. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszDirname</span></code>: a directory of the filesystem to query. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424VSIInstallMemFileHandlerv">
<span id="_CPPv324VSIInstallMemFileHandlerv"></span><span id="_CPPv224VSIInstallMemFileHandlerv"></span><span id="VSIInstallMemFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a66e2e6f093fd42f8a941b962d4c8a19e"></span>void <code class="descname">VSIInstallMemFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424VSIInstallMemFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install “memory” file system handler. </p>
<p>A special file handler is installed that allows block of memory to be treated as files. All portions of the file system underneath the base path “/vsimem/” will be handled by this driver.</p>
<p>Normal VSI*L functions can be used freely to create and destroy memory arrays treating them as if they were real file system objects. Some additional methods exist to efficient create memory file system objects without duplicating original copies of the data or to “steal” the block of memory associated with a memory file.</p>
<p>Directory related functions are supported.</p>
<p>This code example demonstrates using GDAL to translate from one memory buffer to another.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GByte</span> <span class="o">*</span><span class="n">ConvertBufferFormat</span><span class="p">(</span> <span class="n">GByte</span> <span class="o">*</span><span class="n">pabyInData</span><span class="p">,</span> <span class="n">vsi_l_offset</span> <span class="n">nInDataLength</span><span class="p">,</span>
                            <span class="n">vsi_l_offset</span> <span class="o">*</span><span class="n">pnOutDataLength</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">create</span> <span class="n">memory</span> <span class="n">file</span> <span class="n">system</span> <span class="nb">object</span> <span class="kn">from</span> <span class="nn">buffer.</span>
    <span class="n">VSIFCloseL</span><span class="p">(</span> <span class="n">VSIFileFromMemBuffer</span><span class="p">(</span> <span class="s2">&quot;/vsimem/work.dat&quot;</span><span class="p">,</span> <span class="n">pabyInData</span><span class="p">,</span>
                                      <span class="n">nInDataLength</span><span class="p">,</span> <span class="n">FALSE</span> <span class="p">)</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Open</span> <span class="n">memory</span> <span class="n">buffer</span> <span class="k">for</span> <span class="n">read</span><span class="o">.</span>
    <span class="n">GDALDatasetH</span> <span class="n">hDS</span> <span class="o">=</span> <span class="n">GDALOpen</span><span class="p">(</span> <span class="s2">&quot;/vsimem/work.dat&quot;</span><span class="p">,</span> <span class="n">GA_ReadOnly</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Get</span> <span class="n">output</span> <span class="nb">format</span> <span class="n">driver</span><span class="o">.</span>
    <span class="n">GDALDriverH</span> <span class="n">hDriver</span> <span class="o">=</span> <span class="n">GDALGetDriverByName</span><span class="p">(</span> <span class="s2">&quot;GTiff&quot;</span> <span class="p">);</span>
    <span class="n">GDALDatasetH</span> <span class="n">hOutDS</span><span class="p">;</span>

    <span class="n">hOutDS</span> <span class="o">=</span> <span class="n">GDALCreateCopy</span><span class="p">(</span> <span class="n">hDriver</span><span class="p">,</span> <span class="s2">&quot;/vsimem/out.tif&quot;</span><span class="p">,</span> <span class="n">hDS</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span>
                             <span class="n">NULL</span><span class="p">,</span> <span class="n">NULL</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">close</span> <span class="n">source</span> <span class="n">file</span><span class="p">,</span> <span class="ow">and</span> <span class="s2">&quot;unlink&quot;</span> <span class="n">it</span><span class="o">.</span>
    <span class="n">GDALClose</span><span class="p">(</span> <span class="n">hDS</span> <span class="p">);</span>
    <span class="n">VSIUnlink</span><span class="p">(</span> <span class="s2">&quot;/vsimem/work.dat&quot;</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">seize</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">associated</span> <span class="k">with</span> <span class="n">the</span> <span class="n">output</span> <span class="n">file</span><span class="o">.</span>

    <span class="k">return</span> <span class="n">VSIGetMemFileBuffer</span><span class="p">(</span> <span class="s2">&quot;/vsimem/out.tif&quot;</span><span class="p">,</span> <span class="n">pnOutDataLength</span><span class="p">,</span> <span class="n">TRUE</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424VSIInstallSubFileHandlerv">
<span id="_CPPv324VSIInstallSubFileHandlerv"></span><span id="_CPPv224VSIInstallSubFileHandlerv"></span><span id="VSIInstallSubFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1abaee4232440e012b4b9920934fc571cc"></span>void <code class="descname">VSIInstallSubFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424VSIInstallSubFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsisubfile/ virtual file handler. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_subfile">/vsisubfile/ documentation</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425VSIInstallCurlFileHandlerv">
<span id="_CPPv325VSIInstallCurlFileHandlerv"></span><span id="_CPPv225VSIInstallCurlFileHandlerv"></span><span id="VSIInstallCurlFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a4f791960f2d86713d16e99e9c0c36258"></span>void <code class="descname">VSIInstallCurlFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425VSIInstallCurlFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsicurl/ HTTP/FTP file system handler (requires libcurl) </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsicurl">/vsicurl/ documentation</a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.8.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417VSICurlClearCachev">
<span id="_CPPv317VSICurlClearCachev"></span><span id="_CPPv217VSICurlClearCachev"></span><span id="VSICurlClearCache__void"></span><span class="target" id="cpl__vsi_8h_1a6b22260317edc475793c4165957742b6"></span>void <code class="descname">VSICurlClearCache</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417VSICurlClearCachev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean local cache associated with /vsicurl/ (and related file systems) </p>
<p>/vsicurl (and related file systems like /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiswift/) cache a number of metadata and data for faster execution in read-only scenarios. But when the content on the server-side may change during the same process, those mechanisms can prevent opening new files, or give an outdated version of them.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2.1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424VSICurlPartialClearCachePKc">
<span id="_CPPv324VSICurlPartialClearCachePKc"></span><span id="_CPPv224VSICurlPartialClearCachePKc"></span><span id="VSICurlPartialClearCache__cCP"></span><span class="target" id="cpl__vsi_8h_1a6bc83d16f0f279f601059a218ad2c55c"></span>void <code class="descname">VSICurlPartialClearCache</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilenamePrefix</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424VSICurlPartialClearCachePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean local cache associated with /vsicurl/ (and related file systems) for a given filename (and its subfiles and subdirectories if it is a directory) </p>
<p>/vsicurl (and related file systems like /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiswift/) cache a number of metadata and data for faster execution in read-only scenarios. But when the content on the server-side may change during the same process, those mechanisms can prevent opening new files, or give an outdated version of them.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilenamePrefix</span></code>: Filename prefix </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv434VSIInstallCurlStreamingFileHandlerv">
<span id="_CPPv334VSIInstallCurlStreamingFileHandlerv"></span><span id="_CPPv234VSIInstallCurlStreamingFileHandlerv"></span><span id="VSIInstallCurlStreamingFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1ab187e6713f07be9756c22c58b782642d"></span>void <code class="descname">VSIInstallCurlStreamingFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434VSIInstallCurlStreamingFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv423VSIInstallS3FileHandlerv">
<span id="_CPPv323VSIInstallS3FileHandlerv"></span><span id="_CPPv223VSIInstallS3FileHandlerv"></span><span id="VSIInstallS3FileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a5b4754999acd06444bfda172ff2aaa16"></span>void <code class="descname">VSIInstallS3FileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423VSIInstallS3FileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsis3/ Amazon S3 file system handler (requires libcurl) </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsis3">/vsis3/ documentation</a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432VSIInstallS3StreamingFileHandlerv">
<span id="_CPPv332VSIInstallS3StreamingFileHandlerv"></span><span id="_CPPv232VSIInstallS3StreamingFileHandlerv"></span><span id="VSIInstallS3StreamingFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a126c1e0314bbd7e4661bc526f45032c5"></span>void <code class="descname">VSIInstallS3StreamingFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432VSIInstallS3StreamingFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv423VSIInstallGSFileHandlerv">
<span id="_CPPv323VSIInstallGSFileHandlerv"></span><span id="_CPPv223VSIInstallGSFileHandlerv"></span><span id="VSIInstallGSFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1af80a70fd45cd7a2119f1a2f7da071870"></span>void <code class="descname">VSIInstallGSFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423VSIInstallGSFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsigs/ Google Cloud Storage file system handler (requires libcurl) </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsigs">/vsigs/ documentation</a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432VSIInstallGSStreamingFileHandlerv">
<span id="_CPPv332VSIInstallGSStreamingFileHandlerv"></span><span id="_CPPv232VSIInstallGSStreamingFileHandlerv"></span><span id="VSIInstallGSStreamingFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1aca9158701b72f0c840996d8ad98bb2ff"></span>void <code class="descname">VSIInstallGSStreamingFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432VSIInstallGSStreamingFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv426VSIInstallAzureFileHandlerv">
<span id="_CPPv326VSIInstallAzureFileHandlerv"></span><span id="_CPPv226VSIInstallAzureFileHandlerv"></span><span id="VSIInstallAzureFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1af1f1bf516788238d7138c879dedd62a4"></span>void <code class="descname">VSIInstallAzureFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426VSIInstallAzureFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsiaz/ Microsoft Azure Blob file system handler (requires libcurl) </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsiaz">/vsiaz/ documentation</a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv435VSIInstallAzureStreamingFileHandlerv">
<span id="_CPPv335VSIInstallAzureStreamingFileHandlerv"></span><span id="_CPPv235VSIInstallAzureStreamingFileHandlerv"></span><span id="VSIInstallAzureStreamingFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1af913ec753ebec2261f0420e8989dd6dd"></span>void <code class="descname">VSIInstallAzureStreamingFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435VSIInstallAzureStreamingFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv424VSIInstallOSSFileHandlerv">
<span id="_CPPv324VSIInstallOSSFileHandlerv"></span><span id="_CPPv224VSIInstallOSSFileHandlerv"></span><span id="VSIInstallOSSFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1ad393a845ca054eab086fb933cee74be0"></span>void <code class="descname">VSIInstallOSSFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424VSIInstallOSSFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsioss/ Alibaba Cloud Object Storage Service (OSS) file system handler (requires libcurl) </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsioss">/vsioss/ documentation</a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv433VSIInstallOSSStreamingFileHandlerv">
<span id="_CPPv333VSIInstallOSSStreamingFileHandlerv"></span><span id="_CPPv233VSIInstallOSSStreamingFileHandlerv"></span><span id="VSIInstallOSSStreamingFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a966348bdbdd092035cd7925d56943d05"></span>void <code class="descname">VSIInstallOSSStreamingFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433VSIInstallOSSStreamingFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv426VSIInstallSwiftFileHandlerv">
<span id="_CPPv326VSIInstallSwiftFileHandlerv"></span><span id="_CPPv226VSIInstallSwiftFileHandlerv"></span><span id="VSIInstallSwiftFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a87a177eab3fbc4241083f6749b9a75d5"></span>void <code class="descname">VSIInstallSwiftFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426VSIInstallSwiftFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsiswift/ OpenStack Swif Object Storage (Swift) file system handler (requires libcurl) </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsiswift">/vsiswift/ documentation</a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv435VSIInstallSwiftStreamingFileHandlerv">
<span id="_CPPv335VSIInstallSwiftStreamingFileHandlerv"></span><span id="_CPPv235VSIInstallSwiftStreamingFileHandlerv"></span><span id="VSIInstallSwiftStreamingFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a6112f0851a51fe5ad1333f5cd1672ab6"></span>void <code class="descname">VSIInstallSwiftStreamingFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435VSIInstallSwiftStreamingFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv425VSIInstallGZipFileHandlerv">
<span id="_CPPv325VSIInstallGZipFileHandlerv"></span><span id="_CPPv225VSIInstallGZipFileHandlerv"></span><span id="VSIInstallGZipFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a3cde09f204df6f417653b7af4761178e"></span>void <code class="descname">VSIInstallGZipFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425VSIInstallGZipFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install GZip file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly and writing in GZip (.gz) files.</p>
<p>All portions of the file system underneath the base path “/vsigzip/” will be handled by this driver.</p>
<p>Additional documentation is to be found at: <a class="reference external" href="http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip">http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip</a></p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.6.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424VSIInstallZipFileHandlerv">
<span id="_CPPv324VSIInstallZipFileHandlerv"></span><span id="_CPPv224VSIInstallZipFileHandlerv"></span><span id="VSIInstallZipFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a884fac3cd6be2c09deb807e959d78b3a"></span>void <code class="descname">VSIInstallZipFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424VSIInstallZipFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install ZIP file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in ZIP (.zip) archives.</p>
<p>All portions of the file system underneath the base path “/vsizip/” will be handled by this driver.</p>
<p>The syntax to open a file inside a zip file is /vsizip/path/to/the/file.zip/path/inside/the/zip/file where path/to/the/file.zip is relative or absolute and path/inside/the/zip/file is the relative path to the file inside the archive.</p>
<p>Starting with GDAL 2.2, an alternate syntax is available so as to enable chaining and not being dependent on .zip extension : /vsizip/{/path/to/the/archive}/path/inside/the/zip/file. Note that /path/to/the/archive may also itself use this alternate syntax.</p>
<p>If the path is absolute, it should begin with a / on a Unix-like OS (or C:\ on Windows), so the line looks like /vsizip//home/gdal/… For example gdalinfo /vsizip/myarchive.zip/subdir1/file1.tif</p>
<p>Syntactic sugar : if the .zip file contains only one file located at its root, just mentioning “/vsizip/path/to/the/file.zip” will work</p>
<p><a class="reference internal" href="#cpl__vsi_8h_1a2fc1cc4f2893dc422eb57e430798991a"><span class="std std-ref">VSIStatL()</span></a> will return the uncompressed size in st_size member and file nature- file or directory - in st_mode member.</p>
<p>Directory listing is available through <a class="reference internal" href="#cpl__vsi_8h_1a6158d73485d6cf92c75b38e7f26d00c3"><span class="std std-ref">VSIReadDir()</span></a>.</p>
<p>Since GDAL 1.8.0, write capabilities are available. They allow creating a new zip file and adding new files to an already existing (or just created) zip file. Read and write operations cannot be interleaved : the new zip must be closed before being re-opened for read.</p>
<p>Additional documentation is to be found at <a class="reference external" href="http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip">http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip</a></p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.6.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422VSIInstallStdinHandlerv">
<span id="_CPPv322VSIInstallStdinHandlerv"></span><span id="_CPPv222VSIInstallStdinHandlerv"></span><span id="VSIInstallStdinHandler__void"></span><span class="target" id="cpl__vsi_8h_1a2c6b408477f59b40f0aec51d5980eb8e"></span>void <code class="descname">VSIInstallStdinHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422VSIInstallStdinHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsistdin/ file system handler. </p>
<p>A special file handler is installed that allows reading from the standard input stream.</p>
<p>The file operations available are of course limited to Read() and forward Seek() (full seek in the first MB of a file).</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.8.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421VSIInstallHdfsHandlerv">
<span id="_CPPv321VSIInstallHdfsHandlerv"></span><span id="_CPPv221VSIInstallHdfsHandlerv"></span><span id="VSIInstallHdfsHandler__void"></span><span class="target" id="cpl__vsi_8h_1a5c296255c2263248d0e6ad7c4481d746"></span>void <code class="descname">VSIInstallHdfsHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421VSIInstallHdfsHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsihdfs/ file system handler (requires JVM and HDFS support) </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424VSIInstallWebHdfsHandlerv">
<span id="_CPPv324VSIInstallWebHdfsHandlerv"></span><span id="_CPPv224VSIInstallWebHdfsHandlerv"></span><span id="VSIInstallWebHdfsHandler__void"></span><span class="target" id="cpl__vsi_8h_1a51b1d08d5f6dcd37d2ed89583765ee9b"></span>void <code class="descname">VSIInstallWebHdfsHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424VSIInstallWebHdfsHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsiwebhdfs/ WebHDFS (Hadoop File System) REST API file system handler (requires libcurl) </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsiwebhdfs">/vsiwebhdfs/ documentation</a></p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423VSIInstallStdoutHandlerv">
<span id="_CPPv323VSIInstallStdoutHandlerv"></span><span id="_CPPv223VSIInstallStdoutHandlerv"></span><span id="VSIInstallStdoutHandler__void"></span><span class="target" id="cpl__vsi_8h_1a61d2250ab2b22ca79b051a8479ee5383"></span>void <code class="descname">VSIInstallStdoutHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423VSIInstallStdoutHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsistdout/ file system handler. </p>
<p>A special file handler is installed that allows writing to the standard output stream.</p>
<p>The file operations available are of course limited to Write().</p>
<p>A variation of this file system exists as the /vsistdout_redirect/ file system handler, where the output function can be defined with <a class="reference internal" href="#cpl__vsi_8h_1adc4a67cc303d7662c34f506d0bdddd79"><span class="std std-ref">VSIStdoutSetRedirection()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.8.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427VSIInstallSparseFileHandlerv">
<span id="_CPPv327VSIInstallSparseFileHandlerv"></span><span id="_CPPv227VSIInstallSparseFileHandlerv"></span><span id="VSIInstallSparseFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1ab79aed725b28eb22471a8b6733405843"></span>void <code class="descname">VSIInstallSparseFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427VSIInstallSparseFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsisparse/ virtual file handler. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsisparse">/vsisparse/ documentation</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424VSIInstallTarFileHandlerv">
<span id="_CPPv324VSIInstallTarFileHandlerv"></span><span id="_CPPv224VSIInstallTarFileHandlerv"></span><span id="VSIInstallTarFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1ad6dd983338849e7da4eaa88f6458ab64"></span>void <code class="descname">VSIInstallTarFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424VSIInstallTarFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsitar/ file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in TAR (regular .tar, or compressed .tar.gz/.tgz) archives.</p>
<p>All portions of the file system underneath the base path “/vsitar/” will be handled by this driver.</p>
<p>The syntax to open a file inside a tar file is /vsitar/path/to/the/file.tar/path/inside/the/tar/file were path/to/the/file.tar is relative or absolute and path/inside/the/tar/file is the relative path to the file inside the archive.</p>
<p>Starting with GDAL 2.2, an alternate syntax is available so as to enable chaining and not being dependent on .tar extension : /vsitar/{/path/to/the/archive}/path/inside/the/tar/file. Note that /path/to/the/archive may also itself this alternate syntax.</p>
<p>If the path is absolute, it should begin with a / on a Unix-like OS (or C:\ on Windows), so the line looks like /vsitar//home/gdal/… For example gdalinfo /vsitar/myarchive.tar/subdir1/file1.tif</p>
<p>Syntactic sugar : if the tar archive contains only one file located at its root, just mentionning “/vsitar/path/to/the/file.tar” will work</p>
<p><a class="reference internal" href="#cpl__vsi_8h_1a2fc1cc4f2893dc422eb57e430798991a"><span class="std std-ref">VSIStatL()</span></a> will return the uncompressed size in st_size member and file nature- file or directory - in st_mode member.</p>
<p>Directory listing is available through <a class="reference internal" href="#cpl__vsi_8h_1a6158d73485d6cf92c75b38e7f26d00c3"><span class="std std-ref">VSIReadDir()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.8.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426VSIInstallCryptFileHandlerv">
<span id="_CPPv326VSIInstallCryptFileHandlerv"></span><span id="_CPPv226VSIInstallCryptFileHandlerv"></span><span id="VSIInstallCryptFileHandler__void"></span><span class="target" id="cpl__vsi_8h_1a5e20b79947f58970f5514b3eb9a524a9"></span>void <code class="descname">VSIInstallCryptFileHandler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426VSIInstallCryptFileHandlerv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install /vsicrypt/ encrypted file system handler (requires <a class="reference external" href="http://www.cryptopp.com/">libcrypto++</a>) </p>
<p>A special file handler is installed that allows reading/creating/update encrypted files on the fly, with random access capabilities.</p>
<p>The cryptographic algorithms used are <a class="reference external" href="https://en.wikipedia.org/wiki/Block_cipher">block ciphers</a>, with symmetric key.</p>
<p>In their simplest form, recognized filenames are of the form /vsicrypt//absolute_path/to/file, /vsicrypt/c:/absolute_path/to/file or /vsicrypt/relative/path/to/file.</p>
<p>Options can also be used with the following format : /vsicrypt/option1=val1,option2=val2,…,file=/path/to/file</p>
<p>They can also be passed as configuration option/environment variable, because in some use cases, the syntax with option in the filename might not properly work with some drivers.</p>
<p>In all modes, the encryption key must be provided. There are several ways of doing so : <ul class="simple">
<li><p>By adding a key= parameter to the filename, like /vsicrypt/key=my_secret_key,file=/path/to/file. Note that this restricts the key to be in text format, whereas at its full power, it can be binary content. </p></li>
<li><p>By adding a key_b64= parameter to the filename, to specify a binary key expressed in Base64 encoding, like /vsicrypt/key_b64=th1sl00kslikebase64=,file=/path/to/file. </p></li>
<li><p>By setting the VSICRYPT_KEY configuration option. The key should be in text format. </p></li>
<li><p>By setting the VSICRYPT_KEY_B64 configuration option. The key should be encoded in Base64. </p></li>
<li><p>By using the <a class="reference internal" href="#cpl__vsi_8h_1a619a6f6758371a39e0c1a4168462452c"><span class="std std-ref">VSISetCryptKey()</span></a> C function. </p></li>
</ul>
</p>
<p>When creating a file, if key=GENERATE_IT or VSICRYPT_KEY=GENERATE_IT is passed, the encryption key will be generated from the pseudo-random number generator of the operating system. The key will be displayed on the standard error stream in a Base64 form (unless the VSICRYPT_DISPLAY_GENERATED_KEY configuration option is set to OFF), and the VSICRYPT_KEY_B64 configuration option will also be set with the Base64 form of the key (so that CPLGetConfigOption(“VSICRYPT_KEY_B64”, NULL) can be used to get it back).</p>
<p>The available options are : <ul>
<li><p>alg=AES/Blowfish/Camellia/CAST256/DES_EDE2/DES_EDE3/MARS/IDEA/RC5/RC6/Serpent/SHACAL2/SKIPJACK/Twofish/XTEA: to specify the <a class="reference external" href="https://en.wikipedia.org/wiki/Block_cipher">block cipher</a> algorithm. The default is AES. Only used on creation. Ignored otherwise. Note: depending on how GDAL is build, if linked against the DLL version of libcrypto++, only a subset of those algorithms will be available, namely AES, DES_EDE2, DES_EDE3 and SKIPJACK. Also available as VSICRYPT_ALG configuration option. </p></li>
<li><p>mode=CBC/CFB/OFB/CTR/CBC_CTS: to specify the <a class="reference external" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">block cipher mode of operation</a>. The default is CBC. Only used on creation. Ignored otherwise. Also available as VSICRYPT_MODE configuration option. </p></li>
<li><p>key=text_key: see above. </p></li>
<li><p>key_b64=base64_encoded_key: see above. </p></li>
<li><p>freetext=some_text: to specify a text content that will be written <em>unencrypted</em> in the file header, for informational purposes. Default to empty. Only used on creation. Ignored otherwise. Also available as VSICRYPT_FREETEXT configuration option. </p></li>
<li><p>sector_size=int_value: to specify the size of the “sector”, which is the unit chunk of information that is encrypted/decrypted. Default to 512 bytes. The valid values depend on the algorithm and block cipher mode of operation. Only used on creation. Ignored otherwise. Also available as VSICRYPT_SECTOR_SIZE configuration option. </p></li>
<li><p>iv=initial_vector_as_text: to specify the Initial Vector. This is an advanced option that should generally <em>NOT</em> be used. It is only useful to get completely deterministic output given the plaintext, key and other parameters, which in general <em>NOT</em> what you want to do. By default, a random initial vector of the appropriate size will be generated for each new file created. Only used on creation. Ignored otherwise. Also available as VSICRYPT_IV configuration option.</p>
<p></p>
</li>
<li><p>add_key_check=YES/NO: whether a special value should be encrypted in the header, so as to be quickly able to determine if the decryption key is correct. Defaults to NO. Only used on creation. Ignored otherwise. Also available as VSICRYPT_ADD_KEY_CHECK configuration option. </p></li>
<li><p>file=filename. To specify the filename. This must be the last option put in the option list (so as to make it possible to use filenames with comma in them. ) </p></li>
</ul>
</p>
<p>This special file handler can be combined with other virtual filesystems handlers, such as /vsizip. For example, /vsicrypt//vsicurl/path/to/remote/encrypted/file.tif</p>
<p>Implementation details:</p>
<p>The structure of encrypted files is the following: a header, immediately followed by the encrypted payload (by sectors, i.e. chunks of sector_size bytes).</p>
<p>The header structure is the following : <ol class="arabic simple">
<li><p>8 bytes. Signature. Fixed value: VSICRYPT. </p></li>
<li><p>UINT16_LE. Header size (including previous signature bytes). </p></li>
<li><p>UINT8. Format major version. Current value: 1. </p></li>
<li><p>UINT8. Format minor version. Current value: 0. </p></li>
<li><p>UINT16. Sector size. </p></li>
<li><p>UINT8. Cipher algorithm. Valid values are: 0 = AES (Rijndael), 1 = Blowfish, 2 = Camellia, 3 = CAST256, 4 = DES_EDE2, 5 = DES_EDE3, 6 = MARS, 7 = IDEA, 8 = RC5, 9 = RC6, 10 = Serpent, 11 = SHACAL2, 12 = SKIPJACK, 13 = Twofish, 14 = XTEA. </p></li>
<li><p>UINT8. Block cipher mode of operation. Valid values are: 0 = CBC, 1 = CFB, 2 = OFB, 3 = CTR, 4 = CBC_CTS. </p></li>
<li><p>UINT8. Size in bytes of the Initial Vector. </p></li>
<li><p>N bytes with the content of the Initial Vector, where N is the value of the previous field. </p></li>
<li><p>UINT16_LE. Size in bytes of the free text. </p></li>
<li><p>N bytes with the content of the free text, where N is the value of the previous field. </p></li>
<li><p>UINT8. Size in bytes of encrypted content (key check), or 0 if key check is absent. </p></li>
<li><p>N bytes with encrypted content (key check), where N is the value of the previous field. </p></li>
<li><p>UINT64_LE. Size of the unencrypted file, in bytes. </p></li>
<li><p>UINT16_LE. Size in bytes of extra content (of unspecified semantics). For v1.0, fixed value of 0 </p></li>
<li><p>N bytes with extra content (of unspecified semantics), where N is the value of the previous field. </p></li>
</ol>
</p>
<p>This design does not provide any means of authentication or integrity check.</p>
<p>Each sector is encrypted/decrypted independently of other sectors. For that, the Initial Vector contained in the header is XOR’ed with the file offset (relative to plain text file) of the start of the sector being processed, as a 8-byte integer. More precisely, the first byte of the main IV is XOR’ed with the 8 least-significant bits of the sector offset, the second byte of the main IV is XOR’ed with the following 8 bits of the sector offset, etc… until the 8th byte.</p>
<p>This design could potentially be prone to chosen-plaintext attack, for example if the attacker managed to get (part of) an existing encrypted file to be encrypted from plaintext he might have selected.</p>
<p>Note: if “hostile” code can explore process content, or attach to it with a debugger, it might be relatively easy to retrieve the encryption key. A GDAL plugin could for example get the content of configuration options, or list opened datasets and see the key/key_b64 values, so disabling plugin loading might be a first step, as well as linking statically GDAL to application code. If plugin loading is enabled or GDAL dynamically linked, using <a class="reference internal" href="#cpl__vsi_8h_1a619a6f6758371a39e0c1a4168462452c"><span class="std std-ref">VSISetCryptKey()</span></a> to set the key might make it a bit more complicated to spy the key. But, as said initially, this is in no way a perfect protection.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414VSISetCryptKeyPK5GBytei">
<span id="_CPPv314VSISetCryptKeyPK5GBytei"></span><span id="_CPPv214VSISetCryptKeyPK5GBytei"></span><span id="VSISetCryptKey__GByteCP.i"></span><span class="target" id="cpl__vsi_8h_1a619a6f6758371a39e0c1a4168462452c"></span>void <code class="descname">VSISetCryptKey</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<em>pabyKey</em>, int <em>nKeySize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414VSISetCryptKeyPK5GBytei" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Installs the encryption/decryption key. </p>
<p>By passing a NULL key, the previously installed key will be cleared. Note, however, that it is not guaranteed that there won’t be trace of it in other places in memory or in on-disk temporary file.</p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference internal" href="#cpl__vsi_8h_1a5e20b79947f58970f5514b3eb9a524a9"><span class="std std-ref">VSIInstallCryptFileHandler()</span></a> for documentation on /vsicrypt/ </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pabyKey</span></code>: key. Might be NULL to clear previously set key. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nKeySize</span></code>: length of the key in bytes. Might be 0 to clear previously set key.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420VSIFileFromMemBufferPKcP5GByte12vsi_l_offseti">
<span id="_CPPv320VSIFileFromMemBufferPKcP5GByte12vsi_l_offseti"></span><span id="_CPPv220VSIFileFromMemBufferPKcP5GByte12vsi_l_offseti"></span><span id="VSIFileFromMemBuffer__cCP.GByteP.vsi_l_offset.i"></span><span class="target" id="cpl__vsi_8h_1a86b6b1c37bb19d954ee3c4a7e910120c"></span><a class="reference internal" href="#_CPPv48VSILFILE" title="VSILFILE">VSILFILE</a> *<code class="descname">VSIFileFromMemBuffer</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, <a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<em>pabyData</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nDataLength</em>, int <em>bTakeOwnership</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420VSIFileFromMemBufferPKcP5GByte12vsi_l_offseti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create memory “file” from a buffer. </p>
<p>A virtual memory file is created from the passed buffer with the indicated filename. Under normal conditions the filename would need to be absolute and within the /vsimem/ portion of the filesystem.</p>
<p>If bTakeOwnership is TRUE, then the memory file system handler will take ownership of the buffer, freeing it when the file is deleted. Otherwise it remains the responsibility of the caller, but should not be freed as long as it might be accessed as a file. In no circumstances does this function take a copy of the pabyData contents.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>open file handle on created file (see <a class="reference internal" href="#cpl__vsi_8h_1ae3cfa1605ce32e78fddb534bba7742f5"><span class="std std-ref">VSIFOpenL()</span></a>). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the filename to be created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyData</span></code>: the data buffer for the file. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nDataLength</span></code>: the length of buffer in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bTakeOwnership</span></code>: TRUE to transfer “ownership” of buffer or FALSE.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419VSIGetMemFileBufferPKcP12vsi_l_offseti">
<span id="_CPPv319VSIGetMemFileBufferPKcP12vsi_l_offseti"></span><span id="_CPPv219VSIGetMemFileBufferPKcP12vsi_l_offseti"></span><span id="VSIGetMemFileBuffer__cCP.vsi_l_offsetP.i"></span><span class="target" id="cpl__vsi_8h_1aeaf26bcc4a5314371f426bb2a5e6ce7a"></span><a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<code class="descname">VSIGetMemFileBuffer</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszFilename</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> *<em>pnDataLength</em>, int <em>bUnlinkAndSeize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419VSIGetMemFileBufferPKcP12vsi_l_offseti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch buffer underlying memory file. </p>
<p>This function returns a pointer to the memory buffer underlying a virtual “in memory” file. If bUnlinkAndSeize is TRUE the filesystem object will be deleted, and ownership of the buffer will pass to the caller otherwise the underlying file will remain in existence.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to memory buffer or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the name of the file to grab the buffer of. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnDataLength</span></code>: (file) length returned in this variable. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bUnlinkAndSeize</span></code>: TRUE to remove the file, or FALSE to leave unaltered.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423VSIStdoutSetRedirection16VSIWriteFunctionP4FILE">
<span id="_CPPv323VSIStdoutSetRedirection16VSIWriteFunctionP4FILE"></span><span id="_CPPv223VSIStdoutSetRedirection16VSIWriteFunctionP4FILE"></span><span id="VSIStdoutSetRedirection__VSIWriteFunction.FILEP"></span><span class="target" id="cpl__vsi_8h_1adc4a67cc303d7662c34f506d0bdddd79"></span>void <code class="descname">VSIStdoutSetRedirection</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416VSIWriteFunction" title="VSIWriteFunction">VSIWriteFunction</a> <em>pFct</em>, FILE *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423VSIStdoutSetRedirection16VSIWriteFunctionP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set an alternative write function and output file handle instead of fwrite() / stdout. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pFct</span></code>: Function with same signature as fwrite() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stream</span></code>: File handle on which to output. Passed to pFct.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv439VSIAllocFilesystemPluginCallbacksStructv">
<span id="_CPPv339VSIAllocFilesystemPluginCallbacksStructv"></span><span id="_CPPv239VSIAllocFilesystemPluginCallbacksStructv"></span><span id="VSIAllocFilesystemPluginCallbacksStruct__void"></span><span class="target" id="cpl__vsi_8h_1a060262f8e9dbe8509bbe535341021750"></span><a class="reference internal" href="#_CPPv434VSIFilesystemPluginCallbacksStruct" title="VSIFilesystemPluginCallbacksStruct">VSIFilesystemPluginCallbacksStruct</a> *<code class="descname">VSIAllocFilesystemPluginCallbacksStruct</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv439VSIAllocFilesystemPluginCallbacksStructv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return a <a class="reference internal" href="#structVSIFilesystemPluginCallbacksStruct"><span class="std std-ref">VSIFilesystemPluginCallbacksStruct</span></a> to be populated at runtime with handler callbacks </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv438VSIFreeFilesystemPluginCallbacksStructP34VSIFilesystemPluginCallbacksStruct">
<span id="_CPPv338VSIFreeFilesystemPluginCallbacksStructP34VSIFilesystemPluginCallbacksStruct"></span><span id="_CPPv238VSIFreeFilesystemPluginCallbacksStructP34VSIFilesystemPluginCallbacksStruct"></span><span id="VSIFreeFilesystemPluginCallbacksStruct__VSIFilesystemPluginCallbacksStructP"></span><span class="target" id="cpl__vsi_8h_1a463cc08892a277549cff8b1e4fe460a2"></span>void <code class="descname">VSIFreeFilesystemPluginCallbacksStruct</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv434VSIFilesystemPluginCallbacksStruct" title="VSIFilesystemPluginCallbacksStruct">VSIFilesystemPluginCallbacksStruct</a> *<em>poCb</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv438VSIFreeFilesystemPluginCallbacksStructP34VSIFilesystemPluginCallbacksStruct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free resources allocated by VSIAllocFilesystemPluginCallbacksStruct </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423VSIInstallPluginHandlerPKcPK34VSIFilesystemPluginCallbacksStruct">
<span id="_CPPv323VSIInstallPluginHandlerPKcPK34VSIFilesystemPluginCallbacksStruct"></span><span id="_CPPv223VSIInstallPluginHandlerPKcPK34VSIFilesystemPluginCallbacksStruct"></span><span id="VSIInstallPluginHandler__cCP.VSIFilesystemPluginCallbacksStructCP"></span><span class="target" id="cpl__vsi_8h_1a9fd74a1b0cad563fe1518660967a673f"></span>int <code class="descname">VSIInstallPluginHandler</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszPrefix</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv434VSIFilesystemPluginCallbacksStruct" title="VSIFilesystemPluginCallbacksStruct">VSIFilesystemPluginCallbacksStruct</a> *<em>poCb</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423VSIInstallPluginHandlerPKcPK34VSIFilesystemPluginCallbacksStruct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a handler on the given prefix. </p>
<p>All IO on datasets opened with the filename /prefix/xxxxxx will go through these callbacks. pszPrefix must begin and end with a ‘/’ <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv411VSIDIREntry">
<span id="_CPPv311VSIDIREntry"></span><span id="_CPPv211VSIDIREntry"></span><span id="VSIDIREntry"></span><span class="target" id="structVSIDIREntry"></span><em class="property">struct </em><code class="descname">VSIDIREntry</code><a class="headerlink" href="#_CPPv411VSIDIREntry" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_vsi.h&gt;</em><p>Directory entry. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N11VSIDIREntry7pszNameE">
<span id="_CPPv3N11VSIDIREntry7pszNameE"></span><span id="_CPPv2N11VSIDIREntry7pszNameE"></span><span id="VSIDIREntry::pszName__cP"></span><span class="target" id="structVSIDIREntry_1a269e989f65dbf43441ca1920b69ac48d"></span>char *<code class="descname">pszName</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry7pszNameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Filename. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11VSIDIREntry5nModeE">
<span id="_CPPv3N11VSIDIREntry5nModeE"></span><span id="_CPPv2N11VSIDIREntry5nModeE"></span><span id="VSIDIREntry::nMode__i"></span><span class="target" id="structVSIDIREntry_1ae48254f0d8c747c163e4bf49ddaefe25"></span>int <code class="descname">nMode</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry5nModeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>File mode. </p>
<p>See <a class="reference internal" href="#cpl__vsi_8h_1a57c4561cb89d1e6d0273c5be2a374777"><span class="std std-ref">VSI_ISREG()</span></a> / <a class="reference internal" href="#cpl__vsi_8h_1a13e9ada3d2bb3df2eae358b1037f9a1b"><span class="std std-ref">VSI_ISDIR()</span></a> </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11VSIDIREntry5nSizeE">
<span id="_CPPv3N11VSIDIREntry5nSizeE"></span><span id="_CPPv2N11VSIDIREntry5nSizeE"></span><span id="VSIDIREntry::nSize__vsi_l_offset"></span><span class="target" id="structVSIDIREntry_1ac250ac7dc6052c1b3588287f5cb7b7a4"></span><a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <code class="descname">nSize</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry5nSizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>File size. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11VSIDIREntry6nMTimeE">
<span id="_CPPv3N11VSIDIREntry6nMTimeE"></span><span id="_CPPv2N11VSIDIREntry6nMTimeE"></span><span id="VSIDIREntry::nMTime__GIntBig"></span><span class="target" id="structVSIDIREntry_1a517018cd60454e8dd5ae980578687aa9"></span><a class="reference internal" href="#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">nMTime</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry6nMTimeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Last modification time (seconds since 1970/01/01) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11VSIDIREntry10bModeKnownE">
<span id="_CPPv3N11VSIDIREntry10bModeKnownE"></span><span id="_CPPv2N11VSIDIREntry10bModeKnownE"></span><span id="VSIDIREntry::bModeKnown__c"></span><span class="target" id="structVSIDIREntry_1ab06624c830278293b6d8dd4eec10445a"></span>char <code class="descname">bModeKnown</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry10bModeKnownE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether nMode is known: 0 = unknown, 1 = known. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11VSIDIREntry10bSizeKnownE">
<span id="_CPPv3N11VSIDIREntry10bSizeKnownE"></span><span id="_CPPv2N11VSIDIREntry10bSizeKnownE"></span><span id="VSIDIREntry::bSizeKnown__c"></span><span class="target" id="structVSIDIREntry_1a8ad02d8d03ef06ab39e8f6509b35d1dc"></span>char <code class="descname">bSizeKnown</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry10bSizeKnownE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether nSize is known: 0 = unknown, 1 = known. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11VSIDIREntry11bMTimeKnownE">
<span id="_CPPv3N11VSIDIREntry11bMTimeKnownE"></span><span id="_CPPv2N11VSIDIREntry11bMTimeKnownE"></span><span id="VSIDIREntry::bMTimeKnown__c"></span><span class="target" id="structVSIDIREntry_1a5783a966994d75101c520020c5098983"></span>char <code class="descname">bMTimeKnown</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry11bMTimeKnownE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether nMTime is known: 0 = unknown, 1 = known. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11VSIDIREntry10papszExtraE">
<span id="_CPPv3N11VSIDIREntry10papszExtraE"></span><span id="_CPPv2N11VSIDIREntry10papszExtraE"></span><span id="VSIDIREntry::papszExtra__cPP"></span><span class="target" id="structVSIDIREntry_1ac123b60a958aa20e0d4dafb6d3d07248"></span>char **<code class="descname">papszExtra</code><a class="headerlink" href="#_CPPv4N11VSIDIREntry10papszExtraE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>NULL-terminated list of extra properties. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv434VSIFilesystemPluginCallbacksStruct">
<span id="_CPPv334VSIFilesystemPluginCallbacksStruct"></span><span id="_CPPv234VSIFilesystemPluginCallbacksStruct"></span><span id="VSIFilesystemPluginCallbacksStruct"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct"></span><em class="property">struct </em><code class="descname">VSIFilesystemPluginCallbacksStruct</code><a class="headerlink" href="#_CPPv434VSIFilesystemPluginCallbacksStruct" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_vsi.h&gt;</em><p>struct containing callbacks to used by the handler. </p>
<p>(rw), (r), (w) or () at the end indicate wether the given callback is mandatory for reading and or writing handlers. A (?) indicates that the callback might be mandatory for certain drivers only. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.5 </p>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct9pUserDataE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct9pUserDataE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct9pUserDataE"></span><span id="VSIFilesystemPluginCallbacksStruct::pUserData__voidP"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1ada74a0ca4b7b5d854585a16a8db30f89"></span>void *<code class="descname">pUserData</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct9pUserDataE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Optional opaque pointer passed back to filemanager callbacks (e.g. </p>
<p>open, stat, rmdir) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct4statE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct4statE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct4statE"></span><span id="VSIFilesystemPluginCallbacksStruct::stat__VSIFilesystemPluginStatCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1afbbd393174bfc5d3fde3ec17db641946"></span><a class="reference internal" href="#_CPPv431VSIFilesystemPluginStatCallback" title="VSIFilesystemPluginStatCallback">VSIFilesystemPluginStatCallback</a> <code class="descname">stat</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct4statE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>stat handle by name (rw) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct6unlinkE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct6unlinkE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct6unlinkE"></span><span id="VSIFilesystemPluginCallbacksStruct::unlink__VSIFilesystemPluginUnlinkCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a4a90b2036542ca5c0d6eb50dc6f2c088"></span><a class="reference internal" href="#_CPPv433VSIFilesystemPluginUnlinkCallback" title="VSIFilesystemPluginUnlinkCallback">VSIFilesystemPluginUnlinkCallback</a> <code class="descname">unlink</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct6unlinkE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unlink handle by name () </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct6renameE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct6renameE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct6renameE"></span><span id="VSIFilesystemPluginCallbacksStruct::rename__VSIFilesystemPluginRenameCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a38ddf090462fe02ed7d9b087f5238e78"></span><a class="reference internal" href="#_CPPv433VSIFilesystemPluginRenameCallback" title="VSIFilesystemPluginRenameCallback">VSIFilesystemPluginRenameCallback</a> <code class="descname">rename</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct6renameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>rename handle () </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct5mkdirE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct5mkdirE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct5mkdirE"></span><span id="VSIFilesystemPluginCallbacksStruct::mkdir__VSIFilesystemPluginMkdirCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1af8fbfdb1946d5c84e79ec8036a888196"></span><a class="reference internal" href="#_CPPv432VSIFilesystemPluginMkdirCallback" title="VSIFilesystemPluginMkdirCallback">VSIFilesystemPluginMkdirCallback</a> <code class="descname">mkdir</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct5mkdirE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>make directory () </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct5rmdirE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct5rmdirE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct5rmdirE"></span><span id="VSIFilesystemPluginCallbacksStruct::rmdir__VSIFilesystemPluginRmdirCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a5da18368794976dcbb1bc901afc8596f"></span><a class="reference internal" href="#_CPPv432VSIFilesystemPluginRmdirCallback" title="VSIFilesystemPluginRmdirCallback">VSIFilesystemPluginRmdirCallback</a> <code class="descname">rmdir</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct5rmdirE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove directory () </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct8read_dirE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct8read_dirE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct8read_dirE"></span><span id="VSIFilesystemPluginCallbacksStruct::read_dir__VSIFilesystemPluginReadDirCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1ad7b1a705e54fdabb7488636bfcbf0e1e"></span><a class="reference internal" href="#_CPPv434VSIFilesystemPluginReadDirCallback" title="VSIFilesystemPluginReadDirCallback">VSIFilesystemPluginReadDirCallback</a> <code class="descname">read_dir</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct8read_dirE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>list directory content (r?) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct4openE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct4openE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct4openE"></span><span id="VSIFilesystemPluginCallbacksStruct::open__VSIFilesystemPluginOpenCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a7c7ec0690f16d7bdc3f4615d6bc23624"></span><a class="reference internal" href="#_CPPv431VSIFilesystemPluginOpenCallback" title="VSIFilesystemPluginOpenCallback">VSIFilesystemPluginOpenCallback</a> <code class="descname">open</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct4openE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>open handle by name (rw) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct4tellE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct4tellE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct4tellE"></span><span id="VSIFilesystemPluginCallbacksStruct::tell__VSIFilesystemPluginTellCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1afdc784cb122f5dd5d5f2e6b706375ec6"></span><a class="reference internal" href="#_CPPv431VSIFilesystemPluginTellCallback" title="VSIFilesystemPluginTellCallback">VSIFilesystemPluginTellCallback</a> <code class="descname">tell</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct4tellE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get current position of handle (rw) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct4seekE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct4seekE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct4seekE"></span><span id="VSIFilesystemPluginCallbacksStruct::seek__VSIFilesystemPluginSeekCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a995c4f848b39000ed629809233fdc877"></span><a class="reference internal" href="#_CPPv431VSIFilesystemPluginSeekCallback" title="VSIFilesystemPluginSeekCallback">VSIFilesystemPluginSeekCallback</a> <code class="descname">seek</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct4seekE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set current position of handle (rw) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct4readE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct4readE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct4readE"></span><span id="VSIFilesystemPluginCallbacksStruct::read__VSIFilesystemPluginReadCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1ab94346ea870e0157946bee2425dd5a44"></span><a class="reference internal" href="#_CPPv431VSIFilesystemPluginReadCallback" title="VSIFilesystemPluginReadCallback">VSIFilesystemPluginReadCallback</a> <code class="descname">read</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct4readE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read from current position (r) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct16read_multi_rangeE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct16read_multi_rangeE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct16read_multi_rangeE"></span><span id="VSIFilesystemPluginCallbacksStruct::read_multi_range__VSIFilesystemPluginReadMultiRangeCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a44012dc24170f99be9e1ebae0b0e7d67"></span><a class="reference internal" href="#_CPPv441VSIFilesystemPluginReadMultiRangeCallback" title="VSIFilesystemPluginReadMultiRangeCallback">VSIFilesystemPluginReadMultiRangeCallback</a> <code class="descname">read_multi_range</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct16read_multi_rangeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read multiple blocks () </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct16get_range_statusE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct16get_range_statusE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct16get_range_statusE"></span><span id="VSIFilesystemPluginCallbacksStruct::get_range_status__VSIFilesystemPluginGetRangeStatusCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1ab55499ddd29f8bc90dc0e9aa7afd35b0"></span><a class="reference internal" href="#_CPPv441VSIFilesystemPluginGetRangeStatusCallback" title="VSIFilesystemPluginGetRangeStatusCallback">VSIFilesystemPluginGetRangeStatusCallback</a> <code class="descname">get_range_status</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct16get_range_statusE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get range status () </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct3eofE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct3eofE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct3eofE"></span><span id="VSIFilesystemPluginCallbacksStruct::eof__VSIFilesystemPluginEofCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a721befb3168283bb9327315d02e1b11d"></span><a class="reference internal" href="#_CPPv430VSIFilesystemPluginEofCallback" title="VSIFilesystemPluginEofCallback">VSIFilesystemPluginEofCallback</a> <code class="descname">eof</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct3eofE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>has end of file been reached (r?) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct5writeE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct5writeE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct5writeE"></span><span id="VSIFilesystemPluginCallbacksStruct::write__VSIFilesystemPluginWriteCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1a1bf7389b90ab6b469d063cbc9fce4af6"></span><a class="reference internal" href="#_CPPv432VSIFilesystemPluginWriteCallback" title="VSIFilesystemPluginWriteCallback">VSIFilesystemPluginWriteCallback</a> <code class="descname">write</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct5writeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write bytes to current position (w) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct5flushE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct5flushE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct5flushE"></span><span id="VSIFilesystemPluginCallbacksStruct::flush__VSIFilesystemPluginFlushCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1ac754094329da1c6935118763cb991021"></span><a class="reference internal" href="#_CPPv432VSIFilesystemPluginFlushCallback" title="VSIFilesystemPluginFlushCallback">VSIFilesystemPluginFlushCallback</a> <code class="descname">flush</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct5flushE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sync bytes (w) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct8truncateE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct8truncateE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct8truncateE"></span><span id="VSIFilesystemPluginCallbacksStruct::truncate__VSIFilesystemPluginTruncateCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1af88165ba21d31955ba2394e9fef10075"></span><a class="reference internal" href="#_CPPv435VSIFilesystemPluginTruncateCallback" title="VSIFilesystemPluginTruncateCallback">VSIFilesystemPluginTruncateCallback</a> <code class="descname">truncate</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct8truncateE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>truncate handle (w?) </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N34VSIFilesystemPluginCallbacksStruct5closeE">
<span id="_CPPv3N34VSIFilesystemPluginCallbacksStruct5closeE"></span><span id="_CPPv2N34VSIFilesystemPluginCallbacksStruct5closeE"></span><span id="VSIFilesystemPluginCallbacksStruct::close__VSIFilesystemPluginCloseCallback"></span><span class="target" id="structVSIFilesystemPluginCallbacksStruct_1ab74e4a85243591a675aa55c62a043b06"></span><a class="reference internal" href="#_CPPv432VSIFilesystemPluginCloseCallback" title="VSIFilesystemPluginCloseCallback">VSIFilesystemPluginCloseCallback</a> <code class="descname">close</code><a class="headerlink" href="#_CPPv4N34VSIFilesystemPluginCallbacksStruct5closeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>close handle (rw) </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="cpl-vsi-virtual-h">
<h2>cpl_vsi_virtual.h<a class="headerlink" href="#cpl-vsi-virtual-h" title="Permalink to this headline">¶</a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv429VSICreateBufferedReaderHandleP16VSIVirtualHandle">
<span id="_CPPv329VSICreateBufferedReaderHandleP16VSIVirtualHandle"></span><span id="_CPPv229VSICreateBufferedReaderHandleP16VSIVirtualHandle"></span><span id="VSICreateBufferedReaderHandle__VSIVirtualHandleP"></span><span class="target" id="cpl__vsi__virtual_8h_1a514250dfe10b819fba5be6b90654f80b"></span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<code class="descname">VSICreateBufferedReaderHandle</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<em>poBaseHandle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429VSICreateBufferedReaderHandleP16VSIVirtualHandle" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv429VSICreateBufferedReaderHandleP16VSIVirtualHandlePK5GByte12vsi_l_offset">
<span id="_CPPv329VSICreateBufferedReaderHandleP16VSIVirtualHandlePK5GByte12vsi_l_offset"></span><span id="_CPPv229VSICreateBufferedReaderHandleP16VSIVirtualHandlePK5GByte12vsi_l_offset"></span><span id="VSICreateBufferedReaderHandle__VSIVirtualHandleP.GByteCP.vsi_l_offset"></span><span class="target" id="cpl__vsi__virtual_8h_1a8411d59ae1f0ed518d9e930ceacbedd2"></span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<code class="descname">VSICreateBufferedReaderHandle</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<em>poBaseHandle</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv45GByte" title="GByte">GByte</a> *<em>pabyBeginningContent</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nCheatFileSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429VSICreateBufferedReaderHandleP16VSIVirtualHandlePK5GByte12vsi_l_offset" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv419VSICreateCachedFileP16VSIVirtualHandle6size_t6size_t">
<span id="_CPPv319VSICreateCachedFileP16VSIVirtualHandle6size_t6size_t"></span><span id="_CPPv219VSICreateCachedFileP16VSIVirtualHandle6size_t6size_t"></span><span id="VSICreateCachedFile__VSIVirtualHandleP.s.s"></span><span class="target" id="cpl__vsi__virtual_8h_1afdfdf63bb9561830ed2ce47a3ed02cb9"></span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<code class="descname">VSICreateCachedFile</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<em>poBaseHandle</em>, size_t <em>nChunkSize</em> = 32768, size_t <em>nCacheSize</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419VSICreateCachedFileP16VSIVirtualHandle6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv421VSICreateGZipWritableP16VSIVirtualHandleii">
<span id="_CPPv321VSICreateGZipWritableP16VSIVirtualHandleii"></span><span id="_CPPv221VSICreateGZipWritableP16VSIVirtualHandleii"></span><span id="VSICreateGZipWritable__VSIVirtualHandleP.i.i"></span><span class="target" id="cpl__vsi__virtual_8h_1adcaa8f2796348529e7e461493d62e615"></span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<code class="descname">VSICreateGZipWritable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416VSIVirtualHandle" title="VSIVirtualHandle">VSIVirtualHandle</a> *<em>poBaseHandle</em>, int <em>nDeflateType</em>, int <em>bAutoCloseBaseHandle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421VSICreateGZipWritableP16VSIVirtualHandleii" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Variables</p>
<dl class="member">
<dt id="_CPPv421CPL_DEFLATE_TYPE_GZIP">
<span id="_CPPv321CPL_DEFLATE_TYPE_GZIP"></span><span id="_CPPv221CPL_DEFLATE_TYPE_GZIP"></span><span id="CPL_DEFLATE_TYPE_GZIP__iC"></span><span class="target" id="cpl__vsi__virtual_8h_1ac35e02367e071313bdf7c1919504680d"></span><em class="property">const</em> int <code class="descname">CPL_DEFLATE_TYPE_GZIP</code> = 0<a class="headerlink" href="#_CPPv421CPL_DEFLATE_TYPE_GZIP" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv421CPL_DEFLATE_TYPE_ZLIB">
<span id="_CPPv321CPL_DEFLATE_TYPE_ZLIB"></span><span id="_CPPv221CPL_DEFLATE_TYPE_ZLIB"></span><span id="CPL_DEFLATE_TYPE_ZLIB__iC"></span><span class="target" id="cpl__vsi__virtual_8h_1a0286fd7d53ecf7a34ef6a8dd36d39343"></span><em class="property">const</em> int <code class="descname">CPL_DEFLATE_TYPE_ZLIB</code> = 1<a class="headerlink" href="#_CPPv421CPL_DEFLATE_TYPE_ZLIB" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv428CPL_DEFLATE_TYPE_RAW_DEFLATE">
<span id="_CPPv328CPL_DEFLATE_TYPE_RAW_DEFLATE"></span><span id="_CPPv228CPL_DEFLATE_TYPE_RAW_DEFLATE"></span><span id="CPL_DEFLATE_TYPE_RAW_DEFLATE__iC"></span><span class="target" id="cpl__vsi__virtual_8h_1a0661d2b280c0ea7a5796b673f53efbf8"></span><em class="property">const</em> int <code class="descname">CPL_DEFLATE_TYPE_RAW_DEFLATE</code> = 2<a class="headerlink" href="#_CPPv428CPL_DEFLATE_TYPE_RAW_DEFLATE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<dl class="class">
<dt id="_CPPv416VSIVirtualHandle">
<span id="_CPPv316VSIVirtualHandle"></span><span id="_CPPv216VSIVirtualHandle"></span><span id="VSIVirtualHandle"></span><span class="target" id="classVSIVirtualHandle"></span><em class="property">class </em><code class="descname">VSIVirtualHandle</code><a class="headerlink" href="#_CPPv416VSIVirtualHandle" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;cpl_vsi_virtual.h&gt;</em><p>Virtual file handle. </p>
<p>Subclassed by VSISparseFileHandle, VSISubFileHandle</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle4SeekE12vsi_l_offseti">
<span id="_CPPv3N16VSIVirtualHandle4SeekE12vsi_l_offseti"></span><span id="_CPPv2N16VSIVirtualHandle4SeekE12vsi_l_offseti"></span><span id="VSIVirtualHandle::Seek__vsi_l_offset.i"></span><span class="target" id="classVSIVirtualHandle_1aa87a4ad4d3f421ed88d0caea04ca8019"></span>int <code class="descname">Seek</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nOffset</em>, int <em>nWhence</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N16VSIVirtualHandle4SeekE12vsi_l_offseti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Seek to requested offset. </p>
<p>Seek to the desired offset (nOffset) in the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fseek() call.</p>
<p>Caution: vsi_l_offset is a unsigned type, so SEEK_CUR can only be used for positive seek. If negative seek is needed, use handle-&gt;Seek( handle-&gt;<a class="reference internal" href="#classVSIVirtualHandle_1aa77953d5e32c9f1c7f0ebac292d7141f"><span class="std std-ref">Tell()</span></a> + negative_offset, SEEK_SET ).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 one failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: offset in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nWhence</span></code>: one of SEEK_SET, SEEK_CUR or SEEK_END.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle4TellEv">
<span id="_CPPv3N16VSIVirtualHandle4TellEv"></span><span id="_CPPv2N16VSIVirtualHandle4TellEv"></span><span id="VSIVirtualHandle::Tell"></span><span class="target" id="classVSIVirtualHandle_1aa77953d5e32c9f1c7f0ebac292d7141f"></span><code class="descname">Tell</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N16VSIVirtualHandle4TellEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tell current file offset. </p>
<p>Returns the current file read/write offset in bytes from the beginning of the file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftell() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>file offset in bytes. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle4ReadEPv6size_t6size_t">
<span id="_CPPv3N16VSIVirtualHandle4ReadEPv6size_t6size_t"></span><span id="_CPPv2N16VSIVirtualHandle4ReadEPv6size_t6size_t"></span><span id="VSIVirtualHandle::Read__voidP.s.s"></span><span class="target" id="classVSIVirtualHandle_1ab2d52a0ec4db34d2eb0e7835be6638e3"></span><code class="descname">Read</code><span class="sig-paren">(</span>void *<em>pBuffer</em>, size_t <em>nSize</em>, size_t <em>nCount</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N16VSIVirtualHandle4ReadEPv6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read bytes from file. </p>
<p>Reads nCount objects of nSize bytes from the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fread() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of objects successfully read. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pBuffer</span></code>: the buffer into which the data should be read (at least nCount * nSize bytes in size. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: size of objects to read in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: number of objects to read.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle14ReadMultiRangeEiPPvPK12vsi_l_offsetPK6size_t">
<span id="_CPPv3N16VSIVirtualHandle14ReadMultiRangeEiPPvPK12vsi_l_offsetPK6size_t"></span><span id="_CPPv2N16VSIVirtualHandle14ReadMultiRangeEiPPvPK12vsi_l_offsetPK6size_t"></span><span id="VSIVirtualHandle::ReadMultiRange__i.voidPP.vsi_l_offsetCP.sCP"></span><span class="target" id="classVSIVirtualHandle_1ad0bae094921b7d468bfc2a635bbaa13d"></span><code class="descname">ReadMultiRange</code><span class="sig-paren">(</span>int <em>nRanges</em>, void **<em>ppData</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> *<em>panOffsets</em>, <em class="property">const</em> size_t *<em>panSizes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16VSIVirtualHandle14ReadMultiRangeEiPPvPK12vsi_l_offsetPK6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read several ranges of bytes from file. </p>
<p>Reads nRanges objects of panSizes[i] bytes from the indicated file at the offset panOffsets[i] into the buffer ppData[i].</p>
<p>Ranges must be sorted in ascending start offset, and must not overlap each other.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory or /vsicurl/.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 in case of success, -1 otherwise. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nRanges</span></code>: number of ranges to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppData</span></code>: array of nRanges buffer into which the data should be read (ppData[i] must be at list panSizes[i] bytes). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panOffsets</span></code>: array of nRanges offsets at which the data should be read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panSizes</span></code>: array of nRanges sizes of objects to read (in bytes).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle5WriteEPKv6size_t6size_t">
<span id="_CPPv3N16VSIVirtualHandle5WriteEPKv6size_t6size_t"></span><span id="_CPPv2N16VSIVirtualHandle5WriteEPKv6size_t6size_t"></span><span id="VSIVirtualHandle::Write__voidCP.s.s"></span><span class="target" id="classVSIVirtualHandle_1ad4a66b268026aedb669ae061c4afcd95"></span><code class="descname">Write</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>pBuffer</em>, size_t <em>nSize</em>, size_t <em>nCount</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N16VSIVirtualHandle5WriteEPKv6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write bytes to file. </p>
<p>Writess nCount objects of nSize bytes to the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fwrite() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of objects successfully written. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pBuffer</span></code>: the buffer from which the data should be written (at least nCount * nSize bytes in size. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: size of objects to read in bytes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: number of objects to read.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle3EofEv">
<span id="_CPPv3N16VSIVirtualHandle3EofEv"></span><span id="_CPPv2N16VSIVirtualHandle3EofEv"></span><span id="VSIVirtualHandle::Eof"></span><span class="target" id="classVSIVirtualHandle_1ad94476bb616dce80b808d997f6eb4e95"></span><code class="descname">Eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N16VSIVirtualHandle3EofEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for end of file. </p>
<p>Returns TRUE (non-zero) if an end-of-file condition occurred during the previous read operation. The end-of-file flag is cleared by a successful <a class="reference internal" href="#cpl__vsi_8h_1ab32d81e8bf69e8e6e87f0aadf0a490c3"><span class="std std-ref">VSIFSeekL()</span></a> call.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX feof() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if at EOF else FALSE. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle5FlushEv">
<span id="_CPPv3N16VSIVirtualHandle5FlushEv"></span><span id="_CPPv2N16VSIVirtualHandle5FlushEv"></span><span id="VSIVirtualHandle::Flush"></span><span class="target" id="classVSIVirtualHandle_1a4b12ef4dcf1112d3f563e2afe9205531"></span><code class="descname">Flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16VSIVirtualHandle5FlushEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush pending writes to disk. </p>
<p>For files in write or update mode and on filesystem types where it is applicable, all pending output on the file is flushed to the physical disk.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fflush() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on error. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle5CloseEv">
<span id="_CPPv3N16VSIVirtualHandle5CloseEv"></span><span id="_CPPv2N16VSIVirtualHandle5CloseEv"></span><span id="VSIVirtualHandle::Close"></span><span class="target" id="classVSIVirtualHandle_1a9bbc358df3770382b5848c55c04af4dc"></span><code class="descname">Close</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N16VSIVirtualHandle5CloseEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close file. </p>
<p>This function closes the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fclose() function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success or -1 on failure. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle8TruncateE12vsi_l_offset">
<span id="_CPPv3N16VSIVirtualHandle8TruncateE12vsi_l_offset"></span><span id="_CPPv2N16VSIVirtualHandle8TruncateE12vsi_l_offset"></span><span id="VSIVirtualHandle::Truncate__vsi_l_offset"></span><span class="target" id="classVSIVirtualHandle_1afdc2e8a025decb0fea2ec7f3f3ef38e9"></span><code class="descname">Truncate</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nNewSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16VSIVirtualHandle8TruncateE12vsi_l_offset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Truncate/expand the file to the specified size. </p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftruncate() call.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 on success </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nNewSize</span></code>: new size in bytes.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle23GetNativeFileDescriptorEv">
<span id="_CPPv3N16VSIVirtualHandle23GetNativeFileDescriptorEv"></span><span id="_CPPv2N16VSIVirtualHandle23GetNativeFileDescriptorEv"></span><span id="VSIVirtualHandle::GetNativeFileDescriptor"></span><span class="target" id="classVSIVirtualHandle_1aba8066427791b4e2866bda31fd6dcf98"></span><code class="descname">GetNativeFileDescriptor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16VSIVirtualHandle23GetNativeFileDescriptorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the “native” file descriptor for the virtual handle. </p>
<p>This will only return a non-NULL value for “real” files handled by the operating system (to be opposed to GDAL virtual file systems).</p>
<p>On POSIX systems, this will be a integer value (“fd”) cast as a void*. On Windows systems, this will be the HANDLE.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the native file descriptor, or NULL. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandle14GetRangeStatusE12vsi_l_offset12vsi_l_offset">
<span id="_CPPv3N16VSIVirtualHandle14GetRangeStatusE12vsi_l_offset12vsi_l_offset"></span><span id="_CPPv2N16VSIVirtualHandle14GetRangeStatusE12vsi_l_offset12vsi_l_offset"></span><span id="VSIVirtualHandle::GetRangeStatus__vsi_l_offset.vsi_l_offset"></span><span class="target" id="classVSIVirtualHandle_1aa0fc8e6008199ed9b21318a283565a47"></span><code class="descname">GetRangeStatus</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nOffset</em>, <a class="reference internal" href="#_CPPv412vsi_l_offset" title="vsi_l_offset">vsi_l_offset</a> <em>nLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16VSIVirtualHandle14GetRangeStatusE12vsi_l_offset12vsi_l_offset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if a given file range contains data or holes filled with zeroes. </p>
<p>This uses the filesystem capabilities of querying which regions of a sparse file are allocated or not. This is currently only implemented for Linux (and no other Unix derivatives) and Windows.</p>
<p><p>Note: A return of VSI_RANGE_STATUS_DATA doesn’t exclude that the extent is filled with zeroes! It must be interpreted as “may</p>
<p>contain non-zero data”.</p>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>extent status: VSI_RANGE_STATUS_UNKNOWN, VSI_RANGE_STATUS_DATA or VSI_RANGE_STATUS_HOLE </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nOffset</span></code>: offset of the start of the extent. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLength</span></code>: extent length.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N16VSIVirtualHandleD0Ev">
<span id="_CPPv3N16VSIVirtualHandleD0Ev"></span><span id="_CPPv2N16VSIVirtualHandleD0Ev"></span><span id="VSIVirtualHandle::~VSIVirtualHandle"></span><span class="target" id="classVSIVirtualHandle_1ae57ffe651ae52625a556997a7060ab12"></span><em class="property">virtual</em> <code class="descname">~VSIVirtualHandle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N16VSIVirtualHandleD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="raster_c_api.html" class="btn btn-neutral float-right" title="gdal.h: Raster C API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://osgeo.org">
        <div class="osgeo-logo"></div>
      </a>
      <div class="copyright">
      

      &copy; 1998-2019 <a href="https://github.com/warmerdam">Frank Warmerdam</a>,
      <a href="https://github.com/rouault">Even Rouault</a>, and
      <a href="https://github.com/OSGeo/gdal/graphs/contributors">others</a>


      
      </div>
    </div>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>