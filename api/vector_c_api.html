

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ogr_core.h and ogr_api.h: Vector C API &mdash; GDAL  documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://gdal.orgapi/vector_c_api.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/gdal.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="gdal_alg.h: GDAL Algorithms C API" href="gdal_alg.html" />
    <link rel="prev" title="gdal.h: Raster C API" href="raster_c_api.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/gdalicon.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programs/index.html">Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/raster/index.html">Raster drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/vector/index.html">Vector drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Full Doxygen output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#c-api">C API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="cpl.html">Common Portability Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="raster_c_api.html">gdal.h: Raster C API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">ogr_core.h and ogr_api.h: Vector C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gdal_alg.html">gdal_alg.h: GDAL Algorithms C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="ogr_srs_api.html">ogr_srs_api.h: Spatial Reference System C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gdal_utils.html">gdal_utils.h: GDAL Algorithms C API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">C++ API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#python-api">Python API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Java API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">How to contribute?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDAL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html"> GDAL  documentation </a> &raquo;</li>
      
          <li><a href="index.html">API</a> &raquo;</li>
      
      <li>ogr_core.h and ogr_api.h: Vector C API</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/OSGeo/gdal/edit//master/gdal/doc/source/api/vector_c_api.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="gdal_alg.html" class="btn btn-neutral float-right" title="gdal_alg.h: GDAL Algorithms C API" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="raster_c_api.html" class="btn btn-neutral float-left" title="gdal.h: Raster C API" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ogr-core-h-and-ogr-api-h-vector-c-api">
<span id="vector-c-api"></span><h1>ogr_core.h and ogr_api.h: Vector C API<a class="headerlink" href="#ogr-core-h-and-ogr-api-h-vector-c-api" title="Permalink to this headline">¶</a></h1>
<p>Core portability services for cross-platform OGR code. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.OGRERR_NONE">
<span class="target" id="ogr__core_8h_1a67a14d8dceb15392134cc51180c5e6f0"></span><code class="descname">OGRERR_NONE</code><a class="headerlink" href="#c.OGRERR_NONE" title="Permalink to this definition">¶</a></dt>
<dd><p>Success. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_NOT_ENOUGH_DATA">
<span class="target" id="ogr__core_8h_1ab8de2bdd9162c6bc711099f5faf18f89"></span><code class="descname">OGRERR_NOT_ENOUGH_DATA</code><a class="headerlink" href="#c.OGRERR_NOT_ENOUGH_DATA" title="Permalink to this definition">¶</a></dt>
<dd><p>Not enough data to deserialize. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_NOT_ENOUGH_MEMORY">
<span class="target" id="ogr__core_8h_1a1186e39e672505cd5295b12df488b83a"></span><code class="descname">OGRERR_NOT_ENOUGH_MEMORY</code><a class="headerlink" href="#c.OGRERR_NOT_ENOUGH_MEMORY" title="Permalink to this definition">¶</a></dt>
<dd><p>Not enough memory. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_UNSUPPORTED_GEOMETRY_TYPE">
<span class="target" id="ogr__core_8h_1a4412b6b26167ad047403f2938cd58720"></span><code class="descname">OGRERR_UNSUPPORTED_GEOMETRY_TYPE</code><a class="headerlink" href="#c.OGRERR_UNSUPPORTED_GEOMETRY_TYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported geometry type. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_UNSUPPORTED_OPERATION">
<span class="target" id="ogr__core_8h_1a65bd89a6e2d22b1a98bd7304df2ed9ef"></span><code class="descname">OGRERR_UNSUPPORTED_OPERATION</code><a class="headerlink" href="#c.OGRERR_UNSUPPORTED_OPERATION" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported operation. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_CORRUPT_DATA">
<span class="target" id="ogr__core_8h_1a864b0b3ebdec7a89f53d0c5eff552bd7"></span><code class="descname">OGRERR_CORRUPT_DATA</code><a class="headerlink" href="#c.OGRERR_CORRUPT_DATA" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrupt data. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_FAILURE">
<span class="target" id="ogr__core_8h_1a64dd6c75304d5238e4565c37fd72d127"></span><code class="descname">OGRERR_FAILURE</code><a class="headerlink" href="#c.OGRERR_FAILURE" title="Permalink to this definition">¶</a></dt>
<dd><p>Failure. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_UNSUPPORTED_SRS">
<span class="target" id="ogr__core_8h_1af38b2047148669a67583ff4db68faca6"></span><code class="descname">OGRERR_UNSUPPORTED_SRS</code><a class="headerlink" href="#c.OGRERR_UNSUPPORTED_SRS" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsupported SRS. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_INVALID_HANDLE">
<span class="target" id="ogr__core_8h_1aaf7204f7ec7f00974f19e37bf505ff64"></span><code class="descname">OGRERR_INVALID_HANDLE</code><a class="headerlink" href="#c.OGRERR_INVALID_HANDLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalid handle. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRERR_NON_EXISTING_FEATURE">
<span class="target" id="ogr__core_8h_1aa1cae24775a1d7cb0013c42082e27770"></span><code class="descname">OGRERR_NON_EXISTING_FEATURE</code><a class="headerlink" href="#c.OGRERR_NON_EXISTING_FEATURE" title="Permalink to this definition">¶</a></dt>
<dd><p>Non existing feature. </p>
<p>Added in GDAL 2.0 </p>
</dd></dl>

<dl class="macro">
<dt id="c.wkb25DBit">
<span class="target" id="ogr__core_8h_1ae4932f824a0f693faeca375991cd2731"></span><code class="descname">wkb25DBit</code><a class="headerlink" href="#c.wkb25DBit" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <a class="reference internal" href="#ogr__core_8h_1a3a189ffad565220f7136f75acb36cd5b"><span class="std std-ref">wkbHasZ()</span></a> or <a class="reference internal" href="#ogr__core_8h_1af7f9c35ea21bf9f697e928306461b9d2"><span class="std std-ref">wkbSetZ()</span></a> instead </p>
</dd></dl>

<dl class="macro">
<dt id="c.wkbFlatten">
<span class="target" id="ogr__core_8h_1a5d2800b1a2d4f4dbcb906390969bb823"></span><code class="descname">wkbFlatten</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.wkbFlatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D geometry type corresponding to the specified geometry type. </p>
</dd></dl>

<dl class="macro">
<dt id="c.wkbHasZ">
<span class="target" id="ogr__core_8h_1a3a189ffad565220f7136f75acb36cd5b"></span><code class="descname">wkbHasZ</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.wkbHasZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the geometry type is a 3D geometry type. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.wkbSetZ">
<span class="target" id="ogr__core_8h_1af7f9c35ea21bf9f697e928306461b9d2"></span><code class="descname">wkbSetZ</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.wkbSetZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 3D geometry type corresponding to the specified geometry type. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.wkbHasM">
<span class="target" id="ogr__core_8h_1a552060d466efae92b2468986a2c3a85b"></span><code class="descname">wkbHasM</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.wkbHasM" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the geometry type is a measured geometry type. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.wkbSetM">
<span class="target" id="ogr__core_8h_1ac53d390c34fea4a4402b959db2a01af5"></span><code class="descname">wkbSetM</code><span class="sig-paren">(</span>x<span class="sig-paren">)</span><a class="headerlink" href="#c.wkbSetM" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the measured geometry type corresponding to the specified geometry type. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ALTER_NAME_FLAG">
<span class="target" id="ogr__core_8h_1ae5dc1fbc063f26feb53c911b3153c5cf"></span><code class="descname">ALTER_NAME_FLAG</code><a class="headerlink" href="#c.ALTER_NAME_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter field name. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"><span class="std std-ref">OGR_L_AlterFieldDefn()</span></a>. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ALTER_TYPE_FLAG">
<span class="target" id="ogr__core_8h_1a19840ec29ce57dbcc9ae97eb7e758d0d"></span><code class="descname">ALTER_TYPE_FLAG</code><a class="headerlink" href="#c.ALTER_TYPE_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter field type. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"><span class="std std-ref">OGR_L_AlterFieldDefn()</span></a>. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ALTER_WIDTH_PRECISION_FLAG">
<span class="target" id="ogr__core_8h_1a09ec213da159a97fe09b13b5c5693adb"></span><code class="descname">ALTER_WIDTH_PRECISION_FLAG</code><a class="headerlink" href="#c.ALTER_WIDTH_PRECISION_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter field width and precision. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"><span class="std std-ref">OGR_L_AlterFieldDefn()</span></a>. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ALTER_NULLABLE_FLAG">
<span class="target" id="ogr__core_8h_1a4d83ded173814a270803e9d20af2daff"></span><code class="descname">ALTER_NULLABLE_FLAG</code><a class="headerlink" href="#c.ALTER_NULLABLE_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter field NOT NULL constraint. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"><span class="std std-ref">OGR_L_AlterFieldDefn()</span></a>. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ALTER_DEFAULT_FLAG">
<span class="target" id="ogr__core_8h_1a6fea652edd02fdc91061a91b62dc3687"></span><code class="descname">ALTER_DEFAULT_FLAG</code><a class="headerlink" href="#c.ALTER_DEFAULT_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter field DEFAULT value. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"><span class="std std-ref">OGR_L_AlterFieldDefn()</span></a>. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ALTER_ALL_FLAG">
<span class="target" id="ogr__core_8h_1a22b152e645df03a5cd99670130eed6f7"></span><code class="descname">ALTER_ALL_FLAG</code><a class="headerlink" href="#c.ALTER_ALL_FLAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter all parameters of field definition. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"><span class="std std-ref">OGR_L_AlterFieldDefn()</span></a>. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGR_F_VAL_NULL">
<span class="target" id="ogr__core_8h_1a6936ac8aa5272ed9bdf71750e5ecc50d"></span><code class="descname">OGR_F_VAL_NULL</code><a class="headerlink" href="#c.OGR_F_VAL_NULL" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate that fields respect not-null constraints. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1ab798c73a20f4b311026232badda9701d"><span class="std std-ref">OGR_F_Validate()</span></a>. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OGR_F_VAL_GEOM_TYPE">
<span class="target" id="ogr__core_8h_1af6d19add58b02531536f69e6f74f2f20"></span><code class="descname">OGR_F_VAL_GEOM_TYPE</code><a class="headerlink" href="#c.OGR_F_VAL_GEOM_TYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate that geometries respect geometry column type. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1ab798c73a20f4b311026232badda9701d"><span class="std std-ref">OGR_F_Validate()</span></a>. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OGR_F_VAL_WIDTH">
<span class="target" id="ogr__core_8h_1aeaf4227803a98f710b8722319b185a7a"></span><code class="descname">OGR_F_VAL_WIDTH</code><a class="headerlink" href="#c.OGR_F_VAL_WIDTH" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate that (string) fields respect field width. </p>
<p>Used by <a class="reference internal" href="#ogr__api_8h_1ab798c73a20f4b311026232badda9701d"><span class="std std-ref">OGR_F_Validate()</span></a>. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT">
<span class="target" id="ogr__core_8h_1acf3d1264609fad413525c153161baa03"></span><code class="descname">OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT</code><a class="headerlink" href="#c.OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow fields that are null when there’s an associated default value. </p>
<p>This can be used for drivers where the low-level layers will automatically set the field value to the associated default value. This flag only makes sense if OGR_F_VAL_NULL is set too. Used by <a class="reference internal" href="#ogr__api_8h_1ab798c73a20f4b311026232badda9701d"><span class="std std-ref">OGR_F_Validate()</span></a>. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OGR_F_VAL_ALLOW_DIFFERENT_GEOM_DIM">
<span class="target" id="ogr__core_8h_1aff7d06f2baaecd46fb55b4f1ec3b86b2"></span><code class="descname">OGR_F_VAL_ALLOW_DIFFERENT_GEOM_DIM</code><a class="headerlink" href="#c.OGR_F_VAL_ALLOW_DIFFERENT_GEOM_DIM" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow geometry fields to have a different coordinate dimension that their geometry column type. </p>
<p>This flag only makes sense if OGR_F_VAL_GEOM_TYPE is set too. Used by <a class="reference internal" href="#ogr__api_8h_1ab798c73a20f4b311026232badda9701d"><span class="std std-ref">OGR_F_Validate()</span></a>. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OGR_F_VAL_ALL">
<span class="target" id="ogr__core_8h_1afc1c5bba85187cdd49383c9b257bcc70"></span><code class="descname">OGR_F_VAL_ALL</code><a class="headerlink" href="#c.OGR_F_VAL_ALL" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable all validation tests (except OGR_F_VAL_ALLOW_DIFFERENT_GEOM_DIM) Used by <a class="reference internal" href="#ogr__api_8h_1ab798c73a20f4b311026232badda9701d"><span class="std std-ref">OGR_F_Validate()</span></a>. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRNullFID">
<span class="target" id="ogr__core_8h_1a575c23b96692505552e95f43fbee9a85"></span><code class="descname">OGRNullFID</code><a class="headerlink" href="#c.OGRNullFID" title="Permalink to this definition">¶</a></dt>
<dd><p>Special value for a unset FID. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRUnsetMarker">
<span class="target" id="ogr__core_8h_1a1188ba45fc0c8629d5e63d9dfdfcba13"></span><code class="descname">OGRUnsetMarker</code><a class="headerlink" href="#c.OGRUnsetMarker" title="Permalink to this definition">¶</a></dt>
<dd><p>Special value set in OGRField.Set.nMarker1, nMarker2 and nMarker3 for a unset field. </p>
<p>Direct use of this value is strongly discouraged. Use <a class="reference internal" href="#ogr__api_8h_1acaac3d8e8d01fa83a52dd2d95aac0cc3"><span class="std std-ref">OGR_RawField_SetUnset()</span></a> or <a class="reference internal" href="#ogr__api_8h_1ae23095c63fc350d712940bdbf440bbcb"><span class="std std-ref">OGR_RawField_IsUnset()</span></a> instead. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OGRNullMarker">
<span class="target" id="ogr__core_8h_1a7e904b6d4a3e115552b1b123d2fd65b9"></span><code class="descname">OGRNullMarker</code><a class="headerlink" href="#c.OGRNullMarker" title="Permalink to this definition">¶</a></dt>
<dd><p>Special value set in OGRField.Set.nMarker1, nMarker2 and nMarker3 for a null field. </p>
<p>Direct use of this value is strongly discouraged. Use <a class="reference internal" href="#ogr__api_8h_1acf6c613c24de0e11fe259e86160157d3"><span class="std std-ref">OGR_RawField_SetNull()</span></a> or <a class="reference internal" href="#ogr__api_8h_1aa9a401e6dbd5577396b567791cf85115"><span class="std std-ref">OGR_RawField_IsNull()</span></a> instead. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCRandomRead">
<span class="target" id="ogr__core_8h_1a70fa6d299065e825d6fa3b70ba01f3e8"></span><code class="descname">OLCRandomRead</code><a class="headerlink" href="#c.OLCRandomRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for random read. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCSequentialWrite">
<span class="target" id="ogr__core_8h_1afb6873d535981168ced447d148fa9baf"></span><code class="descname">OLCSequentialWrite</code><a class="headerlink" href="#c.OLCSequentialWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for sequential write. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCRandomWrite">
<span class="target" id="ogr__core_8h_1aa45fa1e2760aefaac833fbc357a52024"></span><code class="descname">OLCRandomWrite</code><a class="headerlink" href="#c.OLCRandomWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for random write. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCFastSpatialFilter">
<span class="target" id="ogr__core_8h_1a0b58ffb6bd7240be21146f731d280bd8"></span><code class="descname">OLCFastSpatialFilter</code><a class="headerlink" href="#c.OLCFastSpatialFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for fast spatial filter. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCFastFeatureCount">
<span class="target" id="ogr__core_8h_1a316d04fad08733428538917dd4371812"></span><code class="descname">OLCFastFeatureCount</code><a class="headerlink" href="#c.OLCFastFeatureCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for fast feature count retrieval. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCFastGetExtent">
<span class="target" id="ogr__core_8h_1a72db253ae927fcd2e483a022b7606d5e"></span><code class="descname">OLCFastGetExtent</code><a class="headerlink" href="#c.OLCFastGetExtent" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for fast extent retrieval. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCCreateField">
<span class="target" id="ogr__core_8h_1a45e22b82a5e4814cc22c21fe93687d7e"></span><code class="descname">OLCCreateField</code><a class="headerlink" href="#c.OLCCreateField" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for field creation. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCDeleteField">
<span class="target" id="ogr__core_8h_1a1a38d810067dcc5d15c409c9e06838c6"></span><code class="descname">OLCDeleteField</code><a class="headerlink" href="#c.OLCDeleteField" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for field deletion. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCReorderFields">
<span class="target" id="ogr__core_8h_1a63095f62029529a0eba8bfcc7927975f"></span><code class="descname">OLCReorderFields</code><a class="headerlink" href="#c.OLCReorderFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for field reordering. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCAlterFieldDefn">
<span class="target" id="ogr__core_8h_1a616f0aabf5d9cde13ce08cd9633f6b0a"></span><code class="descname">OLCAlterFieldDefn</code><a class="headerlink" href="#c.OLCAlterFieldDefn" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for field alteration. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCTransactions">
<span class="target" id="ogr__core_8h_1acd22863e11c2f423b45ccd3aa55d32ab"></span><code class="descname">OLCTransactions</code><a class="headerlink" href="#c.OLCTransactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for transactions. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCDeleteFeature">
<span class="target" id="ogr__core_8h_1abfdfcb6643ce7dfbf0175d0e2eeee3c5"></span><code class="descname">OLCDeleteFeature</code><a class="headerlink" href="#c.OLCDeleteFeature" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for feature deletion. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCFastSetNextByIndex">
<span class="target" id="ogr__core_8h_1a7cabbb036cdc5b04127b5666fa95f766"></span><code class="descname">OLCFastSetNextByIndex</code><a class="headerlink" href="#c.OLCFastSetNextByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for setting next feature index. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCStringsAsUTF8">
<span class="target" id="ogr__core_8h_1a1eba7b7e18954793e5c7f0c5acd293b7"></span><code class="descname">OLCStringsAsUTF8</code><a class="headerlink" href="#c.OLCStringsAsUTF8" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for strings returned with UTF-8 encoding. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCIgnoreFields">
<span class="target" id="ogr__core_8h_1ae949eda7147c45f2567561d70a8dc131"></span><code class="descname">OLCIgnoreFields</code><a class="headerlink" href="#c.OLCIgnoreFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for field ignoring. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCCreateGeomField">
<span class="target" id="ogr__core_8h_1ae651e605045f463ffdf6523a6b7b14e5"></span><code class="descname">OLCCreateGeomField</code><a class="headerlink" href="#c.OLCCreateGeomField" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for geometry field creation. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCCurveGeometries">
<span class="target" id="ogr__core_8h_1af892df07fac2d3f5def3f6b37951db82"></span><code class="descname">OLCCurveGeometries</code><a class="headerlink" href="#c.OLCCurveGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for curve geometries support. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLCMeasuredGeometries">
<span class="target" id="ogr__core_8h_1ab0ebd4e82d743969e1527bdbd9be6202"></span><code class="descname">OLCMeasuredGeometries</code><a class="headerlink" href="#c.OLCMeasuredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer capability for measured geometries support. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCCreateLayer">
<span class="target" id="ogr__core_8h_1aef6b1c2b9b7081b6c0c2c14f44f89014"></span><code class="descname">ODsCCreateLayer</code><a class="headerlink" href="#c.ODsCCreateLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for layer creation. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCDeleteLayer">
<span class="target" id="ogr__core_8h_1ad804c84f5aa164ab96f258658803693d"></span><code class="descname">ODsCDeleteLayer</code><a class="headerlink" href="#c.ODsCDeleteLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for layer deletion. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCCreateGeomFieldAfterCreateLayer">
<span class="target" id="ogr__core_8h_1aa814db403bf1fe3b6ee922e30e7e1f7a"></span><code class="descname">ODsCCreateGeomFieldAfterCreateLayer</code><a class="headerlink" href="#c.ODsCCreateGeomFieldAfterCreateLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for geometry field creation support. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCCurveGeometries">
<span class="target" id="ogr__core_8h_1a33a06180934c6832e06567328a1993f3"></span><code class="descname">ODsCCurveGeometries</code><a class="headerlink" href="#c.ODsCCurveGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for curve geometries support. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCTransactions">
<span class="target" id="ogr__core_8h_1ae93f2147bb5cd084fee784367dbe7b69"></span><code class="descname">ODsCTransactions</code><a class="headerlink" href="#c.ODsCTransactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for dataset transcations. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCEmulatedTransactions">
<span class="target" id="ogr__core_8h_1a3d9dfe6be075d029ac9bb1460a3ed8c6"></span><code class="descname">ODsCEmulatedTransactions</code><a class="headerlink" href="#c.ODsCEmulatedTransactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for emulated dataset transactions. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCMeasuredGeometries">
<span class="target" id="ogr__core_8h_1a6c63984a908af16c5943a6b9278d37c0"></span><code class="descname">ODsCMeasuredGeometries</code><a class="headerlink" href="#c.ODsCMeasuredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for measured geometries support. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCRandomLayerRead">
<span class="target" id="ogr__core_8h_1ace275314ed857f0a48acf0d026976fb2"></span><code class="descname">ODsCRandomLayerRead</code><a class="headerlink" href="#c.ODsCRandomLayerRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for GetNextFeature() returning features from random layers. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODsCRandomLayerWrite">
<span class="target" id="ogr__core_8h_1aa401d9a32fa58ff62ac5c34df9da3019"></span><code class="descname">ODsCRandomLayerWrite</code><a class="headerlink" href="#c.ODsCRandomLayerWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Dataset capability for supporting CreateFeature on layer in random order. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODrCCreateDataSource">
<span class="target" id="ogr__core_8h_1ace35ae7cd97ddc359641b8511fef076a"></span><code class="descname">ODrCCreateDataSource</code><a class="headerlink" href="#c.ODrCCreateDataSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver capability for datasource creation. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ODrCDeleteDataSource">
<span class="target" id="ogr__core_8h_1af2d3b4b6004c9da07de7cf9996b6b1b0"></span><code class="descname">ODrCDeleteDataSource</code><a class="headerlink" href="#c.ODrCDeleteDataSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver capability for datasource deletion. </p>
</dd></dl>

<dl class="macro">
<dt id="c.OLMD_FID64">
<span class="target" id="ogr__core_8h_1a3cf2163613d4ae105358c3180f997c4c"></span><code class="descname">OLMD_FID64</code><a class="headerlink" href="#c.OLMD_FID64" title="Permalink to this definition">¶</a></dt>
<dd><p>Capability set to YES as metadata on a layer that has features with 64 bit identifiers. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv46OGRErr">
<span id="_CPPv36OGRErr"></span><span id="_CPPv26OGRErr"></span><span id="OGRErr"></span><span class="target" id="ogr__core_8h_1abd3e8d61c1e766992bdc71f846d56f65"></span><em class="property">typedef </em>int <code class="descname">OGRErr</code><a class="headerlink" href="#_CPPv46OGRErr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type for a OGR error. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv410OGRBoolean">
<span id="_CPPv310OGRBoolean"></span><span id="_CPPv210OGRBoolean"></span><span id="OGRBoolean"></span><span class="target" id="ogr__core_8h_1a1a234b9cde6d25c581b72e2b3c5af664"></span><em class="property">typedef </em>int <code class="descname">OGRBoolean</code><a class="headerlink" href="#_CPPv410OGRBoolean" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type for a OGR boolean. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv412OGRSTClassId">
<span id="_CPPv312OGRSTClassId"></span><span id="_CPPv212OGRSTClassId"></span><span id="OGRSTClassId"></span><span class="target" id="ogr__core_8h_1a109ea92417a0152008c7c11eeec4f028"></span><em class="property">typedef </em><em class="property">enum</em> <a class="reference internal" href="#_CPPv423ogr_style_tool_class_id" title="ogr_style_tool_class_id">ogr_style_tool_class_id</a> <code class="descname">OGRSTClassId</code><a class="headerlink" href="#_CPPv412OGRSTClassId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> derived class types (returned by GetType()). </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv411OGRSTUnitId">
<span id="_CPPv311OGRSTUnitId"></span><span id="_CPPv211OGRSTUnitId"></span><span id="OGRSTUnitId"></span><span class="target" id="ogr__core_8h_1af945b904942ebc25abc8f685bb6b20e1"></span><em class="property">typedef </em><em class="property">enum</em> <a class="reference internal" href="#_CPPv423ogr_style_tool_units_id" title="ogr_style_tool_units_id">ogr_style_tool_units_id</a> <code class="descname">OGRSTUnitId</code><a class="headerlink" href="#_CPPv411OGRSTUnitId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of units supported by OGRStyleTools. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv413OGRSTPenParam">
<span id="_CPPv313OGRSTPenParam"></span><span id="_CPPv213OGRSTPenParam"></span><span id="OGRSTPenParam"></span><span class="target" id="ogr__core_8h_1a389ce71839dfba1db3c2372cd0b9b0a4"></span><em class="property">typedef </em><em class="property">enum</em> <a class="reference internal" href="#_CPPv427ogr_style_tool_param_pen_id" title="ogr_style_tool_param_pen_id">ogr_style_tool_param_pen_id</a> <code class="descname">OGRSTPenParam</code><a class="headerlink" href="#_CPPv413OGRSTPenParam" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStylePen. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv415OGRSTBrushParam">
<span id="_CPPv315OGRSTBrushParam"></span><span id="_CPPv215OGRSTBrushParam"></span><span id="OGRSTBrushParam"></span><span class="target" id="ogr__core_8h_1acde986cc1c9bd94e9d5b0c098021ffd5"></span><em class="property">typedef </em><em class="property">enum</em> <a class="reference internal" href="#_CPPv429ogr_style_tool_param_brush_id" title="ogr_style_tool_param_brush_id">ogr_style_tool_param_brush_id</a> <code class="descname">OGRSTBrushParam</code><a class="headerlink" href="#_CPPv415OGRSTBrushParam" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStyleBrush. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv416OGRSTSymbolParam">
<span id="_CPPv316OGRSTSymbolParam"></span><span id="_CPPv216OGRSTSymbolParam"></span><span id="OGRSTSymbolParam"></span><span class="target" id="ogr__core_8h_1a00015868cea844e58a39438035a06128"></span><em class="property">typedef </em><em class="property">enum</em> <a class="reference internal" href="#_CPPv430ogr_style_tool_param_symbol_id" title="ogr_style_tool_param_symbol_id">ogr_style_tool_param_symbol_id</a> <code class="descname">OGRSTSymbolParam</code><a class="headerlink" href="#_CPPv416OGRSTSymbolParam" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStyleSymbol. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv415OGRSTLabelParam">
<span id="_CPPv315OGRSTLabelParam"></span><span id="_CPPv215OGRSTLabelParam"></span><span id="OGRSTLabelParam"></span><span class="target" id="ogr__core_8h_1a2a32d93d85a291671f3092d5fe9b1a8c"></span><em class="property">typedef </em><em class="property">enum</em> <a class="reference internal" href="#_CPPv429ogr_style_tool_param_label_id" title="ogr_style_tool_param_label_id">ogr_style_tool_param_label_id</a> <code class="descname">OGRSTLabelParam</code><a class="headerlink" href="#_CPPv415OGRSTLabelParam" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStyleLabel. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv418OGRwkbGeometryType">
<span id="_CPPv318OGRwkbGeometryType"></span><span id="_CPPv218OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12a"></span><em class="property">enum </em><code class="descname">OGRwkbGeometryType</code><a class="headerlink" href="#_CPPv418OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of well known binary geometry types. </p>
<p>These are used within the BLOBs but are also returned from <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a5c6bca18682cb933e3227552d480e1a5"><span class="std std-ref">OGRGeometry::getGeometryType()</span></a> to identify the type of a geometry object. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv410wkbUnknown">
<span id="_CPPv310wkbUnknown"></span><span id="_CPPv210wkbUnknown"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f"></span><code class="descname">wkbUnknown</code> = 0<a class="headerlink" href="#_CPPv410wkbUnknown" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unknown type, non-standard </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48wkbPoint">
<span id="_CPPv38wkbPoint"></span><span id="_CPPv28wkbPoint"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f"></span><code class="descname">wkbPoint</code> = 1<a class="headerlink" href="#_CPPv48wkbPoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>0-dimensional geometric object, standard WKB </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413wkbLineString">
<span id="_CPPv313wkbLineString"></span><span id="_CPPv213wkbLineString"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058"></span><code class="descname">wkbLineString</code> = 2<a class="headerlink" href="#_CPPv413wkbLineString" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>1-dimensional geometric object with linear interpolation between Points, standard WKB </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410wkbPolygon">
<span id="_CPPv310wkbPolygon"></span><span id="_CPPv210wkbPolygon"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb"></span><code class="descname">wkbPolygon</code> = 3<a class="headerlink" href="#_CPPv410wkbPolygon" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>planar 2-dimensional geometric object defined by 1 exterior boundary and 0 or more interior boundaries, standard WKB </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413wkbMultiPoint">
<span id="_CPPv313wkbMultiPoint"></span><span id="_CPPv213wkbMultiPoint"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c"></span><code class="descname">wkbMultiPoint</code> = 4<a class="headerlink" href="#_CPPv413wkbMultiPoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GeometryCollection of Points, standard WKB. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418wkbMultiLineString">
<span id="_CPPv318wkbMultiLineString"></span><span id="_CPPv218wkbMultiLineString"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429"></span><code class="descname">wkbMultiLineString</code> = 5<a class="headerlink" href="#_CPPv418wkbMultiLineString" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GeometryCollection of LineStrings, standard WKB. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415wkbMultiPolygon">
<span id="_CPPv315wkbMultiPolygon"></span><span id="_CPPv215wkbMultiPolygon"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1"></span><code class="descname">wkbMultiPolygon</code> = 6<a class="headerlink" href="#_CPPv415wkbMultiPolygon" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GeometryCollection of Polygons, standard WKB. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv421wkbGeometryCollection">
<span id="_CPPv321wkbGeometryCollection"></span><span id="_CPPv221wkbGeometryCollection"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1"></span><code class="descname">wkbGeometryCollection</code> = 7<a class="headerlink" href="#_CPPv421wkbGeometryCollection" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>geometric object that is a collection of 1 or more geometric objects, standard WKB </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417wkbCircularString">
<span id="_CPPv317wkbCircularString"></span><span id="_CPPv217wkbCircularString"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa0bbbf58ce1d0a0033cf3255ffb1b53c7"></span><code class="descname">wkbCircularString</code> = 8<a class="headerlink" href="#_CPPv417wkbCircularString" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>one or more circular arc segments connected end to end, ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbCompoundCurve">
<span id="_CPPv316wkbCompoundCurve"></span><span id="_CPPv216wkbCompoundCurve"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa78925cb3db49fb84a9ec1cd1858a5d7c"></span><code class="descname">wkbCompoundCurve</code> = 9<a class="headerlink" href="#_CPPv416wkbCompoundCurve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sequence of contiguous curves, ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415wkbCurvePolygon">
<span id="_CPPv315wkbCurvePolygon"></span><span id="_CPPv215wkbCurvePolygon"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaa9c15535cef9b7268f8383a916122ea1"></span><code class="descname">wkbCurvePolygon</code> = 10<a class="headerlink" href="#_CPPv415wkbCurvePolygon" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>planar surface, defined by 1 exterior boundary and zero or more interior boundaries, that are curves. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413wkbMultiCurve">
<span id="_CPPv313wkbMultiCurve"></span><span id="_CPPv213wkbMultiCurve"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aafbb3724463cd803727d29d863dae7452"></span><code class="descname">wkbMultiCurve</code> = 11<a class="headerlink" href="#_CPPv413wkbMultiCurve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GeometryCollection of Curves, ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415wkbMultiSurface">
<span id="_CPPv315wkbMultiSurface"></span><span id="_CPPv215wkbMultiSurface"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aab284f2fe29b6a575372562a4c2dfe452"></span><code class="descname">wkbMultiSurface</code> = 12<a class="headerlink" href="#_CPPv415wkbMultiSurface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GeometryCollection of Surfaces, ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48wkbCurve">
<span id="_CPPv38wkbCurve"></span><span id="_CPPv28wkbCurve"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa093d6f04f359d25cea705ef074b77796"></span><code class="descname">wkbCurve</code> = 13<a class="headerlink" href="#_CPPv48wkbCurve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Curve (abstract type). </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410wkbSurface">
<span id="_CPPv310wkbSurface"></span><span id="_CPPv210wkbSurface"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa6a889c67c4b4d6f77645d439ca37357c"></span><code class="descname">wkbSurface</code> = 14<a class="headerlink" href="#_CPPv410wkbSurface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Surface (abstract type). </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv420wkbPolyhedralSurface">
<span id="_CPPv320wkbPolyhedralSurface"></span><span id="_CPPv220wkbPolyhedralSurface"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa661c369246ec7ae541ff9652da340adf"></span><code class="descname">wkbPolyhedralSurface</code> = 15<a class="headerlink" href="#_CPPv420wkbPolyhedralSurface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a contiguous collection of polygons, which share common boundary segments, ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv46wkbTIN">
<span id="_CPPv36wkbTIN"></span><span id="_CPPv26wkbTIN"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa4d3f79c2d489d63fc94b0929952af1fe"></span><code class="descname">wkbTIN</code> = 16<a class="headerlink" href="#_CPPv46wkbTIN" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a PolyhedralSurface consisting only of Triangle patches ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411wkbTriangle">
<span id="_CPPv311wkbTriangle"></span><span id="_CPPv211wkbTriangle"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa1683938b59f52d600d56f70d386bebc6"></span><code class="descname">wkbTriangle</code> = 17<a class="headerlink" href="#_CPPv411wkbTriangle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a Triangle. </p>
<p>ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv47wkbNone">
<span id="_CPPv37wkbNone"></span><span id="_CPPv27wkbNone"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa988c33f9e94f35d2081e5882d4167ec6"></span><code class="descname">wkbNone</code> = 100<a class="headerlink" href="#_CPPv47wkbNone" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>non-standard, for pure attribute records </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413wkbLinearRing">
<span id="_CPPv313wkbLinearRing"></span><span id="_CPPv213wkbLinearRing"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa48a515899277ce8ccd0bb6041fd42bcc"></span><code class="descname">wkbLinearRing</code> = 101<a class="headerlink" href="#_CPPv413wkbLinearRing" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>non-standard, just for createGeometry() </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418wkbCircularStringZ">
<span id="_CPPv318wkbCircularStringZ"></span><span id="_CPPv218wkbCircularStringZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa6c8f25e021d3344952e4aa3257c07c92"></span><code class="descname">wkbCircularStringZ</code> = 1008<a class="headerlink" href="#_CPPv418wkbCircularStringZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wkbCircularString with Z component. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417wkbCompoundCurveZ">
<span id="_CPPv317wkbCompoundCurveZ"></span><span id="_CPPv217wkbCompoundCurveZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aafd56855827141e39377064412f6ff889"></span><code class="descname">wkbCompoundCurveZ</code> = 1009<a class="headerlink" href="#_CPPv417wkbCompoundCurveZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wkbCompoundCurve with Z component. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbCurvePolygonZ">
<span id="_CPPv316wkbCurvePolygonZ"></span><span id="_CPPv216wkbCurvePolygonZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaa0792626836170e845327e040bcbe0ff"></span><code class="descname">wkbCurvePolygonZ</code> = 1010<a class="headerlink" href="#_CPPv416wkbCurvePolygonZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wkbCurvePolygon with Z component. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414wkbMultiCurveZ">
<span id="_CPPv314wkbMultiCurveZ"></span><span id="_CPPv214wkbMultiCurveZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa6c8997202ca9a1d9d703978acce325e4"></span><code class="descname">wkbMultiCurveZ</code> = 1011<a class="headerlink" href="#_CPPv414wkbMultiCurveZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wkbMultiCurve with Z component. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbMultiSurfaceZ">
<span id="_CPPv316wkbMultiSurfaceZ"></span><span id="_CPPv216wkbMultiSurfaceZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aafe872f19c9beec34d480a14980cfdd50"></span><code class="descname">wkbMultiSurfaceZ</code> = 1012<a class="headerlink" href="#_CPPv416wkbMultiSurfaceZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wkbMultiSurface with Z component. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.0 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv49wkbCurveZ">
<span id="_CPPv39wkbCurveZ"></span><span id="_CPPv29wkbCurveZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaf4f04229d9f1eda299c2a44e99c63ed6"></span><code class="descname">wkbCurveZ</code> = 1013<a class="headerlink" href="#_CPPv49wkbCurveZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wkbCurve with Z component. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411wkbSurfaceZ">
<span id="_CPPv311wkbSurfaceZ"></span><span id="_CPPv211wkbSurfaceZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa190e734b9f1fa494074220b3d801172e"></span><code class="descname">wkbSurfaceZ</code> = 1014<a class="headerlink" href="#_CPPv411wkbSurfaceZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wkbSurface with Z component. </p>
<p>ISO SQL/MM Part 3. GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv421wkbPolyhedralSurfaceZ">
<span id="_CPPv321wkbPolyhedralSurfaceZ"></span><span id="_CPPv221wkbPolyhedralSurfaceZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa7ea4bd14b8fb032bd2dccbec8fc28378"></span><code class="descname">wkbPolyhedralSurfaceZ</code> = 1015<a class="headerlink" href="#_CPPv421wkbPolyhedralSurfaceZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv47wkbTINZ">
<span id="_CPPv37wkbTINZ"></span><span id="_CPPv27wkbTINZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa3a11585cc72740ac3fc43560ab684ff2"></span><code class="descname">wkbTINZ</code> = 1016<a class="headerlink" href="#_CPPv47wkbTINZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412wkbTriangleZ">
<span id="_CPPv312wkbTriangleZ"></span><span id="_CPPv212wkbTriangleZ"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaa8087a1b5f65f38be4b36aa7da3ed0a5"></span><code class="descname">wkbTriangleZ</code> = 1017<a class="headerlink" href="#_CPPv412wkbTriangleZ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv49wkbPointM">
<span id="_CPPv39wkbPointM"></span><span id="_CPPv29wkbPointM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa2d9dc6fffc0758db01591624270f0668"></span><code class="descname">wkbPointM</code> = 2001<a class="headerlink" href="#_CPPv49wkbPointM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414wkbLineStringM">
<span id="_CPPv314wkbLineStringM"></span><span id="_CPPv214wkbLineStringM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa4b47caa5aca6a93316fddd1eed0a5312"></span><code class="descname">wkbLineStringM</code> = 2002<a class="headerlink" href="#_CPPv414wkbLineStringM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411wkbPolygonM">
<span id="_CPPv311wkbPolygonM"></span><span id="_CPPv211wkbPolygonM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa3cfe6eab80b84eb59677facd6b02bf81"></span><code class="descname">wkbPolygonM</code> = 2003<a class="headerlink" href="#_CPPv411wkbPolygonM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414wkbMultiPointM">
<span id="_CPPv314wkbMultiPointM"></span><span id="_CPPv214wkbMultiPointM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa9dc56200a025f51aa346ed27fc884c2b"></span><code class="descname">wkbMultiPointM</code> = 2004<a class="headerlink" href="#_CPPv414wkbMultiPointM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419wkbMultiLineStringM">
<span id="_CPPv319wkbMultiLineStringM"></span><span id="_CPPv219wkbMultiLineStringM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa89c69fa32a43315417ff33b869579501"></span><code class="descname">wkbMultiLineStringM</code> = 2005<a class="headerlink" href="#_CPPv419wkbMultiLineStringM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbMultiPolygonM">
<span id="_CPPv316wkbMultiPolygonM"></span><span id="_CPPv216wkbMultiPolygonM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aabafe279749c0ba5bd2ba622d5d3e839f"></span><code class="descname">wkbMultiPolygonM</code> = 2006<a class="headerlink" href="#_CPPv416wkbMultiPolygonM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv422wkbGeometryCollectionM">
<span id="_CPPv322wkbGeometryCollectionM"></span><span id="_CPPv222wkbGeometryCollectionM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aae64d21bd2f313190d49e716d4241ec48"></span><code class="descname">wkbGeometryCollectionM</code> = 2007<a class="headerlink" href="#_CPPv422wkbGeometryCollectionM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418wkbCircularStringM">
<span id="_CPPv318wkbCircularStringM"></span><span id="_CPPv218wkbCircularStringM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa3c523a4f3289df6683fd1c0cb323fa33"></span><code class="descname">wkbCircularStringM</code> = 2008<a class="headerlink" href="#_CPPv418wkbCircularStringM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417wkbCompoundCurveM">
<span id="_CPPv317wkbCompoundCurveM"></span><span id="_CPPv217wkbCompoundCurveM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa33bcee0d09daf77c4f4f3786964a1c07"></span><code class="descname">wkbCompoundCurveM</code> = 2009<a class="headerlink" href="#_CPPv417wkbCompoundCurveM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbCurvePolygonM">
<span id="_CPPv316wkbCurvePolygonM"></span><span id="_CPPv216wkbCurvePolygonM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa647d2c128141fdf688fea9fde2759cb4"></span><code class="descname">wkbCurvePolygonM</code> = 2010<a class="headerlink" href="#_CPPv416wkbCurvePolygonM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414wkbMultiCurveM">
<span id="_CPPv314wkbMultiCurveM"></span><span id="_CPPv214wkbMultiCurveM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa460afe1e627a5a21f0220faa46d77972"></span><code class="descname">wkbMultiCurveM</code> = 2011<a class="headerlink" href="#_CPPv414wkbMultiCurveM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbMultiSurfaceM">
<span id="_CPPv316wkbMultiSurfaceM"></span><span id="_CPPv216wkbMultiSurfaceM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa1bc8a5e9894850c698c90ec30c454c10"></span><code class="descname">wkbMultiSurfaceM</code> = 2012<a class="headerlink" href="#_CPPv416wkbMultiSurfaceM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv49wkbCurveM">
<span id="_CPPv39wkbCurveM"></span><span id="_CPPv29wkbCurveM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aae9960e7b94e7da42729b5c78f8a14dd1"></span><code class="descname">wkbCurveM</code> = 2013<a class="headerlink" href="#_CPPv49wkbCurveM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411wkbSurfaceM">
<span id="_CPPv311wkbSurfaceM"></span><span id="_CPPv211wkbSurfaceM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa514eb130285290b3f02b999462a469fb"></span><code class="descname">wkbSurfaceM</code> = 2014<a class="headerlink" href="#_CPPv411wkbSurfaceM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv421wkbPolyhedralSurfaceM">
<span id="_CPPv321wkbPolyhedralSurfaceM"></span><span id="_CPPv221wkbPolyhedralSurfaceM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa2650045d60ed543d7f97b91fd3057c30"></span><code class="descname">wkbPolyhedralSurfaceM</code> = 2015<a class="headerlink" href="#_CPPv421wkbPolyhedralSurfaceM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv47wkbTINM">
<span id="_CPPv37wkbTINM"></span><span id="_CPPv27wkbTINM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaf25668e0487cde7ef637e2a709251c73"></span><code class="descname">wkbTINM</code> = 2016<a class="headerlink" href="#_CPPv47wkbTINM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412wkbTriangleM">
<span id="_CPPv312wkbTriangleM"></span><span id="_CPPv212wkbTriangleM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaec008f235b62f47eba51d599d411f047"></span><code class="descname">wkbTriangleM</code> = 2017<a class="headerlink" href="#_CPPv412wkbTriangleM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410wkbPointZM">
<span id="_CPPv310wkbPointZM"></span><span id="_CPPv210wkbPointZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaa82f9a2f34d7704909ba02b1a3538564"></span><code class="descname">wkbPointZM</code> = 3001<a class="headerlink" href="#_CPPv410wkbPointZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415wkbLineStringZM">
<span id="_CPPv315wkbLineStringZM"></span><span id="_CPPv215wkbLineStringZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aab0fc74e211ac7aa6aba4ccbf5b0b3ee6"></span><code class="descname">wkbLineStringZM</code> = 3002<a class="headerlink" href="#_CPPv415wkbLineStringZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412wkbPolygonZM">
<span id="_CPPv312wkbPolygonZM"></span><span id="_CPPv212wkbPolygonZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa1e70eaf3c805bd20b96f731c21e87457"></span><code class="descname">wkbPolygonZM</code> = 3003<a class="headerlink" href="#_CPPv412wkbPolygonZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415wkbMultiPointZM">
<span id="_CPPv315wkbMultiPointZM"></span><span id="_CPPv215wkbMultiPointZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa2ad99aba396fe1e412f4d363cd7cb2bc"></span><code class="descname">wkbMultiPointZM</code> = 3004<a class="headerlink" href="#_CPPv415wkbMultiPointZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv420wkbMultiLineStringZM">
<span id="_CPPv320wkbMultiLineStringZM"></span><span id="_CPPv220wkbMultiLineStringZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aadaa2f5ca70381a811f96eda756d1eab3"></span><code class="descname">wkbMultiLineStringZM</code> = 3005<a class="headerlink" href="#_CPPv420wkbMultiLineStringZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417wkbMultiPolygonZM">
<span id="_CPPv317wkbMultiPolygonZM"></span><span id="_CPPv217wkbMultiPolygonZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaedc2190961b3d8fd2c5639bea5e85cc8"></span><code class="descname">wkbMultiPolygonZM</code> = 3006<a class="headerlink" href="#_CPPv417wkbMultiPolygonZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv423wkbGeometryCollectionZM">
<span id="_CPPv323wkbGeometryCollectionZM"></span><span id="_CPPv223wkbGeometryCollectionZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aadf653743f055185cf8bfdac7d4ee27f8"></span><code class="descname">wkbGeometryCollectionZM</code> = 3007<a class="headerlink" href="#_CPPv423wkbGeometryCollectionZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419wkbCircularStringZM">
<span id="_CPPv319wkbCircularStringZM"></span><span id="_CPPv219wkbCircularStringZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa9e25f0f905b0b4ba9238134d7b654953"></span><code class="descname">wkbCircularStringZM</code> = 3008<a class="headerlink" href="#_CPPv419wkbCircularStringZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418wkbCompoundCurveZM">
<span id="_CPPv318wkbCompoundCurveZM"></span><span id="_CPPv218wkbCompoundCurveZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaa292563c45aa7b8dae4240b189cf1d67"></span><code class="descname">wkbCompoundCurveZM</code> = 3009<a class="headerlink" href="#_CPPv418wkbCompoundCurveZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417wkbCurvePolygonZM">
<span id="_CPPv317wkbCurvePolygonZM"></span><span id="_CPPv217wkbCurvePolygonZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaf6a3269c80573b749a303bdd0f3acab5"></span><code class="descname">wkbCurvePolygonZM</code> = 3010<a class="headerlink" href="#_CPPv417wkbCurvePolygonZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415wkbMultiCurveZM">
<span id="_CPPv315wkbMultiCurveZM"></span><span id="_CPPv215wkbMultiCurveZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa930c20da1d4458ce9ad18983dc2977b3"></span><code class="descname">wkbMultiCurveZM</code> = 3011<a class="headerlink" href="#_CPPv415wkbMultiCurveZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417wkbMultiSurfaceZM">
<span id="_CPPv317wkbMultiSurfaceZM"></span><span id="_CPPv217wkbMultiSurfaceZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa39570288f5d7bf4dc61e1514dd28a11e"></span><code class="descname">wkbMultiSurfaceZM</code> = 3012<a class="headerlink" href="#_CPPv417wkbMultiSurfaceZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410wkbCurveZM">
<span id="_CPPv310wkbCurveZM"></span><span id="_CPPv210wkbCurveZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aac69a21adf8c89bde63d2381acc08e750"></span><code class="descname">wkbCurveZM</code> = 3013<a class="headerlink" href="#_CPPv410wkbCurveZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412wkbSurfaceZM">
<span id="_CPPv312wkbSurfaceZM"></span><span id="_CPPv212wkbSurfaceZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa0dd177f582c7a5c14bca3f93c6c27eb9"></span><code class="descname">wkbSurfaceZM</code> = 3014<a class="headerlink" href="#_CPPv412wkbSurfaceZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>GDAL &gt;= 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv422wkbPolyhedralSurfaceZM">
<span id="_CPPv322wkbPolyhedralSurfaceZM"></span><span id="_CPPv222wkbPolyhedralSurfaceZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aadcb552ba58846b844fc4099f3970ffcc"></span><code class="descname">wkbPolyhedralSurfaceZM</code> = 3015<a class="headerlink" href="#_CPPv422wkbPolyhedralSurfaceZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48wkbTINZM">
<span id="_CPPv38wkbTINZM"></span><span id="_CPPv28wkbTINZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa28720566bc896196b773c90780fe7a7c"></span><code class="descname">wkbTINZM</code> = 3016<a class="headerlink" href="#_CPPv48wkbTINZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413wkbTriangleZM">
<span id="_CPPv313wkbTriangleZM"></span><span id="_CPPv213wkbTriangleZM"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aae43895a2988a4cb969ce3e274a00c7f3"></span><code class="descname">wkbTriangleZM</code> = 3017<a class="headerlink" href="#_CPPv413wkbTriangleZM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ISO SQL/MM Part 3. </p>
<p>Reserved in GDAL &gt;= 2.1 but not yet implemented </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411wkbPoint25D">
<span id="_CPPv311wkbPoint25D"></span><span id="_CPPv211wkbPoint25D"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa18b9353087d48fa575fa0e3281b46f13"></span><code class="descname">wkbPoint25D</code> = -2147483647<a class="headerlink" href="#_CPPv411wkbPoint25D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2.5D extension as per 99-402 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbLineString25D">
<span id="_CPPv316wkbLineString25D"></span><span id="_CPPv216wkbLineString25D"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aacf06aa306a087638fa4bebb7caf01ce1"></span><code class="descname">wkbLineString25D</code> = -2147483646<a class="headerlink" href="#_CPPv416wkbLineString25D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2.5D extension as per 99-402 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413wkbPolygon25D">
<span id="_CPPv313wkbPolygon25D"></span><span id="_CPPv213wkbPolygon25D"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa05fb2cddfbd20fb5c7c684cb765ef897"></span><code class="descname">wkbPolygon25D</code> = -2147483645<a class="headerlink" href="#_CPPv413wkbPolygon25D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2.5D extension as per 99-402 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416wkbMultiPoint25D">
<span id="_CPPv316wkbMultiPoint25D"></span><span id="_CPPv216wkbMultiPoint25D"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa95019b3d8d9acf9730406a455e646e15"></span><code class="descname">wkbMultiPoint25D</code> = -2147483644<a class="headerlink" href="#_CPPv416wkbMultiPoint25D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2.5D extension as per 99-402 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv421wkbMultiLineString25D">
<span id="_CPPv321wkbMultiLineString25D"></span><span id="_CPPv221wkbMultiLineString25D"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aaebb9eb043391cd9f4c98f465dcc5b41b"></span><code class="descname">wkbMultiLineString25D</code> = -2147483643<a class="headerlink" href="#_CPPv421wkbMultiLineString25D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2.5D extension as per 99-402 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418wkbMultiPolygon25D">
<span id="_CPPv318wkbMultiPolygon25D"></span><span id="_CPPv218wkbMultiPolygon25D"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa222e72c0c3e89838350888948f2e6af2"></span><code class="descname">wkbMultiPolygon25D</code> = -2147483642<a class="headerlink" href="#_CPPv418wkbMultiPolygon25D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2.5D extension as per 99-402 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv424wkbGeometryCollection25D">
<span id="_CPPv324wkbGeometryCollection25D"></span><span id="_CPPv224wkbGeometryCollection25D"></span><span class="target" id="ogr__core_8h_1a800236a0d460ef66e687b7b65610f12aa4f5e3e491182628c831ed8124ec64e96"></span><code class="descname">wkbGeometryCollection25D</code> = -2147483641<a class="headerlink" href="#_CPPv424wkbGeometryCollection25D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>2.5D extension as per 99-402 </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv413OGRwkbVariant">
<span id="_CPPv313OGRwkbVariant"></span><span id="_CPPv213OGRwkbVariant"></span><span class="target" id="ogr__core_8h_1a6716bd3399c31e7bc8b0fd94fd7d9ba6"></span><em class="property">enum </em><code class="descname">OGRwkbVariant</code><a class="headerlink" href="#_CPPv413OGRwkbVariant" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Output variants of WKB we support. </p>
<p>99-402 was a short-lived extension to SFSQL 1.1 that used a high-bit flag to indicate the presence of Z coordinates in a WKB geometry.</p>
<p>SQL/MM Part 3 and SFSQL 1.2 use offsets of 1000 (Z), 2000 (M) and 3000 (ZM) to indicate the present of higher dimensional coordinates in a WKB geometry. Reference: <a class="reference external" href="https://portal.opengeospatial.org/files/?artifact_id=320243">09-009_Committee_Draft_ISOIEC_CD_13249-3_SQLMM_Spatial.pdf</a>, ISO/IEC JTC 1/SC 32 N 1820, ISO/IEC CD 13249-3:201x(E), Date: 2009-01-16. The codes are also found in §8.2.3 of <a class="reference external" href="http://portal.opengeospatial.org/files/?artifact_id=25355">OGC 06-103r4 “OpenGIS® Implementation Standard for Geographic information - Simple feature access - Part 1: Common architecture”, v1.2.1</a> </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv416wkbVariantOldOgc">
<span id="_CPPv316wkbVariantOldOgc"></span><span id="_CPPv216wkbVariantOldOgc"></span><span class="target" id="ogr__core_8h_1a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8"></span><code class="descname">wkbVariantOldOgc</code><a class="headerlink" href="#_CPPv416wkbVariantOldOgc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Old-style 99-402 extended dimension (Z) WKB types. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413wkbVariantIso">
<span id="_CPPv313wkbVariantIso"></span><span id="_CPPv213wkbVariantIso"></span><span class="target" id="ogr__core_8h_1a6716bd3399c31e7bc8b0fd94fd7d9ba6ac103ec17c4045fb9f3013638726a8bd5"></span><code class="descname">wkbVariantIso</code><a class="headerlink" href="#_CPPv413wkbVariantIso" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418wkbVariantPostGIS1">
<span id="_CPPv318wkbVariantPostGIS1"></span><span id="_CPPv218wkbVariantPostGIS1"></span><span class="target" id="ogr__core_8h_1a6716bd3399c31e7bc8b0fd94fd7d9ba6a23e2d5e282de33b2bbb43c1077002569"></span><code class="descname">wkbVariantPostGIS1</code><a class="headerlink" href="#_CPPv418wkbVariantPostGIS1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>PostGIS 1.X has different codes for CurvePolygon, MultiCurve and MultiSurface. </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv415OGRwkbByteOrder">
<span id="_CPPv315OGRwkbByteOrder"></span><span id="_CPPv215OGRwkbByteOrder"></span><span class="target" id="ogr__core_8h_1a36cc1f4d807ba8f6fb8951f3adf251e2"></span><em class="property">enum </em><code class="descname">OGRwkbByteOrder</code><a class="headerlink" href="#_CPPv415OGRwkbByteOrder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enumeration to describe byte order. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv46wkbXDR">
<span id="_CPPv36wkbXDR"></span><span id="_CPPv26wkbXDR"></span><span class="target" id="ogr__core_8h_1a36cc1f4d807ba8f6fb8951f3adf251e2a2682cb271fcd2dff2e3af02c0e0630f2"></span><code class="descname">wkbXDR</code> = 0<a class="headerlink" href="#_CPPv46wkbXDR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>MSB/Sun/Motoroloa: Most Significant Byte First. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv46wkbNDR">
<span id="_CPPv36wkbNDR"></span><span id="_CPPv26wkbNDR"></span><span class="target" id="ogr__core_8h_1a36cc1f4d807ba8f6fb8951f3adf251e2afa81110d052bb483845dfa235c76991d"></span><code class="descname">wkbNDR</code> = 1<a class="headerlink" href="#_CPPv46wkbNDR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>LSB/Intel/Vax: Least Significant Byte First. </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv412OGRFieldType">
<span id="_CPPv312OGRFieldType"></span><span id="_CPPv212OGRFieldType"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fc"></span><em class="property">enum </em><code class="descname">OGRFieldType</code><a class="headerlink" href="#_CPPv412OGRFieldType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of feature field types. </p>
<p>This list is likely to be extended in the future … avoid coding applications based on the assumption that all field types can be known. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv410OFTInteger">
<span id="_CPPv310OFTInteger"></span><span id="_CPPv210OFTInteger"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca81294535b47252b1da0274f178420ae4"></span><code class="descname">OFTInteger</code> = 0<a class="headerlink" href="#_CPPv410OFTInteger" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simple 32bit integer. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414OFTIntegerList">
<span id="_CPPv314OFTIntegerList"></span><span id="_CPPv214OFTIntegerList"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca6406fce5e1937d3092f587ed83aff009"></span><code class="descname">OFTIntegerList</code> = 1<a class="headerlink" href="#_CPPv414OFTIntegerList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of 32bit integers. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv47OFTReal">
<span id="_CPPv37OFTReal"></span><span id="_CPPv27OFTReal"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca99520e47d9e26303f7c0127c1254c962"></span><code class="descname">OFTReal</code> = 2<a class="headerlink" href="#_CPPv47OFTReal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Double Precision floating point. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OFTRealList">
<span id="_CPPv311OFTRealList"></span><span id="_CPPv211OFTRealList"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca8d1dd6b4ecafa6fdc552de07a2e612a7"></span><code class="descname">OFTRealList</code> = 3<a class="headerlink" href="#_CPPv411OFTRealList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of doubles. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv49OFTString">
<span id="_CPPv39OFTString"></span><span id="_CPPv29OFTString"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca862a7b8506c67c5390c2e0860c4edf45"></span><code class="descname">OFTString</code> = 4<a class="headerlink" href="#_CPPv49OFTString" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>String of ASCII chars. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413OFTStringList">
<span id="_CPPv313OFTStringList"></span><span id="_CPPv213OFTStringList"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fcac29f48b1251f60a6e6eb1bb66dc75ad2"></span><code class="descname">OFTStringList</code> = 5<a class="headerlink" href="#_CPPv413OFTStringList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Array of strings. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413OFTWideString">
<span id="_CPPv313OFTWideString"></span><span id="_CPPv213OFTWideString"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fcaf593e8e08c5fa62f5c87d667ebbf9815"></span><code class="descname">OFTWideString</code> = 6<a class="headerlink" href="#_CPPv413OFTWideString" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deprecated </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417OFTWideStringList">
<span id="_CPPv317OFTWideStringList"></span><span id="_CPPv217OFTWideStringList"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca7a5f917073a6b2bd6e7c8c2ff28b22b2"></span><code class="descname">OFTWideStringList</code> = 7<a class="headerlink" href="#_CPPv417OFTWideStringList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deprecated </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv49OFTBinary">
<span id="_CPPv39OFTBinary"></span><span id="_CPPv29OFTBinary"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca87c732175b3e99aeebca957ada1f6a2c"></span><code class="descname">OFTBinary</code> = 8<a class="headerlink" href="#_CPPv49OFTBinary" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Raw Binary data. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv47OFTDate">
<span id="_CPPv37OFTDate"></span><span id="_CPPv27OFTDate"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca742f1a13593939558dd7f0083e78df27"></span><code class="descname">OFTDate</code> = 9<a class="headerlink" href="#_CPPv47OFTDate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Date. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv47OFTTime">
<span id="_CPPv37OFTTime"></span><span id="_CPPv27OFTTime"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca30c4c3e7adec85f189b4a025efa6725f"></span><code class="descname">OFTTime</code> = 10<a class="headerlink" href="#_CPPv47OFTTime" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Time. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OFTDateTime">
<span id="_CPPv311OFTDateTime"></span><span id="_CPPv211OFTDateTime"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fcac88631a8d99c78b5df17f971b8304239"></span><code class="descname">OFTDateTime</code> = 11<a class="headerlink" href="#_CPPv411OFTDateTime" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Date and Time. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OFTInteger64">
<span id="_CPPv312OFTInteger64"></span><span id="_CPPv212OFTInteger64"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fcaec6a4e68818f1f377dfd6ae103f48f61"></span><code class="descname">OFTInteger64</code> = 12<a class="headerlink" href="#_CPPv412OFTInteger64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Single 64bit integer. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OFTInteger64List">
<span id="_CPPv316OFTInteger64List"></span><span id="_CPPv216OFTInteger64List"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca311faab9f746224ab712ae92aff523b6"></span><code class="descname">OFTInteger64List</code> = 13<a class="headerlink" href="#_CPPv416OFTInteger64List" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of 64bit integers. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410OFTMaxType">
<span id="_CPPv310OFTMaxType"></span><span id="_CPPv210OFTMaxType"></span><span class="target" id="ogr__core_8h_1a787194bea637faf12d61643124a7c9fca20804ff992988b7f937935af03bb4b63"></span><code class="descname">OFTMaxType</code> = 13<a class="headerlink" href="#_CPPv410OFTMaxType" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv415OGRFieldSubType">
<span id="_CPPv315OGRFieldSubType"></span><span id="_CPPv215OGRFieldSubType"></span><span class="target" id="ogr__core_8h_1a24d96814a798fa79bffd2b8ce6135284"></span><em class="property">enum </em><code class="descname">OGRFieldSubType</code><a class="headerlink" href="#_CPPv415OGRFieldSubType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of field subtypes. </p>
<p>A subtype represents a hint, a restriction of the main type, that is not strictly necessary to consult. This list is likely to be extended in the future … avoid coding applications based on the assumption that all field types can be known. Most subtypes only make sense for a restricted set of main types. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
</dl>
</p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv48OFSTNone">
<span id="_CPPv38OFSTNone"></span><span id="_CPPv28OFSTNone"></span><span class="target" id="ogr__core_8h_1a24d96814a798fa79bffd2b8ce6135284a8959458e6b987c875dddc723da7c85b3"></span><code class="descname">OFSTNone</code> = 0<a class="headerlink" href="#_CPPv48OFSTNone" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No subtype. </p>
<p>This is the default value </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OFSTBoolean">
<span id="_CPPv311OFSTBoolean"></span><span id="_CPPv211OFSTBoolean"></span><span class="target" id="ogr__core_8h_1a24d96814a798fa79bffd2b8ce6135284a2c18f7df78b6be02025caa6eb1f43e87"></span><code class="descname">OFSTBoolean</code> = 1<a class="headerlink" href="#_CPPv411OFSTBoolean" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Boolean integer. </p>
<p>Only valid for OFTInteger and OFTIntegerList. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv49OFSTInt16">
<span id="_CPPv39OFSTInt16"></span><span id="_CPPv29OFSTInt16"></span><span class="target" id="ogr__core_8h_1a24d96814a798fa79bffd2b8ce6135284a643c6fd690d762b064237a71af71e262"></span><code class="descname">OFSTInt16</code> = 2<a class="headerlink" href="#_CPPv49OFSTInt16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signed 16-bit integer. </p>
<p>Only valid for OFTInteger and OFTIntegerList. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OFSTFloat32">
<span id="_CPPv311OFSTFloat32"></span><span id="_CPPv211OFSTFloat32"></span><span class="target" id="ogr__core_8h_1a24d96814a798fa79bffd2b8ce6135284ab9083ad41e90f0fbd74257a5c876ebe8"></span><code class="descname">OFSTFloat32</code> = 3<a class="headerlink" href="#_CPPv411OFSTFloat32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Single precision (32 bit) floating point. </p>
<p>Only valid for OFTReal and OFTRealList. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48OFSTJSON">
<span id="_CPPv38OFSTJSON"></span><span id="_CPPv28OFSTJSON"></span><span class="target" id="ogr__core_8h_1a24d96814a798fa79bffd2b8ce6135284a74c6aa7b551ec06a45cf173be0156018"></span><code class="descname">OFSTJSON</code> = 4<a class="headerlink" href="#_CPPv48OFSTJSON" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>JSON content. </p>
<p>Only valid for OFTString. <dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.4 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414OFSTMaxSubType">
<span id="_CPPv314OFSTMaxSubType"></span><span id="_CPPv214OFSTMaxSubType"></span><span class="target" id="ogr__core_8h_1a24d96814a798fa79bffd2b8ce6135284abbe43daaa2b23062598fab871d57fc11"></span><code class="descname">OFSTMaxSubType</code> = 4<a class="headerlink" href="#_CPPv414OFSTMaxSubType" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv416OGRJustification">
<span id="_CPPv316OGRJustification"></span><span id="_CPPv216OGRJustification"></span><span class="target" id="ogr__core_8h_1a701976be938cd60a2fa96454f61d3600"></span><em class="property">enum </em><code class="descname">OGRJustification</code><a class="headerlink" href="#_CPPv416OGRJustification" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Display justification for field values. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv411OJUndefined">
<span id="_CPPv311OJUndefined"></span><span id="_CPPv211OJUndefined"></span><span class="target" id="ogr__core_8h_1a701976be938cd60a2fa96454f61d3600a3aed875a8d64940077b037cadc79ab6f"></span><code class="descname">OJUndefined</code> = 0<a class="headerlink" href="#_CPPv411OJUndefined" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv46OJLeft">
<span id="_CPPv36OJLeft"></span><span id="_CPPv26OJLeft"></span><span class="target" id="ogr__core_8h_1a701976be938cd60a2fa96454f61d3600a1bc88895602196c2817e20d0565999e6"></span><code class="descname">OJLeft</code> = 1<a class="headerlink" href="#_CPPv46OJLeft" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv47OJRight">
<span id="_CPPv37OJRight"></span><span id="_CPPv27OJRight"></span><span class="target" id="ogr__core_8h_1a701976be938cd60a2fa96454f61d3600ac8c6e0312e163999efa3cfc5e8bca861"></span><code class="descname">OJRight</code> = 2<a class="headerlink" href="#_CPPv47OJRight" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv423ogr_style_tool_class_id">
<span id="_CPPv323ogr_style_tool_class_id"></span><span id="_CPPv223ogr_style_tool_class_id"></span><span class="target" id="ogr__core_8h_1ae392af0d0b0305cea3b85f529cd25cc6"></span><em class="property">enum </em><code class="descname">ogr_style_tool_class_id</code><a class="headerlink" href="#_CPPv423ogr_style_tool_class_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> derived class types (returned by GetType()). </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv410OGRSTCNone">
<span id="_CPPv310OGRSTCNone"></span><span id="_CPPv210OGRSTCNone"></span><span class="target" id="ogr__core_8h_1ae392af0d0b0305cea3b85f529cd25cc6a2beae815e66a88b57d4d157adcd7d839"></span><code class="descname">OGRSTCNone</code> = 0<a class="headerlink" href="#_CPPv410OGRSTCNone" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>None. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv49OGRSTCPen">
<span id="_CPPv39OGRSTCPen"></span><span id="_CPPv29OGRSTCPen"></span><span class="target" id="ogr__core_8h_1ae392af0d0b0305cea3b85f529cd25cc6a67362079de5e835f5dd57edf349f0f79"></span><code class="descname">OGRSTCPen</code> = 1<a class="headerlink" href="#_CPPv49OGRSTCPen" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pen. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OGRSTCBrush">
<span id="_CPPv311OGRSTCBrush"></span><span id="_CPPv211OGRSTCBrush"></span><span class="target" id="ogr__core_8h_1ae392af0d0b0305cea3b85f529cd25cc6a0cb26929e6c190d07d0520870e302d19"></span><code class="descname">OGRSTCBrush</code> = 2<a class="headerlink" href="#_CPPv411OGRSTCBrush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Brush. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTCSymbol">
<span id="_CPPv312OGRSTCSymbol"></span><span id="_CPPv212OGRSTCSymbol"></span><span class="target" id="ogr__core_8h_1ae392af0d0b0305cea3b85f529cd25cc6ab63da0b6737dafbd2048461dc13a1f5d"></span><code class="descname">OGRSTCSymbol</code> = 3<a class="headerlink" href="#_CPPv412OGRSTCSymbol" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Symbol. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OGRSTCLabel">
<span id="_CPPv311OGRSTCLabel"></span><span id="_CPPv211OGRSTCLabel"></span><span class="target" id="ogr__core_8h_1ae392af0d0b0305cea3b85f529cd25cc6a5332d70327fa7734dc0eedc3e133b804"></span><code class="descname">OGRSTCLabel</code> = 4<a class="headerlink" href="#_CPPv411OGRSTCLabel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Label. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTCVector">
<span id="_CPPv312OGRSTCVector"></span><span id="_CPPv212OGRSTCVector"></span><span class="target" id="ogr__core_8h_1ae392af0d0b0305cea3b85f529cd25cc6a2bbe5df3acf42978c28d307c91eb7634"></span><code class="descname">OGRSTCVector</code> = 5<a class="headerlink" href="#_CPPv412OGRSTCVector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Vector. </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv423ogr_style_tool_units_id">
<span id="_CPPv323ogr_style_tool_units_id"></span><span id="_CPPv223ogr_style_tool_units_id"></span><span class="target" id="ogr__core_8h_1a8b3b8ef5c9bc0798ee1e121b40941f72"></span><em class="property">enum </em><code class="descname">ogr_style_tool_units_id</code><a class="headerlink" href="#_CPPv423ogr_style_tool_units_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of units supported by OGRStyleTools. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv412OGRSTUGround">
<span id="_CPPv312OGRSTUGround"></span><span id="_CPPv212OGRSTUGround"></span><span class="target" id="ogr__core_8h_1a8b3b8ef5c9bc0798ee1e121b40941f72a11f94624ace21b0953bbc48f962d8129"></span><code class="descname">OGRSTUGround</code> = 0<a class="headerlink" href="#_CPPv412OGRSTUGround" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ground unit. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OGRSTUPixel">
<span id="_CPPv311OGRSTUPixel"></span><span id="_CPPv211OGRSTUPixel"></span><span class="target" id="ogr__core_8h_1a8b3b8ef5c9bc0798ee1e121b40941f72ae5077e043f8f6a1be90d6c65507cb256"></span><code class="descname">OGRSTUPixel</code> = 1<a class="headerlink" href="#_CPPv411OGRSTUPixel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pixel. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTUPoints">
<span id="_CPPv312OGRSTUPoints"></span><span id="_CPPv212OGRSTUPoints"></span><span class="target" id="ogr__core_8h_1a8b3b8ef5c9bc0798ee1e121b40941f72aba963b36e8bbb24e97d8986e09e14dfe"></span><code class="descname">OGRSTUPoints</code> = 2<a class="headerlink" href="#_CPPv412OGRSTUPoints" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Points. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48OGRSTUMM">
<span id="_CPPv38OGRSTUMM"></span><span id="_CPPv28OGRSTUMM"></span><span class="target" id="ogr__core_8h_1a8b3b8ef5c9bc0798ee1e121b40941f72a1fb88910b2f69672157247309411d95b"></span><code class="descname">OGRSTUMM</code> = 3<a class="headerlink" href="#_CPPv48OGRSTUMM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Millimeter. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48OGRSTUCM">
<span id="_CPPv38OGRSTUCM"></span><span id="_CPPv28OGRSTUCM"></span><span class="target" id="ogr__core_8h_1a8b3b8ef5c9bc0798ee1e121b40941f72a7c949a395eabaf9f683204e09fc54996"></span><code class="descname">OGRSTUCM</code> = 4<a class="headerlink" href="#_CPPv48OGRSTUCM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Centimeter. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTUInches">
<span id="_CPPv312OGRSTUInches"></span><span id="_CPPv212OGRSTUInches"></span><span class="target" id="ogr__core_8h_1a8b3b8ef5c9bc0798ee1e121b40941f72a5b134e924ddb6f786adb8d7852a66be7"></span><code class="descname">OGRSTUInches</code> = 5<a class="headerlink" href="#_CPPv412OGRSTUInches" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inch. </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv427ogr_style_tool_param_pen_id">
<span id="_CPPv327ogr_style_tool_param_pen_id"></span><span id="_CPPv227ogr_style_tool_param_pen_id"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1"></span><em class="property">enum </em><code class="descname">ogr_style_tool_param_pen_id</code><a class="headerlink" href="#_CPPv427ogr_style_tool_param_pen_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStylePen. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv413OGRSTPenColor">
<span id="_CPPv313OGRSTPenColor"></span><span id="_CPPv213OGRSTPenColor"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1ad0bb8018a1f95b0f7760db06ea3bb54e"></span><code class="descname">OGRSTPenColor</code> = 0<a class="headerlink" href="#_CPPv413OGRSTPenColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Color. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413OGRSTPenWidth">
<span id="_CPPv313OGRSTPenWidth"></span><span id="_CPPv213OGRSTPenWidth"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1a439de9f33d8291c47ac0e256a3332341"></span><code class="descname">OGRSTPenWidth</code> = 1<a class="headerlink" href="#_CPPv413OGRSTPenWidth" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Width. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415OGRSTPenPattern">
<span id="_CPPv315OGRSTPenPattern"></span><span id="_CPPv215OGRSTPenPattern"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1af546e4180644a940774920647b1edbfd"></span><code class="descname">OGRSTPenPattern</code> = 2<a class="headerlink" href="#_CPPv415OGRSTPenPattern" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pattern. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410OGRSTPenId">
<span id="_CPPv310OGRSTPenId"></span><span id="_CPPv210OGRSTPenId"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1a1799391fe3fa48c98a01f7cce91d08bd"></span><code class="descname">OGRSTPenId</code> = 3<a class="headerlink" href="#_CPPv410OGRSTPenId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Id. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417OGRSTPenPerOffset">
<span id="_CPPv317OGRSTPenPerOffset"></span><span id="_CPPv217OGRSTPenPerOffset"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1a325600b5fad0fc7422589821e583f3a8"></span><code class="descname">OGRSTPenPerOffset</code> = 4<a class="headerlink" href="#_CPPv417OGRSTPenPerOffset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perpendicular offset. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411OGRSTPenCap">
<span id="_CPPv311OGRSTPenCap"></span><span id="_CPPv211OGRSTPenCap"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1a2d57da160a40e78759bba2f082a85e30"></span><code class="descname">OGRSTPenCap</code> = 5<a class="headerlink" href="#_CPPv411OGRSTPenCap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cap. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTPenJoin">
<span id="_CPPv312OGRSTPenJoin"></span><span id="_CPPv212OGRSTPenJoin"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1ad438318ad613f1cf1e465d2bedd62d19"></span><code class="descname">OGRSTPenJoin</code> = 6<a class="headerlink" href="#_CPPv412OGRSTPenJoin" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Join. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTPenPriority">
<span id="_CPPv316OGRSTPenPriority"></span><span id="_CPPv216OGRSTPenPriority"></span><span class="target" id="ogr__core_8h_1ae7e31cd2352ef6eeae9319a63623d4c1ad506095155e0833765d96730b834f94b"></span><code class="descname">OGRSTPenPriority</code> = 7<a class="headerlink" href="#_CPPv416OGRSTPenPriority" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Priority. </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv429ogr_style_tool_param_brush_id">
<span id="_CPPv329ogr_style_tool_param_brush_id"></span><span id="_CPPv229ogr_style_tool_param_brush_id"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1"></span><em class="property">enum </em><code class="descname">ogr_style_tool_param_brush_id</code><a class="headerlink" href="#_CPPv429ogr_style_tool_param_brush_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStyleBrush. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv416OGRSTBrushFColor">
<span id="_CPPv316OGRSTBrushFColor"></span><span id="_CPPv216OGRSTBrushFColor"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1ae21166e07efa77620b5c0d3062d6ee84"></span><code class="descname">OGRSTBrushFColor</code> = 0<a class="headerlink" href="#_CPPv416OGRSTBrushFColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Foreground color. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTBrushBColor">
<span id="_CPPv316OGRSTBrushBColor"></span><span id="_CPPv216OGRSTBrushBColor"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1a73435d16588d09c7645fee324709b1c8"></span><code class="descname">OGRSTBrushBColor</code> = 1<a class="headerlink" href="#_CPPv416OGRSTBrushBColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Background color. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTBrushId">
<span id="_CPPv312OGRSTBrushId"></span><span id="_CPPv212OGRSTBrushId"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1a1ce6fb65ce582ca266017bc09454e6a9"></span><code class="descname">OGRSTBrushId</code> = 2<a class="headerlink" href="#_CPPv412OGRSTBrushId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Id. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415OGRSTBrushAngle">
<span id="_CPPv315OGRSTBrushAngle"></span><span id="_CPPv215OGRSTBrushAngle"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1a03cb0b8025bd63b20e23d7c6dc7dabaf"></span><code class="descname">OGRSTBrushAngle</code> = 3<a class="headerlink" href="#_CPPv415OGRSTBrushAngle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angle. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414OGRSTBrushSize">
<span id="_CPPv314OGRSTBrushSize"></span><span id="_CPPv214OGRSTBrushSize"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1a7817a1ef425495b1ef51ebbd3b9bdc3a"></span><code class="descname">OGRSTBrushSize</code> = 4<a class="headerlink" href="#_CPPv414OGRSTBrushSize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Size. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTBrushDx">
<span id="_CPPv312OGRSTBrushDx"></span><span id="_CPPv212OGRSTBrushDx"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1af1425a64313222fedfd07726f99d295d"></span><code class="descname">OGRSTBrushDx</code> = 5<a class="headerlink" href="#_CPPv412OGRSTBrushDx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dx. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTBrushDy">
<span id="_CPPv312OGRSTBrushDy"></span><span id="_CPPv212OGRSTBrushDy"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1ac7bcf5aa454378973b2b67b4ac7b28e2"></span><code class="descname">OGRSTBrushDy</code> = 6<a class="headerlink" href="#_CPPv412OGRSTBrushDy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dy. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418OGRSTBrushPriority">
<span id="_CPPv318OGRSTBrushPriority"></span><span id="_CPPv218OGRSTBrushPriority"></span><span class="target" id="ogr__core_8h_1ac236cfd5e5241bd8ad8f611e6a8559f1a597d379ce0242116993fb4a691c97e74"></span><code class="descname">OGRSTBrushPriority</code> = 7<a class="headerlink" href="#_CPPv418OGRSTBrushPriority" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Priority. </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv430ogr_style_tool_param_symbol_id">
<span id="_CPPv330ogr_style_tool_param_symbol_id"></span><span id="_CPPv230ogr_style_tool_param_symbol_id"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003"></span><em class="property">enum </em><code class="descname">ogr_style_tool_param_symbol_id</code><a class="headerlink" href="#_CPPv430ogr_style_tool_param_symbol_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStyleSymbol. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv413OGRSTSymbolId">
<span id="_CPPv313OGRSTSymbolId"></span><span id="_CPPv213OGRSTSymbolId"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a1947ec83457f3a23cc443fc4f0fb3142"></span><code class="descname">OGRSTSymbolId</code> = 0<a class="headerlink" href="#_CPPv413OGRSTSymbolId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Id. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTSymbolAngle">
<span id="_CPPv316OGRSTSymbolAngle"></span><span id="_CPPv216OGRSTSymbolAngle"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a6921b280f474b33ed683e64889bbfe64"></span><code class="descname">OGRSTSymbolAngle</code> = 1<a class="headerlink" href="#_CPPv416OGRSTSymbolAngle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angle. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTSymbolColor">
<span id="_CPPv316OGRSTSymbolColor"></span><span id="_CPPv216OGRSTSymbolColor"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a33e2f54ee1808bb81a421ef8c26bc081"></span><code class="descname">OGRSTSymbolColor</code> = 2<a class="headerlink" href="#_CPPv416OGRSTSymbolColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Color. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415OGRSTSymbolSize">
<span id="_CPPv315OGRSTSymbolSize"></span><span id="_CPPv215OGRSTSymbolSize"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a228e644128e556ecb2d07df4572e55b5"></span><code class="descname">OGRSTSymbolSize</code> = 3<a class="headerlink" href="#_CPPv415OGRSTSymbolSize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Size. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413OGRSTSymbolDx">
<span id="_CPPv313OGRSTSymbolDx"></span><span id="_CPPv213OGRSTSymbolDx"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a4f8bf93135069a9b428d6d95df501144"></span><code class="descname">OGRSTSymbolDx</code> = 4<a class="headerlink" href="#_CPPv413OGRSTSymbolDx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dx. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413OGRSTSymbolDy">
<span id="_CPPv313OGRSTSymbolDy"></span><span id="_CPPv213OGRSTSymbolDy"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a0e0b3b2745693c310e5811974a0b9dbc"></span><code class="descname">OGRSTSymbolDy</code> = 5<a class="headerlink" href="#_CPPv413OGRSTSymbolDy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dy. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415OGRSTSymbolStep">
<span id="_CPPv315OGRSTSymbolStep"></span><span id="_CPPv215OGRSTSymbolStep"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003ad155c50d0973a49bbb024b2daf3fedf7"></span><code class="descname">OGRSTSymbolStep</code> = 6<a class="headerlink" href="#_CPPv415OGRSTSymbolStep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Step. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415OGRSTSymbolPerp">
<span id="_CPPv315OGRSTSymbolPerp"></span><span id="_CPPv215OGRSTSymbolPerp"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a64ebbde616b1596819bd9f1daee7055d"></span><code class="descname">OGRSTSymbolPerp</code> = 7<a class="headerlink" href="#_CPPv415OGRSTSymbolPerp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perpendicular. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417OGRSTSymbolOffset">
<span id="_CPPv317OGRSTSymbolOffset"></span><span id="_CPPv217OGRSTSymbolOffset"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003af5ffe1e7b1911ba7092f58e4b8928281"></span><code class="descname">OGRSTSymbolOffset</code> = 8<a class="headerlink" href="#_CPPv417OGRSTSymbolOffset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Offset. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419OGRSTSymbolPriority">
<span id="_CPPv319OGRSTSymbolPriority"></span><span id="_CPPv219OGRSTSymbolPriority"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a94048b5edf9961bc4b414f7ed6e406b4"></span><code class="descname">OGRSTSymbolPriority</code> = 9<a class="headerlink" href="#_CPPv419OGRSTSymbolPriority" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Priority. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419OGRSTSymbolFontName">
<span id="_CPPv319OGRSTSymbolFontName"></span><span id="_CPPv219OGRSTSymbolFontName"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a2dec8073d9ff60324e0c759922886e26"></span><code class="descname">OGRSTSymbolFontName</code> = 10<a class="headerlink" href="#_CPPv419OGRSTSymbolFontName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Font name. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417OGRSTSymbolOColor">
<span id="_CPPv317OGRSTSymbolOColor"></span><span id="_CPPv217OGRSTSymbolOColor"></span><span class="target" id="ogr__core_8h_1a27bf4ac0889f4078a58df6b8ad8fe003a8ddd8b6d8057872d65567d0ff0b9ec7b"></span><code class="descname">OGRSTSymbolOColor</code> = 11<a class="headerlink" href="#_CPPv417OGRSTSymbolOColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Outline color. </p>
</dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv429ogr_style_tool_param_label_id">
<span id="_CPPv329ogr_style_tool_param_label_id"></span><span id="_CPPv229ogr_style_tool_param_label_id"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abb"></span><em class="property">enum </em><code class="descname">ogr_style_tool_param_label_id</code><a class="headerlink" href="#_CPPv429ogr_style_tool_param_label_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of parameters for use with OGRStyleLabel. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv418OGRSTLabelFontName">
<span id="_CPPv318OGRSTLabelFontName"></span><span id="_CPPv218OGRSTLabelFontName"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbafdc0a86d0c95c5be6a97a4a41df7e1ec"></span><code class="descname">OGRSTLabelFontName</code> = 0<a class="headerlink" href="#_CPPv418OGRSTLabelFontName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Font name. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414OGRSTLabelSize">
<span id="_CPPv314OGRSTLabelSize"></span><span id="_CPPv214OGRSTLabelSize"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbabcaa9bf275c386ce5e999022f4752d00"></span><code class="descname">OGRSTLabelSize</code> = 1<a class="headerlink" href="#_CPPv414OGRSTLabelSize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Size. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv420OGRSTLabelTextString">
<span id="_CPPv320OGRSTLabelTextString"></span><span id="_CPPv220OGRSTLabelTextString"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba9a928577060022c476edb7cf7dc4cc68"></span><code class="descname">OGRSTLabelTextString</code> = 2<a class="headerlink" href="#_CPPv420OGRSTLabelTextString" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Text string. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415OGRSTLabelAngle">
<span id="_CPPv315OGRSTLabelAngle"></span><span id="_CPPv215OGRSTLabelAngle"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbac9ac651ea11befe82bd4f55cc9c13929"></span><code class="descname">OGRSTLabelAngle</code> = 3<a class="headerlink" href="#_CPPv415OGRSTLabelAngle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angle. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTLabelFColor">
<span id="_CPPv316OGRSTLabelFColor"></span><span id="_CPPv216OGRSTLabelFColor"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbadb6c135588db3b967e8031f8bac2a034"></span><code class="descname">OGRSTLabelFColor</code> = 4<a class="headerlink" href="#_CPPv416OGRSTLabelFColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Foreground color. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTLabelBColor">
<span id="_CPPv316OGRSTLabelBColor"></span><span id="_CPPv216OGRSTLabelBColor"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba1ec4fabb061658b7eae7ebb5391083bf"></span><code class="descname">OGRSTLabelBColor</code> = 5<a class="headerlink" href="#_CPPv416OGRSTLabelBColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Background color. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419OGRSTLabelPlacement">
<span id="_CPPv319OGRSTLabelPlacement"></span><span id="_CPPv219OGRSTLabelPlacement"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba376e6d1f6041de6df8d4b4eb70ff96ed"></span><code class="descname">OGRSTLabelPlacement</code> = 6<a class="headerlink" href="#_CPPv419OGRSTLabelPlacement" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Placement. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTLabelAnchor">
<span id="_CPPv316OGRSTLabelAnchor"></span><span id="_CPPv216OGRSTLabelAnchor"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbaffa4e467f15dc625b7355a10929c13ef"></span><code class="descname">OGRSTLabelAnchor</code> = 7<a class="headerlink" href="#_CPPv416OGRSTLabelAnchor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Anchor. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTLabelDx">
<span id="_CPPv312OGRSTLabelDx"></span><span id="_CPPv212OGRSTLabelDx"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba700640976c182f83236e56831a82c05e"></span><code class="descname">OGRSTLabelDx</code> = 8<a class="headerlink" href="#_CPPv412OGRSTLabelDx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dx. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412OGRSTLabelDy">
<span id="_CPPv312OGRSTLabelDy"></span><span id="_CPPv212OGRSTLabelDy"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbaf286b42ab249c177b6b1f6f5bd694987"></span><code class="descname">OGRSTLabelDy</code> = 9<a class="headerlink" href="#_CPPv412OGRSTLabelDy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dy. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414OGRSTLabelPerp">
<span id="_CPPv314OGRSTLabelPerp"></span><span id="_CPPv214OGRSTLabelPerp"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba3abd33cbe521fa7924a5d8db6f7f2a37"></span><code class="descname">OGRSTLabelPerp</code> = 10<a class="headerlink" href="#_CPPv414OGRSTLabelPerp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perpendicular. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414OGRSTLabelBold">
<span id="_CPPv314OGRSTLabelBold"></span><span id="_CPPv214OGRSTLabelBold"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba0f95d4717d8d0fcd9ccc082c3cf6be40"></span><code class="descname">OGRSTLabelBold</code> = 11<a class="headerlink" href="#_CPPv414OGRSTLabelBold" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Bold. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTLabelItalic">
<span id="_CPPv316OGRSTLabelItalic"></span><span id="_CPPv216OGRSTLabelItalic"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba94fae6c19fb8c502138117b5fee09a2a"></span><code class="descname">OGRSTLabelItalic</code> = 12<a class="headerlink" href="#_CPPv416OGRSTLabelItalic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Italic. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419OGRSTLabelUnderline">
<span id="_CPPv319OGRSTLabelUnderline"></span><span id="_CPPv219OGRSTLabelUnderline"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba02114413b1731f4ae8b9231d3104d295"></span><code class="descname">OGRSTLabelUnderline</code> = 13<a class="headerlink" href="#_CPPv419OGRSTLabelUnderline" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Underline. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv418OGRSTLabelPriority">
<span id="_CPPv318OGRSTLabelPriority"></span><span id="_CPPv218OGRSTLabelPriority"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba07cfea1694c6426ec569ca0e132a3340"></span><code class="descname">OGRSTLabelPriority</code> = 14<a class="headerlink" href="#_CPPv418OGRSTLabelPriority" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Priority. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419OGRSTLabelStrikeout">
<span id="_CPPv319OGRSTLabelStrikeout"></span><span id="_CPPv219OGRSTLabelStrikeout"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba1c6fbf837ad3e28a913b41cfa3cd75a5"></span><code class="descname">OGRSTLabelStrikeout</code> = 15<a class="headerlink" href="#_CPPv419OGRSTLabelStrikeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Strike out. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417OGRSTLabelStretch">
<span id="_CPPv317OGRSTLabelStretch"></span><span id="_CPPv217OGRSTLabelStretch"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbafebff89848496de6a3bdfce26f947688"></span><code class="descname">OGRSTLabelStretch</code> = 16<a class="headerlink" href="#_CPPv417OGRSTLabelStretch" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stretch. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTLabelAdjHor">
<span id="_CPPv316OGRSTLabelAdjHor"></span><span id="_CPPv216OGRSTLabelAdjHor"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abbaffde39bab4d55711bbf229b7f7796a72"></span><code class="descname">OGRSTLabelAdjHor</code> = 17<a class="headerlink" href="#_CPPv416OGRSTLabelAdjHor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>OBSOLETE; do not use. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417OGRSTLabelAdjVert">
<span id="_CPPv317OGRSTLabelAdjVert"></span><span id="_CPPv217OGRSTLabelAdjVert"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba0d8933c5151c7c7e1085484abc059fff"></span><code class="descname">OGRSTLabelAdjVert</code> = 18<a class="headerlink" href="#_CPPv417OGRSTLabelAdjVert" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>OBSOLETE; do not use. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTLabelHColor">
<span id="_CPPv316OGRSTLabelHColor"></span><span id="_CPPv216OGRSTLabelHColor"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba84e650059beedc14039e36b980326b36"></span><code class="descname">OGRSTLabelHColor</code> = 19<a class="headerlink" href="#_CPPv416OGRSTLabelHColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Highlight color. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv416OGRSTLabelOColor">
<span id="_CPPv316OGRSTLabelOColor"></span><span id="_CPPv216OGRSTLabelOColor"></span><span class="target" id="ogr__core_8h_1a87ca7bd0d09fa50725d49aa434909abba6bef3d6f88b9f5f45e87a248b054a339"></span><code class="descname">OGRSTLabelOColor</code> = 20<a class="headerlink" href="#_CPPv416OGRSTLabelOColor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Outline color. </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv421OGRGeometryTypeToName18OGRwkbGeometryType">
<span id="_CPPv321OGRGeometryTypeToName18OGRwkbGeometryType"></span><span id="_CPPv221OGRGeometryTypeToName18OGRwkbGeometryType"></span><span id="OGRGeometryTypeToName__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1ae9baf1b3d7f8fce4220e58e24ba8ff94"></span><em class="property">const</em> char *<code class="descname">OGRGeometryTypeToName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGRGeometryTypeToName18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a human readable name corresponding to an OGRwkbGeometryType value. </p>
<p>The returned value should not be modified, or freed by the application.</p>
<p>This function is C callable.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>internal human readable string, or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the geometry type.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGRMergeGeometryTypes18OGRwkbGeometryType18OGRwkbGeometryType">
<span id="_CPPv321OGRMergeGeometryTypes18OGRwkbGeometryType18OGRwkbGeometryType"></span><span id="_CPPv221OGRMergeGeometryTypes18OGRwkbGeometryType18OGRwkbGeometryType"></span><span id="OGRMergeGeometryTypes__OGRwkbGeometryType.OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a6992108568e481174635277da161db43"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGRMergeGeometryTypes</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eMain</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eExtra</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGRMergeGeometryTypes18OGRwkbGeometryType18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find common geometry type. </p>
<p>Given two geometry types, find the most specific common type. Normally used repeatedly with the geometries in a layer to try and establish the most specific geometry type that can be reported for the layer.</p>
<p>NOTE: wkbUnknown is the “worst case” indicating a mixture of geometry types with nothing in common but the base geometry type. wkbNone should be used to indicate that no geometries have been encountered yet, and means the first geometry encountered will establish the preliminary type.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the merged geometry type. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eMain</span></code>: the first input geometry type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eExtra</span></code>: the second input geometry type.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGRMergeGeometryTypesEx18OGRwkbGeometryType18OGRwkbGeometryTypei">
<span id="_CPPv323OGRMergeGeometryTypesEx18OGRwkbGeometryType18OGRwkbGeometryTypei"></span><span id="_CPPv223OGRMergeGeometryTypesEx18OGRwkbGeometryType18OGRwkbGeometryTypei"></span><span id="OGRMergeGeometryTypesEx__OGRwkbGeometryType.OGRwkbGeometryType.i"></span><span class="target" id="ogr__core_8h_1a0285034932b375c926a68ad6a4971e74"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGRMergeGeometryTypesEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eMain</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eExtra</em>, int <em>bAllowPromotingToCurves</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGRMergeGeometryTypesEx18OGRwkbGeometryType18OGRwkbGeometryTypei" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find common geometry type. </p>
<p>Given two geometry types, find the most specific common type. Normally used repeatedly with the geometries in a layer to try and establish the most specific geometry type that can be reported for the layer.</p>
<p>NOTE: wkbUnknown is the “worst case” indicating a mixture of geometry types with nothing in common but the base geometry type. wkbNone should be used to indicate that no geometries have been encountered yet, and means the first geometry encountered will establish the preliminary type.</p>
<p>If bAllowPromotingToCurves is set to TRUE, mixing Polygon and CurvePolygon will return CurvePolygon. Mixing LineString, CircularString, CompoundCurve will return CompoundCurve. Mixing MultiPolygon and MultiSurface will return MultiSurface. Mixing MultiCurve and MultiLineString will return MultiCurve.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the merged geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eMain</span></code>: the first input geometry type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eExtra</span></code>: the second input geometry type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bAllowPromotingToCurves</span></code>: determine if promotion to curve type must be done.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_GT_Flatten18OGRwkbGeometryType">
<span id="_CPPv314OGR_GT_Flatten18OGRwkbGeometryType"></span><span id="_CPPv214OGR_GT_Flatten18OGRwkbGeometryType"></span><span id="OGR_GT_Flatten__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1ae4f248ce986143ef9a272ca787ef006b"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GT_Flatten</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_GT_Flatten18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the 2D geometry type corresponding to the passed geometry type. </p>
<p>This function is intended to work with geometry types as old-style 99-402 extended dimension (Z) WKB types, as well as with newer SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>2D geometry type corresponding to the passed geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_GT_SetZ18OGRwkbGeometryType">
<span id="_CPPv311OGR_GT_SetZ18OGRwkbGeometryType"></span><span id="_CPPv211OGR_GT_SetZ18OGRwkbGeometryType"></span><span id="OGR_GT_SetZ__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a630ed6cba27b401f7362a46bd5f351aa"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GT_SetZ</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_GT_SetZ18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the 3D geometry type corresponding to the passed geometry type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>3D geometry type corresponding to the passed geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_GT_SetM18OGRwkbGeometryType">
<span id="_CPPv311OGR_GT_SetM18OGRwkbGeometryType"></span><span id="_CPPv211OGR_GT_SetM18OGRwkbGeometryType"></span><span id="OGR_GT_SetM__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1adc165345639ac077962eb0d01799b393"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GT_SetM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_GT_SetM18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the measured geometry type corresponding to the passed geometry type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>measured geometry type corresponding to the passed geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_GT_SetModifier18OGRwkbGeometryTypeii">
<span id="_CPPv318OGR_GT_SetModifier18OGRwkbGeometryTypeii"></span><span id="_CPPv218OGR_GT_SetModifier18OGRwkbGeometryTypeii"></span><span id="OGR_GT_SetModifier__OGRwkbGeometryType.i.i"></span><span class="target" id="ogr__core_8h_1a832c4f12463431d9cbecd7d5fdcd96cd"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GT_SetModifier</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em>, int <em>bSetZ</em>, int <em>bSetM</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_GT_SetModifier18OGRwkbGeometryTypeii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a XY, XYZ, XYM or XYZM geometry type depending on parameter. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Output geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bHasZ</span></code>: TRUE if the output geometry type must be 3D. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bHasM</span></code>: TRUE if the output geometry type must be measured.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_GT_HasZ18OGRwkbGeometryType">
<span id="_CPPv311OGR_GT_HasZ18OGRwkbGeometryType"></span><span id="_CPPv211OGR_GT_HasZ18OGRwkbGeometryType"></span><span id="OGR_GT_HasZ__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1af410dc8cff82273b8bc5b1530ebf79ce"></span>int <code class="descname">OGR_GT_HasZ</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_GT_HasZ18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if the geometry type is a 3D geometry type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry type is a 3D geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_GT_HasM18OGRwkbGeometryType">
<span id="_CPPv311OGR_GT_HasM18OGRwkbGeometryType"></span><span id="_CPPv211OGR_GT_HasM18OGRwkbGeometryType"></span><span id="OGR_GT_HasM__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a19448c1698a398bef775e9c4a00b5f52"></span>int <code class="descname">OGR_GT_HasM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_GT_HasM18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if the geometry type is a measured type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry type is a measured type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_GT_IsSubClassOf18OGRwkbGeometryType18OGRwkbGeometryType">
<span id="_CPPv319OGR_GT_IsSubClassOf18OGRwkbGeometryType18OGRwkbGeometryType"></span><span id="_CPPv219OGR_GT_IsSubClassOf18OGRwkbGeometryType18OGRwkbGeometryType"></span><span id="OGR_GT_IsSubClassOf__OGRwkbGeometryType.OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a8e5768f6566ce3f68edb496ae7d6e233"></span>int <code class="descname">OGR_GT_IsSubClassOf</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eSuperType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_GT_IsSubClassOf18OGRwkbGeometryType18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns if a type is a subclass of another one. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if eType is a subclass of eSuperType.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eSuperType</span></code>: Super type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_GT_IsCurve18OGRwkbGeometryType">
<span id="_CPPv314OGR_GT_IsCurve18OGRwkbGeometryType"></span><span id="_CPPv214OGR_GT_IsCurve18OGRwkbGeometryType"></span><span id="OGR_GT_IsCurve__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a53d43b3c326aba77423ce89ba2fcc1eb"></span>int <code class="descname">OGR_GT_IsCurve</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eGeomType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_GT_IsCurve18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if a geometry type is an instance of Curve. </p>
<p>Such geometry type are wkbLineString, wkbCircularString, wkbCompoundCurve and their Z/M/ZM variant.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry type is an instance of Curve</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eGeomType</span></code>: the geometry type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_GT_IsSurface18OGRwkbGeometryType">
<span id="_CPPv316OGR_GT_IsSurface18OGRwkbGeometryType"></span><span id="_CPPv216OGR_GT_IsSurface18OGRwkbGeometryType"></span><span id="OGR_GT_IsSurface__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a19f3477957f5aee379025ba11ce3e0e0"></span>int <code class="descname">OGR_GT_IsSurface</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eGeomType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_GT_IsSurface18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if a geometry type is an instance of Surface. </p>
<p>Such geometry type are wkbCurvePolygon and wkbPolygon and their Z/M/ZM variant.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry type is an instance of Surface</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eGeomType</span></code>: the geometry type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_GT_IsNonLinear18OGRwkbGeometryType">
<span id="_CPPv318OGR_GT_IsNonLinear18OGRwkbGeometryType"></span><span id="_CPPv218OGR_GT_IsNonLinear18OGRwkbGeometryType"></span><span id="OGR_GT_IsNonLinear__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1af00785e757dee5cddfada6decc610e65"></span>int <code class="descname">OGR_GT_IsNonLinear</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eGeomType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_GT_IsNonLinear18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if a geometry type is a non-linear geometry type. </p>
<p>Such geometry type are wkbCurve, wkbCircularString, wkbCompoundCurve, wkbSurface, wkbCurvePolygon, wkbMultiCurve, wkbMultiSurface and their Z/M variants.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry type is a non-linear geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eGeomType</span></code>: the geometry type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_GT_GetCollection18OGRwkbGeometryType">
<span id="_CPPv320OGR_GT_GetCollection18OGRwkbGeometryType"></span><span id="_CPPv220OGR_GT_GetCollection18OGRwkbGeometryType"></span><span id="OGR_GT_GetCollection__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1ad98b8626b3eb0d2b175532bc365bb9c5"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GT_GetCollection</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_GT_GetCollection18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the collection type that can contain the passed geometry type. </p>
<p>Handled conversions are : wkbNone-&gt;wkbNone, wkbPoint -&gt; wkbMultiPoint, wkbLineString-&gt;wkbMultiLineString, wkbPolygon/wkbTriangle/wkbPolyhedralSurface/wkbTIN-&gt;wkbMultiPolygon, wkbCircularString-&gt;wkbMultiCurve, wkbCompoundCurve-&gt;wkbMultiCurve, wkbCurvePolygon-&gt;wkbMultiSurface. In other cases, wkbUnknown is returned</p>
<p>Passed Z, M, ZM flag is preserved.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the collection type that can contain the passed geometry type or wkbUnknown</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_GT_GetCurve18OGRwkbGeometryType">
<span id="_CPPv315OGR_GT_GetCurve18OGRwkbGeometryType"></span><span id="_CPPv215OGR_GT_GetCurve18OGRwkbGeometryType"></span><span id="OGR_GT_GetCurve__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a7fdc3e7159652e9c4d06365119bb6538"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GT_GetCurve</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_GT_GetCurve18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the curve geometry type that can contain the passed geometry type. </p>
<p>Handled conversions are : wkbPolygon -&gt; wkbCurvePolygon, wkbLineString-&gt;wkbCompoundCurve, wkbMultiPolygon-&gt;wkbMultiSurface and wkbMultiLineString-&gt;wkbMultiCurve. In other cases, the passed geometry is returned.</p>
<p>Passed Z, M, ZM flag is preserved.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the curve type that can contain the passed geometry type</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_GT_GetLinear18OGRwkbGeometryType">
<span id="_CPPv316OGR_GT_GetLinear18OGRwkbGeometryType"></span><span id="_CPPv216OGR_GT_GetLinear18OGRwkbGeometryType"></span><span id="OGR_GT_GetLinear__OGRwkbGeometryType"></span><span class="target" id="ogr__core_8h_1a510e29430cffef63b0b12a5d40db59e8"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GT_GetLinear</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_GT_GetLinear18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the non-curve geometry type that can contain the passed geometry type. </p>
<p>Handled conversions are : wkbCurvePolygon -&gt; wkbPolygon, wkbCircularString-&gt;wkbLineString, wkbCompoundCurve-&gt;wkbLineString, wkbMultiSurface-&gt;wkbMultiPolygon and wkbMultiCurve-&gt;wkbMultiLineString. In other cases, the passed geometry is returned.</p>
<p>Passed Z, M, ZM flag is preserved.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the non-curve type that can contain the passed geometry type</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Input geometry type</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_GET_MSf">
<span id="_CPPv310OGR_GET_MSf"></span><span id="_CPPv210OGR_GET_MSf"></span><span id="OGR_GET_MS__float"></span><span class="target" id="ogr__core_8h_1ac164401cb59a7bc3874cd19159a0e24f"></span>int <code class="descname">OGR_GET_MS</code><span class="sig-paren">(</span>float <em>fSec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_GET_MSf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of milliseconds from a datetime with decimal seconds. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGRParseDatePKcP8OGRFieldi">
<span id="_CPPv312OGRParseDatePKcP8OGRFieldi"></span><span id="_CPPv212OGRParseDatePKcP8OGRFieldi"></span><span id="OGRParseDate__cCP.OGRFieldP.i"></span><span class="target" id="ogr__core_8h_1a37160eac077aa6a30e48a7a43cf3a492"></span>int <code class="descname">OGRParseDate</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszInput</em>, <a class="reference internal" href="#_CPPv48OGRField" title="OGRField">OGRField</a> *<em>psOutput</em>, int <em>nOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGRParseDatePKcP8OGRFieldi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse date string. </p>
<p>This function attempts to parse a date string in a variety of formats into the OGRField.Date format suitable for use with OGR. Generally speaking this function is expecting values like:</p>
<p>YYYY-MM-DD HH:MM:SS[.sss]+nn or YYYY-MM-DDTHH:MM:SS[.sss]Z (ISO 8601 format) or YYYY-MM-DDZ</p>
<p>The seconds may also have a decimal portion (which is ignored). And just dates (YYYY-MM-DD) or just times (HH:MM:SS[.sss]) are also supported. The date may also be in YYYY/MM/DD format. If the year is less than 100 and greater than 30 a “1900” century value will be set. If it is less than 30 and greater than -1 then a “2000” century value will be set. In the future this function may be generalized, and additional control provided through nOptions, but an nOptions value of “0” should always do a reasonable default form of processing.</p>
<p>The value of psField will be indeterminate if the function fails (returns FALSE).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if apparently successful or FALSE on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszInput</span></code>: the input date string. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psField</span></code>: the <a class="reference internal" href="#unionOGRField"><span class="std std-ref">OGRField</span></a> that will be updated with the parsed result. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOptions</span></code>: parsing options, for now always 0.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv411OGREnvelope">
<span id="_CPPv311OGREnvelope"></span><span id="_CPPv211OGREnvelope"></span><span id="OGREnvelope"></span><span class="target" id="classOGREnvelope"></span><em class="property">class </em><code class="descname">OGREnvelope</code><a class="headerlink" href="#_CPPv411OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;ogr_core.h&gt;</em><p>Simple container for a bounding region (rectangle) </p>
<p>Subclassed by <a class="reference internal" href="#classOGREnvelope3D"><span class="std std-ref">OGREnvelope3D</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N11OGREnvelope11OGREnvelopeEv">
<span id="_CPPv3N11OGREnvelope11OGREnvelopeEv"></span><span id="_CPPv2N11OGREnvelope11OGREnvelopeEv"></span><span id="OGREnvelope::OGREnvelope"></span><span class="target" id="classOGREnvelope_1a5d4056fdc1fd8c410d5e0cb0d14ea83f"></span><code class="descname">OGREnvelope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11OGREnvelope11OGREnvelopeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor. </p>
<p>Defines an empty rectangle </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11OGREnvelope11OGREnvelopeERK11OGREnvelope">
<span id="_CPPv3N11OGREnvelope11OGREnvelopeERK11OGREnvelope"></span><span id="_CPPv2N11OGREnvelope11OGREnvelopeERK11OGREnvelope"></span><span id="OGREnvelope::OGREnvelope__OGREnvelopeCR"></span><span class="target" id="classOGREnvelope_1ae08ec1720b04c57a5562e99500e811f3"></span><code class="descname">OGREnvelope</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N11OGREnvelope11OGREnvelopeEv" title="OGREnvelope::OGREnvelope">OGREnvelope</a> &amp;<em>oOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11OGREnvelope11OGREnvelopeERK11OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11OGREnvelopeaSERK11OGREnvelope">
<span id="_CPPv3N11OGREnvelopeaSERK11OGREnvelope"></span><span id="_CPPv2N11OGREnvelopeaSERK11OGREnvelope"></span><span id="OGREnvelope::assign-operator__OGREnvelopeCR"></span><span class="target" id="classOGREnvelope_1a2d710c8f13d3c4822e7b385d24050f74"></span><a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11OGREnvelopeaSERK11OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK11OGREnvelope6IsInitEv">
<span id="_CPPv3NK11OGREnvelope6IsInitEv"></span><span id="_CPPv2NK11OGREnvelope6IsInitEv"></span><span id="OGREnvelope::IsInitC"></span><span class="target" id="classOGREnvelope_1a6504f8f3b96e3152a8120e9ce54c9a9b"></span>int <code class="descname">IsInit</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK11OGREnvelope6IsInitEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether the object has been initialized, that is, is non empty. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11OGREnvelope5MergeERK11OGREnvelope">
<span id="_CPPv3N11OGREnvelope5MergeERK11OGREnvelope"></span><span id="_CPPv2N11OGREnvelope5MergeERK11OGREnvelope"></span><span id="OGREnvelope::Merge__OGREnvelopeCR"></span><span class="target" id="classOGREnvelope_1ae98cf6c0729ba361543312705e7bb7b4"></span>void <code class="descname">Merge</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> <em class="property">const</em> &amp;<em>sOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11OGREnvelope5MergeERK11OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update the current object by computing its union with the other rectangle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11OGREnvelope5MergeEdd">
<span id="_CPPv3N11OGREnvelope5MergeEdd"></span><span id="_CPPv2N11OGREnvelope5MergeEdd"></span><span id="OGREnvelope::Merge__double.double"></span><span class="target" id="classOGREnvelope_1a6dd4e57da2578b1420a29d1a800cf522"></span>void <code class="descname">Merge</code><span class="sig-paren">(</span>double <em>dfX</em>, double <em>dfY</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11OGREnvelope5MergeEdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update the current object by computing its union with the provided point. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N11OGREnvelope9IntersectERK11OGREnvelope">
<span id="_CPPv3N11OGREnvelope9IntersectERK11OGREnvelope"></span><span id="_CPPv2N11OGREnvelope9IntersectERK11OGREnvelope"></span><span id="OGREnvelope::Intersect__OGREnvelopeCR"></span><span class="target" id="classOGREnvelope_1a59d75c24facbc81f321c7f878d375869"></span>void <code class="descname">Intersect</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> <em class="property">const</em> &amp;<em>sOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11OGREnvelope9IntersectERK11OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update the current object by computing its intersection with the other rectangle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK11OGREnvelope10IntersectsERK11OGREnvelope">
<span id="_CPPv3NK11OGREnvelope10IntersectsERK11OGREnvelope"></span><span id="_CPPv2NK11OGREnvelope10IntersectsERK11OGREnvelope"></span><span id="OGREnvelope::Intersects__OGREnvelopeCRC"></span><span class="target" id="classOGREnvelope_1a6712fdb2a7b7d10f3d2f17067d318161"></span>int <code class="descname">Intersects</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> <em class="property">const</em> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK11OGREnvelope10IntersectsERK11OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether the current object intersects with the other rectangle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK11OGREnvelope8ContainsERK11OGREnvelope">
<span id="_CPPv3NK11OGREnvelope8ContainsERK11OGREnvelope"></span><span id="_CPPv2NK11OGREnvelope8ContainsERK11OGREnvelope"></span><span id="OGREnvelope::Contains__OGREnvelopeCRC"></span><span class="target" id="classOGREnvelope_1a314754ec18b97826a71e41496f2e8058"></span>int <code class="descname">Contains</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> <em class="property">const</em> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK11OGREnvelope8ContainsERK11OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether the current object contains the other rectangle. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N11OGREnvelope4MinXE">
<span id="_CPPv3N11OGREnvelope4MinXE"></span><span id="_CPPv2N11OGREnvelope4MinXE"></span><span id="OGREnvelope::MinX__double"></span><span class="target" id="classOGREnvelope_1a5cd0496c5505caf1bfedcbf1a396d30f"></span>double <code class="descname">MinX</code><a class="headerlink" href="#_CPPv4N11OGREnvelope4MinXE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum X value. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11OGREnvelope4MaxXE">
<span id="_CPPv3N11OGREnvelope4MaxXE"></span><span id="_CPPv2N11OGREnvelope4MaxXE"></span><span id="OGREnvelope::MaxX__double"></span><span class="target" id="classOGREnvelope_1a55cd25e093379420a241a517b4327814"></span>double <code class="descname">MaxX</code><a class="headerlink" href="#_CPPv4N11OGREnvelope4MaxXE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Maximum X value. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11OGREnvelope4MinYE">
<span id="_CPPv3N11OGREnvelope4MinYE"></span><span id="_CPPv2N11OGREnvelope4MinYE"></span><span id="OGREnvelope::MinY__double"></span><span class="target" id="classOGREnvelope_1a373ec4657ccea1b46db49c87dac48462"></span>double <code class="descname">MinY</code><a class="headerlink" href="#_CPPv4N11OGREnvelope4MinYE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum Y value. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11OGREnvelope4MaxYE">
<span id="_CPPv3N11OGREnvelope4MaxYE"></span><span id="_CPPv2N11OGREnvelope4MaxYE"></span><span id="OGREnvelope::MaxY__double"></span><span class="target" id="classOGREnvelope_1a5e80b4ff0411586fe072308244c9ca90"></span>double <code class="descname">MaxY</code><a class="headerlink" href="#_CPPv4N11OGREnvelope4MaxYE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Maximum Y value. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv413OGREnvelope3D">
<span id="_CPPv313OGREnvelope3D"></span><span id="_CPPv213OGREnvelope3D"></span><span id="OGREnvelope3D"></span><span class="target" id="classOGREnvelope3D"></span><em class="property">class </em><code class="descname">OGREnvelope3D</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a><a class="headerlink" href="#_CPPv413OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;ogr_core.h&gt;</em><p>Simple container for a bounding region in 3D. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13OGREnvelope3D13OGREnvelope3DEv">
<span id="_CPPv3N13OGREnvelope3D13OGREnvelope3DEv"></span><span id="_CPPv2N13OGREnvelope3D13OGREnvelope3DEv"></span><span id="OGREnvelope3D::OGREnvelope3D"></span><span class="target" id="classOGREnvelope3D_1ab7ff53b570cd7e396a7a46858e266340"></span><code class="descname">OGREnvelope3D</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13OGREnvelope3D13OGREnvelope3DEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor. </p>
<p>Defines an empty rectangle </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13OGREnvelope3D13OGREnvelope3DERK13OGREnvelope3D">
<span id="_CPPv3N13OGREnvelope3D13OGREnvelope3DERK13OGREnvelope3D"></span><span id="_CPPv2N13OGREnvelope3D13OGREnvelope3DERK13OGREnvelope3D"></span><span id="OGREnvelope3D::OGREnvelope3D__OGREnvelope3DCR"></span><span class="target" id="classOGREnvelope3D_1af23cde04ebd521c1a987977031a5aa31"></span><code class="descname">OGREnvelope3D</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N13OGREnvelope3D13OGREnvelope3DEv" title="OGREnvelope3D::OGREnvelope3D">OGREnvelope3D</a> &amp;<em>oOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13OGREnvelope3D13OGREnvelope3DERK13OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13OGREnvelope3DaSERK13OGREnvelope3D">
<span id="_CPPv3N13OGREnvelope3DaSERK13OGREnvelope3D"></span><span id="_CPPv2N13OGREnvelope3DaSERK13OGREnvelope3D"></span><span id="OGREnvelope3D::assign-operator__OGREnvelope3DCR"></span><span class="target" id="classOGREnvelope3D_1a2ea7569c84437deaa49c95cea2099318"></span><a class="reference internal" href="#_CPPv413OGREnvelope3D" title="OGREnvelope3D">OGREnvelope3D</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv413OGREnvelope3D" title="OGREnvelope3D">OGREnvelope3D</a>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13OGREnvelope3DaSERK13OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13OGREnvelope3D6IsInitEv">
<span id="_CPPv3NK13OGREnvelope3D6IsInitEv"></span><span id="_CPPv2NK13OGREnvelope3D6IsInitEv"></span><span id="OGREnvelope3D::IsInitC"></span><span class="target" id="classOGREnvelope3D_1a17a1b69658b203fbcbeaa9f400fb511a"></span>int <code class="descname">IsInit</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13OGREnvelope3D6IsInitEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether the object has been initialized, that is, is non empty. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13OGREnvelope3D5MergeERK13OGREnvelope3D">
<span id="_CPPv3N13OGREnvelope3D5MergeERK13OGREnvelope3D"></span><span id="_CPPv2N13OGREnvelope3D5MergeERK13OGREnvelope3D"></span><span id="OGREnvelope3D::Merge__OGREnvelope3DCR"></span><span class="target" id="classOGREnvelope3D_1a026eb8ed912f1565bad58ca3f620d96d"></span>void <code class="descname">Merge</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGREnvelope3D" title="OGREnvelope3D">OGREnvelope3D</a> <em class="property">const</em> &amp;<em>sOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13OGREnvelope3D5MergeERK13OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update the current object by computing its union with the other rectangle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13OGREnvelope3D5MergeEddd">
<span id="_CPPv3N13OGREnvelope3D5MergeEddd"></span><span id="_CPPv2N13OGREnvelope3D5MergeEddd"></span><span id="OGREnvelope3D::Merge__double.double.double"></span><span class="target" id="classOGREnvelope3D_1a1eb708627a1d8ac759fe9ab6946ae4ef"></span>void <code class="descname">Merge</code><span class="sig-paren">(</span>double <em>dfX</em>, double <em>dfY</em>, double <em>dfZ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13OGREnvelope3D5MergeEddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update the current object by computing its union with the provided point. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N13OGREnvelope3D9IntersectERK13OGREnvelope3D">
<span id="_CPPv3N13OGREnvelope3D9IntersectERK13OGREnvelope3D"></span><span id="_CPPv2N13OGREnvelope3D9IntersectERK13OGREnvelope3D"></span><span id="OGREnvelope3D::Intersect__OGREnvelope3DCR"></span><span class="target" id="classOGREnvelope3D_1adce510a77c3ddc3ce63f976864810f85"></span>void <code class="descname">Intersect</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGREnvelope3D" title="OGREnvelope3D">OGREnvelope3D</a> <em class="property">const</em> &amp;<em>sOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13OGREnvelope3D9IntersectERK13OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update the current object by computing its intersection with the other rectangle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13OGREnvelope3D10IntersectsERK13OGREnvelope3D">
<span id="_CPPv3NK13OGREnvelope3D10IntersectsERK13OGREnvelope3D"></span><span id="_CPPv2NK13OGREnvelope3D10IntersectsERK13OGREnvelope3D"></span><span id="OGREnvelope3D::Intersects__OGREnvelope3DCRC"></span><span class="target" id="classOGREnvelope3D_1a4e0c0a0a5aacb70e232cfa33541b91b5"></span>int <code class="descname">Intersects</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGREnvelope3D" title="OGREnvelope3D">OGREnvelope3D</a> <em class="property">const</em> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13OGREnvelope3D10IntersectsERK13OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether the current object intersects with the other rectangle. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK13OGREnvelope3D8ContainsERK13OGREnvelope3D">
<span id="_CPPv3NK13OGREnvelope3D8ContainsERK13OGREnvelope3D"></span><span id="_CPPv2NK13OGREnvelope3D8ContainsERK13OGREnvelope3D"></span><span id="OGREnvelope3D::Contains__OGREnvelope3DCRC"></span><span class="target" id="classOGREnvelope3D_1ac7c721215ceb46d08bb9ce21f6a7b85f"></span>int <code class="descname">Contains</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGREnvelope3D" title="OGREnvelope3D">OGREnvelope3D</a> <em class="property">const</em> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK13OGREnvelope3D8ContainsERK13OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether the current object contains the other rectangle. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N13OGREnvelope3D4MinZE">
<span id="_CPPv3N13OGREnvelope3D4MinZE"></span><span id="_CPPv2N13OGREnvelope3D4MinZE"></span><span id="OGREnvelope3D::MinZ__double"></span><span class="target" id="classOGREnvelope3D_1aaf97b687c25c7d837bcc8b5ad92300e1"></span>double <code class="descname">MinZ</code><a class="headerlink" href="#_CPPv4N13OGREnvelope3D4MinZE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum Z value. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13OGREnvelope3D4MaxZE">
<span id="_CPPv3N13OGREnvelope3D4MaxZE"></span><span id="_CPPv2N13OGREnvelope3D4MaxZE"></span><span id="OGREnvelope3D::MaxZ__double"></span><span class="target" id="classOGREnvelope3D_1a8164346da3998efcc563249f1512d694"></span>double <code class="descname">MaxZ</code><a class="headerlink" href="#_CPPv4N13OGREnvelope3D4MaxZE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Maximum Z value. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="union">
<dt id="_CPPv48OGRField">
<span id="_CPPv38OGRField"></span><span id="_CPPv28OGRField"></span><span class="target" id="unionOGRField"></span><em class="property">union </em><code class="descname">OGRField</code><a class="headerlink" href="#_CPPv48OGRField" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;ogr_core.h&gt;</em><p><a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> field attribute value union. </p>
</dd></dl>

<p>C API and defines for <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a>, <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry"><span class="std std-ref">OGRGeometry</span></a>, and OGRDataSource related classes. </p>
<p>See also: ogr_geometry.h, ogr_feature.h, ogrsf_frmts.h, ogr_featurestyle.h </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.OGR_FOR_EACH_FEATURE_BEGIN">
<span class="target" id="ogr__api_8h_1a261ecc4eb3468bae5f5deaed761f4221"></span><code class="descname">OGR_FOR_EACH_FEATURE_BEGIN</code><span class="sig-paren">(</span>hFeat, hLayer<span class="sig-paren">)</span><a class="headerlink" href="#c.OGR_FOR_EACH_FEATURE_BEGIN" title="Permalink to this definition">¶</a></dt>
<dd><p>Conveniency macro to iterate over features of a layer. </p>
<p>Typical usage is: </p>
<p>In C++, you might want to use instead range-based loop: </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.3 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: variable name for OGRFeatureH. The variable will be declared inside the macro body. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: layer to iterate over.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.OGR_FOR_EACH_FEATURE_END">
<span class="target" id="ogr__api_8h_1a7c1c16c3af1f08084b3c261411beaf99"></span><code class="descname">OGR_FOR_EACH_FEATURE_END</code><span class="sig-paren">(</span>hFeat<span class="sig-paren">)</span><a class="headerlink" href="#c.OGR_FOR_EACH_FEATURE_END" title="Permalink to this definition">¶</a></dt>
<dd><p>End of iterator. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv412OGRGeometryH">
<span id="_CPPv312OGRGeometryH"></span><span id="_CPPv212OGRGeometryH"></span><span id="OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a147386126eed05cc383cb3eb1b34104c"></span><em class="property">typedef </em>void *<code class="descname">OGRGeometryH</code><a class="headerlink" href="#_CPPv412OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a geometry. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv419OGRGeomTransformerH">
<span id="_CPPv319OGRGeomTransformerH"></span><span id="_CPPv219OGRGeomTransformerH"></span><span id="OGRGeomTransformerH"></span><span class="target" id="ogr__api_8h_1abfd327453a3ded09dad8dcfa88170dbb"></span><em class="property">typedef </em><em class="property">struct</em> OGRGeomTransformer *<code class="descname">OGRGeomTransformerH</code><a class="headerlink" href="#_CPPv419OGRGeomTransformerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a geometry transformer. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv413OGRFieldDefnH">
<span id="_CPPv313OGRFieldDefnH"></span><span id="_CPPv213OGRFieldDefnH"></span><span id="OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a624dc73953f25ea4efd8686d5121249b"></span><em class="property">typedef </em>void *<code class="descname">OGRFieldDefnH</code><a class="headerlink" href="#_CPPv413OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a field definition (<a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn"><span class="std std-ref">OGRFieldDefn</span></a>) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv415OGRFeatureDefnH">
<span id="_CPPv315OGRFeatureDefnH"></span><span id="_CPPv215OGRFeatureDefnH"></span><span id="OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a827cc74dba4613e928843c4b5f781618"></span><em class="property">typedef </em>void *<code class="descname">OGRFeatureDefnH</code><a class="headerlink" href="#_CPPv415OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a feature definition (<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv411OGRFeatureH">
<span id="_CPPv311OGRFeatureH"></span><span id="_CPPv211OGRFeatureH"></span><span id="OGRFeatureH"></span><span class="target" id="ogr__api_8h_1aa4ebb4d695364da5635718ec664b95bf"></span><em class="property">typedef </em>void *<code class="descname">OGRFeatureH</code><a class="headerlink" href="#_CPPv411OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a feature (<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a>) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv414OGRStyleTableH">
<span id="_CPPv314OGRStyleTableH"></span><span id="_CPPv214OGRStyleTableH"></span><span id="OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1ade9fad6abd55f6760170e0e47a7455d8"></span><em class="property">typedef </em>void *<code class="descname">OGRStyleTableH</code><a class="headerlink" href="#_CPPv414OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a style table (<a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable"><span class="std std-ref">OGRStyleTable</span></a>) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv417OGRGeomFieldDefnH">
<span id="_CPPv317OGRGeomFieldDefnH"></span><span id="_CPPv217OGRGeomFieldDefnH"></span><span id="OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1ab02dff2945904f6c0664e17a80c5f6bf"></span><em class="property">typedef </em><em class="property">struct</em> OGRGeomFieldDefnHS *<code class="descname">OGRGeomFieldDefnH</code><a class="headerlink" href="#_CPPv417OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a geometry field definition (<a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn"><span class="std std-ref">OGRGeomFieldDefn</span></a>) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv49OGRLayerH">
<span id="_CPPv39OGRLayerH"></span><span id="_CPPv29OGRLayerH"></span><span id="OGRLayerH"></span><span class="target" id="ogr__api_8h_1a635095fa23dfea934f4bb2df38fb9a67"></span><em class="property">typedef </em>void *<code class="descname">OGRLayerH</code><a class="headerlink" href="#_CPPv49OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a layer (<a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a>) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv414OGRDataSourceH">
<span id="_CPPv314OGRDataSourceH"></span><span id="_CPPv214OGRDataSourceH"></span><span id="OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1ae37d6a007fbf6453a11062443c9cc2a4"></span><em class="property">typedef </em>void *<code class="descname">OGRDataSourceH</code><a class="headerlink" href="#_CPPv414OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a OGR datasource (OGRDataSource) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv412OGRSFDriverH">
<span id="_CPPv312OGRSFDriverH"></span><span id="_CPPv212OGRSFDriverH"></span><span id="OGRSFDriverH"></span><span class="target" id="ogr__api_8h_1acb21d6f230ef8a5d2c1e65bf98473eca"></span><em class="property">typedef </em>void *<code class="descname">OGRSFDriverH</code><a class="headerlink" href="#_CPPv412OGRSFDriverH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque type for a OGR driver (OGRSFDriver) </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv412OGRStyleMgrH">
<span id="_CPPv312OGRStyleMgrH"></span><span id="_CPPv212OGRStyleMgrH"></span><span id="OGRStyleMgrH"></span><span class="target" id="ogr__api_8h_1a52e20dd0f2767e72fdf1cd84bfa58edd"></span><em class="property">typedef </em>void *<code class="descname">OGRStyleMgrH</code><a class="headerlink" href="#_CPPv412OGRStyleMgrH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Style manager opaque type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv413OGRStyleToolH">
<span id="_CPPv313OGRStyleToolH"></span><span id="_CPPv213OGRStyleToolH"></span><span id="OGRStyleToolH"></span><span class="target" id="ogr__api_8h_1a92f1ce388fcfa9dfcedf873eb417e1c5"></span><em class="property">typedef </em>void *<code class="descname">OGRStyleToolH</code><a class="headerlink" href="#_CPPv413OGRStyleToolH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Style tool opaque type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv419OGR_G_CreateFromWkbPKv20OGRSpatialReferenceHP12OGRGeometryHi">
<span id="_CPPv319OGR_G_CreateFromWkbPKv20OGRSpatialReferenceHP12OGRGeometryHi"></span><span id="_CPPv219OGR_G_CreateFromWkbPKv20OGRSpatialReferenceHP12OGRGeometryHi"></span><span id="OGR_G_CreateFromWkb__voidCP.OGRSpatialReferenceH.OGRGeometryHP.i"></span><span class="target" id="ogr__api_8h_1a65af51cbb3d62789dee6f96044f4dcb6"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_CreateFromWkb</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>pabyData</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSRS</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> *<em>phGeometry</em>, int <em>nBytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_CreateFromWkbPKv20OGRSpatialReferenceHP12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a geometry object of the appropriate type from its well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="reference internal" href="#ogr__api_8h_1a5f7035a933b957a9d453184c154c237c"><span class="std std-ref">OGR_G_WkbSize()</span></a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>The <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a66de314779c192b94e2e8cf2836c13c8"><span class="std std-ref">OGRGeometryFactory::createFromWkb()</span></a> CPP method is the same as this function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pabyData</span></code>: pointer to the input BLOB data. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSRS</span></code>: handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phGeometry</span></code>: the newly created geometry object will be assigned to the indicated handle on return. This will be NULL in case of failure. If not NULL, *phGeometry should be freed with <a class="reference internal" href="#ogr__api_8h_1ac4e665f5f9690c4fa0c190b930fe9492"><span class="std std-ref">OGR_G_DestroyGeometry()</span></a> after use. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBytes</span></code>: the number of bytes of data available in pabyData, or -1 if it is not known, but assumed to be sufficient.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_CreateFromWktPPc20OGRSpatialReferenceHP12OGRGeometryH">
<span id="_CPPv319OGR_G_CreateFromWktPPc20OGRSpatialReferenceHP12OGRGeometryH"></span><span id="_CPPv219OGR_G_CreateFromWktPPc20OGRSpatialReferenceHP12OGRGeometryH"></span><span id="OGR_G_CreateFromWkt__cPP.OGRSpatialReferenceH.OGRGeometryHP"></span><span class="target" id="ogr__api_8h_1ac02c3ed5f7ebd5039dc2ae70154fd94a"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_CreateFromWkt</code><span class="sig-paren">(</span>char **<em>ppszData</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSRS</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> *<em>phGeometry</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_CreateFromWktPPc20OGRSpatialReferenceHP12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a geometry object of the appropriate type from its well known text representation. </p>
<p>The <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a955f997c743af4220655285eda8724a9"><span class="std std-ref">OGRGeometryFactory::createFromWkt</span></a> CPP method is the same as this function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ppszData</span></code>: input zero terminated string containing well known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSRS</span></code>: handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phGeometry</span></code>: the newly created geometry object will be assigned to the indicated handle on return. This will be NULL if the method fails. If not NULL, *phGeometry should be freed with <a class="reference internal" href="#ogr__api_8h_1ac4e665f5f9690c4fa0c190b930fe9492"><span class="std std-ref">OGR_G_DestroyGeometry()</span></a> after use.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_CreateFromFgfPKv20OGRSpatialReferenceHP12OGRGeometryHiPi">
<span id="_CPPv319OGR_G_CreateFromFgfPKv20OGRSpatialReferenceHP12OGRGeometryHiPi"></span><span id="_CPPv219OGR_G_CreateFromFgfPKv20OGRSpatialReferenceHP12OGRGeometryHiPi"></span><span id="OGR_G_CreateFromFgf__voidCP.OGRSpatialReferenceH.OGRGeometryHP.i.iP"></span><span class="target" id="ogr__api_8h_1a3ab486f7ab98a4b592d25e4b8a0ac698"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_CreateFromFgf</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>pabyData</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSRS</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> *<em>phGeometry</em>, int <em>nBytes</em>, int *<em>pnBytesConsumed</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_CreateFromFgfPKv20OGRSpatialReferenceHP12OGRGeometryHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representation. </p>
<p>See <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a99be8486694e4b99384c38aab094ebdc"><span class="std std-ref">OGRGeometryFactory::createFromFgf()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_G_DestroyGeometry12OGRGeometryH">
<span id="_CPPv321OGR_G_DestroyGeometry12OGRGeometryH"></span><span id="_CPPv221OGR_G_DestroyGeometry12OGRGeometryH"></span><span id="OGR_G_DestroyGeometry__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ac4e665f5f9690c4fa0c190b930fe9492"></span>void <code class="descname">OGR_G_DestroyGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_G_DestroyGeometry12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy geometry object. </p>
<p>Equivalent to invoking delete on a geometry, but it guaranteed to take place within the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1aae001086e26985d95c36ccd255a8c6d5"><span class="std std-ref">OGRGeometryFactory::destroyGeometry</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to delete. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_CreateGeometry18OGRwkbGeometryType">
<span id="_CPPv320OGR_G_CreateGeometry18OGRwkbGeometryType"></span><span id="_CPPv220OGR_G_CreateGeometry18OGRwkbGeometryType"></span><span id="OGR_G_CreateGeometry__OGRwkbGeometryType"></span><span class="target" id="ogr__api_8h_1a60311342f2a329f433ea66e2d6fedadc"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_CreateGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eGeometryType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_CreateGeometry18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an empty geometry of desired type. </p>
<p>This is equivalent to allocating the desired geometry with new, but the allocation is guaranteed to take place in the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1ae4887e270d5099357f9a19b1eda6027a"><span class="std std-ref">OGRGeometryFactory::createGeometry</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle to the newly create geometry or NULL on failure. Should be freed with <a class="reference internal" href="#ogr__api_8h_1ac4e665f5f9690c4fa0c190b930fe9492"><span class="std std-ref">OGR_G_DestroyGeometry()</span></a> after use. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eGeometryType</span></code>: the type code of the geometry to be created.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_G_ApproximateArcAnglesddddddddd">
<span id="_CPPv326OGR_G_ApproximateArcAnglesddddddddd"></span><span id="_CPPv226OGR_G_ApproximateArcAnglesddddddddd"></span><span id="OGR_G_ApproximateArcAngles__double.double.double.double.double.double.double.double.double"></span><span class="target" id="ogr__api_8h_1a87f8bce40c82b3513e36109ea051dff2"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ApproximateArcAngles</code><span class="sig-paren">(</span>double <em>dfCenterX</em>, double <em>dfCenterY</em>, double <em>dfZ</em>, double <em>dfPrimaryRadius</em>, double <em>dfSecondaryAxis</em>, double <em>dfRotation</em>, double <em>dfStartAngle</em>, double <em>dfEndAngle</em>, double <em>dfMaxAngleStepSizeDegrees</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_G_ApproximateArcAnglesddddddddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stroke arc to linestring. </p>
<p>Stroke an arc of a circle to a linestring based on a center point, radius, start angle and end angle, all angles in degrees.</p>
<p>If the dfMaxAngleStepSizeDegrees is zero, then a default value will be used. This is currently 4 degrees unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference internal" href="cpl.html#cpl__conv_8h_1aa0cd1a68fe4f2fc7874cd2da605c36ce"><span class="std std-ref">CPLSetConfigOption()</span></a></p>
</dd>
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="ogrgeometry_cpp.html#classOGRLineString"><span class="std std-ref">OGRLineString</span></a> geometry representing an approximation of the arc.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dfCenterX</span></code>: center X </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfCenterY</span></code>: center Y </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfZ</span></code>: center Z </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfPrimaryRadius</span></code>: X radius of ellipse. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfSecondaryRadius</span></code>: Y radius of ellipse. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfRotation</span></code>: rotation of the ellipse clockwise. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfStartAngle</span></code>: angle to first point on arc (clockwise of X-positive) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfEndAngle</span></code>: angle to last point on arc (clockwise of X-positive) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxAngleStepSizeDegrees</span></code>: the largest step in degrees along the arc, zero to use the default setting.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_ForceToPolygon12OGRGeometryH">
<span id="_CPPv320OGR_G_ForceToPolygon12OGRGeometryH"></span><span id="_CPPv220OGR_G_ForceToPolygon12OGRGeometryH"></span><span id="OGR_G_ForceToPolygon__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a0fc3d5b213a7891355329d205aaa0d2c"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ForceToPolygon</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_ForceToPolygon12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to polygon. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1afd61936e41ea69831b3196e817658d08"><span class="std std-ref">OGRGeometryFactory::forceToPolygon()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the converted geometry (ownership to caller).</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL/OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to convert (ownership surrendered). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_G_ForceToLineString12OGRGeometryH">
<span id="_CPPv323OGR_G_ForceToLineString12OGRGeometryH"></span><span id="_CPPv223OGR_G_ForceToLineString12OGRGeometryH"></span><span id="OGR_G_ForceToLineString__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a5cee9b0081977f61681a909231608146"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ForceToLineString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_G_ForceToLineString12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to line string. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1adcae79ea28620e332a3d1df87f1180f3"><span class="std std-ref">OGRGeometryFactory::forceToLineString()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the converted geometry (ownership to caller).</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL/OGR 1.10.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to convert (ownership surrendered). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_G_ForceToMultiPolygon12OGRGeometryH">
<span id="_CPPv325OGR_G_ForceToMultiPolygon12OGRGeometryH"></span><span id="_CPPv225OGR_G_ForceToMultiPolygon12OGRGeometryH"></span><span id="OGR_G_ForceToMultiPolygon__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a4c0c5be9aa982ba776f4cfdab4d8b798"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ForceToMultiPolygon</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_G_ForceToMultiPolygon12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to multipolygon. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a2a40032fa65cc71c028516bf8fc0df3e"><span class="std std-ref">OGRGeometryFactory::forceToMultiPolygon()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the converted geometry (ownership to caller).</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL/OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to convert (ownership surrendered). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_G_ForceToMultiPoint12OGRGeometryH">
<span id="_CPPv323OGR_G_ForceToMultiPoint12OGRGeometryH"></span><span id="_CPPv223OGR_G_ForceToMultiPoint12OGRGeometryH"></span><span id="OGR_G_ForceToMultiPoint__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1abb60e8b68ba76843577df5ebab22ab95"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ForceToMultiPoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_G_ForceToMultiPoint12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to multipoint. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1aa97b7837101f6c56e476520d10a9f3c3"><span class="std std-ref">OGRGeometryFactory::forceToMultiPoint()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the converted geometry (ownership to caller).</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL/OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to convert (ownership surrendered). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_G_ForceToMultiLineString12OGRGeometryH">
<span id="_CPPv328OGR_G_ForceToMultiLineString12OGRGeometryH"></span><span id="_CPPv228OGR_G_ForceToMultiLineString12OGRGeometryH"></span><span id="OGR_G_ForceToMultiLineString__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a0776505ab4794d50e425b5333415cf9b"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ForceToMultiLineString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_G_ForceToMultiLineString12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to multilinestring. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a1c00a78cec110d71175726d6f26b1b39"><span class="std std-ref">OGRGeometryFactory::forceToMultiLineString()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the converted geometry (ownership to caller).</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL/OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to convert (ownership surrendered). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_G_ForceTo12OGRGeometryH18OGRwkbGeometryTypePPc">
<span id="_CPPv313OGR_G_ForceTo12OGRGeometryH18OGRwkbGeometryTypePPc"></span><span id="_CPPv213OGR_G_ForceTo12OGRGeometryH18OGRwkbGeometryTypePPc"></span><span id="OGR_G_ForceTo__OGRGeometryH.OGRwkbGeometryType.cPP"></span><span class="target" id="ogr__api_8h_1a3a37c25a9b628982e86b1821446e3a0e"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ForceTo</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eTargetType</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_G_ForceTo12OGRGeometryH18OGRwkbGeometryTypePPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert to another geometry type. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a26120382ccfec8ac4b5f932dd3a67c5f"><span class="std std-ref">OGRGeometryFactory::forceTo()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>new geometry.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the input geometry - ownership is passed to the method. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eTargetType</span></code>: target output geometry type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: options as a null-terminated list of strings or NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv434OGR_G_RemoveLowerDimensionSubGeomsK12OGRGeometryH">
<span id="_CPPv334OGR_G_RemoveLowerDimensionSubGeomsK12OGRGeometryH"></span><span id="_CPPv234OGR_G_RemoveLowerDimensionSubGeomsK12OGRGeometryH"></span><span id="OGR_G_RemoveLowerDimensionSubGeoms__OGRGeometryHC"></span><span class="target" id="ogr__api_8h_1af244bd6a0608d0b817efb7747c9a1ef6"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_RemoveLowerDimensionSubGeoms</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434OGR_G_RemoveLowerDimensionSubGeomsK12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove sub-geometries from a geometry collection that do not have the maximum topological dimensionality of the collection. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a9dda76280700944f813f6b4c8e7be7a0"><span class="std std-ref">OGRGeometryFactory::removeLowerDimensionSubGeoms()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to convert </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_G_GetDimension12OGRGeometryH">
<span id="_CPPv318OGR_G_GetDimension12OGRGeometryH"></span><span id="_CPPv218OGR_G_GetDimension12OGRGeometryH"></span><span id="OGR_G_GetDimension__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a94b633e1acd208c258ad49f8d4fd4104"></span>int <code class="descname">OGR_G_GetDimension</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_G_GetDimension12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the dimension of this geometry. </p>
<p>This function corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the geometry, but does not indicate the dimension of the underlying space (as indicated by <a class="reference internal" href="#ogr__api_8h_1a8a5e78b0753339d1cdd282b0e151d28f"><span class="std std-ref">OGR_G_GetCoordinateDimension()</span></a> function).</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aadca09471fa9917452e087ba12d73eeb"><span class="std std-ref">OGRGeometry::getDimension()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>0 for points, 1 for lines and 2 for surfaces. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to get the dimension from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_G_GetCoordinateDimension12OGRGeometryH">
<span id="_CPPv328OGR_G_GetCoordinateDimension12OGRGeometryH"></span><span id="_CPPv228OGR_G_GetCoordinateDimension12OGRGeometryH"></span><span id="OGR_G_GetCoordinateDimension__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a8a5e78b0753339d1cdd282b0e151d28f"></span>int <code class="descname">OGR_G_GetCoordinateDimension</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_G_GetCoordinateDimension12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the dimension of the coordinates in this geometry. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a4a6fdd4df7c043558b5428d8f1c35b16"><span class="std std-ref">OGRGeometry::getCoordinateDimension()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to get the dimension of the coordinates from.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>this will return 2 or 3. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_G_CoordinateDimension12OGRGeometryH">
<span id="_CPPv325OGR_G_CoordinateDimension12OGRGeometryH"></span><span id="_CPPv225OGR_G_CoordinateDimension12OGRGeometryH"></span><span id="OGR_G_CoordinateDimension__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ac4843a200c0c4e57bbdc99e509f68baf"></span>int <code class="descname">OGR_G_CoordinateDimension</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_G_CoordinateDimension12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the dimension of the coordinates in this geometry. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a35c4f4d75ec84fa225a9a4dee0a609c1"><span class="std std-ref">OGRGeometry::CoordinateDimension()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to get the dimension of the coordinates from.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_G_SetCoordinateDimension12OGRGeometryHi">
<span id="_CPPv328OGR_G_SetCoordinateDimension12OGRGeometryHi"></span><span id="_CPPv228OGR_G_SetCoordinateDimension12OGRGeometryHi"></span><span id="OGR_G_SetCoordinateDimension__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1ac6bcad9553f488f7d8b6c8674cf7771c"></span>void <code class="descname">OGR_G_SetCoordinateDimension</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>nNewDimension</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_G_SetCoordinateDimension12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection, a compound curve, a polygon, etc. will affect the children geometries. This will also remove the M dimension if present before this call.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to set the dimension of the coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nNewDimension</span></code>: New coordinate dimension value, either 2 or 3. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_G_Is3D12OGRGeometryH">
<span id="_CPPv310OGR_G_Is3D12OGRGeometryH"></span><span id="_CPPv210OGR_G_Is3D12OGRGeometryH"></span><span id="OGR_G_Is3D__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1af2d4c2fb8935e9ee9584f0243e4bd0ca"></span>int <code class="descname">OGR_G_Is3D</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_G_Is3D12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>See whether this geometry has Z coordinates. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ae9867dbbd6b840ca9c9240c7cb9c3b8c"><span class="std std-ref">OGRGeometry::Is3D()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry has Z coordinates. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to check whether it has Z coordinates.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_IsMeasured12OGRGeometryH">
<span id="_CPPv316OGR_G_IsMeasured12OGRGeometryH"></span><span id="_CPPv216OGR_G_IsMeasured12OGRGeometryH"></span><span id="OGR_G_IsMeasured__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a84a8bf231d721ac04ed465d5208bac6e"></span>int <code class="descname">OGR_G_IsMeasured</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_IsMeasured12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>See whether this geometry is measured. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a959d5776c17018e362b580b1e61e1caa"><span class="std std-ref">OGRGeometry::IsMeasured()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry has M coordinates. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to check whether it is measured.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_G_Set3D12OGRGeometryHi">
<span id="_CPPv311OGR_G_Set3D12OGRGeometryHi"></span><span id="_CPPv211OGR_G_Set3D12OGRGeometryHi"></span><span id="OGR_G_Set3D__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a13c109c8afc2c614f206f8f610c7c4be"></span>void <code class="descname">OGR_G_Set3D</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>bIs3D</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_G_Set3D12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add or remove the Z coordinate dimension. </p>
<p>This method adds or removes the explicit Z coordinate dimension. Removing the Z coordinate dimension of a geometry will remove any existing Z values. Adding the Z dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to set or unset the Z dimension. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bIs3D</span></code>: Should the geometry have a Z dimension, either TRUE or FALSE. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_SetMeasured12OGRGeometryHi">
<span id="_CPPv317OGR_G_SetMeasured12OGRGeometryHi"></span><span id="_CPPv217OGR_G_SetMeasured12OGRGeometryHi"></span><span id="OGR_G_SetMeasured__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a8840ed4e65bfbf50a6a52779305a78f6"></span>void <code class="descname">OGR_G_SetMeasured</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>bIsMeasured</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_SetMeasured12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add or remove the M coordinate dimension. </p>
<p>This method adds or removes the explicit M coordinate dimension. Removing the M coordinate dimension of a geometry will remove any existing M values. Adding the M dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to set or unset the M dimension. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bIsMeasured</span></code>: Should the geometry have a M dimension, either TRUE or FALSE. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_G_Clone12OGRGeometryH">
<span id="_CPPv311OGR_G_Clone12OGRGeometryH"></span><span id="_CPPv211OGR_G_Clone12OGRGeometryH"></span><span id="OGR_G_Clone__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1aed1c08151c1873ebd4722cdf79a5ae2c"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Clone</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_G_Clone12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Make a copy of this object. </p>
<p>This function relates to the SFCOM IGeometry::clone() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a678d3e4fc419b7b714ecb80cbf603eb5"><span class="std std-ref">OGRGeometry::clone()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle on the copy of the geometry with the spatial reference system as the original. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to clone from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_GetEnvelope12OGRGeometryHP11OGREnvelope">
<span id="_CPPv317OGR_G_GetEnvelope12OGRGeometryHP11OGREnvelope"></span><span id="_CPPv217OGR_G_GetEnvelope12OGRGeometryHP11OGREnvelope"></span><span id="OGR_G_GetEnvelope__OGRGeometryH.OGREnvelopeP"></span><span class="target" id="ogr__api_8h_1a617a9c9ea85157661619a1d8f0a69cf9"></span>void <code class="descname">OGR_G_GetEnvelope</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> *<em>psEnvelope</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_GetEnvelope12OGRGeometryHP11OGREnvelope" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aa3d42b06ae6f7bbef6d1a2886da8d398"><span class="std std-ref">OGRGeometry::getEnvelope()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle of the geometry to get envelope from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psEnvelope</span></code>: the structure in which to place the results. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_GetEnvelope3D12OGRGeometryHP13OGREnvelope3D">
<span id="_CPPv319OGR_G_GetEnvelope3D12OGRGeometryHP13OGREnvelope3D"></span><span id="_CPPv219OGR_G_GetEnvelope3D12OGRGeometryHP13OGREnvelope3D"></span><span id="OGR_G_GetEnvelope3D__OGRGeometryH.OGREnvelope3DP"></span><span class="target" id="ogr__api_8h_1a9a950633ac824042b0afdb88c670c5ce"></span>void <code class="descname">OGR_G_GetEnvelope3D</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv413OGREnvelope3D" title="OGREnvelope3D">OGREnvelope3D</a> *<em>psEnvelope</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_GetEnvelope3D12OGRGeometryHP13OGREnvelope3D" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aa3d42b06ae6f7bbef6d1a2886da8d398"><span class="std std-ref">OGRGeometry::getEnvelope()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle of the geometry to get envelope from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psEnvelope</span></code>: the structure in which to place the results.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_ImportFromWkb12OGRGeometryHPKvi">
<span id="_CPPv319OGR_G_ImportFromWkb12OGRGeometryHPKvi"></span><span id="_CPPv219OGR_G_ImportFromWkb12OGRGeometryHPKvi"></span><span id="OGR_G_ImportFromWkb__OGRGeometryH.voidCP.i"></span><span class="target" id="ogr__api_8h_1ae523fe14c8c87dffcee706438ec2e81f"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_ImportFromWkb</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <em class="property">const</em> void *<em>pabyData</em>, int <em>nSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_ImportFromWkb12OGRGeometryHPKvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a0e604e7393db0dd511b458f3ecd0b819"><span class="std std-ref">OGRGeometry::importFromWkb()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to assign the well know binary data to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyData</span></code>: the binary input data. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSize</span></code>: the size of pabyData in bytes, or -1 if not known.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_ExportToWkb12OGRGeometryH15OGRwkbByteOrderPh">
<span id="_CPPv317OGR_G_ExportToWkb12OGRGeometryH15OGRwkbByteOrderPh"></span><span id="_CPPv217OGR_G_ExportToWkb12OGRGeometryH15OGRwkbByteOrderPh"></span><span id="OGR_G_ExportToWkb__OGRGeometryH.OGRwkbByteOrder.unsigned-cP"></span><span class="target" id="ogr__api_8h_1ad5c94ae76c09774dba8725c24daeefd6"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_ExportToWkb</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv415OGRwkbByteOrder" title="OGRwkbByteOrder">OGRwkbByteOrder</a> <em>eOrder</em>, unsigned char *<em>pabyDstBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_ExportToWkb12OGRGeometryH15OGRwkbByteOrderPh" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>For backward compatibility purposes, it exports the Old-style 99-402 extended dimension (Z) WKB types for types Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For other geometry types, it is equivalent to <a class="reference internal" href="#ogr__api_8h_1a622a18776e6d51515d0f2ff0ee211d91"><span class="std std-ref">OGR_G_ExportToIsoWkb()</span></a>.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a9a3ad2f9b55285be500ca6ac5dc75d1d"><span class="std std-ref">OGRGeometry::exportToWkb</span></a>(OGRwkbByteOrder, unsigned char *, OGRwkbVariant) with eWkbVariant = wkbVariantOldOgc.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Currently OGRERR_NONE is always returned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to convert to a well know binary data from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eOrder</span></code>: One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyDstBuffer</span></code>: a buffer into which the binary representation is written. This buffer must be at least <a class="reference internal" href="#ogr__api_8h_1a5f7035a933b957a9d453184c154c237c"><span class="std std-ref">OGR_G_WkbSize()</span></a> byte in size.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_ExportToIsoWkb12OGRGeometryH15OGRwkbByteOrderPh">
<span id="_CPPv320OGR_G_ExportToIsoWkb12OGRGeometryH15OGRwkbByteOrderPh"></span><span id="_CPPv220OGR_G_ExportToIsoWkb12OGRGeometryH15OGRwkbByteOrderPh"></span><span id="OGR_G_ExportToIsoWkb__OGRGeometryH.OGRwkbByteOrder.unsigned-cP"></span><span class="target" id="ogr__api_8h_1a622a18776e6d51515d0f2ff0ee211d91"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_ExportToIsoWkb</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv415OGRwkbByteOrder" title="OGRwkbByteOrder">OGRwkbByteOrder</a> <em>eOrder</em>, unsigned char *<em>pabyDstBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_ExportToIsoWkb12OGRGeometryH15OGRwkbByteOrderPh" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method. It exports the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types.</p>
<p>This function is the same as the CPP method OGRGeometry::exportToWkb(OGRwkbByteOrder, unsigned char *, OGRwkbVariant) with eWkbVariant = wkbVariantIso.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Currently OGRERR_NONE is always returned.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to convert to a well know binary data from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eOrder</span></code>: One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyDstBuffer</span></code>: a buffer into which the binary representation is written. This buffer must be at least <a class="reference internal" href="#ogr__api_8h_1a5f7035a933b957a9d453184c154c237c"><span class="std std-ref">OGR_G_WkbSize()</span></a> byte in size.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_G_WkbSize12OGRGeometryH">
<span id="_CPPv313OGR_G_WkbSize12OGRGeometryH"></span><span id="_CPPv213OGR_G_WkbSize12OGRGeometryH"></span><span id="OGR_G_WkbSize__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a5f7035a933b957a9d453184c154c237c"></span>int <code class="descname">OGR_G_WkbSize</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_G_WkbSize12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns size of related binary representation. </p>
<p>This function returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This function relates to the SFCOM IWks::WkbSize() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1acd1a8164dae2e44e50990756ed6b8b4a"><span class="std std-ref">OGRGeometry::WkbSize()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>size of binary representation in bytes. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to get the binary size from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_ImportFromWkt12OGRGeometryHPPc">
<span id="_CPPv319OGR_G_ImportFromWkt12OGRGeometryHPPc"></span><span id="_CPPv219OGR_G_ImportFromWkt12OGRGeometryHPPc"></span><span id="OGR_G_ImportFromWkt__OGRGeometryH.cPP"></span><span class="target" id="ogr__api_8h_1a4286ba243fb05a831a49f52aabcbc6f8"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_ImportFromWkt</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, char **<em>ppszSrcText</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_ImportFromWkt12OGRGeometryHPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1af1bb0f7cae630c31511766718bcc5b66"><span class="std std-ref">OGRGeometry::importFromWkt()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to assign well know text data to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppszSrcText</span></code>: pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_ExportToWkt12OGRGeometryHPPc">
<span id="_CPPv317OGR_G_ExportToWkt12OGRGeometryHPPc"></span><span id="_CPPv217OGR_G_ExportToWkt12OGRGeometryHPPc"></span><span id="OGR_G_ExportToWkt__OGRGeometryH.cPP"></span><span class="target" id="ogr__api_8h_1a3bc9310302e2dbfaab1690de9e2fd2fb"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_ExportToWkt</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, char **<em>ppszSrcText</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_ExportToWkt12OGRGeometryHPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into well known text format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>For backward compatibility purposes, it exports the Old-style 99-402 extended dimension (Z) WKB types for types Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For other geometry types, it is equivalent to <a class="reference internal" href="#ogr__api_8h_1a0d988d220539479601e1a80a58864d1e"><span class="std std-ref">OGR_G_ExportToIsoWkt()</span></a>.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ad17cfebfd9826a22763dff6280ba196e"><span class="std std-ref">OGRGeometry::exportToWkt()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Currently OGRERR_NONE is always returned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to convert to a text format from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppszSrcText</span></code>: a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="reference internal" href="cpl.html#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_ExportToIsoWkt12OGRGeometryHPPc">
<span id="_CPPv320OGR_G_ExportToIsoWkt12OGRGeometryHPPc"></span><span id="_CPPv220OGR_G_ExportToIsoWkt12OGRGeometryHPPc"></span><span id="OGR_G_ExportToIsoWkt__OGRGeometryH.cPP"></span><span class="target" id="ogr__api_8h_1a0d988d220539479601e1a80a58864d1e"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_ExportToIsoWkt</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, char **<em>ppszSrcText</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_ExportToIsoWkt12OGRGeometryHPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKT() method. It exports the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types.</p>
<p>This function is the same as the CPP method OGRGeometry::exportToWkt(wkbVariantIso).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Currently OGRERR_NONE is always returned.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to convert to a text format from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppszSrcText</span></code>: a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="reference internal" href="cpl.html#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_G_GetGeometryType12OGRGeometryH">
<span id="_CPPv321OGR_G_GetGeometryType12OGRGeometryH"></span><span id="_CPPv221OGR_G_GetGeometryType12OGRGeometryH"></span><span id="OGR_G_GetGeometryType__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a8fae58102f5c4a4cf2526e5ca8369a76"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_G_GetGeometryType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_G_GetGeometryType12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the <a class="reference internal" href="#ogr__core_8h_1a5d2800b1a2d4f4dbcb906390969bb823"><span class="std std-ref">wkbFlatten()</span></a> macro to the return result.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a5c6bca18682cb933e3227552d480e1a5"><span class="std std-ref">OGRGeometry::getGeometryType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the geometry type code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to get type from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_G_GetGeometryName12OGRGeometryH">
<span id="_CPPv321OGR_G_GetGeometryName12OGRGeometryH"></span><span id="_CPPv221OGR_G_GetGeometryName12OGRGeometryH"></span><span id="OGR_G_GetGeometryName__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a18121f835b2fb724a0c1a87beb1a437a"></span><em class="property">const</em> char *<code class="descname">OGR_G_GetGeometryName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_G_GetGeometryName12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this function.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aba109e1c53ce1452942f85eae66d88b8"><span class="std std-ref">OGRGeometry::getGeometryName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>name used for this geometry type in well known text format. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to get name from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_G_DumpReadable12OGRGeometryHP4FILEPKc">
<span id="_CPPv318OGR_G_DumpReadable12OGRGeometryHP4FILEPKc"></span><span id="_CPPv218OGR_G_DumpReadable12OGRGeometryHP4FILEPKc"></span><span id="OGR_G_DumpReadable__OGRGeometryH.FILEP.cCP"></span><span class="target" id="ogr__api_8h_1a3a99330bd108940f8a33036c0f83119f"></span>void <code class="descname">OGR_G_DumpReadable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, FILE *<em>fp</em>, <em class="property">const</em> char *<em>pszPrefix</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_G_DumpReadable12OGRGeometryHP4FILEPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dump geometry in well known text format to indicated output file. </p>
<p>This method is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a846513c8437824899bcc6059f5070a23"><span class="std std-ref">OGRGeometry::dumpReadable</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to dump. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fp</span></code>: the text file to write the geometry to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszPrefix</span></code>: the prefix to put on each line of output. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_FlattenTo2D12OGRGeometryH">
<span id="_CPPv317OGR_G_FlattenTo2D12OGRGeometryH"></span><span id="_CPPv217OGR_G_FlattenTo2D12OGRGeometryH"></span><span id="OGR_G_FlattenTo2D__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1afdb7354b55c7448b60b44cd9e36073b8"></span>void <code class="descname">OGR_G_FlattenTo2D</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_FlattenTo2D12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert geometry to strictly 2D. </p>
<p>In a sense this converts all Z coordinates to 0.0.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aaae1a2ced937a5900b2bfeb717bad6c9"><span class="std std-ref">OGRGeometry::flattenTo2D()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to convert. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_CloseRings12OGRGeometryH">
<span id="_CPPv316OGR_G_CloseRings12OGRGeometryH"></span><span id="_CPPv216OGR_G_CloseRings12OGRGeometryH"></span><span id="OGR_G_CloseRings__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1acfeb849dcfd4fdf4d6dab66e6ea697c0"></span>void <code class="descname">OGR_G_CloseRings</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_CloseRings12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_CreateFromGMLPKc">
<span id="_CPPv319OGR_G_CreateFromGMLPKc"></span><span id="_CPPv219OGR_G_CreateFromGMLPKc"></span><span id="OGR_G_CreateFromGML__cCP"></span><span class="target" id="ogr__api_8h_1a216201a5f821e553bd484d6953fa2ffb"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_CreateFromGML</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszGML</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_CreateFromGMLPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create geometry from GML. </p>
<p>This method translates a fragment of GML containing only the geometry portion into a corresponding <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry"><span class="std std-ref">OGRGeometry</span></a>. There are many limitations on the forms of GML geometries supported by this parser, but they are too numerous to list here.</p>
<p>The following GML2 elements are parsed : Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.</p>
<p>(OGR &gt;= 1.8.0) The following GML3 elements are parsed : Surface, MultiSurface, PolygonPatch, Triangle, Rectangle, Curve, MultiCurve, CompositeCurve, LineStringSegment, Arc, Circle, CompositeSurface, OrientableSurface, Solid, Tin, TriangulatedSurface.</p>
<p>Arc and Circle elements are stroked to linestring, by using a 4 degrees step, unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>The C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1af8714df4e6b6c5d5b2cdbdeec78af08c"><span class="std std-ref">OGRGeometryFactory::createFromGML()</span></a> is the same as this function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a geometry on success, or NULL on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszGML</span></code>: The GML fragment for the geometry.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_ExportToGML12OGRGeometryH">
<span id="_CPPv317OGR_G_ExportToGML12OGRGeometryH"></span><span id="_CPPv217OGR_G_ExportToGML12OGRGeometryH"></span><span id="OGR_G_ExportToGML__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ac0cde7d88247415bf2d015b312ebb00d"></span>char *<code class="descname">OGR_G_ExportToGML</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeometry</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_ExportToGML12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="reference internal" href="cpl.html#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1abbd63002f416db1ea0eb24857b5ef9f2"><span class="std std-ref">OGRGeometry::exportToGML()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A GML fragment or NULL in case of error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeometry</span></code>: handle to the geometry. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_ExportToGMLEx12OGRGeometryHPPc">
<span id="_CPPv319OGR_G_ExportToGMLEx12OGRGeometryHPPc"></span><span id="_CPPv219OGR_G_ExportToGMLEx12OGRGeometryHPPc"></span><span id="OGR_G_ExportToGMLEx__OGRGeometryH.cPP"></span><span class="target" id="ogr__api_8h_1ab95226e12c2de1cdd2837c1ca15366fd"></span>char *<code class="descname">OGR_G_ExportToGMLEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeometry</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_ExportToGMLEx12OGRGeometryHPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="reference internal" href="cpl.html#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer required.</p>
<p>The supported options are : <ul>
<li><p>FORMAT=GML2/GML3/GML32 (GML2 or GML32 added in GDAL 2.1). If not set, it will default to GML 2.1.2 output. </p></li>
<li><p>GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used . </p></li>
<li><p>GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3, deprecated by SRSNAME_FORMAT in GDAL &gt;=2.2). Defaults to YES. If YES, SRS with EPSG authority will be written with the “urn:ogc:def:crs:EPSG::” prefix. In the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it. If set to NO, SRS with EPSG authority will be written with the “EPSG:” prefix, even if they are in lat/long order. </p></li>
<li><p>SRSNAME_FORMAT=SHORT/OGC_URN/OGC_URL (Only valid for FORMAT=GML3, added in GDAL 2.2). Defaults to OGC_URN. If SHORT, then srsName will be in the form AUTHORITY_NAME:AUTHORITY_CODE. If OGC_URN, then srsName will be in the form urn:ogc:def:crs:AUTHORITY_NAME::AUTHORITY_CODE. If OGC_URL, then srsName will be in the form <a class="reference external" href="http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE">http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE</a>. For OGC_URN and OGC_URL, in the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it. </p></li>
<li><p>GMLID=astring. If specified, a gml:id attribute will be written in the top-level geometry element with the provided value. Required for GML 3.2 compatibility. </p></li>
<li><p>SRSDIMENSION_LOC=POSLIST/GEOMETRY/GEOMETRY,POSLIST. (Only valid for FORMAT=GML3/GML32, GDAL &gt;= 2.0) Default to POSLIST. For 2.5D geometries, define the location where to attach the srsDimension attribute. There are diverging implementations. Some put in on the &lt;gml:posList&gt; element, other on the top geometry element.</p>
<p></p>
</li>
<li><p>NAMESPACE_DECL=YES/NO. If set to YES, xmlns:gml=”http://www.opengis.net/gml” will be added to the root node for GML &lt; 3.2 or xmlns:gml=”http://www.opengis.net/gml/3.2” for GML 3.2 </p></li>
</ul>
</p>
<p>Note that curve geometries like CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE are not supported in GML 2.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1abbd63002f416db1ea0eb24857b5ef9f2"><span class="std std-ref">OGRGeometry::exportToGML()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A GML fragment or NULL in case of error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeometry</span></code>: handle to the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL-terminated list of options. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_G_CreateFromGMLTreePK10CPLXMLNode">
<span id="_CPPv323OGR_G_CreateFromGMLTreePK10CPLXMLNode"></span><span id="_CPPv223OGR_G_CreateFromGMLTreePK10CPLXMLNode"></span><span id="OGR_G_CreateFromGMLTree__CPLXMLNodeCP"></span><span class="target" id="ogr__api_8h_1a38986cd8e7e609cbce2fb0e7e5d75491"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_CreateFromGMLTree</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="cpl.html#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_G_CreateFromGMLTreePK10CPLXMLNode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create geometry from GML. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_G_ExportToGMLTree12OGRGeometryH">
<span id="_CPPv321OGR_G_ExportToGMLTree12OGRGeometryH"></span><span id="_CPPv221OGR_G_ExportToGMLTree12OGRGeometryH"></span><span id="OGR_G_ExportToGMLTree__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a556102dd03db654301035ad5ed1e14ac"></span><a class="reference internal" href="cpl.html#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">OGR_G_ExportToGMLTree</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeometry</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_G_ExportToGMLTree12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into GML format. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429OGR_G_ExportEnvelopeToGMLTree12OGRGeometryH">
<span id="_CPPv329OGR_G_ExportEnvelopeToGMLTree12OGRGeometryH"></span><span id="_CPPv229OGR_G_ExportEnvelopeToGMLTree12OGRGeometryH"></span><span id="OGR_G_ExportEnvelopeToGMLTree__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ad273f59c62bc1354fb5d1b3758622955"></span><a class="reference internal" href="cpl.html#_CPPv410CPLXMLNode" title="CPLXMLNode">CPLXMLNode</a> *<code class="descname">OGR_G_ExportEnvelopeToGMLTree</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeometry</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429OGR_G_ExportEnvelopeToGMLTree12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Export the envelope of a geometry as a gml:Box. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_ExportToKML12OGRGeometryHPKc">
<span id="_CPPv317OGR_G_ExportToKML12OGRGeometryHPKc"></span><span id="_CPPv217OGR_G_ExportToKML12OGRGeometryHPKc"></span><span id="OGR_G_ExportToKML__OGRGeometryH.cCP"></span><span class="target" id="ogr__api_8h_1a5a2d35d3f6f10b4ca936a40a76d70d20"></span>char *<code class="descname">OGR_G_ExportToKML</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeometry</em>, <em class="property">const</em> char *<em>pszAltitudeMode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_ExportToKML12OGRGeometryHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with <a class="reference internal" href="cpl.html#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ab73487475ea43a2e677fe0556bf738e0"><span class="std std-ref">OGRGeometry::exportToKML()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A KML fragment or NULL in case of error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeometry</span></code>: handle to the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszAltitudeMode</span></code>: value to write in altitudeMode element, or NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_G_ExportToJson12OGRGeometryH">
<span id="_CPPv318OGR_G_ExportToJson12OGRGeometryH"></span><span id="_CPPv218OGR_G_ExportToJson12OGRGeometryH"></span><span id="OGR_G_ExportToJson__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1aaf6d95725bd9fdb110b42d3c2749dd38"></span>char *<code class="descname">OGR_G_ExportToJson</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeometry</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_G_ExportToJson12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="reference internal" href="cpl.html#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a7ae299ed972272fef0caea9d1949e98f"><span class="std std-ref">OGRGeometry::exportToJson()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A GeoJSON fragment or NULL in case of error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeometry</span></code>: handle to the geometry. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_ExportToJsonEx12OGRGeometryHPPc">
<span id="_CPPv320OGR_G_ExportToJsonEx12OGRGeometryHPPc"></span><span id="_CPPv220OGR_G_ExportToJsonEx12OGRGeometryHPPc"></span><span id="OGR_G_ExportToJsonEx__OGRGeometryH.cPP"></span><span class="target" id="ogr__api_8h_1a9e034548ba5f4c24d6fe72688e26f5ef"></span>char *<code class="descname">OGR_G_ExportToJsonEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeometry</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_ExportToJsonEx12OGRGeometryHPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="reference internal" href="cpl.html#cpl__conv_8h_1a21b7f312da39ddb0a12bdde06b153b48"><span class="std std-ref">CPLFree()</span></a> when no longer required.</p>
<p>The following options are supported : <ul class="simple">
<li><p>COORDINATE_PRECISION=number: maximum number of figures after decimal separator to write in coordinates. </p></li>
<li><p>SIGNIFICANT_FIGURES=number: maximum number of significant figures (GDAL &gt;= 2.1). </p></li>
</ul>
</p>
<p>If COORDINATE_PRECISION is defined, SIGNIFICANT_FIGURES will be ignored if specified. When none are defined, the default is COORDINATE_PRECISION=15.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a7ae299ed972272fef0caea9d1949e98f"><span class="std std-ref">OGRGeometry::exportToJson()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A GeoJSON fragment or NULL in case of error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeometry</span></code>: handle to the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: a null terminated list of options. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_G_CreateGeometryFromJsonPKc">
<span id="_CPPv328OGR_G_CreateGeometryFromJsonPKc"></span><span id="_CPPv228OGR_G_CreateGeometryFromJsonPKc"></span><span id="OGR_G_CreateGeometryFromJson__cCP"></span><span class="target" id="ogr__api_8h_1adc681c6889a63a01baa301f1e3566c7c"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_CreateGeometryFromJson</code><span class="sig-paren">(</span><em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_G_CreateGeometryFromJsonPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a OGR geometry from a GeoJSON geometry object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432OGR_G_CreateGeometryFromEsriJsonPKc">
<span id="_CPPv332OGR_G_CreateGeometryFromEsriJsonPKc"></span><span id="_CPPv232OGR_G_CreateGeometryFromEsriJsonPKc"></span><span id="OGR_G_CreateGeometryFromEsriJson__cCP"></span><span class="target" id="ogr__api_8h_1ae9d26550bbb5c23f6fff32b03a7c6bef"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_CreateGeometryFromEsriJson</code><span class="sig-paren">(</span><em class="property">const</em> char *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432OGR_G_CreateGeometryFromEsriJsonPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a OGR geometry from a ESRI JSON geometry object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_G_AssignSpatialReference12OGRGeometryH20OGRSpatialReferenceH">
<span id="_CPPv328OGR_G_AssignSpatialReference12OGRGeometryH20OGRSpatialReferenceH"></span><span id="_CPPv228OGR_G_AssignSpatialReference12OGRGeometryH20OGRSpatialReferenceH"></span><span id="OGR_G_AssignSpatialReference__OGRGeometryH.OGRSpatialReferenceH"></span><span class="target" id="ogr__api_8h_1a4dfbd5861e1cd20b372d090539fa4536"></span>void <code class="descname">OGR_G_AssignSpatialReference</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSRS</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_G_AssignSpatialReference12OGRGeometryH20OGRSpatialReferenceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="reference internal" href="ogrspatialref.html#classOGRSpatialReference"><span class="std std-ref">OGRSpatialReference</span></a>, but does not copy it.</p>
<p>Starting with GDAL 2.3, this will also assign the spatial reference to potential sub-geometries of the geometry (<a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection"><span class="std std-ref">OGRGeometryCollection</span></a>, OGRCurvePolygon/OGRPolygon, OGRCompoundCurve, <a class="reference internal" href="ogrgeometry_cpp.html#classOGRPolyhedralSurface"><span class="std std-ref">OGRPolyhedralSurface</span></a> and their derived classes).</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a4308e3549c65aa12cc2ba41be15d99a0"><span class="std std-ref">OGRGeometry::assignSpatialReference</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to apply the new spatial reference system. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSRS</span></code>: handle on the new spatial reference system to apply. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_G_GetSpatialReference12OGRGeometryH">
<span id="_CPPv325OGR_G_GetSpatialReference12OGRGeometryH"></span><span id="_CPPv225OGR_G_GetSpatialReference12OGRGeometryH"></span><span id="OGR_G_GetSpatialReference__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1abc393e40282eec3801fb4a4abc9e25bf"></span><a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <code class="descname">OGR_G_GetSpatialReference</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_G_GetSpatialReference12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns spatial reference system for geometry. </p>
<p>This function relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a66a53c103e37c6d1ead00d2d74586ddd"><span class="std std-ref">OGRGeometry::getSpatialReference()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a reference to the spatial reference geometry. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to get spatial reference from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_G_Transform12OGRGeometryH28OGRCoordinateTransformationH">
<span id="_CPPv315OGR_G_Transform12OGRGeometryH28OGRCoordinateTransformationH"></span><span id="_CPPv215OGR_G_Transform12OGRGeometryH28OGRCoordinateTransformationH"></span><span id="OGR_G_Transform__OGRGeometryH.OGRCoordinateTransformationH"></span><span class="target" id="ogr__api_8h_1a59a5b3f954b11cfbf6e78807c28d6090"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_Transform</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv428OGRCoordinateTransformationH" title="OGRCoordinateTransformationH">OGRCoordinateTransformationH</a> <em>hTransform</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_G_Transform12OGRGeometryH28OGRCoordinateTransformationH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this function does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="reference internal" href="ogrspatialref.html#classOGRCoordinateTransformation"><span class="std std-ref">OGRCoordinateTransformation</span></a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="reference internal" href="ogrspatialref.html#classOGRSpatialReference"><span class="std std-ref">OGRSpatialReference</span></a> of the <a class="reference internal" href="ogrspatialref.html#classOGRCoordinateTransformation"><span class="std std-ref">OGRCoordinateTransformation</span></a> will be assigned to the geometry.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aa9e8bfb3c2129f25cf622660f734e1ba"><span class="std std-ref">OGRGeometry::transform</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success or an error code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to apply the transform to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hTransform</span></code>: handle on the transformation to apply.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_TransformTo12OGRGeometryH20OGRSpatialReferenceH">
<span id="_CPPv317OGR_G_TransformTo12OGRGeometryH20OGRSpatialReferenceH"></span><span id="_CPPv217OGR_G_TransformTo12OGRGeometryH20OGRSpatialReferenceH"></span><span id="OGR_G_TransformTo__OGRGeometryH.OGRSpatialReferenceH"></span><span class="target" id="ogr__api_8h_1a43af4c2127cea0a5059692a62c0feb63"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_TransformTo</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSRS</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_TransformTo12OGRGeometryH20OGRSpatialReferenceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transform geometry to new spatial reference system. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This function will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this function requires internal creation and initialization of an <a class="reference internal" href="ogrspatialref.html#classOGRCoordinateTransformation"><span class="std std-ref">OGRCoordinateTransformation</span></a> object it is significantly more expensive to use this function to transform many geometries than it is to create the <a class="reference internal" href="ogrspatialref.html#classOGRCoordinateTransformation"><span class="std std-ref">OGRCoordinateTransformation</span></a> in advance, and call transform() with that transformation. This function exists primarily for convenience when only transforming a single geometry.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ae3f0b441fbf2f66ce3ef3571268ab10f"><span class="std std-ref">OGRGeometry::transformTo</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success, or an error code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to apply the transform to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSRS</span></code>: handle on the spatial reference system to apply.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_GeomTransformer_Create28OGRCoordinateTransformationH12CSLConstList">
<span id="_CPPv326OGR_GeomTransformer_Create28OGRCoordinateTransformationH12CSLConstList"></span><span id="_CPPv226OGR_GeomTransformer_Create28OGRCoordinateTransformationH12CSLConstList"></span><span id="OGR_GeomTransformer_Create__OGRCoordinateTransformationH.CSLConstList"></span><span class="target" id="ogr__api_8h_1adcc3ea8bd6aeffdbe26bbc519cc16882"></span><a class="reference internal" href="#_CPPv419OGRGeomTransformerH" title="OGRGeomTransformerH">OGRGeomTransformerH</a> <code class="descname">OGR_GeomTransformer_Create</code><span class="sig-paren">(</span><a class="reference internal" href="ogr_srs_api.html#_CPPv428OGRCoordinateTransformationH" title="OGRCoordinateTransformationH">OGRCoordinateTransformationH</a> <em>hCT</em>, <a class="reference internal" href="cpl.html#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_GeomTransformer_Create28OGRCoordinateTransformationH12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a geometry transformer. </p>
<p>This is a enhanced version of <a class="reference internal" href="#ogr__api_8h_1a59a5b3f954b11cfbf6e78807c28d6090"><span class="std std-ref">OGR_G_Transform()</span></a>.</p>
<p>When reprojecting geometries from a Polar Stereographic projection or a projection naturally crossing the antimeridian (like UTM Zone 60) to a geographic CRS, it will cut geometries along the antimeridian. So a LineString might be returned as a MultiLineString.</p>
<p>The WRAPDATELINE=YES option might be specified for circumstances to correct geometries that incorrectly go from a longitude on a side of the antimeridian to the other side, like a LINESTRING(-179 0,179 0) will be transformed to a MULTILINESTRING ((-179 0,-180 0),(180 0,179 0)). For that use case, hCT might be NULL.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>transformer object to free with <a class="reference internal" href="#ogr__api_8h_1ae5729c801d758baee9dc23b95ac80f55"><span class="std std-ref">OGR_GeomTransformer_Destroy()</span></a> </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hCT</span></code>: Coordinate transformation object (will be cloned) or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options, or NULL. Supported options are: <ul>
<li><p>WRAPDATELINE=YES </p></li>
<li><p>DATELINEOFFSET=longitude_gap_in_degree. Defaults to 10. </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429OGR_GeomTransformer_Transform19OGRGeomTransformerH12OGRGeometryH">
<span id="_CPPv329OGR_GeomTransformer_Transform19OGRGeomTransformerH12OGRGeometryH"></span><span id="_CPPv229OGR_GeomTransformer_Transform19OGRGeomTransformerH12OGRGeometryH"></span><span id="OGR_GeomTransformer_Transform__OGRGeomTransformerH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1aed5ac945d4635e074c7e09816ea13efe"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_GeomTransformer_Transform</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419OGRGeomTransformerH" title="OGRGeomTransformerH">OGRGeomTransformerH</a> <em>hTransformer</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429OGR_GeomTransformer_Transform19OGRGeomTransformerH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transforms a geometry. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry (or NULL) to destroy with <a class="reference internal" href="#ogr__api_8h_1ac4e665f5f9690c4fa0c190b930fe9492"><span class="std std-ref">OGR_G_DestroyGeometry()</span></a> </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTransformer</span></code>: transformer object. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: Source geometry. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427OGR_GeomTransformer_Destroy19OGRGeomTransformerH">
<span id="_CPPv327OGR_GeomTransformer_Destroy19OGRGeomTransformerH"></span><span id="_CPPv227OGR_GeomTransformer_Destroy19OGRGeomTransformerH"></span><span id="OGR_GeomTransformer_Destroy__OGRGeomTransformerH"></span><span class="target" id="ogr__api_8h_1ae5729c801d758baee9dc23b95ac80f55"></span>void <code class="descname">OGR_GeomTransformer_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419OGRGeomTransformerH" title="OGRGeomTransformerH">OGRGeomTransformerH</a> <em>hTransformer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427OGR_GeomTransformer_Destroy19OGRGeomTransformerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy a geometry transformer allocated with <a class="reference internal" href="#ogr__api_8h_1adcc3ea8bd6aeffdbe26bbc519cc16882"><span class="std std-ref">OGR_GeomTransformer_Create()</span></a> </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTransformer</span></code>: transformer object. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_Simplify12OGRGeometryHd">
<span id="_CPPv314OGR_G_Simplify12OGRGeometryHd"></span><span id="_CPPv214OGR_G_Simplify12OGRGeometryHd"></span><span id="OGR_G_Simplify__OGRGeometryH.double"></span><span class="target" id="ogr__api_8h_1ae7727c1e3f1aea8740020a75d150b09c"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Simplify</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, double <em>tolerance</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_Simplify12OGRGeometryHd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute a simplified geometry. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1acf92969a640cdd29c4c4eaacc95e6093"><span class="std std-ref">OGRGeometry::Simplify()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the simplified geometry or NULL if an error occurs.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dTolerance</span></code>: the distance tolerance for the simplification.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430OGR_G_SimplifyPreserveTopology12OGRGeometryHd">
<span id="_CPPv330OGR_G_SimplifyPreserveTopology12OGRGeometryHd"></span><span id="_CPPv230OGR_G_SimplifyPreserveTopology12OGRGeometryHd"></span><span id="OGR_G_SimplifyPreserveTopology__OGRGeometryH.double"></span><span class="target" id="ogr__api_8h_1a2393494229046406871c38e58ffaf156"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_SimplifyPreserveTopology</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, double <em>tolerance</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430OGR_G_SimplifyPreserveTopology12OGRGeometryHd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a0f4d7948332d9efd6548e1cf87bb6c8f"><span class="std std-ref">OGRGeometry::SimplifyPreserveTopology()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the simplified geometry or NULL if an error occurs.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dTolerance</span></code>: the distance tolerance for the simplification.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427OGR_G_DelaunayTriangulation12OGRGeometryHdi">
<span id="_CPPv327OGR_G_DelaunayTriangulation12OGRGeometryHdi"></span><span id="_CPPv227OGR_G_DelaunayTriangulation12OGRGeometryHdi"></span><span id="OGR_G_DelaunayTriangulation__OGRGeometryH.double.i"></span><span class="target" id="ogr__api_8h_1a8fff3faa236d12e0374f5c65f61972ae"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_DelaunayTriangulation</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, double <em>dfTolerance</em>, int <em>bOnlyEdges</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427OGR_G_DelaunayTriangulation12OGRGeometryHdi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a Delaunay triangulation of the vertices of the geometry. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ab7d3c3e5b033ca6bbb470016e7661da7"><span class="std std-ref">OGRGeometry::DelaunayTriangulation()</span></a>.</p>
<p>This function is built on the GEOS library, v3.4 or above. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the geometry resulting from the Delaunay triangulation or NULL if an error occurs.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfTolerance</span></code>: optional snapping tolerance to use for improved robustness </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bOnlyEdges</span></code>: if TRUE, will return a MULTILINESTRING, otherwise it will return a GEOMETRYCOLLECTION containing triangular POLYGONs.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_Segmentize12OGRGeometryHd">
<span id="_CPPv316OGR_G_Segmentize12OGRGeometryHd"></span><span id="_CPPv216OGR_G_Segmentize12OGRGeometryHd"></span><span id="OGR_G_Segmentize__OGRGeometryH.double"></span><span class="target" id="ogr__api_8h_1ade9f08c8d63bc0e726cb20c201c86423"></span>void <code class="descname">OGR_G_Segmentize</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, double <em>dfMaxLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_Segmentize12OGRGeometryHd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a91685bd7c0bdd67cd073a8b4da3c06a5"><span class="std std-ref">OGRGeometry::segmentize()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to segmentize </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxLength</span></code>: the maximum distance between 2 points after segmentization </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_Intersects12OGRGeometryH12OGRGeometryH">
<span id="_CPPv316OGR_G_Intersects12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv216OGR_G_Intersects12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Intersects__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1acaed6926b75cd33a42b284c10def6e87"></span>int <code class="descname">OGR_G_Intersects</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOtherGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_Intersects12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Do these features intersect? </p>
<p>Determines whether two geometries intersect. If GEOS is enabled, then this is done in rigorous fashion otherwise TRUE is returned if the envelopes (bounding boxes) of the two geometries overlap.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a12b9bf1e607908703d68bcdd5a82440c"><span class="std std-ref">OGRGeometry::Intersects</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometries intersect, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the first geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOtherGeom</span></code>: handle on the other geometry to test against.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_G_Equals12OGRGeometryH12OGRGeometryH">
<span id="_CPPv312OGR_G_Equals12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv212OGR_G_Equals12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Equals__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1abaed0c4fb6f08abc280f91619e2e47d3"></span>int <code class="descname">OGR_G_Equals</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_G_Equals12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns TRUE if two geometries are equivalent. </p>
<p>This operation implements the SQL/MM ST_OrderingEquals() operation.</p>
<p>The comparison is done in a structural way, that is to say that the geometry types must be identical, as well as the number and ordering of sub-geometries and vertices. Or equivalently, two geometries are considered equal by this method if their WKT/WKB representation is equal. Note: this must be distinguished for equality in a spatial way (which is the purpose of the ST_Equals() operation).</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a1b80c7f464de1d332215f16d35138590"><span class="std std-ref">OGRGeometry::Equals()</span></a> method.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if equivalent or FALSE otherwise. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the first geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: handle on the other geometry to test against. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_Disjoint12OGRGeometryH12OGRGeometryH">
<span id="_CPPv314OGR_G_Disjoint12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv214OGR_G_Disjoint12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Disjoint__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a7980d65f3d82d5a5442c5141efe3f503"></span>int <code class="descname">OGR_G_Disjoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_Disjoint12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for disjointness. </p>
<p>Tests if this geometry and the other geometry are disjoint.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aaa4f0b34b165b589ffbef7d3ea65c00c"><span class="std std-ref">OGRGeometry::Disjoint()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if they are disjoint, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry to compare. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_G_Touches12OGRGeometryH12OGRGeometryH">
<span id="_CPPv313OGR_G_Touches12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv213OGR_G_Touches12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Touches__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a6f67616eb88f479eba50f9783c8494d9"></span>int <code class="descname">OGR_G_Touches</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_G_Touches12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for touching. </p>
<p>Tests if this geometry and the other geometry are touching.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1abd1be78538ab56a7c16cfa65797eeb0c"><span class="std std-ref">OGRGeometry::Touches()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if they are touching, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry to compare. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_G_Crosses12OGRGeometryH12OGRGeometryH">
<span id="_CPPv313OGR_G_Crosses12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv213OGR_G_Crosses12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Crosses__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a7af82e14406879c08841331b2a4cfe7c"></span>int <code class="descname">OGR_G_Crosses</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_G_Crosses12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for crossing. </p>
<p>Tests if this geometry and the other geometry are crossing.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1adf30cb59307e8d5889e9fcf71d371afb"><span class="std std-ref">OGRGeometry::Crosses()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if they are crossing, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry to compare. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_G_Within12OGRGeometryH12OGRGeometryH">
<span id="_CPPv312OGR_G_Within12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv212OGR_G_Within12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Within__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a80ba9e516ccae381ae7240cc9684eb72"></span>int <code class="descname">OGR_G_Within</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_G_Within12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for containment. </p>
<p>Tests if this geometry is within the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a9803164ead0c4fbea9eafce64184160c"><span class="std std-ref">OGRGeometry::Within()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if hThis is within hOther, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry to compare. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_Contains12OGRGeometryH12OGRGeometryH">
<span id="_CPPv314OGR_G_Contains12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv214OGR_G_Contains12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Contains__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ad87e37380f0320faddbe5e67e23312f8"></span>int <code class="descname">OGR_G_Contains</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_Contains12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for containment. </p>
<p>Tests if this geometry contains the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ae818178178f80c2987c6173ab4da041e"><span class="std std-ref">OGRGeometry::Contains()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if hThis contains hOther geometry, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry to compare. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_Overlaps12OGRGeometryH12OGRGeometryH">
<span id="_CPPv314OGR_G_Overlaps12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv214OGR_G_Overlaps12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Overlaps__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a07acfe1bef39cd2cd1ad4a5ec26f2ceb"></span>int <code class="descname">OGR_G_Overlaps</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_Overlaps12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test for overlap. </p>
<p>Tests if this geometry and the other geometry overlap, that is their intersection has a non-zero area.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a432b89868f8094004467e8e9b51ad5ca"><span class="std std-ref">OGRGeometry::Overlaps()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if they are overlapping, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry to compare. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_Boundary12OGRGeometryH">
<span id="_CPPv314OGR_G_Boundary12OGRGeometryH"></span><span id="_CPPv214OGR_G_Boundary12OGRGeometryH"></span><span id="OGR_G_Boundary__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a88e2ce6b8ad4347fa8bdbb1cdc0ad272"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Boundary</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_Boundary12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="#ogr__api_8h_1a88e2ce6b8ad4347fa8bdbb1cdc0ad272"><span class="std std-ref">OGR_G_Boundary()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTarget</span></code>: The Geometry to calculate the boundary of.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_ConvexHull12OGRGeometryH">
<span id="_CPPv316OGR_G_ConvexHull12OGRGeometryH"></span><span id="_CPPv216OGR_G_ConvexHull12OGRGeometryH"></span><span id="OGR_G_ConvexHull__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ad5408cae52870b2d162f166f42cd684b"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_ConvexHull</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_ConvexHull12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a94d1ef564a0423a7619b2acc61cdc0dd"><span class="std std-ref">OGRGeometry::ConvexHull()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to a newly allocated geometry now owned by the caller, or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTarget</span></code>: The Geometry to calculate the convex hull of.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_G_Buffer12OGRGeometryHdi">
<span id="_CPPv312OGR_G_Buffer12OGRGeometryHdi"></span><span id="_CPPv212OGR_G_Buffer12OGRGeometryHdi"></span><span id="OGR_G_Buffer__OGRGeometryH.double.i"></span><span class="target" id="ogr__api_8h_1a650366258bd4aa2a5a5e55966299cfc1"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Buffer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hTarget</em>, double <em>dfDist</em>, int <em>nQuadSegs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_G_Buffer12OGRGeometryHdi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segments should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1af1b450af88d10c763e5fb86e056fb307"><span class="std std-ref">OGRGeometry::Buffer()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the newly created geometry, or NULL if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTarget</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfDist</span></code>: the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nQuadSegs</span></code>: the number of segments used to approximate a 90 degree (quadrant) of curvature.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_G_Intersection12OGRGeometryH12OGRGeometryH">
<span id="_CPPv318OGR_G_Intersection12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv218OGR_G_Intersection12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Intersection__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a96d73915584c997f9bd79c8940379578"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Intersection</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_G_Intersection12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="reference internal" href="#ogr__api_8h_1acaed6926b75cd33a42b284c10def6e87"><span class="std std-ref">OGR_G_Intersects()</span></a> function can be used to test if two geometries intersect.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a83adb426e79958c90aecb418d91c765c"><span class="std std-ref">OGRGeometry::Intersection()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_G_Union12OGRGeometryH12OGRGeometryH">
<span id="_CPPv311OGR_G_Union12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv211OGR_G_Union12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Union__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a59a695a0e26f4992ba58d79eac92ed25"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Union</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_G_Union12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a939bb2b738337a3af1fc715187822171"><span class="std std-ref">OGRGeometry::Union()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry representing the union or NULL if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_UnionCascaded12OGRGeometryH">
<span id="_CPPv319OGR_G_UnionCascaded12OGRGeometryH"></span><span id="_CPPv219OGR_G_UnionCascaded12OGRGeometryH"></span><span id="OGR_G_UnionCascaded__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ad6a2be7e6f0e16a18df2d0d54f55554f"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_UnionCascaded</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_UnionCascaded12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute union using cascading. </p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a3413bfa82a0afc6b5fa77fafa3933549"><span class="std std-ref">OGRGeometry::UnionCascaded()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry representing the union or NULL if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_PointOnSurface12OGRGeometryH">
<span id="_CPPv320OGR_G_PointOnSurface12OGRGeometryH"></span><span id="_CPPv220OGR_G_PointOnSurface12OGRGeometryH"></span><span id="OGR_G_PointOnSurface__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a1b43b2b0a38c1d63d785c37b392dc9ec"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_PointOnSurface</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_PointOnSurface12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a point guaranteed to lie on the surface. </p>
<p>This method relates to the SFCOM ISurface::get_PointOnSurface() method however the current implementation based on GEOS can operate on other geometry types than the types that are supported by SQL/MM-Part 3 : surfaces (polygons) and multisurfaces (multipolygons).</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a point guaranteed to lie on the surface or NULL if an error occurred.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the geometry to operate on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_Difference12OGRGeometryH12OGRGeometryH">
<span id="_CPPv316OGR_G_Difference12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv216OGR_G_Difference12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Difference__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a6e4a22abdb38514237f13828dc1a987f"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Difference</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_Difference12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the other geometry removed.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a817c860c39a7b2848f0ff2105faaa25a"><span class="std std-ref">OGRGeometry::Difference()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_SymDifference12OGRGeometryH12OGRGeometryH">
<span id="_CPPv319OGR_G_SymDifference12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv219OGR_G_SymDifference12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_SymDifference__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1af59305c5838b6118e2d3f57f919ae666"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_SymDifference</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hThis</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_SymDifference12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method OGRGeometry::SymmetricDifference().</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hThis</span></code>: the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_Distance12OGRGeometryH12OGRGeometryH">
<span id="_CPPv314OGR_G_Distance12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv214OGR_G_Distance12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Distance__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ab01002a9fd4175832af965930f069401"></span>double <code class="descname">OGR_G_Distance</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hFirst</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_Distance12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a72e832f8dc1001de35e9e888a4bae8b3"><span class="std std-ref">OGRGeometry::Distance()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the distance between the geometries or -1 if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFirst</span></code>: the first geometry to compare against. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare against.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_Distance3D12OGRGeometryH12OGRGeometryH">
<span id="_CPPv316OGR_G_Distance3D12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv216OGR_G_Distance3D12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Distance3D__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a7313a805a15bf78a26c52ff1bc6242e2"></span>double <code class="descname">OGR_G_Distance3D</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hFirst</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hOther</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_Distance3D12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the 3D distance between two geometries. </p>
<p>The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is built on the SFCGAL library, check it for the definition of the geometry operation. If OGR is built without the SFCGAL library, this method will always return -1.0</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aa2e39301afc475f5fff022af690fcf84"><span class="std std-ref">OGRGeometry::Distance3D()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>distance between the two geometries </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>the distance between the geometries or -1 if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFirst</span></code>: the first geometry to compare against. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOther</span></code>: the other geometry to compare against. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_G_Length12OGRGeometryH">
<span id="_CPPv312OGR_G_Length12OGRGeometryH"></span><span id="_CPPv212OGR_G_Length12OGRGeometryH"></span><span id="OGR_G_Length__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a5eb038c3271dbf41ac7ebc02fad3907f"></span>double <code class="descname">OGR_G_Length</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_G_Length12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute length of a geometry. </p>
<p>Computes the length for <a class="reference internal" href="ogrgeometry_cpp.html#classOGRCurve"><span class="std std-ref">OGRCurve</span></a> or MultiCurve objects. Undefined for all other geometry types (returns zero).</p>
<p>This function utilizes the C++ get_Length() method.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the length or 0.0 for unsupported geometry types.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the geometry to operate on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_G_Area12OGRGeometryH">
<span id="_CPPv310OGR_G_Area12OGRGeometryH"></span><span id="_CPPv210OGR_G_Area12OGRGeometryH"></span><span id="OGR_G_Area__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a2a849c584cd22a199bcfb9b34b9a1a8f"></span>double <code class="descname">OGR_G_Area</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_G_Area12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute geometry area. </p>
<p>Computes the area for an <a class="reference internal" href="ogrgeometry_cpp.html#classOGRLinearRing"><span class="std std-ref">OGRLinearRing</span></a>, <a class="reference internal" href="ogrgeometry_cpp.html#classOGRPolygon"><span class="std std-ref">OGRPolygon</span></a> or <a class="reference internal" href="ogrgeometry_cpp.html#classOGRMultiPolygon"><span class="std std-ref">OGRMultiPolygon</span></a>. Undefined for all other geometry types (returns zero).</p>
<p>This function utilizes the C++ get_Area() methods such as <a class="reference internal" href="ogrgeometry_cpp.html#classOGRCurvePolygon_1a6159cf2c28cd236ad2aa593c005c473a"><span class="std std-ref">OGRPolygon::get_Area()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the area or 0.0 for unsupported geometry types.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the geometry to operate on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_Centroid12OGRGeometryH12OGRGeometryH">
<span id="_CPPv314OGR_G_Centroid12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv214OGR_G_Centroid12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_Centroid__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a23f5a19a81628af7f9cc59a37378cb2b"></span>int <code class="descname">OGR_G_Centroid</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hCentroidPoint</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_Centroid12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="reference internal" href="ogrgeometry_cpp.html#classOGRPoint"><span class="std std-ref">OGRPoint</span></a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a91787f669b2a148169667e270e7e40df"><span class="std std-ref">OGRGeometry::Centroid()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success or OGRERR_FAILURE on error. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_G_Value12OGRGeometryHd">
<span id="_CPPv311OGR_G_Value12OGRGeometryHd"></span><span id="_CPPv211OGR_G_Value12OGRGeometryHd"></span><span id="OGR_G_Value__OGRGeometryH.double"></span><span class="target" id="ogr__api_8h_1a40fe6b95093ed248db61791cbf48b017"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Value</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, double <em>dfDistance</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_G_Value12OGRGeometryHd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch point at given distance along curve. </p>
<p>This function relates to the SF COM ICurve::get_Value() method.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRCurve_1a690570c5282483c043c0badbf94ce38b"><span class="std std-ref">OGRCurve::Value()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a point or NULL.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: curve geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfDistance</span></code>: distance along the curve at which to sample position. This distance should be between zero and get_Length() for this curve. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_G_Empty12OGRGeometryH">
<span id="_CPPv311OGR_G_Empty12OGRGeometryH"></span><span id="_CPPv211OGR_G_Empty12OGRGeometryH"></span><span id="OGR_G_Empty__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a90cc83b0a3052b8fbe2ed77a86323bf2"></span>void <code class="descname">OGR_G_Empty</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_G_Empty12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear geometry information. </p>
<p>This restores the geometry to its initial state after construction, and before assignment of actual geometry.</p>
<p>This function relates to the SFCOM IGeometry::Empty() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a1702b5b8142abe761061a6cd44e50b05"><span class="std std-ref">OGRGeometry::empty()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle on the geometry to empty. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_G_IsEmpty12OGRGeometryH">
<span id="_CPPv313OGR_G_IsEmpty12OGRGeometryH"></span><span id="_CPPv213OGR_G_IsEmpty12OGRGeometryH"></span><span id="OGR_G_IsEmpty__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a737b0c4d73928e7406d69c658209dbbf"></span>int <code class="descname">OGR_G_IsEmpty</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_G_IsEmpty12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if the geometry is empty. </p>
<p>This method is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ac8653ba97e53f3e3b041946ca2acc111"><span class="std std-ref">OGRGeometry::IsEmpty()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry has no points, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: The Geometry to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_G_IsValid12OGRGeometryH">
<span id="_CPPv313OGR_G_IsValid12OGRGeometryH"></span><span id="_CPPv213OGR_G_IsValid12OGRGeometryH"></span><span id="OGR_G_IsValid__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a4df68924f3b41fd377c5b4aa6631a00b"></span>int <code class="descname">OGR_G_IsValid</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_G_IsValid12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if the geometry is valid. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a681c8b8f8136764fd689ffbce24085d3"><span class="std std-ref">OGRGeometry::IsValid()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry has no points, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: The Geometry to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_G_MakeValid12OGRGeometryH">
<span id="_CPPv315OGR_G_MakeValid12OGRGeometryH"></span><span id="_CPPv215OGR_G_MakeValid12OGRGeometryH"></span><span id="OGR_G_MakeValid__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a60dbb0e05a715b16404a673d1ae2c9f5"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_MakeValid</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_G_MakeValid12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Attempts to make an invalid geometry valid without losing vertices. </p>
<p>Already-valid geometries are cloned without further intervention.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a26664b35c9a65737ccb26a38dc161214"><span class="std std-ref">OGRGeometry::MakeValid()</span></a>.</p>
<p>This function is built on the GEOS &gt;= 3.8 library, check it for the definition of the geometry operation. If OGR is built without the GEOS &gt;= 3.8 library, this function will return a clone of the input geometry if it is valid, or NULL if it is invalid</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a newly allocated geometry now owned by the caller, or NULL on failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: The Geometry to make valid.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_IsSimple12OGRGeometryH">
<span id="_CPPv314OGR_G_IsSimple12OGRGeometryH"></span><span id="_CPPv214OGR_G_IsSimple12OGRGeometryH"></span><span id="OGR_G_IsSimple__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a3cb66472d7e302d16aacf0d66c01ac73"></span>int <code class="descname">OGR_G_IsSimple</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_IsSimple12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns TRUE if the geometry is simple. </p>
<p>Returns TRUE if the geometry has no anomalous geometric points, such as self intersection or self tangency. The description of each instantiable geometric class will include the specific conditions that cause an instance of that class to be classified as not simple.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1afe41ef903c94999a81a98c356b32e624"><span class="std std-ref">OGRGeometry::IsSimple()</span></a> method.</p>
<p>If OGR is built without the GEOS library, this function will always return FALSE.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if object is simple, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: The Geometry to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_G_IsRing12OGRGeometryH">
<span id="_CPPv312OGR_G_IsRing12OGRGeometryH"></span><span id="_CPPv212OGR_G_IsRing12OGRGeometryH"></span><span id="OGR_G_IsRing__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ab9e99b4792042aca861866cb29bdf826"></span>int <code class="descname">OGR_G_IsRing</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_G_IsRing12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if the geometry is a ring. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1afe3c69f5b89fa5eb0bfb03e4880822bf"><span class="std std-ref">OGRGeometry::IsRing()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the geometry has no points, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: The Geometry to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_Polygonize12OGRGeometryH">
<span id="_CPPv316OGR_G_Polygonize12OGRGeometryH"></span><span id="_CPPv216OGR_G_Polygonize12OGRGeometryH"></span><span id="OGR_G_Polygonize__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ad7c6a082065407712ff865471ad7136f"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_Polygonize</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hTarget</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_Polygonize12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn’t corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topological inconsistencies.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a5524faa1746d9b6646ce5c6f28d31291"><span class="std std-ref">OGRGeometry::Polygonize()</span></a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTarget</span></code>: The Geometry to be polygonized.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_GetPointCount12OGRGeometryH">
<span id="_CPPv319OGR_G_GetPointCount12OGRGeometryH"></span><span id="_CPPv219OGR_G_GetPointCount12OGRGeometryH"></span><span id="OGR_G_GetPointCount__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1aec43cbe83609bc7b43739d67858846c1"></span>int <code class="descname">OGR_G_GetPointCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_GetPointCount12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch number of points from a geometry. </p>
<p>Only wkbPoint[25D] or wkbLineString[25D] may return a valid value. Other geometry types will silently return 0.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of points. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the number of points. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_G_GetPoints12OGRGeometryHPviPviPvi">
<span id="_CPPv315OGR_G_GetPoints12OGRGeometryHPviPviPvi"></span><span id="_CPPv215OGR_G_GetPoints12OGRGeometryHPviPviPvi"></span><span id="OGR_G_GetPoints__OGRGeometryH.voidP.i.voidP.i.voidP.i"></span><span class="target" id="ogr__api_8h_1a6c22d91b27d7a42c225a7dfde28f09c4"></span>int <code class="descname">OGR_G_GetPoints</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, void *<em>pabyX</em>, int <em>nXStride</em>, void *<em>pabyY</em>, int <em>nYStride</em>, void *<em>pabyZ</em>, int <em>nZStride</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_G_GetPoints12OGRGeometryHPviPviPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutive elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of points</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyX</span></code>: a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXStride</span></code>: the number of bytes between 2 elements of pabyX. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyY</span></code>: a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYStride</span></code>: the number of bytes between 2 elements of pabyY. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyZ</span></code>: a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nZStride</span></code>: the number of bytes between 2 elements of pabyZ.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_GetPointsZM12OGRGeometryHPviPviPviPvi">
<span id="_CPPv317OGR_G_GetPointsZM12OGRGeometryHPviPviPviPvi"></span><span id="_CPPv217OGR_G_GetPointsZM12OGRGeometryHPviPviPviPvi"></span><span id="OGR_G_GetPointsZM__OGRGeometryH.voidP.i.voidP.i.voidP.i.voidP.i"></span><span class="target" id="ogr__api_8h_1a0ce63762b79f4d882e1498981a4c26ba"></span>int <code class="descname">OGR_G_GetPointsZM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, void *<em>pabyX</em>, int <em>nXStride</em>, void *<em>pabyY</em>, int <em>nYStride</em>, void *<em>pabyZ</em>, int <em>nZStride</em>, void *<em>pabyM</em>, int <em>nMStride</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_GetPointsZM12OGRGeometryHPviPviPviPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutive elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of points</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyX</span></code>: a buffer of at least (nXStride * nPointCount) bytes, may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXStride</span></code>: the number of bytes between 2 elements of pabyX. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyY</span></code>: a buffer of at least (nYStride * nPointCount) bytes, may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYStride</span></code>: the number of bytes between 2 elements of pabyY. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyZ</span></code>: a buffer of at last size (nZStride * nPointCount) bytes, may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nZStride</span></code>: the number of bytes between 2 elements of pabyZ. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyM</span></code>: a buffer of at last size (nMStride * nPointCount) bytes, may be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMStride</span></code>: the number of bytes between 2 elements of pabyM.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_G_GetX12OGRGeometryHi">
<span id="_CPPv310OGR_G_GetX12OGRGeometryHi"></span><span id="_CPPv210OGR_G_GetX12OGRGeometryHi"></span><span id="OGR_G_GetX__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a354146161d0a087b63ab6e350bae4d86"></span>double <code class="descname">OGR_G_GetX</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_G_GetX12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the x coordinate of a point from a geometry. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the X coordinate of this point. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the x coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: point to get the x coordinate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_G_GetY12OGRGeometryHi">
<span id="_CPPv310OGR_G_GetY12OGRGeometryHi"></span><span id="_CPPv210OGR_G_GetY12OGRGeometryHi"></span><span id="OGR_G_GetY__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a8405350c9aea2ab7d0f759f0b09b926f"></span>double <code class="descname">OGR_G_GetY</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_G_GetY12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the x coordinate of a point from a geometry. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the Y coordinate of this point. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the y coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: point to get the Y coordinate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_G_GetZ12OGRGeometryHi">
<span id="_CPPv310OGR_G_GetZ12OGRGeometryHi"></span><span id="_CPPv210OGR_G_GetZ12OGRGeometryHi"></span><span id="OGR_G_GetZ__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a1d8c6aeb013325f33b8e642003fc17ad"></span>double <code class="descname">OGR_G_GetZ</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_G_GetZ12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the z coordinate of a point from a geometry. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the Z coordinate of this point. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the Z coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: point to get the Z coordinate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_G_GetM12OGRGeometryHi">
<span id="_CPPv310OGR_G_GetM12OGRGeometryHi"></span><span id="_CPPv210OGR_G_GetM12OGRGeometryHi"></span><span id="OGR_G_GetM__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a49fa1c4594aa103068870ef4b4ef094f"></span>double <code class="descname">OGR_G_GetM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_G_GetM12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the m coordinate of a point from a geometry. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the M coordinate of this point. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the M coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: point to get the M coordinate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_GetPoint12OGRGeometryHiPdPdPd">
<span id="_CPPv314OGR_G_GetPoint12OGRGeometryHiPdPdPd"></span><span id="_CPPv214OGR_G_GetPoint12OGRGeometryHiPdPdPd"></span><span id="OGR_G_GetPoint__OGRGeometryH.i.doubleP.doubleP.doubleP"></span><span class="target" id="ogr__api_8h_1a67b897ffcd88a83832964c3735fa1dcb"></span>void <code class="descname">OGR_G_GetPoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iPoint</em>, double *<em>pdfX</em>, double *<em>pdfY</em>, double *<em>pdfZ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_GetPoint12OGRGeometryHiPdPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a point in line string or a point geometry. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfX</span></code>: value of x coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfY</span></code>: value of y coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfZ</span></code>: value of z coordinate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_GetPointZM12OGRGeometryHiPdPdPdPd">
<span id="_CPPv316OGR_G_GetPointZM12OGRGeometryHiPdPdPdPd"></span><span id="_CPPv216OGR_G_GetPointZM12OGRGeometryHiPdPdPdPd"></span><span id="OGR_G_GetPointZM__OGRGeometryH.i.doubleP.doubleP.doubleP.doubleP"></span><span class="target" id="ogr__api_8h_1a362999cdf708959829209e9d885d923d"></span>void <code class="descname">OGR_G_GetPointZM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iPoint</em>, double *<em>pdfX</em>, double *<em>pdfY</em>, double *<em>pdfZ</em>, double *<em>pdfM</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_GetPointZM12OGRGeometryHiPdPdPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a point in line string or a point geometry. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry from which to get the coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfX</span></code>: value of x coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfY</span></code>: value of y coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfZ</span></code>: value of z coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfM</span></code>: value of m coordinate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_G_SetPointCount12OGRGeometryHi">
<span id="_CPPv319OGR_G_SetPointCount12OGRGeometryHi"></span><span id="_CPPv219OGR_G_SetPointCount12OGRGeometryHi"></span><span id="OGR_G_SetPointCount__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a4f4f7bff0d685b2713504bd89b14d0fc"></span>void <code class="descname">OGR_G_SetPointCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>nNewPointCount</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_G_SetPointCount12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set number of points in a geometry. </p>
<p>This method primary exists to preset the number of points in a linestring geometry before setPoint() is used to assign them to avoid reallocating the array larger with each call to addPoint().</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nNewPointCount</span></code>: the new number of points for geometry. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_SetPoint12OGRGeometryHiddd">
<span id="_CPPv314OGR_G_SetPoint12OGRGeometryHiddd"></span><span id="_CPPv214OGR_G_SetPoint12OGRGeometryHiddd"></span><span id="OGR_G_SetPoint__OGRGeometryH.i.double.double.double"></span><span class="target" id="ogr__api_8h_1a303fb1a2a94363c15f9e61dc46b710e8"></span>void <code class="descname">OGR_G_SetPoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iPoint</em>, double <em>dfX</em>, double <em>dfY</em>, double <em>dfZ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_SetPoint12OGRGeometryHiddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a vertex to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the index of the vertex to assign (zero based) or zero for a point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: input X coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: input Y coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfZ</span></code>: input Z coordinate to assign (defaults to zero). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_SetPoint_2D12OGRGeometryHidd">
<span id="_CPPv317OGR_G_SetPoint_2D12OGRGeometryHidd"></span><span id="_CPPv217OGR_G_SetPoint_2D12OGRGeometryHidd"></span><span id="OGR_G_SetPoint_2D__OGRGeometryH.i.double.double"></span><span class="target" id="ogr__api_8h_1ab14b9730d6f9fc829fe6be9bc2a5ec48"></span>void <code class="descname">OGR_G_SetPoint_2D</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iPoint</em>, double <em>dfX</em>, double <em>dfY</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_SetPoint_2D12OGRGeometryHidd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a vertex to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the index of the vertex to assign (zero based) or zero for a point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: input X coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: input Y coordinate to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_G_SetPointM12OGRGeometryHiddd">
<span id="_CPPv315OGR_G_SetPointM12OGRGeometryHiddd"></span><span id="_CPPv215OGR_G_SetPointM12OGRGeometryHiddd"></span><span id="OGR_G_SetPointM__OGRGeometryH.i.double.double.double"></span><span class="target" id="ogr__api_8h_1ab4ce9b54d1e821bd020a7a6731d2f529"></span>void <code class="descname">OGR_G_SetPointM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iPoint</em>, double <em>dfX</em>, double <em>dfY</em>, double <em>dfM</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_G_SetPointM12OGRGeometryHiddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a vertex to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the index of the vertex to assign (zero based) or zero for a point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: input X coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: input Y coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfM</span></code>: input M coordinate to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_SetPointZM12OGRGeometryHidddd">
<span id="_CPPv316OGR_G_SetPointZM12OGRGeometryHidddd"></span><span id="_CPPv216OGR_G_SetPointZM12OGRGeometryHidddd"></span><span id="OGR_G_SetPointZM__OGRGeometryH.i.double.double.double.double"></span><span class="target" id="ogr__api_8h_1a034b6b1bae3843345cbfc78e07fa7075"></span>void <code class="descname">OGR_G_SetPointZM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iPoint</em>, double <em>dfX</em>, double <em>dfY</em>, double <em>dfZ</em>, double <em>dfM</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_SetPointZM12OGRGeometryHidddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a vertex to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the index of the vertex to assign (zero based) or zero for a point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: input X coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: input Y coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfZ</span></code>: input Z coordinate to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfM</span></code>: input M coordinate to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_G_AddPoint12OGRGeometryHddd">
<span id="_CPPv314OGR_G_AddPoint12OGRGeometryHddd"></span><span id="_CPPv214OGR_G_AddPoint12OGRGeometryHddd"></span><span id="OGR_G_AddPoint__OGRGeometryH.double.double.double"></span><span class="target" id="ogr__api_8h_1aa2702d812663bc767e3a8f8832fda089"></span>void <code class="descname">OGR_G_AddPoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, double <em>dfX</em>, double <em>dfY</em>, double <em>dfZ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_G_AddPoint12OGRGeometryHddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a point to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: x coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: y coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfZ</span></code>: z coordinate of point to add. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_AddPoint_2D12OGRGeometryHdd">
<span id="_CPPv317OGR_G_AddPoint_2D12OGRGeometryHdd"></span><span id="_CPPv217OGR_G_AddPoint_2D12OGRGeometryHdd"></span><span id="OGR_G_AddPoint_2D__OGRGeometryH.double.double"></span><span class="target" id="ogr__api_8h_1a280275c1492d6426cfe0a918d4725374"></span>void <code class="descname">OGR_G_AddPoint_2D</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, double <em>dfX</em>, double <em>dfY</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_AddPoint_2D12OGRGeometryHdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a point to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: x coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: y coordinate of point to add. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_G_AddPointM12OGRGeometryHddd">
<span id="_CPPv315OGR_G_AddPointM12OGRGeometryHddd"></span><span id="_CPPv215OGR_G_AddPointM12OGRGeometryHddd"></span><span id="OGR_G_AddPointM__OGRGeometryH.double.double.double"></span><span class="target" id="ogr__api_8h_1a16370d0b3feb2505fa5f3a2acfffbf17"></span>void <code class="descname">OGR_G_AddPointM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, double <em>dfX</em>, double <em>dfY</em>, double <em>dfM</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_G_AddPointM12OGRGeometryHddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a point to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: x coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: y coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfM</span></code>: m coordinate of point to add. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_G_AddPointZM12OGRGeometryHdddd">
<span id="_CPPv316OGR_G_AddPointZM12OGRGeometryHdddd"></span><span id="_CPPv216OGR_G_AddPointZM12OGRGeometryHdddd"></span><span id="OGR_G_AddPointZM__OGRGeometryH.double.double.double.double"></span><span class="target" id="ogr__api_8h_1adf01e19ca7b9951a5201b345ea130325"></span>void <code class="descname">OGR_G_AddPointZM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, double <em>dfX</em>, double <em>dfY</em>, double <em>dfZ</em>, double <em>dfM</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_G_AddPointZM12OGRGeometryHdddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to add a point to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: x coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: y coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfZ</span></code>: z coordinate of point to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfM</span></code>: m coordinate of point to add. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_G_SetPoints12OGRGeometryHiPKviPKviPKvi">
<span id="_CPPv315OGR_G_SetPoints12OGRGeometryHiPKviPKviPKvi"></span><span id="_CPPv215OGR_G_SetPoints12OGRGeometryHiPKviPKviPKvi"></span><span id="OGR_G_SetPoints__OGRGeometryH.i.voidCP.i.voidCP.i.voidCP.i"></span><span class="target" id="ogr__api_8h_1a51438701454d7e86988efc62b25d6aeb"></span>void <code class="descname">OGR_G_SetPoints</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>nPointsIn</em>, <em class="property">const</em> void *<em>pabyX</em>, int <em>nXStride</em>, <em class="property">const</em> void *<em>pabyY</em>, int <em>nYStride</em>, <em class="property">const</em> void *<em>pabyZ</em>, int <em>nZStride</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_G_SetPoints12OGRGeometryHiPKviPKviPKvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign all points in a point or a line string geometry. </p>
<p>This method clear any existing points assigned to this geometry, and assigns a whole new set.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to set the coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPointsIn</span></code>: number of points being passed in padfX and padfY. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyX</span></code>: list of X coordinates (double values) of points being assigned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXStride</span></code>: the number of bytes between 2 elements of pabyX. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyY</span></code>: list of Y coordinates (double values) of points being assigned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYStride</span></code>: the number of bytes between 2 elements of pabyY. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyZ</span></code>: list of Z coordinates (double values) of points being assigned (defaults to NULL for 2D objects). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nZStride</span></code>: the number of bytes between 2 elements of pabyZ. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_SetPointsZM12OGRGeometryHiPKviPKviPKviPKvi">
<span id="_CPPv317OGR_G_SetPointsZM12OGRGeometryHiPKviPKviPKviPKvi"></span><span id="_CPPv217OGR_G_SetPointsZM12OGRGeometryHiPKviPKviPKviPKvi"></span><span id="OGR_G_SetPointsZM__OGRGeometryH.i.voidCP.i.voidCP.i.voidCP.i.voidCP.i"></span><span class="target" id="ogr__api_8h_1ac54402dc365f496b29ad1f01261e4576"></span>void <code class="descname">OGR_G_SetPointsZM</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>nPointsIn</em>, <em class="property">const</em> void *<em>pabyX</em>, int <em>nXStride</em>, <em class="property">const</em> void *<em>pabyY</em>, int <em>nYStride</em>, <em class="property">const</em> void *<em>pabyZ</em>, int <em>nZStride</em>, <em class="property">const</em> void *<em>pabyM</em>, int <em>nMStride</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_SetPointsZM12OGRGeometryHiPKviPKviPKviPKvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign all points in a point or a line string geometry. </p>
<p>This method clear any existing points assigned to this geometry, and assigns a whole new set.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to set the coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPointsIn</span></code>: number of points being passed in padfX and padfY. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pX</span></code>: list of X coordinates (double values) of points being assigned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXStride</span></code>: the number of bytes between 2 elements of pX. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pY</span></code>: list of Y coordinates (double values) of points being assigned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYStride</span></code>: the number of bytes between 2 elements of pY. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pZ</span></code>: list of Z coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have Z coordinate). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nZStride</span></code>: the number of bytes between 2 elements of pZ. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pM</span></code>: list of M coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have M coordinate). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMStride</span></code>: the number of bytes between 2 elements of pM. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_G_SwapXY12OGRGeometryH">
<span id="_CPPv312OGR_G_SwapXY12OGRGeometryH"></span><span id="_CPPv212OGR_G_SwapXY12OGRGeometryH"></span><span id="OGR_G_SwapXY__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a4cacbe8ef1bbacdcee7ad7c3d74ed593"></span>void <code class="descname">OGR_G_SwapXY</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_G_SwapXY12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Swap x and y coordinates. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 2.3.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: geometry. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_G_GetGeometryCount12OGRGeometryH">
<span id="_CPPv322OGR_G_GetGeometryCount12OGRGeometryH"></span><span id="_CPPv222OGR_G_GetGeometryCount12OGRGeometryH"></span><span id="OGR_G_GetGeometryCount__OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a1fa07ddf969f97f6444de6ae5128d842"></span>int <code class="descname">OGR_G_GetGeometryCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_G_GetGeometryCount12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the number of elements in a geometry or number of geometries in container. </p>
<p>Only geometries of type wkbPolygon[25D], wkbMultiPoint[25D], wkbMultiLineString[25D], wkbMultiPolygon[25D] or wkbGeometryCollection[25D] may return a valid value. Other geometry types will silently return 0.</p>
<p>For a polygon, the returned number is the number of rings (exterior ring + interior rings).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of elements. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: single geometry or geometry container from which to get the number of elements. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_GetGeometryRef12OGRGeometryHi">
<span id="_CPPv320OGR_G_GetGeometryRef12OGRGeometryHi"></span><span id="_CPPv220OGR_G_GetGeometryRef12OGRGeometryHi"></span><span id="OGR_G_GetGeometryRef__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1a6bac93150529a5c98811db29e289dd66"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_GetGeometryRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iSubGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_GetGeometryRef12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch geometry from a geometry container. </p>
<p>This function returns an handle to a geometry within the container. The returned geometry remains owned by the container, and should not be modified. The handle is only valid until the next change to the geometry container. Use <a class="reference internal" href="#ogr__api_8h_1aed1c08151c1873ebd4722cdf79a5ae2c"><span class="std std-ref">OGR_G_Clone()</span></a> to make a copy.</p>
<p>This function relates to the SFCOM IGeometryCollection::get_Geometry() method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection_1ad609f2c7886918a766dd3d3a4fa52ec3"><span class="std std-ref">OGRGeometryCollection::getGeometryRef()</span></a>.</p>
<p>For a polygon, OGR_G_GetGeometryRef(iSubGeom) returns the exterior ring if iSubGeom == 0, and the interior rings for iSubGeom &gt; 0.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle to the requested geometry. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry container from which to get a geometry from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iSubGeom</span></code>: the index of the geometry to fetch, between 0 and getNumGeometries() - 1. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_G_AddGeometry12OGRGeometryH12OGRGeometryH">
<span id="_CPPv317OGR_G_AddGeometry12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv217OGR_G_AddGeometry12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_AddGeometry__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a4a15e130614cb4c66fc99bb93dc6b3b5"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_AddGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hNewSubGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_G_AddGeometry12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a geometry to a geometry container. </p>
<p>Some subclasses of <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection"><span class="std std-ref">OGRGeometryCollection</span></a> restrict the types of geometry that can be added, and may return an error. The passed geometry is cloned to make an internal copy.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection_1a3da519655d14346e591d22a547562b0c"><span class="std std-ref">OGRGeometryCollection::addGeometry</span></a>.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of existing geometry. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: existing geometry container. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hNewSubGeom</span></code>: geometry to add to the container.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_G_AddGeometryDirectly12OGRGeometryH12OGRGeometryH">
<span id="_CPPv325OGR_G_AddGeometryDirectly12OGRGeometryH12OGRGeometryH"></span><span id="_CPPv225OGR_G_AddGeometryDirectly12OGRGeometryH12OGRGeometryH"></span><span id="OGR_G_AddGeometryDirectly__OGRGeometryH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1aff56cae8305396a9c5b690d8356e39c9"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_AddGeometryDirectly</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hNewSubGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_G_AddGeometryDirectly12OGRGeometryH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a geometry directly to an existing geometry container. </p>
<p>Some subclasses of <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection"><span class="std std-ref">OGRGeometryCollection</span></a> restrict the types of geometry that can be added, and may return an error. Ownership of the passed geometry is taken by the container rather than cloning as addGeometry() does.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection_1a8422907a01d088ec5ef916382bea8eb3"><span class="std std-ref">OGRGeometryCollection::addGeometryDirectly</span></a>.</p>
<p>There is no SFCOM analog to this method.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of geometry container. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: existing geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hNewSubGeom</span></code>: geometry to add to the existing geometry.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_G_RemoveGeometry12OGRGeometryHii">
<span id="_CPPv320OGR_G_RemoveGeometry12OGRGeometryHii"></span><span id="_CPPv220OGR_G_RemoveGeometry12OGRGeometryHii"></span><span id="OGR_G_RemoveGeometry__OGRGeometryH.i.i"></span><span class="target" id="ogr__api_8h_1a54ea024bb659e48d3297404e53800237"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_G_RemoveGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>iGeom</em>, int <em>bDelete</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_G_RemoveGeometry12OGRGeometryHii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a geometry from an exiting geometry container. </p>
<p>Removing a geometry will cause the geometry count to drop by one, and all “higher” geometries will shuffle down one in index.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection_1ae37405203118eeb0430ef38668a385b7"><span class="std std-ref">OGRGeometryCollection::removeGeometry()</span></a> for geometry collections, <a class="reference internal" href="ogrgeometry_cpp.html#classOGRCurvePolygon_1af7fb46dfd0cd7eebe68555ac1b6da76f"><span class="std std-ref">OGRCurvePolygon::removeRing()</span></a> for polygons / curve polygons and <a class="reference internal" href="ogrgeometry_cpp.html#classOGRPolyhedralSurface_1afb16af941e5fc7d2758c033c490cac4b"><span class="std std-ref">OGRPolyhedralSurface::removeGeometry()</span></a> for polyhedral surfaces and TINs.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is out of range. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the existing geometry to delete from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iGeom</span></code>: the index of the geometry to delete. A value of -1 is a special flag meaning that all geometries should be removed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDelete</span></code>: if TRUE the geometry will be destroyed, otherwise it will not. The default is TRUE as the existing geometry is considered to own the geometries in it.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_G_HasCurveGeometry12OGRGeometryHi">
<span id="_CPPv322OGR_G_HasCurveGeometry12OGRGeometryHi"></span><span id="_CPPv222OGR_G_HasCurveGeometry12OGRGeometryHi"></span><span id="OGR_G_HasCurveGeometry__OGRGeometryH.i"></span><span class="target" id="ogr__api_8h_1af4f8e7d05f06a1fe69ea9638085e5e26"></span>int <code class="descname">OGR_G_HasCurveGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, int <em>bLookForNonLinear</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_G_HasCurveGeometry12OGRGeometryHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns if this geometry is or has curve geometry. </p>
<p>Returns if a geometry is or has CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it.</p>
<p>If bLookForNonLinear is set to TRUE, it will be actually looked if the geometry or its subgeometries are or contain a non-linear geometry in them. In which case, if the method returns TRUE, it means that <a class="reference internal" href="#ogr__api_8h_1a6bd069f8338954fc8a6215594a37a8db"><span class="std std-ref">OGR_G_GetLinearGeometry()</span></a> would return an approximate version of the geometry. Otherwise, <a class="reference internal" href="#ogr__api_8h_1a6bd069f8338954fc8a6215594a37a8db"><span class="std std-ref">OGR_G_GetLinearGeometry()</span></a> would do a conversion, but with just converting container type, like COMPOUNDCURVE -&gt; LINESTRING, MULTICURVE -&gt; MULTILINESTRING or MULTISURFACE -&gt; MULTIPOLYGON, resulting in a “loss-less” conversion.</p>
<p>This function is the same as C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a15afb03f64091205af0530d8d1262798"><span class="std std-ref">OGRGeometry::hasCurveGeometry()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if this geometry is or has curve geometry.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the geometry to operate on. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bLookForNonLinear</span></code>: set it to TRUE to check if the geometry is or contains a CIRCULARSTRING. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_G_GetLinearGeometry12OGRGeometryHdPPc">
<span id="_CPPv323OGR_G_GetLinearGeometry12OGRGeometryHdPPc"></span><span id="_CPPv223OGR_G_GetLinearGeometry12OGRGeometryHdPPc"></span><span id="OGR_G_GetLinearGeometry__OGRGeometryH.double.cPP"></span><span class="target" id="ogr__api_8h_1a6bd069f8338954fc8a6215594a37a8db"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_GetLinearGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, double <em>dfMaxAngleStepSizeDegrees</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_G_GetLinearGeometry12OGRGeometryHdPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return, possibly approximate, linear version of this geometry. </p>
<p>Returns a geometry that has no CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by approximating curve geometries.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse function is <a class="reference internal" href="#ogr__api_8h_1a4989d5287899041d70f4176d41ceeac2"><span class="std std-ref">OGR_G_GetCurveGeometry()</span></a>.</p>
<p>This method relates to the ISO SQL/MM Part 3 ICurve::CurveToLine() and CurvePolygon::CurvePolyToPoly() methods.</p>
<p>This function is the same as C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1ac13fa59ae1a0d46070e05d8007bd295e"><span class="std std-ref">OGRGeometry::getLinearGeometry()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the geometry to operate on. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxAngleStepSizeDegrees</span></code>: the largest step in degrees along the arc, zero to use the default setting. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: options as a null-terminated list of strings or NULL. See <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryFactory_1a6f661d6691fcf745ca185ae4d586156c"><span class="std std-ref">OGRGeometryFactory::curveToLineString()</span></a> for valid options.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_G_GetCurveGeometry12OGRGeometryHPPc">
<span id="_CPPv322OGR_G_GetCurveGeometry12OGRGeometryHPPc"></span><span id="_CPPv222OGR_G_GetCurveGeometry12OGRGeometryHPPc"></span><span id="OGR_G_GetCurveGeometry__OGRGeometryH.cPP"></span><span class="target" id="ogr__api_8h_1a4989d5287899041d70f4176d41ceeac2"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_G_GetCurveGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_G_GetCurveGeometry12OGRGeometryHPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return curve version of this geometry. </p>
<p>Returns a geometry that has possibly CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by de-approximating linear into curve geometries.</p>
<p>If the geometry has no curve portion, the returned geometry will be a clone of it.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse function is <a class="reference internal" href="#ogr__api_8h_1a6bd069f8338954fc8a6215594a37a8db"><span class="std std-ref">OGR_G_GetLinearGeometry()</span></a>.</p>
<p>This function is the same as C++ method <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1a49749581ed7c99f9923029333f7c834c"><span class="std std-ref">OGRGeometry::getCurveGeometry()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new geometry.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: the geometry to operate on. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: options as a null-terminated list of strings. Unused for now. Must be set to NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGRBuildPolygonFromEdges12OGRGeometryHiidP6OGRErr">
<span id="_CPPv324OGRBuildPolygonFromEdges12OGRGeometryHiidP6OGRErr"></span><span id="_CPPv224OGRBuildPolygonFromEdges12OGRGeometryHiidP6OGRErr"></span><span id="OGRBuildPolygonFromEdges__OGRGeometryH.i.i.double.OGRErrP"></span><span class="target" id="ogr__api_8h_1ac96ffb0c7265926d107dadde9a634763"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGRBuildPolygonFromEdges</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hLinesAsCollection</em>, int <em>bBestEffort</em>, int <em>bAutoClose</em>, double <em>dfTolerance</em>, <a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> *<em>peErr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGRBuildPolygonFromEdges12OGRGeometryHiidP6OGRErr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Build a ring from a bunch of arcs. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the new geometry, a polygon. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLines</span></code>: handle to an <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometryCollection"><span class="std std-ref">OGRGeometryCollection</span></a> (or <a class="reference internal" href="ogrgeometry_cpp.html#classOGRMultiLineString"><span class="std std-ref">OGRMultiLineString</span></a>) containing the line string geometries to be built into rings. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bBestEffort</span></code>: not yet implemented???. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bAutoClose</span></code>: indicates if the ring should be close when first and last points of the ring are the same. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfTolerance</span></code>: tolerance into which two arcs are considered close enough to be joined. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">peErr</span></code>: OGRERR_NONE on success, or OGRERR_FAILURE on failure. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv436OGRSetNonLinearGeometriesEnabledFlagi">
<span id="_CPPv336OGRSetNonLinearGeometriesEnabledFlagi"></span><span id="_CPPv236OGRSetNonLinearGeometriesEnabledFlagi"></span><span id="OGRSetNonLinearGeometriesEnabledFlag__i"></span><span class="target" id="ogr__api_8h_1a31febe0b845d7cc0052767e6257e7349"></span>void <code class="descname">OGRSetNonLinearGeometriesEnabledFlag</code><span class="sig-paren">(</span>int <em>bFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436OGRSetNonLinearGeometriesEnabledFlagi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set flag to enable/disable returning non-linear geometries in the C API. </p>
<p>This flag has only an effect on the <a class="reference internal" href="#ogr__api_8h_1a1bf9596756aeacec4da502383c378f5c"><span class="std std-ref">OGR_F_GetGeometryRef()</span></a>, <a class="reference internal" href="#ogr__api_8h_1a37aa8b53b1fc8816c5b7bcbbcb6a46ca"><span class="std std-ref">OGR_F_GetGeomFieldRef()</span></a>, <a class="reference internal" href="#ogr__api_8h_1a0adea8ce1ca795ce0a6a76505f90f078"><span class="std std-ref">OGR_L_GetGeomType()</span></a>, <a class="reference internal" href="#ogr__api_8h_1a323f4350c2e90c6e67df37f68d244a0d"><span class="std std-ref">OGR_GFld_GetType()</span></a> and <a class="reference internal" href="#ogr__api_8h_1add0b3a6b6062122e4f4316d194d2a1cf"><span class="std std-ref">OGR_FD_GetGeomType()</span></a> C API, and corresponding methods in the SWIG bindings. It is meant as making it simple for applications using the OGR C API not to have to deal with non-linear geometries, even if such geometries might be returned by drivers. In which case, they will be transformed into their closest linear geometry, by doing linear approximation, with <a class="reference internal" href="#ogr__api_8h_1a3a37c25a9b628982e86b1821446e3a0e"><span class="std std-ref">OGR_G_ForceTo()</span></a>.</p>
<p>Libraries should generally <em>not</em> use that method, since that could interfere with other libraries or applications.</p>
<p>Note that it <em>does</em> not affect the behavior of the C++ API.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bFlag</span></code>: TRUE if non-linear geometries might be returned (default value). FALSE to ask for non-linear geometries to be approximated as linear geometries.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv436OGRGetNonLinearGeometriesEnabledFlagv">
<span id="_CPPv336OGRGetNonLinearGeometriesEnabledFlagv"></span><span id="_CPPv236OGRGetNonLinearGeometriesEnabledFlagv"></span><span id="OGRGetNonLinearGeometriesEnabledFlag__void"></span><span class="target" id="ogr__api_8h_1af7f6cfab316f5f22962bcd85216c4684"></span>int <code class="descname">OGRGetNonLinearGeometriesEnabledFlag</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436OGRGetNonLinearGeometriesEnabledFlagv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get flag to enable/disable returning non-linear geometries in the C API. </p>
<p>return TRUE if non-linear geometries might be returned (default value is TRUE).</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference internal" href="#ogr__api_8h_1a31febe0b845d7cc0052767e6257e7349"><span class="std std-ref">OGRSetNonLinearGeometriesEnabledFlag()</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_Fld_CreatePKc12OGRFieldType">
<span id="_CPPv314OGR_Fld_CreatePKc12OGRFieldType"></span><span id="_CPPv214OGR_Fld_CreatePKc12OGRFieldType"></span><span id="OGR_Fld_Create__cCP.OGRFieldType"></span><span class="target" id="ogr__api_8h_1a24af159359797a83c354fdf6cced3265"></span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <code class="descname">OGR_Fld_Create</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em>, <a class="reference internal" href="#_CPPv412OGRFieldType" title="OGRFieldType">OGRFieldType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_Fld_CreatePKc12OGRFieldType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new field definition. </p>
<p>By default, fields have no width, precision, are nullable and not ignored.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1afc375f038b548b5a86b854c214fee114"><span class="std std-ref">OGRFieldDefn::OGRFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle to the new field definition. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the new field definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the type of the new field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_Fld_Destroy13OGRFieldDefnH">
<span id="_CPPv315OGR_Fld_Destroy13OGRFieldDefnH"></span><span id="_CPPv215OGR_Fld_Destroy13OGRFieldDefnH"></span><span id="OGR_Fld_Destroy__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a455fa4a2c2451b1748facb6b7126a822"></span>void <code class="descname">OGR_Fld_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_Fld_Destroy13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy a field definition. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to destroy. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_Fld_SetName13OGRFieldDefnHPKc">
<span id="_CPPv315OGR_Fld_SetName13OGRFieldDefnHPKc"></span><span id="_CPPv215OGR_Fld_SetName13OGRFieldDefnHPKc"></span><span id="OGR_Fld_SetName__OGRFieldDefnH.cCP"></span><span class="target" id="ogr__api_8h_1a6599fa42bad3aba26574ae3260c6984d"></span>void <code class="descname">OGR_Fld_SetName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_Fld_SetName13OGRFieldDefnHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a241585cd66a38311aa0322f34e6d5214"><span class="std std-ref">OGRFieldDefn::SetName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to apply the new name to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the new name to apply. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_GetNameRef13OGRFieldDefnH">
<span id="_CPPv318OGR_Fld_GetNameRef13OGRFieldDefnH"></span><span id="_CPPv218OGR_Fld_GetNameRef13OGRFieldDefnH"></span><span id="OGR_Fld_GetNameRef__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a8d7640a6b6a47a95d83415f9271ffe30"></span><em class="property">const</em> char *<code class="descname">OGR_Fld_GetNameRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_GetNameRef13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a0264c5e7e6ff31fbd6a2b55aab86c6a6"><span class="std std-ref">OGRFieldDefn::GetNameRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the name of the field definition. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_Fld_GetType13OGRFieldDefnH">
<span id="_CPPv315OGR_Fld_GetType13OGRFieldDefnH"></span><span id="_CPPv215OGR_Fld_GetType13OGRFieldDefnH"></span><span id="OGR_Fld_GetType__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1ad8d150dfc678e0a2a7f5241ba38c5611"></span><a class="reference internal" href="#_CPPv412OGRFieldType" title="OGRFieldType">OGRFieldType</a> <code class="descname">OGR_Fld_GetType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_Fld_GetType13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch type of this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a8bb642e3e582146e3090247a1673d715"><span class="std std-ref">OGRFieldDefn::GetType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>field type. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to get type from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_Fld_SetType13OGRFieldDefnH12OGRFieldType">
<span id="_CPPv315OGR_Fld_SetType13OGRFieldDefnH12OGRFieldType"></span><span id="_CPPv215OGR_Fld_SetType13OGRFieldDefnH12OGRFieldType"></span><span id="OGR_Fld_SetType__OGRFieldDefnH.OGRFieldType"></span><span class="target" id="ogr__api_8h_1a76195990f814eb93e821c01ce0599a50"></span>void <code class="descname">OGR_Fld_SetType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, <a class="reference internal" href="#_CPPv412OGRFieldType" title="OGRFieldType">OGRFieldType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_Fld_SetType13OGRFieldDefnH12OGRFieldType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the type of this field. </p>
<p>This should never be done to an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn"><span class="std std-ref">OGRFieldDefn</span></a> that is already part of an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a26bf22b7d805b9e33dd5c5fe9b4a8363"><span class="std std-ref">OGRFieldDefn::SetType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to set type to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the new field type. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_GetSubType13OGRFieldDefnH">
<span id="_CPPv318OGR_Fld_GetSubType13OGRFieldDefnH"></span><span id="_CPPv218OGR_Fld_GetSubType13OGRFieldDefnH"></span><span id="OGR_Fld_GetSubType__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a3ef13952aa38f83b0dc1da047870511f"></span><a class="reference internal" href="#_CPPv415OGRFieldSubType" title="OGRFieldSubType">OGRFieldSubType</a> <code class="descname">OGR_Fld_GetSubType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_GetSubType13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch subtype of this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a3c18c491717be99e2e1a3c96cfc2ffd9"><span class="std std-ref">OGRFieldDefn::GetSubType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>field subtype. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to get subtype from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_SetSubType13OGRFieldDefnH15OGRFieldSubType">
<span id="_CPPv318OGR_Fld_SetSubType13OGRFieldDefnH15OGRFieldSubType"></span><span id="_CPPv218OGR_Fld_SetSubType13OGRFieldDefnH15OGRFieldSubType"></span><span id="OGR_Fld_SetSubType__OGRFieldDefnH.OGRFieldSubType"></span><span class="target" id="ogr__api_8h_1ab83497e3ce74c6abb615a234791850c1"></span>void <code class="descname">OGR_Fld_SetSubType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, <a class="reference internal" href="#_CPPv415OGRFieldSubType" title="OGRFieldSubType">OGRFieldSubType</a> <em>eSubType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_SetSubType13OGRFieldDefnH15OGRFieldSubType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the subtype of this field. </p>
<p>This should never be done to an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn"><span class="std std-ref">OGRFieldDefn</span></a> that is already part of an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1af5e277ae923683e8b4982d9dd009740d"><span class="std std-ref">OGRFieldDefn::SetSubType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to set type to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eSubType</span></code>: the new field subtype. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_GetJustify13OGRFieldDefnH">
<span id="_CPPv318OGR_Fld_GetJustify13OGRFieldDefnH"></span><span id="_CPPv218OGR_Fld_GetJustify13OGRFieldDefnH"></span><span id="OGR_Fld_GetJustify__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a0cf8a09826e47763e6bf667af0dae1a7"></span><a class="reference internal" href="#_CPPv416OGRJustification" title="OGRJustification">OGRJustification</a> <code class="descname">OGR_Fld_GetJustify</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_GetJustify13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the justification for this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a5ac2afcfb22e885321bf877d2d1fd99d"><span class="std std-ref">OGRFieldDefn::GetJustify()</span></a>.</p>
<p>Note: no driver is know to use the concept of field justification.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the justification. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to get justification from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_SetJustify13OGRFieldDefnH16OGRJustification">
<span id="_CPPv318OGR_Fld_SetJustify13OGRFieldDefnH16OGRJustification"></span><span id="_CPPv218OGR_Fld_SetJustify13OGRFieldDefnH16OGRJustification"></span><span id="OGR_Fld_SetJustify__OGRFieldDefnH.OGRJustification"></span><span class="target" id="ogr__api_8h_1ae4809f2fe957002b8e18aacc1bdca240"></span>void <code class="descname">OGR_Fld_SetJustify</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, <a class="reference internal" href="#_CPPv416OGRJustification" title="OGRJustification">OGRJustification</a> <em>eJustify</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_SetJustify13OGRFieldDefnH16OGRJustification" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the justification for this field. </p>
<p>Note: no driver is know to use the concept of field justification.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1acbd783e3b61ab388eab3f45c25cf1bc0"><span class="std std-ref">OGRFieldDefn::SetJustify()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to set justification to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eJustify</span></code>: the new justification. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_Fld_GetWidth13OGRFieldDefnH">
<span id="_CPPv316OGR_Fld_GetWidth13OGRFieldDefnH"></span><span id="_CPPv216OGR_Fld_GetWidth13OGRFieldDefnH"></span><span id="OGR_Fld_GetWidth__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1aa6500186e3f22761a615428c55bba0ce"></span>int <code class="descname">OGR_Fld_GetWidth</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_Fld_GetWidth13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the formatting width for this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1aa8c4090f59d60ca949ba3fd0eada9f36"><span class="std std-ref">OGRFieldDefn::GetWidth()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the width, zero means no specified width. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to get width from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_Fld_SetWidth13OGRFieldDefnHi">
<span id="_CPPv316OGR_Fld_SetWidth13OGRFieldDefnHi"></span><span id="_CPPv216OGR_Fld_SetWidth13OGRFieldDefnHi"></span><span id="OGR_Fld_SetWidth__OGRFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1a1d7bf7c14a299448efac58f7bf364326"></span>void <code class="descname">OGR_Fld_SetWidth</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, int <em>nNewWidth</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_Fld_SetWidth13OGRFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the formatting width for this field in characters. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1aa793194c45ccba5ec7e9f7aea49dc6f3"><span class="std std-ref">OGRFieldDefn::SetWidth()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to set width to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nNewWidth</span></code>: the new width. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_Fld_GetPrecision13OGRFieldDefnH">
<span id="_CPPv320OGR_Fld_GetPrecision13OGRFieldDefnH"></span><span id="_CPPv220OGR_Fld_GetPrecision13OGRFieldDefnH"></span><span id="OGR_Fld_GetPrecision__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a120dd56ee23070922e4d84ed06b06e27"></span>int <code class="descname">OGR_Fld_GetPrecision</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_Fld_GetPrecision13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the formatting precision for this field. </p>
<p>This should normally be zero for fields of types other than OFTReal.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a86337654bc490bdc3e3b17e292b09c4b"><span class="std std-ref">OGRFieldDefn::GetPrecision()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the precision. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to get precision from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_Fld_SetPrecision13OGRFieldDefnHi">
<span id="_CPPv320OGR_Fld_SetPrecision13OGRFieldDefnHi"></span><span id="_CPPv220OGR_Fld_SetPrecision13OGRFieldDefnHi"></span><span id="OGR_Fld_SetPrecision__OGRFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1a13890f01f7d7e57bcd07e23f3e2947da"></span>void <code class="descname">OGR_Fld_SetPrecision</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, int <em>nPrecision</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_Fld_SetPrecision13OGRFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the formatting precision for this field in characters. </p>
<p>This should normally be zero for fields of types other than OFTReal.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1abea88d3ed96c46b4f0eda415460f8664"><span class="std std-ref">OGRFieldDefn::SetPrecision()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to set precision to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPrecision</span></code>: the new precision. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_Fld_Set13OGRFieldDefnHPKc12OGRFieldTypeii16OGRJustification">
<span id="_CPPv311OGR_Fld_Set13OGRFieldDefnHPKc12OGRFieldTypeii16OGRJustification"></span><span id="_CPPv211OGR_Fld_Set13OGRFieldDefnHPKc12OGRFieldTypeii16OGRJustification"></span><span id="OGR_Fld_Set__OGRFieldDefnH.cCP.OGRFieldType.i.i.OGRJustification"></span><span class="target" id="ogr__api_8h_1a5922e599fe8746b81adf251be6b5ecf0"></span>void <code class="descname">OGR_Fld_Set</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, <em class="property">const</em> char *<em>pszNameIn</em>, <a class="reference internal" href="#_CPPv412OGRFieldType" title="OGRFieldType">OGRFieldType</a> <em>eTypeIn</em>, int <em>nWidthIn</em>, int <em>nPrecisionIn</em>, <a class="reference internal" href="#_CPPv416OGRJustification" title="OGRJustification">OGRJustification</a> <em>eJustifyIn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_Fld_Set13OGRFieldDefnHPKc12OGRFieldTypeii16OGRJustification" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set defining parameters for a field in one call. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a9b08b348f111ecbfe2970b312d9ce54b"><span class="std std-ref">OGRFieldDefn::Set()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition to set to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNameIn</span></code>: the new name to assign. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eTypeIn</span></code>: the new type (one of the OFT values like OFTInteger). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nWidthIn</span></code>: the preferred formatting width. Defaults to zero indicating undefined. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPrecisionIn</span></code>: number of decimals places for formatting, defaults to zero indicating undefined. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eJustifyIn</span></code>: the formatting justification (OJLeft or OJRight), defaults to OJUndefined. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_Fld_IsIgnored13OGRFieldDefnH">
<span id="_CPPv317OGR_Fld_IsIgnored13OGRFieldDefnH"></span><span id="_CPPv217OGR_Fld_IsIgnored13OGRFieldDefnH"></span><span id="OGR_Fld_IsIgnored__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a29bec35ae5a4c232ad850315bdc2b675"></span>int <code class="descname">OGR_Fld_IsIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_Fld_IsIgnored13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1ae55ec65c6013cfbf0bd08b7acecb0b9f"><span class="std std-ref">OGRFieldDefn::IsIgnored()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ignore state </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_SetIgnored13OGRFieldDefnHi">
<span id="_CPPv318OGR_Fld_SetIgnored13OGRFieldDefnHi"></span><span id="_CPPv218OGR_Fld_SetIgnored13OGRFieldDefnHi"></span><span id="OGR_Fld_SetIgnored__OGRFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1aeddf9aa9767cd28c90dc66ed2a7a7332"></span>void <code class="descname">OGR_Fld_SetIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, int <em>ignore</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_SetIgnored13OGRFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a5d8df84c8a8d87908b8416fef6913934"><span class="std std-ref">OGRFieldDefn::SetIgnored()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore</span></code>: ignore state </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_IsNullable13OGRFieldDefnH">
<span id="_CPPv318OGR_Fld_IsNullable13OGRFieldDefnH"></span><span id="_CPPv218OGR_Fld_IsNullable13OGRFieldDefnH"></span><span id="OGR_Fld_IsNullable__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a57bfc414977d37ee22edefd38c1f414b"></span>int <code class="descname">OGR_Fld_IsNullable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_IsNullable13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether this field can receive null values. </p>
<p>By default, fields are nullable.</p>
<p>Even if this method returns FALSE (i.e not-nullable field), it doesn’t mean that <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a905bb73fe5e6df57f1be5a8b77489b74"><span class="std std-ref">OGRFeature::IsFieldSet()</span></a> will necessary return TRUE, as fields can be temporary unset and null/not-null validation is usually done when <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a5d6db0be3b8876142d54e8bfd5dc8324"><span class="std std-ref">OGRLayer::CreateFeature()</span></a>/SetFeature() is called.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a0a610ad741b9a6d81689de70133937d0"><span class="std std-ref">OGRFieldDefn::IsNullable()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the field is authorized to be null. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_Fld_SetNullable13OGRFieldDefnHi">
<span id="_CPPv319OGR_Fld_SetNullable13OGRFieldDefnHi"></span><span id="_CPPv219OGR_Fld_SetNullable13OGRFieldDefnHi"></span><span id="OGR_Fld_SetNullable__OGRFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1a9a35def2d6766804a59f0b4c24e457d5"></span>void <code class="descname">OGR_Fld_SetNullable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, int <em>bNullableIn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_Fld_SetNullable13OGRFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set whether this field can receive null values. </p>
<p>By default, fields are nullable, so this method is generally called with FALSE to set a not-null constraint.</p>
<p>Drivers that support writing not-null constraint will advertise the GDAL_DCAP_NOTNULL_FIELDS driver metadata item.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1ac10a3da064cd17f9b5d377b690d3162c"><span class="std std-ref">OGRFieldDefn::SetNullable()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bNullableIn</span></code>: FALSE if the field must have a not-null constraint. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_GetDefault13OGRFieldDefnH">
<span id="_CPPv318OGR_Fld_GetDefault13OGRFieldDefnH"></span><span id="_CPPv218OGR_Fld_GetDefault13OGRFieldDefnH"></span><span id="OGR_Fld_GetDefault__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1aacc96ddb37f8b8076e711e48ee9ead62"></span><em class="property">const</em> char *<code class="descname">OGR_Fld_GetDefault</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_GetDefault13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get default field value. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1ac4210fa7c6f10ed090a5558224447cfa"><span class="std std-ref">OGRFieldDefn::GetDefault()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>default field value or NULL. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_Fld_SetDefault13OGRFieldDefnHPKc">
<span id="_CPPv318OGR_Fld_SetDefault13OGRFieldDefnHPKc"></span><span id="_CPPv218OGR_Fld_SetDefault13OGRFieldDefnHPKc"></span><span id="OGR_Fld_SetDefault__OGRFieldDefnH.cCP"></span><span class="target" id="ogr__api_8h_1aa0268ee60f240e6fa668b7c612354f80"></span>void <code class="descname">OGR_Fld_SetDefault</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em>, <em class="property">const</em> char *<em>pszDefault</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_Fld_SetDefault13OGRFieldDefnHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set default field value. </p>
<p>The default field value is taken into account by drivers (generally those with a SQL interface) that support it at field creation time. OGR will generally not automatically set the default field value to null fields by itself when calling <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a0ef4455f24cfbec6cf37110f9116cf15"><span class="std std-ref">OGRFeature::CreateFeature()</span></a> / OGRFeature::SetFeature(), but will let the low-level layers to do the job. So retrieving the feature from the layer is recommended.</p>
<p>The accepted values are NULL, a numeric value, a literal value enclosed between single quote characters (and inner single quote characters escaped by repetition of the single quote character), CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or a driver specific expression (that might be ignored by other drivers). For a datetime literal value, format should be ‘YYYY/MM/DD HH:MM:SS[.sss]’ (considered as UTC time).</p>
<p>Drivers that support writing DEFAULT clauses will advertise the GDAL_DCAP_DEFAULT_FIELDS driver metadata item.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a2371ed1f14f00bd9aa9ee4bce11dd768"><span class="std std-ref">OGRFieldDefn::SetDefault()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDefault</span></code>: new default field value or NULL pointer.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv431OGR_Fld_IsDefaultDriverSpecific13OGRFieldDefnH">
<span id="_CPPv331OGR_Fld_IsDefaultDriverSpecific13OGRFieldDefnH"></span><span id="_CPPv231OGR_Fld_IsDefaultDriverSpecific13OGRFieldDefnH"></span><span id="OGR_Fld_IsDefaultDriverSpecific__OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a4bf08ca1607bdc678f2ae166ad0f27e2"></span>int <code class="descname">OGR_Fld_IsDefaultDriverSpecific</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431OGR_Fld_IsDefaultDriverSpecific13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the default value is driver specific. </p>
<p>Driver specific default values are those that are <em>not</em> NULL, a numeric value, a literal value enclosed between single quote characters, CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal value.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a979f31c748be9d066c888c549e410876"><span class="std std-ref">OGRFieldDefn::IsDefaultDriverSpecific()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the default value is driver specific. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_GetFieldTypeName12OGRFieldType">
<span id="_CPPv320OGR_GetFieldTypeName12OGRFieldType"></span><span id="_CPPv220OGR_GetFieldTypeName12OGRFieldType"></span><span id="OGR_GetFieldTypeName__OGRFieldType"></span><span class="target" id="ogr__api_8h_1af1e61b89ae2d799cf5e217d01ef7b415"></span><em class="property">const</em> char *<code class="descname">OGR_GetFieldTypeName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRFieldType" title="OGRFieldType">OGRFieldType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_GetFieldTypeName12OGRFieldType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch human readable name for a field type. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1afc2a020f72be8296b6e09f5ab979f930"><span class="std std-ref">OGRFieldDefn::GetFieldTypeName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the name. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the field type to get name for. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_GetFieldSubTypeName15OGRFieldSubType">
<span id="_CPPv323OGR_GetFieldSubTypeName15OGRFieldSubType"></span><span id="_CPPv223OGR_GetFieldSubTypeName15OGRFieldSubType"></span><span id="OGR_GetFieldSubTypeName__OGRFieldSubType"></span><span class="target" id="ogr__api_8h_1a9611cba58f204544ecad73fd8defe3f3"></span><em class="property">const</em> char *<code class="descname">OGR_GetFieldSubTypeName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFieldSubType" title="OGRFieldSubType">OGRFieldSubType</a> <em>eSubType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_GetFieldSubTypeName15OGRFieldSubType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch human readable name for a field subtype. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn_1a51ec3ceae06d8a5113fc2a8e2e52e954"><span class="std std-ref">OGRFieldDefn::GetFieldSubTypeName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the name.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eSubType</span></code>: the field subtype to get name for. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_AreTypeSubTypeCompatible12OGRFieldType15OGRFieldSubType">
<span id="_CPPv328OGR_AreTypeSubTypeCompatible12OGRFieldType15OGRFieldSubType"></span><span id="_CPPv228OGR_AreTypeSubTypeCompatible12OGRFieldType15OGRFieldSubType"></span><span id="OGR_AreTypeSubTypeCompatible__OGRFieldType.OGRFieldSubType"></span><span class="target" id="ogr__api_8h_1a3f3caffcd90d58c859cb51adef4c6c5d"></span>int <code class="descname">OGR_AreTypeSubTypeCompatible</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRFieldType" title="OGRFieldType">OGRFieldType</a> <em>eType</em>, <a class="reference internal" href="#_CPPv415OGRFieldSubType" title="OGRFieldSubType">OGRFieldSubType</a> <em>eSubType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_AreTypeSubTypeCompatible12OGRFieldType15OGRFieldSubType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return if type and subtype are compatible. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if type and subtype are compatible</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the field type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eSubType</span></code>: the field subtype. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_GFld_CreatePKc18OGRwkbGeometryType">
<span id="_CPPv315OGR_GFld_CreatePKc18OGRwkbGeometryType"></span><span id="_CPPv215OGR_GFld_CreatePKc18OGRwkbGeometryType"></span><span id="OGR_GFld_Create__cCP.OGRwkbGeometryType"></span><span class="target" id="ogr__api_8h_1a4681750642cae49933ba4fc962744b78"></span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <code class="descname">OGR_GFld_Create</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_GFld_CreatePKc18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new field geometry definition. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1ac69cdfca5b480465569b88bc4f9f7765"><span class="std std-ref">OGRGeomFieldDefn::OGRGeomFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle to the new field definition.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the new field definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the type of the new field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_GFld_Destroy17OGRGeomFieldDefnH">
<span id="_CPPv316OGR_GFld_Destroy17OGRGeomFieldDefnH"></span><span id="_CPPv216OGR_GFld_Destroy17OGRGeomFieldDefnH"></span><span id="OGR_GFld_Destroy__OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1a0f3e65993ea2b8b907e43ffa8b106871"></span>void <code class="descname">OGR_GFld_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_GFld_Destroy17OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy a geometry field definition. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition to destroy.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_GFld_SetName17OGRGeomFieldDefnHPKc">
<span id="_CPPv316OGR_GFld_SetName17OGRGeomFieldDefnHPKc"></span><span id="_CPPv216OGR_GFld_SetName17OGRGeomFieldDefnHPKc"></span><span id="OGR_GFld_SetName__OGRGeomFieldDefnH.cCP"></span><span class="target" id="ogr__api_8h_1a6c9b9d56381cae346c5129943641f628"></span>void <code class="descname">OGR_GFld_SetName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_GFld_SetName17OGRGeomFieldDefnHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1ae3ca3a2ccdea222a2675cd0f7eeb57f7"><span class="std std-ref">OGRGeomFieldDefn::SetName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition to apply the new name to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the new name to apply.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_GFld_GetNameRef17OGRGeomFieldDefnH">
<span id="_CPPv319OGR_GFld_GetNameRef17OGRGeomFieldDefnH"></span><span id="_CPPv219OGR_GFld_GetNameRef17OGRGeomFieldDefnH"></span><span id="OGR_GFld_GetNameRef__OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1ad9914366a6cc3b4169a3359c2b1ef614"></span><em class="property">const</em> char *<code class="descname">OGR_GFld_GetNameRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_GFld_GetNameRef17OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1afee61d406460dd46eeaa48a77f477991"><span class="std std-ref">OGRGeomFieldDefn::GetNameRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the name of the geometry field definition.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_GFld_GetType17OGRGeomFieldDefnH">
<span id="_CPPv316OGR_GFld_GetType17OGRGeomFieldDefnH"></span><span id="_CPPv216OGR_GFld_GetType17OGRGeomFieldDefnH"></span><span id="OGR_GFld_GetType__OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1a323f4350c2e90c6e67df37f68d244a0d"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_GFld_GetType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_GFld_GetType17OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch geometry type of this field. </p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1ac06e4141dee676afc00d33166c01d13f"><span class="std std-ref">OGRGeomFieldDefn::GetType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>field geometry type.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition to get type from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_GFld_SetType17OGRGeomFieldDefnH18OGRwkbGeometryType">
<span id="_CPPv316OGR_GFld_SetType17OGRGeomFieldDefnH18OGRwkbGeometryType"></span><span id="_CPPv216OGR_GFld_SetType17OGRGeomFieldDefnH18OGRwkbGeometryType"></span><span id="OGR_GFld_SetType__OGRGeomFieldDefnH.OGRwkbGeometryType"></span><span class="target" id="ogr__api_8h_1affb3691474967ca5f0c9789e0626d55f"></span>void <code class="descname">OGR_GFld_SetType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_GFld_SetType17OGRGeomFieldDefnH18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the geometry type of this field. </p>
<p>This should never be done to an <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn"><span class="std std-ref">OGRGeomFieldDefn</span></a> that is already part of an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>.</p>
<p>This function is the same as the CPP method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1a9b030e08d01a09b1917c1d01638a4ac8"><span class="std std-ref">OGRGeomFieldDefn::SetType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition to set type to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the new field geometry type.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_GFld_GetSpatialRef17OGRGeomFieldDefnH">
<span id="_CPPv322OGR_GFld_GetSpatialRef17OGRGeomFieldDefnH"></span><span id="_CPPv222OGR_GFld_GetSpatialRef17OGRGeomFieldDefnH"></span><span id="OGR_GFld_GetSpatialRef__OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1a7927b11a85659d8ce6da8857f52b05c4"></span><a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <code class="descname">OGR_GFld_GetSpatialRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_GFld_GetSpatialRef17OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch spatial reference system of this field. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1acf7ddda34f67658433de5ccaedcd91e9"><span class="std std-ref">OGRGeomFieldDefn::GetSpatialRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>field spatial reference system.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_GFld_SetSpatialRef17OGRGeomFieldDefnH20OGRSpatialReferenceH">
<span id="_CPPv322OGR_GFld_SetSpatialRef17OGRGeomFieldDefnH20OGRSpatialReferenceH"></span><span id="_CPPv222OGR_GFld_SetSpatialRef17OGRGeomFieldDefnH20OGRSpatialReferenceH"></span><span id="OGR_GFld_SetSpatialRef__OGRGeomFieldDefnH.OGRSpatialReferenceH"></span><span class="target" id="ogr__api_8h_1aa717acc8f4f5f33825334fe72edc2be9"></span>void <code class="descname">OGR_GFld_SetSpatialRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSRS</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_GFld_SetSpatialRef17OGRGeomFieldDefnH20OGRSpatialReferenceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the spatial reference of this field. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1a4a00f45c93467aa5f85d3c01c4dd4cec"><span class="std std-ref">OGRGeomFieldDefn::SetSpatialRef()</span></a>.</p>
<p>This function drops the reference of the previously set SRS object and acquires a new reference on the passed object (if non-NULL).</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSRS</span></code>: the new SRS to apply.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_GFld_IsNullable17OGRGeomFieldDefnH">
<span id="_CPPv319OGR_GFld_IsNullable17OGRGeomFieldDefnH"></span><span id="_CPPv219OGR_GFld_IsNullable17OGRGeomFieldDefnH"></span><span id="OGR_GFld_IsNullable__OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1a9bfbda2b68e11227611ff74ee0105d47"></span>int <code class="descname">OGR_GFld_IsNullable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_GFld_IsNullable17OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether this geometry field can receive null values. </p>
<p>By default, fields are nullable.</p>
<p>Even if this method returns FALSE (i.e not-nullable field), it doesn’t mean that <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a905bb73fe5e6df57f1be5a8b77489b74"><span class="std std-ref">OGRFeature::IsFieldSet()</span></a> will necessary return TRUE, as fields can be temporary unset and null/not-null validation is usually done when <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a5d6db0be3b8876142d54e8bfd5dc8324"><span class="std std-ref">OGRLayer::CreateFeature()</span></a>/SetFeature() is called.</p>
<p>Note that not-nullable geometry fields might also contain ‘empty’ geometries.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1a7c56d7cea54c57f9be60b0b76f9a03ff"><span class="std std-ref">OGRGeomFieldDefn::IsNullable()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the field is authorized to be null. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_GFld_SetNullable17OGRGeomFieldDefnHi">
<span id="_CPPv320OGR_GFld_SetNullable17OGRGeomFieldDefnHi"></span><span id="_CPPv220OGR_GFld_SetNullable17OGRGeomFieldDefnHi"></span><span id="OGR_GFld_SetNullable__OGRGeomFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"></span>void <code class="descname">OGR_GFld_SetNullable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em>, int <em>bNullableIn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_GFld_SetNullable17OGRGeomFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set whether this geometry field can receive null values. </p>
<p>By default, fields are nullable, so this method is generally called with FALSE to set a not-null constraint.</p>
<p>Drivers that support writing not-null constraint will advertise the GDAL_DCAP_NOTNULL_GEOMFIELDS driver metadata item.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1aac631bcd6cd10d531aa11062c9f2453c"><span class="std std-ref">OGRGeomFieldDefn::SetNullable()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the field definition </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bNullableIn</span></code>: FALSE if the field must have a not-null constraint. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_GFld_IsIgnored17OGRGeomFieldDefnH">
<span id="_CPPv318OGR_GFld_IsIgnored17OGRGeomFieldDefnH"></span><span id="_CPPv218OGR_GFld_IsIgnored17OGRGeomFieldDefnH"></span><span id="OGR_GFld_IsIgnored__OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1ab232798830d8dcae0742d83948e33d1a"></span>int <code class="descname">OGR_GFld_IsIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_GFld_IsIgnored17OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1aec9839abc6fa2633310ef691d753329a"><span class="std std-ref">OGRGeomFieldDefn::IsIgnored()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ignore state</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_GFld_SetIgnored17OGRGeomFieldDefnHi">
<span id="_CPPv319OGR_GFld_SetIgnored17OGRGeomFieldDefnHi"></span><span id="_CPPv219OGR_GFld_SetIgnored17OGRGeomFieldDefnHi"></span><span id="OGR_GFld_SetIgnored__OGRGeomFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1af3a4e5e2af01140209e9d2814869eb41"></span>void <code class="descname">OGR_GFld_SetIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hDefn</em>, int <em>ignore</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_GFld_SetIgnored17OGRGeomFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1a0266cdd27bf12420f0eb2107091a49b7"><span class="std std-ref">OGRGeomFieldDefn::SetIgnored()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the geometry field definition </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore</span></code>: ignore state</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_FD_CreatePKc">
<span id="_CPPv313OGR_FD_CreatePKc"></span><span id="_CPPv213OGR_FD_CreatePKc"></span><span id="OGR_FD_Create__cCP"></span><span class="target" id="ogr__api_8h_1a8cbc5146fcab99667f021c40c714628c"></span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <code class="descname">OGR_FD_Create</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_FD_CreatePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new feature definition object to hold the field definitions. </p>
<p>The <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> maintains a reference count, but this starts at zero, and should normally be incremented by the owner.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1ada5564d238a73a8c98b30807c4c8db73"><span class="std std-ref">OGRFeatureDefn::OGRFeatureDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle to the newly created feature definition. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name to be assigned to this layer/class. It does not need to be unique. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_FD_Destroy15OGRFeatureDefnH">
<span id="_CPPv314OGR_FD_Destroy15OGRFeatureDefnH"></span><span id="_CPPv214OGR_FD_Destroy15OGRFeatureDefnH"></span><span id="OGR_FD_Destroy__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a59d5cbb660cce8467a210caa4d68a011"></span>void <code class="descname">OGR_FD_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_FD_Destroy15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy a feature definition object and release all memory associated with it. </p>
<p>This function is the same as the C++ method OGRFeatureDefn::~OGRFeatureDefn().</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to be destroyed. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_FD_Release15OGRFeatureDefnH">
<span id="_CPPv314OGR_FD_Release15OGRFeatureDefnH"></span><span id="_CPPv214OGR_FD_Release15OGRFeatureDefnH"></span><span id="OGR_FD_Release__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a0755b0360414095e15eaf2c1496f8c47"></span>void <code class="descname">OGR_FD_Release</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_FD_Release15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Drop a reference, and destroy if unreferenced. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a75e1424e3ce755d4393f5b42736d13ee"><span class="std std-ref">OGRFeatureDefn::Release()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to be released. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_FD_GetName15OGRFeatureDefnH">
<span id="_CPPv314OGR_FD_GetName15OGRFeatureDefnH"></span><span id="_CPPv214OGR_FD_GetName15OGRFeatureDefnH"></span><span id="OGR_FD_GetName__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a20f309bf10e5b76cc083848b710babb8"></span><em class="property">const</em> char *<code class="descname">OGR_FD_GetName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_FD_GetName15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get name of the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> passed as an argument. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1ab8fa2428efb085a0b5dd78342b535aeb"><span class="std std-ref">OGRFeatureDefn::GetName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the name. This name is internal and should not be modified, or freed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get the name from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_FD_GetFieldCount15OGRFeatureDefnH">
<span id="_CPPv320OGR_FD_GetFieldCount15OGRFeatureDefnH"></span><span id="_CPPv220OGR_FD_GetFieldCount15OGRFeatureDefnH"></span><span id="OGR_FD_GetFieldCount__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a586a14271a457387a2b5c0097a02c8da"></span>int <code class="descname">OGR_FD_GetFieldCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_FD_GetFieldCount15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch number of fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a3abba98e1e957a01b3af0b9e0f73f493"><span class="std std-ref">OGRFeatureDefn::GetFieldCount()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>count of fields. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get the fields count from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_FD_GetFieldDefn15OGRFeatureDefnHi">
<span id="_CPPv319OGR_FD_GetFieldDefn15OGRFeatureDefnHi"></span><span id="_CPPv219OGR_FD_GetFieldDefn15OGRFeatureDefnHi"></span><span id="OGR_FD_GetFieldDefn__OGRFeatureDefnH.i"></span><span class="target" id="ogr__api_8h_1a484456df86a01284769d0afe3beaa4f6"></span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <code class="descname">OGR_FD_GetFieldDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_FD_GetFieldDefn15OGRFeatureDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a43b95ce699bbca73acb453cc959378e7"><span class="std std-ref">OGRFeatureDefn::GetFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get the field definition from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, between 0 and GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_FD_GetFieldIndex15OGRFeatureDefnHPKc">
<span id="_CPPv320OGR_FD_GetFieldIndex15OGRFeatureDefnHPKc"></span><span id="_CPPv220OGR_FD_GetFieldIndex15OGRFeatureDefnHPKc"></span><span id="OGR_FD_GetFieldIndex__OGRFeatureDefnH.cCP"></span><span class="target" id="ogr__api_8h_1a1e54c3271dce0562209d78ae6eaae330"></span>int <code class="descname">OGR_FD_GetFieldIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, <em class="property">const</em> char *<em>pszFieldName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_FD_GetFieldIndex15OGRFeatureDefnHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find field by name. </p>
<p>The field index of the first field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1adf94fefd88e82172e5279f5188b3873b"><span class="std std-ref">OGRFeatureDefn::GetFieldIndex</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field index, or -1 if no match found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get field index from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFieldName</span></code>: the field name to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_FD_AddFieldDefn15OGRFeatureDefnH13OGRFieldDefnH">
<span id="_CPPv319OGR_FD_AddFieldDefn15OGRFeatureDefnH13OGRFieldDefnH"></span><span id="_CPPv219OGR_FD_AddFieldDefn15OGRFeatureDefnH13OGRFieldDefnH"></span><span id="OGR_FD_AddFieldDefn__OGRFeatureDefnH.OGRFieldDefnH"></span><span class="target" id="ogr__api_8h_1a2a798e8d03299403418a7c87862f1acb"></span>void <code class="descname">OGR_FD_AddFieldDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, <a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hNewField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_FD_AddFieldDefn15OGRFeatureDefnH13OGRFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="reference internal" href="#ogr__api_8h_1aab585ef1166c61c4819f7fd46ee4a275"><span class="std std-ref">OGR_L_CreateField()</span></a> instead.</p>
<p>This function should only be called while there are no <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> objects in existence based on this <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>. The <a class="reference internal" href="ogrfeature_cpp.html#classOGRFieldDefn"><span class="std std-ref">OGRFieldDefn</span></a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a40e681d8464b42f1a1fac655f16ac3dd"><span class="std std-ref">OGRFeatureDefn::AddFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to add the field definition to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hNewField</span></code>: handle to the new field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_FD_DeleteFieldDefn15OGRFeatureDefnHi">
<span id="_CPPv322OGR_FD_DeleteFieldDefn15OGRFeatureDefnHi"></span><span id="_CPPv222OGR_FD_DeleteFieldDefn15OGRFeatureDefnHi"></span><span id="OGR_FD_DeleteFieldDefn__OGRFeatureDefnH.i"></span><span class="target" id="ogr__api_8h_1a6283475163d911204f5ff45098c8479e"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_FD_DeleteFieldDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_FD_DeleteFieldDefn15OGRFeatureDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete an existing field definition. </p>
<p>To delete an existing field definition from a layer definition, do not use this function directly, but use <a class="reference internal" href="#ogr__api_8h_1afc861413683418eba5d31e487da2f9e2"><span class="std std-ref">OGR_L_DeleteField()</span></a> instead.</p>
<p>This method should only be called while there are no <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> objects in existence based on this <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1ada48e1a3e90798bdccc2dd26f32f48cb"><span class="std std-ref">OGRFeatureDefn::DeleteFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE in case of success. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the index of the field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_FD_ReorderFieldDefns15OGRFeatureDefnHPi">
<span id="_CPPv324OGR_FD_ReorderFieldDefns15OGRFeatureDefnHPi"></span><span id="_CPPv224OGR_FD_ReorderFieldDefns15OGRFeatureDefnHPi"></span><span id="OGR_FD_ReorderFieldDefns__OGRFeatureDefnH.iP"></span><span class="target" id="ogr__api_8h_1a87da23094f3473a9a11bf2fdb6fd2dc4"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_FD_ReorderFieldDefns</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, int *<em>panMap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_FD_ReorderFieldDefns15OGRFeatureDefnHPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorder the field definitions in the array of the feature definition. </p>
<p>To reorder the field definitions in a layer definition, do not use this function directly, but use <a class="reference internal" href="#ogr__api_8h_1a4cc576cb39e1dd4a1f074125199245bb"><span class="std std-ref">OGR_L_ReorderFields()</span></a> instead.</p>
<p>This method should only be called while there are no <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> objects in existence based on this <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a9abb45931317ea5e6c62f4954451dba4"><span class="std std-ref">OGRFeatureDefn::ReorderFieldDefns()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE in case of success. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 2.1.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panMap</span></code>: an array of GetFieldCount() elements which is a permutation of [0, GetFieldCount()-1]. panMap is such that, for each field definition at position i after reordering, its position before reordering was panMap[i]. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_FD_GetGeomType15OGRFeatureDefnH">
<span id="_CPPv318OGR_FD_GetGeomType15OGRFeatureDefnH"></span><span id="_CPPv218OGR_FD_GetGeomType15OGRFeatureDefnH"></span><span id="OGR_FD_GetGeomType__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1add0b3a6b6062122e4f4316d194d2a1cf"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_FD_GetGeomType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_FD_GetGeomType15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the geometry base type of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1acc3e3904d856b9c8b5b26204c68e916a"><span class="std std-ref">OGRFeatureDefn::GetGeomType()</span></a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;GetType().</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the base type for all geometry related to this definition. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get the geometry type from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_FD_SetGeomType15OGRFeatureDefnH18OGRwkbGeometryType">
<span id="_CPPv318OGR_FD_SetGeomType15OGRFeatureDefnH18OGRwkbGeometryType"></span><span id="_CPPv218OGR_FD_SetGeomType15OGRFeatureDefnH18OGRwkbGeometryType"></span><span id="OGR_FD_SetGeomType__OGRFeatureDefnH.OGRwkbGeometryType"></span><span class="target" id="ogr__api_8h_1a11ca3a84b54ac36c5f68a03821f1fa78"></span>void <code class="descname">OGR_FD_SetGeomType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_FD_SetGeomType15OGRFeatureDefnH18OGRwkbGeometryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign the base geometry type for the passed layer (the same as the feature definition). </p>
<p>All geometry objects using this type must be of the defined type or a derived type. The default upon creation is wkbUnknown which allows for any geometry type. The geometry type should generally not be changed after any OGRFeatures have been created against this definition.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1aa0f50b39efbba6559a510d7afcfa5efb"><span class="std std-ref">OGRFeatureDefn::SetGeomType()</span></a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetType().</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the layer or feature definition to set the geometry type to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the new type to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_FD_IsGeometryIgnored15OGRFeatureDefnH">
<span id="_CPPv324OGR_FD_IsGeometryIgnored15OGRFeatureDefnH"></span><span id="_CPPv224OGR_FD_IsGeometryIgnored15OGRFeatureDefnH"></span><span id="OGR_FD_IsGeometryIgnored__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1ad1208985f67db526136dbe74f490c8d3"></span>int <code class="descname">OGR_FD_IsGeometryIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_FD_IsGeometryIgnored15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1ab64252824a66afa3e1ada210a1f29d28"><span class="std std-ref">OGRFeatureDefn::IsGeometryIgnored()</span></a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;IsIgnored().</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ignore state </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition on witch <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_FD_SetGeometryIgnored15OGRFeatureDefnHi">
<span id="_CPPv325OGR_FD_SetGeometryIgnored15OGRFeatureDefnHi"></span><span id="_CPPv225OGR_FD_SetGeometryIgnored15OGRFeatureDefnHi"></span><span id="OGR_FD_SetGeometryIgnored__OGRFeatureDefnH.i"></span><span class="target" id="ogr__api_8h_1a1bbc85e1ba2378679e4ce6bf3523bf8e"></span>void <code class="descname">OGR_FD_SetGeometryIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, int <em>bIgnore</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_FD_SetGeometryIgnored15OGRFeatureDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a539b87cd1587dc928b246a211839e22a"><span class="std std-ref">OGRFeatureDefn::SetGeometryIgnored()</span></a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetIgnored().</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition on witch <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bIgnore</span></code>: ignore state </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_FD_IsStyleIgnored15OGRFeatureDefnH">
<span id="_CPPv321OGR_FD_IsStyleIgnored15OGRFeatureDefnH"></span><span id="_CPPv221OGR_FD_IsStyleIgnored15OGRFeatureDefnH"></span><span id="OGR_FD_IsStyleIgnored__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1aa9490e3e5d25b780723ad3f0ab3302eb"></span>int <code class="descname">OGR_FD_IsStyleIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_FD_IsStyleIgnored15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a7edc3d1a8add158e00475faec76c036a"><span class="std std-ref">OGRFeatureDefn::IsStyleIgnored()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ignore state </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition on which <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_FD_SetStyleIgnored15OGRFeatureDefnHi">
<span id="_CPPv322OGR_FD_SetStyleIgnored15OGRFeatureDefnHi"></span><span id="_CPPv222OGR_FD_SetStyleIgnored15OGRFeatureDefnHi"></span><span id="OGR_FD_SetStyleIgnored__OGRFeatureDefnH.i"></span><span class="target" id="ogr__api_8h_1a6c09218e9ef9e49abcdd0b76858a514b"></span>void <code class="descname">OGR_FD_SetStyleIgnored</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em>, int <em>bIgnore</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_FD_SetStyleIgnored15OGRFeatureDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a18e45edc2008f3a73e8bf4fed39fddd9"><span class="std std-ref">OGRFeatureDefn::SetStyleIgnored()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition on witch <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bIgnore</span></code>: ignore state </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_FD_Reference15OGRFeatureDefnH">
<span id="_CPPv316OGR_FD_Reference15OGRFeatureDefnH"></span><span id="_CPPv216OGR_FD_Reference15OGRFeatureDefnH"></span><span id="OGR_FD_Reference__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a6763104e7fafcab1b52d9b0f275e19e8"></span>int <code class="descname">OGR_FD_Reference</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_FD_Reference15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increments the reference count by one. </p>
<p>The reference count is used keep track of the number of <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> objects referencing this definition.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a2c58c6238242dff3d472faf5e3803922"><span class="std std-ref">OGRFeatureDefn::Reference()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the updated reference count. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition on witch <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_FD_Dereference15OGRFeatureDefnH">
<span id="_CPPv318OGR_FD_Dereference15OGRFeatureDefnH"></span><span id="_CPPv218OGR_FD_Dereference15OGRFeatureDefnH"></span><span id="OGR_FD_Dereference__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a107635936c90c7f4347d7b3f9fb06e6d"></span>int <code class="descname">OGR_FD_Dereference</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_FD_Dereference15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decrements the reference count by one. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a87a280dd42634206dfbcfc47b1ecfea4"><span class="std std-ref">OGRFeatureDefn::Dereference()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the updated reference count. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition on witch <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_FD_GetReferenceCount15OGRFeatureDefnH">
<span id="_CPPv324OGR_FD_GetReferenceCount15OGRFeatureDefnH"></span><span id="_CPPv224OGR_FD_GetReferenceCount15OGRFeatureDefnH"></span><span id="OGR_FD_GetReferenceCount__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a9e4e8867edeaf1a6f98e6ff284835811"></span>int <code class="descname">OGR_FD_GetReferenceCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_FD_GetReferenceCount15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch current reference count. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1aedb957000f22445d536d89c566f32526"><span class="std std-ref">OGRFeatureDefn::GetReferenceCount()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the current reference count. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition on witch <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_FD_GetGeomFieldCount15OGRFeatureDefnH">
<span id="_CPPv324OGR_FD_GetGeomFieldCount15OGRFeatureDefnH"></span><span id="_CPPv224OGR_FD_GetGeomFieldCount15OGRFeatureDefnH"></span><span id="OGR_FD_GetGeomFieldCount__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a0b34027b691ea40e20b911290f863303"></span>int <code class="descname">OGR_FD_GetGeomFieldCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hFDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_FD_GetGeomFieldCount15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch number of geometry fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1ad5e568a81eca8d6101ae4475b653f1c9"><span class="std std-ref">OGRFeatureDefn::GetGeomFieldCount()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>count of geometry fields.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get the fields count from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_FD_GetGeomFieldDefn15OGRFeatureDefnHi">
<span id="_CPPv323OGR_FD_GetGeomFieldDefn15OGRFeatureDefnHi"></span><span id="_CPPv223OGR_FD_GetGeomFieldDefn15OGRFeatureDefnHi"></span><span id="OGR_FD_GetGeomFieldDefn__OGRFeatureDefnH.i"></span><span class="target" id="ogr__api_8h_1a82275ef1d2655817f6fe582f885c92c7"></span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <code class="descname">OGR_FD_GetGeomFieldDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hFDefn</em>, int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_FD_GetGeomFieldDefn15OGRFeatureDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch geometry field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1acacca3de3718ae525565e5130b5474dc"><span class="std std-ref">OGRFeatureDefn::GetGeomFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get the field definition from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iGeomField</span></code>: the geometry field to fetch, between 0 and GetGeomFieldCount() - 1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_FD_GetGeomFieldIndex15OGRFeatureDefnHPKc">
<span id="_CPPv324OGR_FD_GetGeomFieldIndex15OGRFeatureDefnHPKc"></span><span id="_CPPv224OGR_FD_GetGeomFieldIndex15OGRFeatureDefnHPKc"></span><span id="OGR_FD_GetGeomFieldIndex__OGRFeatureDefnH.cCP"></span><span class="target" id="ogr__api_8h_1a69be97ea100c50bdaad8a1d3c30e7b14"></span>int <code class="descname">OGR_FD_GetGeomFieldIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hFDefn</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_FD_GetGeomFieldIndex15OGRFeatureDefnHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find geometry field by name. </p>
<p>The geometry field index of the first geometry field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1af033ae277fade415ff13ed8b5643e4be"><span class="std std-ref">OGRFeatureDefn::GetGeomFieldIndex</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the geometry field index, or -1 if no match found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to get field index from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszGeomFieldName</span></code>: the geometry field name to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_FD_AddGeomFieldDefn15OGRFeatureDefnH17OGRGeomFieldDefnH">
<span id="_CPPv323OGR_FD_AddGeomFieldDefn15OGRFeatureDefnH17OGRGeomFieldDefnH"></span><span id="_CPPv223OGR_FD_AddGeomFieldDefn15OGRFeatureDefnH17OGRGeomFieldDefnH"></span><span id="OGR_FD_AddGeomFieldDefn__OGRFeatureDefnH.OGRGeomFieldDefnH"></span><span class="target" id="ogr__api_8h_1aa080fdbe88c1829c1b7adcce208ec4b8"></span>void <code class="descname">OGR_FD_AddGeomFieldDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hFDefn</em>, <a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hGFldDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_FD_AddGeomFieldDefn15OGRFeatureDefnH17OGRGeomFieldDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="reference internal" href="#ogr__api_8h_1af6908931c4f3ad364fef8d6e831363bc"><span class="std std-ref">OGR_L_CreateGeomField()</span></a> instead.</p>
<p>This function should only be called while there are no <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> objects in existence based on this <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>. The <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn"><span class="std std-ref">OGRGeomFieldDefn</span></a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a99700a7f755c91c3382eaa65bc49f4f9"><span class="std std-ref">OGRFeatureDefn::AddGeomFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition to add the geometry field definition to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hNewGeomField</span></code>: handle to the new field definition.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_FD_DeleteGeomFieldDefn15OGRFeatureDefnHi">
<span id="_CPPv326OGR_FD_DeleteGeomFieldDefn15OGRFeatureDefnHi"></span><span id="_CPPv226OGR_FD_DeleteGeomFieldDefn15OGRFeatureDefnHi"></span><span id="OGR_FD_DeleteGeomFieldDefn__OGRFeatureDefnH.i"></span><span class="target" id="ogr__api_8h_1a1fb650102be3837fc220b086b17f4462"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_FD_DeleteGeomFieldDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hFDefn</em>, int <em>iGeomField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_FD_DeleteGeomFieldDefn15OGRFeatureDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete an existing geometry field definition. </p>
<p>To delete an existing geometry field definition from a layer definition, do not use this function directly, but use OGR_L_DeleteGeomField() instead (<em>not implemented yet</em>).</p>
<p>This method should only be called while there are no <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> objects in existence based on this <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a2c67a35c58cfd9ac384858d1b7b7ec48"><span class="std std-ref">OGRFeatureDefn::DeleteGeomFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE in case of success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iGeomField</span></code>: the index of the geometry field definition. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_FD_IsSame15OGRFeatureDefnH15OGRFeatureDefnH">
<span id="_CPPv313OGR_FD_IsSame15OGRFeatureDefnH15OGRFeatureDefnH"></span><span id="_CPPv213OGR_FD_IsSame15OGRFeatureDefnH15OGRFeatureDefnH"></span><span id="OGR_FD_IsSame__OGRFeatureDefnH.OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1ab07056d514160c26724f3a2d5319185f"></span>int <code class="descname">OGR_FD_IsSame</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hFDefn</em>, <a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hOtherFDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_FD_IsSame15OGRFeatureDefnH15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if the feature definition is identical to the other one. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the feature definition is identical to the other one.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFDefn</span></code>: handle to the feature definition on witch <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> are based on. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOtherFDefn</span></code>: handle to the other feature definition to compare to. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_F_Create15OGRFeatureDefnH">
<span id="_CPPv312OGR_F_Create15OGRFeatureDefnH"></span><span id="_CPPv212OGR_F_Create15OGRFeatureDefnH"></span><span id="OGR_F_Create__OGRFeatureDefnH"></span><span class="target" id="ogr__api_8h_1a335fbf2220d7f93437621cae723558ac"></span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <code class="descname">OGR_F_Create</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <em>hDefn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_F_Create15OGRFeatureDefnH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Feature factory. </p>
<p>Note that the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> will increment the reference count of its defining <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>. Destruction of the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> before destruction of all OGRFeatures that depend on it is likely to result in a crash.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ae6559a9f3c26274d1253e5d043b2e852"><span class="std std-ref">OGRFeature::OGRFeature()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the new feature object with null fields and no geometry, or, starting with GDAL 2.1, NULL in case out of memory situation. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDefn</span></code>: handle to the feature class (layer) definition to which the feature will adhere.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_F_Destroy11OGRFeatureH">
<span id="_CPPv313OGR_F_Destroy11OGRFeatureH"></span><span id="_CPPv213OGR_F_Destroy11OGRFeatureH"></span><span id="OGR_F_Destroy__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a16fb8126aa932f4b4acdaca5ea99bbbb"></span>void <code class="descname">OGR_F_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_F_Destroy11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy feature. </p>
<p>The feature is deleted, but within the context of the GDAL/OGR heap. This is necessary when higher level applications use GDAL/OGR from a DLL and they want to delete a feature created within the DLL. If the delete is done in the calling application the memory will be freed onto the application heap which is inappropriate.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5d2602d11f21567119da0ca6b6c5ad45"><span class="std std-ref">OGRFeature::DestroyFeature()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to destroy. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_F_GetDefnRef11OGRFeatureH">
<span id="_CPPv316OGR_F_GetDefnRef11OGRFeatureH"></span><span id="_CPPv216OGR_F_GetDefnRef11OGRFeatureH"></span><span id="OGR_F_GetDefnRef__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a123dfa431bf655aafd2dbd42247dd7be"></span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <code class="descname">OGR_F_GetDefnRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_F_GetDefnRef11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch feature definition. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a01ef8d59265a7ab7a575387a8269bf92"><span class="std std-ref">OGRFeature::GetDefnRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the feature definition object on which feature depends. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to get the feature definition from.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_F_SetGeometryDirectly11OGRFeatureH12OGRGeometryH">
<span id="_CPPv325OGR_F_SetGeometryDirectly11OGRFeatureH12OGRGeometryH"></span><span id="_CPPv225OGR_F_SetGeometryDirectly11OGRFeatureH12OGRGeometryH"></span><span id="OGR_F_SetGeometryDirectly__OGRFeatureH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ad391d3197728bb6d12a6b0c2e2661aa4"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_F_SetGeometryDirectly</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_F_SetGeometryDirectly11OGRFeatureH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometry(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a40a4ddb33f09a5f340b9139be72e277d"><span class="std std-ref">OGRFeature::SetGeometryDirectly</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> (checking not yet implemented). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which to apply the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the new geometry to apply to feature.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_F_SetGeometry11OGRFeatureH12OGRGeometryH">
<span id="_CPPv317OGR_F_SetGeometry11OGRFeatureH12OGRGeometryH"></span><span id="_CPPv217OGR_F_SetGeometry11OGRFeatureH12OGRGeometryH"></span><span id="OGR_F_SetGeometry__OGRFeatureH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a7b9c524f5c01a6a4b4e50e351d03299f"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_F_SetGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_F_SetGeometry11OGRFeatureH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a67949569519c0de6ee3ea48f23ff11c9"><span class="std std-ref">OGRFeature::SetGeometry()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> (checking not yet implemented). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which new geometry is applied to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the new geometry to apply to feature.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_GetGeometryRef11OGRFeatureH">
<span id="_CPPv320OGR_F_GetGeometryRef11OGRFeatureH"></span><span id="_CPPv220OGR_F_GetGeometryRef11OGRFeatureH"></span><span id="OGR_F_GetGeometryRef__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a1bf9596756aeacec4da502383c378f5c"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_F_GetGeometryRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_GetGeometryRef11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch an handle to feature geometry. </p>
<p>This function is essentially the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1acc966ce8c10ae3ddf9f14c2736fdce9a"><span class="std std-ref">OGRFeature::GetGeometryRef()</span></a> (the only difference is that this C function honours <a class="reference internal" href="#ogr__api_8h_1af7f6cfab316f5f22962bcd85216c4684"><span class="std std-ref">OGRGetNonLinearGeometriesEnabledFlag()</span></a>)</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to internal feature geometry. This object should not be modified. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to get geometry from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_F_StealGeometry11OGRFeatureH">
<span id="_CPPv319OGR_F_StealGeometry11OGRFeatureH"></span><span id="_CPPv219OGR_F_StealGeometry11OGRFeatureH"></span><span id="OGR_F_StealGeometry__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1ae2153b17a82c0026c20d710a79e6a779"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_F_StealGeometry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_F_StealGeometry11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Take away ownership of geometry. </p>
<p>Fetch the geometry from this feature, and clear the reference to the geometry on the feature. This is a mechanism for the application to take over ownership of the geometry from the feature without copying. Sort of an inverse to OGR_FSetGeometryDirectly().</p>
<p>After this call the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> will have a NULL geometry.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the pointer to the geometry. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_F_Clone11OGRFeatureH">
<span id="_CPPv311OGR_F_Clone11OGRFeatureH"></span><span id="_CPPv211OGR_F_Clone11OGRFeatureH"></span><span id="OGR_F_Clone__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a102988416ae11403cab68cbaea7386d1"></span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <code class="descname">OGR_F_Clone</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_F_Clone11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Duplicate feature. </p>
<p>The newly created feature is owned by the caller, and will have its own reference to the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a16fba4633e17322df19e85a737aebc1c"><span class="std std-ref">OGRFeature::Clone()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the new feature, exactly matching this feature. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to clone. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_F_Equal11OGRFeatureH11OGRFeatureH">
<span id="_CPPv311OGR_F_Equal11OGRFeatureH11OGRFeatureH"></span><span id="_CPPv211OGR_F_Equal11OGRFeatureH11OGRFeatureH"></span><span id="OGR_F_Equal__OGRFeatureH.OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a8b6a502ec0b70f3de50e7184a087a264"></span>int <code class="descname">OGR_F_Equal</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hOtherFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_F_Equal11OGRFeatureH11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if two features are the same. </p>
<p>Two features are considered equal if the share them (handle equality) same <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>, have the same field values, and the same geometry (as tested by OGR_G_Equal()) as well as the same feature id.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a52b96b85923e2128f17bc049fbd548a2"><span class="std std-ref">OGRFeature::Equal()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if they are equal, otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to one of the feature. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOtherFeat</span></code>: handle to the other feature to test this one against.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_F_GetFieldCount11OGRFeatureH">
<span id="_CPPv319OGR_F_GetFieldCount11OGRFeatureH"></span><span id="_CPPv219OGR_F_GetFieldCount11OGRFeatureH"></span><span id="OGR_F_GetFieldCount__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1af6c1440956ee56c0c160394bccf96990"></span>int <code class="descname">OGR_F_GetFieldCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_F_GetFieldCount11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch number of fields on this feature This will always be the same as the field count for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5f2125ed7986f684e835c3d44feda6fe"><span class="std std-ref">OGRFeature::GetFieldCount()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>count of fields. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to get the fields count from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_F_GetFieldDefnRef11OGRFeatureHi">
<span id="_CPPv321OGR_F_GetFieldDefnRef11OGRFeatureHi"></span><span id="_CPPv221OGR_F_GetFieldDefnRef11OGRFeatureHi"></span><span id="OGR_F_GetFieldDefnRef__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a6f8fc7fd6ecca789ad90db6d28391623"></span><a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <code class="descname">OGR_F_GetFieldDefnRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_F_GetFieldDefnRef11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch definition for this field. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a545a4c983e1fa557e64333fe63656637"><span class="std std-ref">OGRFeature::GetFieldDefnRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the field definition (from the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>). This is an internal reference, and should not be deleted or modified. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is found. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the field to fetch, from 0 to GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_F_GetFieldIndex11OGRFeatureHPKc">
<span id="_CPPv319OGR_F_GetFieldIndex11OGRFeatureHPKc"></span><span id="_CPPv219OGR_F_GetFieldIndex11OGRFeatureHPKc"></span><span id="OGR_F_GetFieldIndex__OGRFeatureH.cCP"></span><span class="target" id="ogr__api_8h_1a9a8a6b93ab97204b94f5c2b358f8f98e"></span>int <code class="descname">OGR_F_GetFieldIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_F_GetFieldIndex11OGRFeatureHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the field index given field name. </p>
<p>This is a cover for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1adf94fefd88e82172e5279f5188b3873b"><span class="std std-ref">OGRFeatureDefn::GetFieldIndex()</span></a> method.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a989153f429715d02e4d5c45d0e43f303"><span class="std std-ref">OGRFeature::GetFieldIndex()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field index, or -1 if no matching field is found. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is found. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the field to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_F_IsFieldSet11OGRFeatureHi">
<span id="_CPPv316OGR_F_IsFieldSet11OGRFeatureHi"></span><span id="_CPPv216OGR_F_IsFieldSet11OGRFeatureHi"></span><span id="OGR_F_IsFieldSet__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1abb018a9030ed76353ae26082deaaef11"></span>int <code class="descname">OGR_F_IsFieldSet</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_F_IsFieldSet11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if a field has ever been assigned a value or not. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a905bb73fe5e6df57f1be5a8b77489b74"><span class="std std-ref">OGRFeature::IsFieldSet()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the field has been set, otherwise false. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_F_UnsetField11OGRFeatureHi">
<span id="_CPPv316OGR_F_UnsetField11OGRFeatureHi"></span><span id="_CPPv216OGR_F_UnsetField11OGRFeatureHi"></span><span id="OGR_F_UnsetField__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1aa70b7675a003141e63f9603c752ee22e"></span>void <code class="descname">OGR_F_UnsetField</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_F_UnsetField11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear a field, marking it as unset. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a937b21e0137e40bc1473f354879975da"><span class="std std-ref">OGRFeature::UnsetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to unset. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_F_IsFieldNull11OGRFeatureHi">
<span id="_CPPv317OGR_F_IsFieldNull11OGRFeatureHi"></span><span id="_CPPv217OGR_F_IsFieldNull11OGRFeatureHi"></span><span id="OGR_F_IsFieldNull__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1aa4d08c0ac3b9624955e682a9a2afe2b1"></span>int <code class="descname">OGR_F_IsFieldNull</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_F_IsFieldNull11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if a field is null. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a655ee311e45188dcb5143ce3e408884e"><span class="std std-ref">OGRFeature::IsFieldNull()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the field is null, otherwise false.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_F_IsFieldSetAndNotNull11OGRFeatureHi">
<span id="_CPPv326OGR_F_IsFieldSetAndNotNull11OGRFeatureHi"></span><span id="_CPPv226OGR_F_IsFieldSetAndNotNull11OGRFeatureHi"></span><span id="OGR_F_IsFieldSetAndNotNull__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1adf414eb3a145bcd7203fca727f7a2ead"></span>int <code class="descname">OGR_F_IsFieldSetAndNotNull</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_F_IsFieldSetAndNotNull11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if a field is set and not null. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a55cee63d6370dc1123dfca2b8333b1ac"><span class="std std-ref">OGRFeature::IsFieldSetAndNotNull()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the field is set and not null, otherwise false.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_F_SetFieldNull11OGRFeatureHi">
<span id="_CPPv318OGR_F_SetFieldNull11OGRFeatureHi"></span><span id="_CPPv218OGR_F_SetFieldNull11OGRFeatureHi"></span><span id="OGR_F_SetFieldNull__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a090a6a8d699d4eed977ce9fcf028137a"></span>void <code class="descname">OGR_F_SetFieldNull</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_F_SetFieldNull11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear a field, marking it as null. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a21e81c0995c1f2a8e5c9f6c76fdfb2f4"><span class="std std-ref">OGRFeature::SetFieldNull()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set to null.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_GetRawFieldRef11OGRFeatureHi">
<span id="_CPPv320OGR_F_GetRawFieldRef11OGRFeatureHi"></span><span id="_CPPv220OGR_F_GetRawFieldRef11OGRFeatureHi"></span><span id="OGR_F_GetRawFieldRef__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1af7043e9dfadbdeca8059ace336875d4c"></span><a class="reference internal" href="#_CPPv48OGRField" title="OGRField">OGRField</a> *<code class="descname">OGR_F_GetRawFieldRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_GetRawFieldRef11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch an handle to the internal field value given the index. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ae7f676d5a8e1f62d80b438c13b159ee0"><span class="std std-ref">OGRFeature::GetRawFieldRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the returned handle is to an internal data structure, and should not be freed, or modified. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which field is found. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_RawField_IsUnsetPK8OGRField">
<span id="_CPPv320OGR_RawField_IsUnsetPK8OGRField"></span><span id="_CPPv220OGR_RawField_IsUnsetPK8OGRField"></span><span id="OGR_RawField_IsUnset__OGRFieldCP"></span><span class="target" id="ogr__api_8h_1ae23095c63fc350d712940bdbf440bbcb"></span>int <code class="descname">OGR_RawField_IsUnset</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv48OGRField" title="OGRField">OGRField</a> *<em>puField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_RawField_IsUnsetPK8OGRField" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether a raw field is unset. </p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="reference internal" href="#ogr__api_8h_1abb018a9030ed76353ae26082deaaef11"><span class="std std-ref">OGR_F_IsFieldSet()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">puField</span></code>: pointer to raw field. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_RawField_IsNullPK8OGRField">
<span id="_CPPv319OGR_RawField_IsNullPK8OGRField"></span><span id="_CPPv219OGR_RawField_IsNullPK8OGRField"></span><span id="OGR_RawField_IsNull__OGRFieldCP"></span><span class="target" id="ogr__api_8h_1aa9a401e6dbd5577396b567791cf85115"></span>int <code class="descname">OGR_RawField_IsNull</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv48OGRField" title="OGRField">OGRField</a> *<em>puField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_RawField_IsNullPK8OGRField" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether a raw field is null. </p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="reference internal" href="#ogr__api_8h_1aa4d08c0ac3b9624955e682a9a2afe2b1"><span class="std std-ref">OGR_F_IsFieldNull()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">puField</span></code>: pointer to raw field. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_RawField_SetUnsetP8OGRField">
<span id="_CPPv321OGR_RawField_SetUnsetP8OGRField"></span><span id="_CPPv221OGR_RawField_SetUnsetP8OGRField"></span><span id="OGR_RawField_SetUnset__OGRFieldP"></span><span class="target" id="ogr__api_8h_1acaac3d8e8d01fa83a52dd2d95aac0cc3"></span>void <code class="descname">OGR_RawField_SetUnset</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48OGRField" title="OGRField">OGRField</a> *<em>puField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_RawField_SetUnsetP8OGRField" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a raw field as unset. </p>
<p>This should be called on a un-initialized field. In particular this will not free any memory dynamically allocated.</p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="reference internal" href="#ogr__api_8h_1aa70b7675a003141e63f9603c752ee22e"><span class="std std-ref">OGR_F_UnsetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">puField</span></code>: pointer to raw field. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_RawField_SetNullP8OGRField">
<span id="_CPPv320OGR_RawField_SetNullP8OGRField"></span><span id="_CPPv220OGR_RawField_SetNullP8OGRField"></span><span id="OGR_RawField_SetNull__OGRFieldP"></span><span class="target" id="ogr__api_8h_1acf6c613c24de0e11fe259e86160157d3"></span>void <code class="descname">OGR_RawField_SetNull</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48OGRField" title="OGRField">OGRField</a> *<em>puField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_RawField_SetNullP8OGRField" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a raw field as null. </p>
<p>This should be called on a un-initialized field. In particular this will not free any memory dynamically allocated.</p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="reference internal" href="#ogr__api_8h_1a090a6a8d699d4eed977ce9fcf028137a"><span class="std std-ref">OGR_F_SetFieldNull()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">puField</span></code>: pointer to raw field. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_F_GetFieldAsInteger11OGRFeatureHi">
<span id="_CPPv323OGR_F_GetFieldAsInteger11OGRFeatureHi"></span><span id="_CPPv223OGR_F_GetFieldAsInteger11OGRFeatureHi"></span><span id="OGR_F_GetFieldAsInteger__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1acfb4d2c0001af379e396021ecbdaf275"></span>int <code class="descname">OGR_F_GetFieldAsInteger</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_F_GetFieldAsInteger11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as integer. </p>
<p>OFTString features will be translated using atoi(). OFTReal fields will be cast to integer. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1aa0fa233c76792a07bf2e72c2846502f1"><span class="std std-ref">OGRFeature::GetFieldAsInteger()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_F_GetFieldAsInteger6411OGRFeatureHi">
<span id="_CPPv325OGR_F_GetFieldAsInteger6411OGRFeatureHi"></span><span id="_CPPv225OGR_F_GetFieldAsInteger6411OGRFeatureHi"></span><span id="OGR_F_GetFieldAsInteger64__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a0e190099fd6ee40e206bf4bf74d3b784"></span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">OGR_F_GetFieldAsInteger64</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_F_GetFieldAsInteger6411OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as integer 64 bit. </p>
<p>OFTInteger are promoted to 64 bit. OFTString features will be translated using <a class="reference internal" href="cpl.html#cpl__conv_8h_1aa35579a348f417a35965d6be69cde090"><span class="std std-ref">CPLAtoGIntBig()</span></a>. OFTReal fields will be cast to integer. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a7178e6fe945237da0595a934aba9e2ff"><span class="std std-ref">OGRFeature::GetFieldAsInteger64()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_F_GetFieldAsDouble11OGRFeatureHi">
<span id="_CPPv322OGR_F_GetFieldAsDouble11OGRFeatureHi"></span><span id="_CPPv222OGR_F_GetFieldAsDouble11OGRFeatureHi"></span><span id="OGR_F_GetFieldAsDouble__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a62252a0d4538c695d41956a96cdc6978"></span>double <code class="descname">OGR_F_GetFieldAsDouble</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_F_GetFieldAsDouble11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as a double. </p>
<p>OFTString features will be translated using <a class="reference internal" href="cpl.html#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a>. OFTInteger fields will be cast to double. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1af1e473ed4496676610640a3fbe15d8e3"><span class="std std-ref">OGRFeature::GetFieldAsDouble()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_F_GetFieldAsString11OGRFeatureHi">
<span id="_CPPv322OGR_F_GetFieldAsString11OGRFeatureHi"></span><span id="_CPPv222OGR_F_GetFieldAsString11OGRFeatureHi"></span><span id="OGR_F_GetFieldAsString__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a42acfd1f4b49dddc1c308462ae800c26"></span><em class="property">const</em> char *<code class="descname">OGR_F_GetFieldAsString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_F_GetFieldAsString11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as a string. </p>
<p>OFTReal and OFTInteger fields will be translated to string using sprintf(), but not necessarily using the established formatting rules. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a92ecdc127eeb3fe7e2ead80f1d17d4b4"><span class="std std-ref">OGRFeature::GetFieldAsString()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. This string is internal, and should not be modified, or freed. Its lifetime may be very brief. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427OGR_F_GetFieldAsIntegerList11OGRFeatureHiPi">
<span id="_CPPv327OGR_F_GetFieldAsIntegerList11OGRFeatureHiPi"></span><span id="_CPPv227OGR_F_GetFieldAsIntegerList11OGRFeatureHiPi"></span><span id="OGR_F_GetFieldAsIntegerList__OGRFeatureH.i.iP"></span><span class="target" id="ogr__api_8h_1ac671852e05692c584b493b2acbd6b8ce"></span><em class="property">const</em> int *<code class="descname">OGR_F_GetFieldAsIntegerList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int *<em>pnCount</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427OGR_F_GetFieldAsIntegerList11OGRFeatureHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as a list of integers. </p>
<p>Currently this function only works for OFTIntegerList fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a8f3817334dc5a0987d2a384708efc9af"><span class="std std-ref">OGRFeature::GetFieldAsIntegerList()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnCount</span></code>: an integer to put the list count (number of integers) into.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429OGR_F_GetFieldAsInteger64List11OGRFeatureHiPi">
<span id="_CPPv329OGR_F_GetFieldAsInteger64List11OGRFeatureHiPi"></span><span id="_CPPv229OGR_F_GetFieldAsInteger64List11OGRFeatureHiPi"></span><span id="OGR_F_GetFieldAsInteger64List__OGRFeatureH.i.iP"></span><span class="target" id="ogr__api_8h_1a9df79763bd50aeef2581454bcab51ce6"></span><em class="property">const</em> <a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> *<code class="descname">OGR_F_GetFieldAsInteger64List</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int *<em>pnCount</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429OGR_F_GetFieldAsInteger64List11OGRFeatureHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as a list of 64 bit integers. </p>
<p>Currently this function only works for OFTInteger64List fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1afddc9cb3f91db6ba82b105a20b57cb6c"><span class="std std-ref">OGRFeature::GetFieldAsInteger64List()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnCount</span></code>: an integer to put the list count (number of integers) into.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_F_GetFieldAsDoubleList11OGRFeatureHiPi">
<span id="_CPPv326OGR_F_GetFieldAsDoubleList11OGRFeatureHiPi"></span><span id="_CPPv226OGR_F_GetFieldAsDoubleList11OGRFeatureHiPi"></span><span id="OGR_F_GetFieldAsDoubleList__OGRFeatureH.i.iP"></span><span class="target" id="ogr__api_8h_1a4a27f74a38506ac492ec8b6e00eb58c9"></span><em class="property">const</em> double *<code class="descname">OGR_F_GetFieldAsDoubleList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int *<em>pnCount</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_F_GetFieldAsDoubleList11OGRFeatureHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as a list of doubles. </p>
<p>Currently this function only works for OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a206f481869ded42b685a163cc97e04cd"><span class="std std-ref">OGRFeature::GetFieldAsDoubleList()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnCount</span></code>: an integer to put the list count (number of doubles) into.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_F_GetFieldAsStringList11OGRFeatureHi">
<span id="_CPPv326OGR_F_GetFieldAsStringList11OGRFeatureHi"></span><span id="_CPPv226OGR_F_GetFieldAsStringList11OGRFeatureHi"></span><span id="OGR_F_GetFieldAsStringList__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a3e55ba4a06d4c4a392206518b390ac38"></span>char **<code class="descname">OGR_F_GetFieldAsStringList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_F_GetFieldAsStringList11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as a list of strings. </p>
<p>Currently this method only works for OFTStringList fields.</p>
<p>The returned list is terminated by a NULL pointer. The number of elements can also be calculated using <a class="reference internal" href="cpl.html#cpl__string_8h_1a827f21b7a67d16059c131d0946482bb1"><span class="std std-ref">CSLCount()</span></a>.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a317004e2ab87ff097bc76a7a7619e4b4"><span class="std std-ref">OGRFeature::GetFieldAsStringList()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_F_GetFieldAsBinary11OGRFeatureHiPi">
<span id="_CPPv322OGR_F_GetFieldAsBinary11OGRFeatureHiPi"></span><span id="_CPPv222OGR_F_GetFieldAsBinary11OGRFeatureHiPi"></span><span id="OGR_F_GetFieldAsBinary__OGRFeatureH.i.iP"></span><span class="target" id="ogr__api_8h_1a72727f2f59d1defa01cedfb884df1a09"></span><a class="reference internal" href="cpl.html#_CPPv45GByte" title="GByte">GByte</a> *<code class="descname">OGR_F_GetFieldAsBinary</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int *<em>pnBytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_F_GetFieldAsBinary11OGRFeatureHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as binary. </p>
<p>This method only works for OFTBinary and OFTString fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a2bda1256e28dbb14d37e5b6920fbc8d9"><span class="std std-ref">OGRFeature::GetFieldAsBinary()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnBytes</span></code>: location to place count of bytes returned.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_F_GetFieldAsDateTime11OGRFeatureHiPiPiPiPiPiPiPi">
<span id="_CPPv324OGR_F_GetFieldAsDateTime11OGRFeatureHiPiPiPiPiPiPiPi"></span><span id="_CPPv224OGR_F_GetFieldAsDateTime11OGRFeatureHiPiPiPiPiPiPiPi"></span><span id="OGR_F_GetFieldAsDateTime__OGRFeatureH.i.iP.iP.iP.iP.iP.iP.iP"></span><span class="target" id="ogr__api_8h_1a47ca681bb6099eb8c18004d1f7112d95"></span>int <code class="descname">OGR_F_GetFieldAsDateTime</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int *<em>pnYear</em>, int *<em>pnMonth</em>, int *<em>pnDay</em>, int *<em>pnHour</em>, int *<em>pnMinute</em>, int *<em>pnSecond</em>, int *<em>pnTZFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_F_GetFieldAsDateTime11OGRFeatureHiPiPiPiPiPiPiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as date and time. </p>
<p>Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a54097fad3054b57cfc7b6b0b0dd805e2"><span class="std std-ref">OGRFeature::GetFieldAsDateTime()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE on failure.</p>
</dd>
<dt><strong>See</strong></dt><dd><p>Use <a class="reference internal" href="#ogr__api_8h_1a748995fa28574b25f6b723013a405a8f"><span class="std std-ref">OGR_F_GetFieldAsDateTimeEx()</span></a> for second with millisecond accuracy. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnYear</span></code>: (including century) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnMonth</span></code>: (1-12) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnDay</span></code>: (1-31) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnHour</span></code>: (0-23) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnMinute</span></code>: (0-59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnSecond</span></code>: (0-59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnTZFlag</span></code>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_F_GetFieldAsDateTimeEx11OGRFeatureHiPiPiPiPiPiPfPi">
<span id="_CPPv326OGR_F_GetFieldAsDateTimeEx11OGRFeatureHiPiPiPiPiPiPfPi"></span><span id="_CPPv226OGR_F_GetFieldAsDateTimeEx11OGRFeatureHiPiPiPiPiPiPfPi"></span><span id="OGR_F_GetFieldAsDateTimeEx__OGRFeatureH.i.iP.iP.iP.iP.iP.floatP.iP"></span><span class="target" id="ogr__api_8h_1a748995fa28574b25f6b723013a405a8f"></span>int <code class="descname">OGR_F_GetFieldAsDateTimeEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int *<em>pnYear</em>, int *<em>pnMonth</em>, int *<em>pnDay</em>, int *<em>pnHour</em>, int *<em>pnMinute</em>, float *<em>pfSecond</em>, int *<em>pnTZFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_F_GetFieldAsDateTimeEx11OGRFeatureHiPiPiPiPiPiPfPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch field value as date and time. </p>
<p>Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a54097fad3054b57cfc7b6b0b0dd805e2"><span class="std std-ref">OGRFeature::GetFieldAsDateTime()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success or FALSE on failure. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnYear</span></code>: (including century) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnMonth</span></code>: (1-12) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnDay</span></code>: (1-31) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnHour</span></code>: (0-23) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnMinute</span></code>: (0-59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfSecond</span></code>: (0-59 with millisecond accuracy) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnTZFlag</span></code>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_F_SetFieldInteger11OGRFeatureHii">
<span id="_CPPv321OGR_F_SetFieldInteger11OGRFeatureHii"></span><span id="_CPPv221OGR_F_SetFieldInteger11OGRFeatureHii"></span><span id="OGR_F_SetFieldInteger__OGRFeatureH.i.i"></span><span class="target" id="ogr__api_8h_1ad902fb7c7fe459aacf0b2c26b8e6d1ee"></span>void <code class="descname">OGR_F_SetFieldInteger</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int <em>nValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_F_SetFieldInteger11OGRFeatureHii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to integer value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nValue</span></code>: the value to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_F_SetFieldInteger6411OGRFeatureHi7GIntBig">
<span id="_CPPv323OGR_F_SetFieldInteger6411OGRFeatureHi7GIntBig"></span><span id="_CPPv223OGR_F_SetFieldInteger6411OGRFeatureHi7GIntBig"></span><span id="OGR_F_SetFieldInteger64__OGRFeatureH.i.GIntBig"></span><span class="target" id="ogr__api_8h_1a1c95abf476d0ad250eb7499627f0e3b1"></span>void <code class="descname">OGR_F_SetFieldInteger64</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, <a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <em>nValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_F_SetFieldInteger6411OGRFeatureHi7GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to 64 bit integer value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nValue</span></code>: the value to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_SetFieldDouble11OGRFeatureHid">
<span id="_CPPv320OGR_F_SetFieldDouble11OGRFeatureHid"></span><span id="_CPPv220OGR_F_SetFieldDouble11OGRFeatureHid"></span><span id="OGR_F_SetFieldDouble__OGRFeatureH.i.double"></span><span class="target" id="ogr__api_8h_1a9d28aa13b1b7c88f07066c36286d13b9"></span>void <code class="descname">OGR_F_SetFieldDouble</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, double <em>dfValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_SetFieldDouble11OGRFeatureHid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to double value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfValue</span></code>: the value to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_SetFieldString11OGRFeatureHiPKc">
<span id="_CPPv320OGR_F_SetFieldString11OGRFeatureHiPKc"></span><span id="_CPPv220OGR_F_SetFieldString11OGRFeatureHiPKc"></span><span id="OGR_F_SetFieldString__OGRFeatureH.i.cCP"></span><span class="target" id="ogr__api_8h_1ad1a3e8b4a08f9558807389bcdde85bab"></span>void <code class="descname">OGR_F_SetFieldString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_SetFieldString11OGRFeatureHiPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to string value. </p>
<p>OFTInteger fields will be set based on an atoi() conversion of the string. OFTInteger64 fields will be set based on an <a class="reference internal" href="cpl.html#cpl__conv_8h_1aa35579a348f417a35965d6be69cde090"><span class="std std-ref">CPLAtoGIntBig()</span></a> conversion of the string. OFTReal fields will be set based on an <a class="reference internal" href="cpl.html#cpl__conv_8h_1afb5bf88066f997b1ab3b3911f5e9b722"><span class="std std-ref">CPLAtof()</span></a> conversion of the string. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the value to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_F_SetFieldIntegerList11OGRFeatureHiiPKi">
<span id="_CPPv325OGR_F_SetFieldIntegerList11OGRFeatureHiiPKi"></span><span id="_CPPv225OGR_F_SetFieldIntegerList11OGRFeatureHiiPKi"></span><span id="OGR_F_SetFieldIntegerList__OGRFeatureH.i.i.iCP"></span><span class="target" id="ogr__api_8h_1a984c8595693b4e94f3be5f796e6f7c92"></span>void <code class="descname">OGR_F_SetFieldIntegerList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int <em>nCount</em>, <em class="property">const</em> int *<em>panValues</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_F_SetFieldIntegerList11OGRFeatureHiiPKi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to list of integers value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List and OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: the number of values in the list being assigned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panValues</span></code>: the values to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427OGR_F_SetFieldInteger64List11OGRFeatureHiiPK7GIntBig">
<span id="_CPPv327OGR_F_SetFieldInteger64List11OGRFeatureHiiPK7GIntBig"></span><span id="_CPPv227OGR_F_SetFieldInteger64List11OGRFeatureHiiPK7GIntBig"></span><span id="OGR_F_SetFieldInteger64List__OGRFeatureH.i.i.GIntBigCP"></span><span class="target" id="ogr__api_8h_1af7538949a9e8b85920381809fadbe897"></span>void <code class="descname">OGR_F_SetFieldInteger64List</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int <em>nCount</em>, <em class="property">const</em> <a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> *<em>panValues</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427OGR_F_SetFieldInteger64List11OGRFeatureHiiPK7GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to list of 64 bit integers value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List and OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: the number of values in the list being assigned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panValues</span></code>: the values to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_F_SetFieldDoubleList11OGRFeatureHiiPKd">
<span id="_CPPv324OGR_F_SetFieldDoubleList11OGRFeatureHiiPKd"></span><span id="_CPPv224OGR_F_SetFieldDoubleList11OGRFeatureHiiPKd"></span><span id="OGR_F_SetFieldDoubleList__OGRFeatureH.i.i.doubleCP"></span><span class="target" id="ogr__api_8h_1a83a56d01128bf247016c139faed157be"></span>void <code class="descname">OGR_F_SetFieldDoubleList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int <em>nCount</em>, <em class="property">const</em> double *<em>padfValues</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_F_SetFieldDoubleList11OGRFeatureHiiPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to list of doubles value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List, OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCount</span></code>: the number of values in the list being assigned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfValues</span></code>: the values to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_F_SetFieldStringList11OGRFeatureHi12CSLConstList">
<span id="_CPPv324OGR_F_SetFieldStringList11OGRFeatureHi12CSLConstList"></span><span id="_CPPv224OGR_F_SetFieldStringList11OGRFeatureHi12CSLConstList"></span><span id="OGR_F_SetFieldStringList__OGRFeatureH.i.CSLConstList"></span><span class="target" id="ogr__api_8h_1a35dd76723ae1acc91135054e64d7598e"></span>void <code class="descname">OGR_F_SetFieldStringList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, <a class="reference internal" href="cpl.html#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszValues</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_F_SetFieldStringList11OGRFeatureHi12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to list of strings value. </p>
<p>This function currently on has an effect of OFTStringList fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszValues</span></code>: the values to assign. List of NUL-terminated string, ending with a NULL pointer. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_F_SetFieldRaw11OGRFeatureHiP8OGRField">
<span id="_CPPv317OGR_F_SetFieldRaw11OGRFeatureHiP8OGRField"></span><span id="_CPPv217OGR_F_SetFieldRaw11OGRFeatureHiP8OGRField"></span><span id="OGR_F_SetFieldRaw__OGRFeatureH.i.OGRFieldP"></span><span class="target" id="ogr__api_8h_1af3cfe4f766f5579f670bb651c53a99ca"></span>void <code class="descname">OGR_F_SetFieldRaw</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, <a class="reference internal" href="#_CPPv48OGRField" title="OGRField">OGRField</a> *<em>psValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_F_SetFieldRaw11OGRFeatureHiP8OGRField" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field. </p>
<p>The passed value <a class="reference internal" href="#unionOGRField"><span class="std std-ref">OGRField</span></a> must be of exactly the same type as the target field, or an application crash may occur. The passed value is copied, and will not be affected. It remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to fetch, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psValue</span></code>: handle on the value to assign. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_SetFieldBinary11OGRFeatureHiiPKv">
<span id="_CPPv320OGR_F_SetFieldBinary11OGRFeatureHiiPKv"></span><span id="_CPPv220OGR_F_SetFieldBinary11OGRFeatureHiiPKv"></span><span id="OGR_F_SetFieldBinary__OGRFeatureH.i.i.voidCP"></span><span class="target" id="ogr__api_8h_1a348b1423e9ae34290f2e32f3bdf8154b"></span>void <code class="descname">OGR_F_SetFieldBinary</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int <em>nBytes</em>, <em class="property">const</em> void *<em>pabyData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_SetFieldBinary11OGRFeatureHiiPKv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to binary data. </p>
<p>This function currently on has an effect of OFTBinary fields.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a4abbe118cc2f3e48bbac7f710b71b531"><span class="std std-ref">OGRFeature::SetField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBytes</span></code>: the number of bytes in pabyData array. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pabyData</span></code>: the data to apply. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_F_SetFieldDateTime11OGRFeatureHiiiiiiii">
<span id="_CPPv322OGR_F_SetFieldDateTime11OGRFeatureHiiiiiiii"></span><span id="_CPPv222OGR_F_SetFieldDateTime11OGRFeatureHiiiiiiii"></span><span id="OGR_F_SetFieldDateTime__OGRFeatureH.i.i.i.i.i.i.i.i"></span><span class="target" id="ogr__api_8h_1a627970180a20e2a4b1c7ae694923fd73"></span>void <code class="descname">OGR_F_SetFieldDateTime</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int <em>nYear</em>, int <em>nMonth</em>, int <em>nDay</em>, int <em>nHour</em>, int <em>nMinute</em>, int <em>nSecond</em>, int <em>nTZFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_F_SetFieldDateTime11OGRFeatureHiiiiiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to datetime. </p>
<p>This method currently only has an effect for OFTDate, OFTTime and OFTDateTime fields.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>See</strong></dt><dd><p>Use <a class="reference internal" href="#ogr__api_8h_1a71e1bc23b8a31553550775a212075da3"><span class="std std-ref">OGR_F_SetFieldDateTimeEx()</span></a> for second with millisecond accuracy. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYear</span></code>: (including century) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMonth</span></code>: (1-12) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nDay</span></code>: (1-31) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nHour</span></code>: (0-23) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMinute</span></code>: (0-59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSecond</span></code>: (0-59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nTZFlag</span></code>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_F_SetFieldDateTimeEx11OGRFeatureHiiiiiifi">
<span id="_CPPv324OGR_F_SetFieldDateTimeEx11OGRFeatureHiiiiiifi"></span><span id="_CPPv224OGR_F_SetFieldDateTimeEx11OGRFeatureHiiiiiifi"></span><span id="OGR_F_SetFieldDateTimeEx__OGRFeatureH.i.i.i.i.i.i.float.i"></span><span class="target" id="ogr__api_8h_1a71e1bc23b8a31553550775a212075da3"></span>void <code class="descname">OGR_F_SetFieldDateTimeEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, int <em>nYear</em>, int <em>nMonth</em>, int <em>nDay</em>, int <em>nHour</em>, int <em>nMinute</em>, float <em>fSecond</em>, int <em>nTZFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_F_SetFieldDateTimeEx11OGRFeatureHiiiiiifi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set field to datetime. </p>
<p>This method currently only has an effect for OFTDate, OFTTime and OFTDateTime fields.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a> must be used afterwards. Or if this is a new feature, <a class="reference internal" href="#ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"><span class="std std-ref">OGR_L_CreateFeature()</span></a> must be used afterwards.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature that owned the field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: the field to set, from 0 to GetFieldCount()-1. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYear</span></code>: (including century) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMonth</span></code>: (1-12) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nDay</span></code>: (1-31) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nHour</span></code>: (0-23) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nMinute</span></code>: (0-59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fSecond</span></code>: (0-59, with millisecond accuracy) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nTZFlag</span></code>: (0=unknown, 1=localtime, 100=GMT, see data model for details)</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_F_GetGeomFieldCount11OGRFeatureH">
<span id="_CPPv323OGR_F_GetGeomFieldCount11OGRFeatureH"></span><span id="_CPPv223OGR_F_GetGeomFieldCount11OGRFeatureH"></span><span id="OGR_F_GetGeomFieldCount__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a7975076d4ab247189487c0fd50d8365c"></span>int <code class="descname">OGR_F_GetGeomFieldCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_F_GetGeomFieldCount11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a372e4ace921fa830a342181328a5a4cf"><span class="std std-ref">OGRFeature::GetGeomFieldCount()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>count of geometry fields.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to get the geometry fields count from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_F_GetGeomFieldDefnRef11OGRFeatureHi">
<span id="_CPPv325OGR_F_GetGeomFieldDefnRef11OGRFeatureHi"></span><span id="_CPPv225OGR_F_GetGeomFieldDefnRef11OGRFeatureHi"></span><span id="OGR_F_GetGeomFieldDefnRef__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a11c3d59a3854dad80c4257e788c5d881"></span><a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <code class="descname">OGR_F_GetGeomFieldDefnRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_F_GetGeomFieldDefnRef11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch definition for this geometry field. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ab0416401dc7d6a7634c2a24ca1f7d255"><span class="std std-ref">OGRFeature::GetGeomFieldDefnRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the field definition (from the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>). This is an internal reference, and should not be deleted or modified.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the field is found. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: the field to fetch, from 0 to GetGeomFieldCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_F_GetGeomFieldIndex11OGRFeatureHPKc">
<span id="_CPPv323OGR_F_GetGeomFieldIndex11OGRFeatureHPKc"></span><span id="_CPPv223OGR_F_GetGeomFieldIndex11OGRFeatureHPKc"></span><span id="OGR_F_GetGeomFieldIndex__OGRFeatureH.cCP"></span><span class="target" id="ogr__api_8h_1a546acd0aad47128b1f178a8d01765e63"></span>int <code class="descname">OGR_F_GetGeomFieldIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_F_GetGeomFieldIndex11OGRFeatureHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the geometry field index given geometry field name. </p>
<p>This is a cover for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1af033ae277fade415ff13ed8b5643e4be"><span class="std std-ref">OGRFeatureDefn::GetGeomFieldIndex()</span></a> method.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1aae3ed6071596aea439843f1e4110ad40"><span class="std std-ref">OGRFeature::GetGeomFieldIndex()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the geometry field index, or -1 if no matching geometry field is found.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which the geometry field is found. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the geometry field to search for.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_F_GetGeomFieldRef11OGRFeatureHi">
<span id="_CPPv321OGR_F_GetGeomFieldRef11OGRFeatureHi"></span><span id="_CPPv221OGR_F_GetGeomFieldRef11OGRFeatureHi"></span><span id="OGR_F_GetGeomFieldRef__OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1a37aa8b53b1fc8816c5b7bcbbcb6a46ca"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_F_GetGeomFieldRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_F_GetGeomFieldRef11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch an handle to feature geometry. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ae54d999d4649730d5c7b37de731e4f69"><span class="std std-ref">OGRFeature::GetGeomFieldRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to internal feature geometry. This object should not be modified.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to get geometry from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: geometry field to get. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_F_SetGeomFieldDirectly11OGRFeatureHi12OGRGeometryH">
<span id="_CPPv326OGR_F_SetGeomFieldDirectly11OGRFeatureHi12OGRGeometryH"></span><span id="_CPPv226OGR_F_SetGeomFieldDirectly11OGRFeatureHi12OGRGeometryH"></span><span id="OGR_F_SetGeomFieldDirectly__OGRFeatureH.i.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a01530e163973979cfd8248e3ecbf2640"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_F_SetGeomFieldDirectly</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_F_SetGeomFieldDirectly11OGRFeatureHi12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeomField(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ae0ddbbc910727ada3b2cd00a357222da"><span class="std std-ref">OGRFeature::SetGeomFieldDirectly</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is invalid, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> (checking not yet implemented).</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which to apply the geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: geometry field to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the new geometry to apply to feature.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_F_SetGeomField11OGRFeatureHi12OGRGeometryH">
<span id="_CPPv318OGR_F_SetGeomField11OGRFeatureHi12OGRGeometryH"></span><span id="_CPPv218OGR_F_SetGeomField11OGRFeatureHi12OGRGeometryH"></span><span id="OGR_F_SetGeomField__OGRFeatureH.i.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1ad75b18930385432110aa8d3461854cce"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_F_SetGeomField</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>iField</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_F_SetGeomField11OGRFeatureHi12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ab03a00692c1ccd5da895b2b90593508c"><span class="std std-ref">OGRFeature::SetGeomField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> (checking not yet implemented). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature on which new geometry is applied to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: geometry field to set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the new geometry to apply to feature.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_F_GetFID11OGRFeatureH">
<span id="_CPPv312OGR_F_GetFID11OGRFeatureH"></span><span id="_CPPv212OGR_F_GetFID11OGRFeatureH"></span><span id="OGR_F_GetFID__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1afc99defd1fb1f8f71ff89c38982f2103"></span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">OGR_F_GetFID</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_F_GetFID11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get feature identifier. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ae7254201e4d96e8429c2509194740d58"><span class="std std-ref">OGRFeature::GetFID()</span></a>. Note: since GDAL 2.0, this method returns a GIntBig (previously a long)</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>feature id or OGRNullFID if none has been assigned. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature from which to get the feature identifier. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_F_SetFID11OGRFeatureH7GIntBig">
<span id="_CPPv312OGR_F_SetFID11OGRFeatureH7GIntBig"></span><span id="_CPPv212OGR_F_SetFID11OGRFeatureH7GIntBig"></span><span id="OGR_F_SetFID__OGRFeatureH.GIntBig"></span><span class="target" id="ogr__api_8h_1adf24e93da4c03360d1d2e01664596e29"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_F_SetFID</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <em>nFID</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_F_SetFID11OGRFeatureH7GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the feature identifier. </p>
<p>For specific types of features this operation may fail on illegal features ids. Generally it always succeeds. Feature ids should be greater than or equal to zero, with the exception of OGRNullFID (-1) indicating that the feature id is unknown.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ad159156f6e544343f3f24081208a4b42"><span class="std std-ref">OGRFeature::SetFID()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>On success OGRERR_NONE, or on failure some other value. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to set the feature id to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFID</span></code>: the new feature identifier value to assign.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_F_DumpReadable11OGRFeatureHP4FILE">
<span id="_CPPv318OGR_F_DumpReadable11OGRFeatureHP4FILE"></span><span id="_CPPv218OGR_F_DumpReadable11OGRFeatureHP4FILE"></span><span id="OGR_F_DumpReadable__OGRFeatureH.FILEP"></span><span class="target" id="ogr__api_8h_1ae38d330f942798fcbaaf27e5807fb567"></span>void <code class="descname">OGR_F_DumpReadable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, FILE *<em>fpOut</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_F_DumpReadable11OGRFeatureHP4FILE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dump this feature in a human readable form. </p>
<p>This dumps the attributes, and geometry; however, it doesn’t definition information (other than field types and names), nor does it report the geometry spatial reference system.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a26eb15de8bbbe80e6cf9a47381f7df6b"><span class="std std-ref">OGRFeature::DumpReadable()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to dump. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fpOut</span></code>: the stream to write to, such as strout. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_F_SetFrom11OGRFeatureH11OGRFeatureHi">
<span id="_CPPv313OGR_F_SetFrom11OGRFeatureH11OGRFeatureHi"></span><span id="_CPPv213OGR_F_SetFrom11OGRFeatureH11OGRFeatureHi"></span><span id="OGR_F_SetFrom__OGRFeatureH.OGRFeatureH.i"></span><span class="target" id="ogr__api_8h_1ad7f7057a7a3764c526a4a59e2b587fba"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_F_SetFrom</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hOtherFeat</em>, int <em>bForgiving</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_F_SetFrom11OGRFeatureH11OGRFeatureHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>. Field values are copied by corresponding field names. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a32dda6780196687ef5f77b4915ed8243"><span class="std std-ref">OGRFeature::SetFrom()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to set to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOtherFeat</span></code>: handle to the feature from which geometry, and field values will be copied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bForgiving</span></code>: TRUE if the operation should continue despite lacking output fields matching some of the source fields.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_SetFromWithMap11OGRFeatureH11OGRFeatureHiPKi">
<span id="_CPPv320OGR_F_SetFromWithMap11OGRFeatureH11OGRFeatureHiPKi"></span><span id="_CPPv220OGR_F_SetFromWithMap11OGRFeatureH11OGRFeatureHiPKi"></span><span id="OGR_F_SetFromWithMap__OGRFeatureH.OGRFeatureH.i.iCP"></span><span class="target" id="ogr__api_8h_1a9c1b7383891a47387a9b48cb02918fde"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_F_SetFromWithMap</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hOtherFeat</em>, int <em>bForgiving</em>, <em class="property">const</em> int *<em>panMap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_SetFromWithMap11OGRFeatureH11OGRFeatureHiPKi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>. Field values are copied according to the provided indices map. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed. This is more efficient than <a class="reference internal" href="#ogr__api_8h_1ad7f7057a7a3764c526a4a59e2b587fba"><span class="std std-ref">OGR_F_SetFrom()</span></a> in that this doesn’t lookup the fields by their names. Particularly useful when the field names don’t match.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a32dda6780196687ef5f77b4915ed8243"><span class="std std-ref">OGRFeature::SetFrom()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to set to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOtherFeat</span></code>: handle to the feature from which geometry, and field values will be copied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panMap</span></code>: Array of the indices of the destination feature’s fields stored at the corresponding index of the source feature’s fields. A value of -1 should be used to ignore the source’s field. The array should not be NULL and be as long as the number of fields in the source feature.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bForgiving</span></code>: TRUE if the operation should continue despite lacking output fields matching some of the source fields.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_GetStyleString11OGRFeatureH">
<span id="_CPPv320OGR_F_GetStyleString11OGRFeatureH"></span><span id="_CPPv220OGR_F_GetStyleString11OGRFeatureH"></span><span id="OGR_F_GetStyleString__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a10fb5f53d99ccf46280e4c38afe4a5a5"></span><em class="property">const</em> char *<code class="descname">OGR_F_GetStyleString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_GetStyleString11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch style string for this feature. </p>
<p>Set the OGR Feature Style Specification for details on the format of this string, and ogr_featurestyle.h for services available to parse it.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a6f0eba9faff40c251784217584ac97a4"><span class="std std-ref">OGRFeature::GetStyleString()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a reference to a representation in string format, or NULL if there isn’t one. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to get the style from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_F_SetStyleString11OGRFeatureHPKc">
<span id="_CPPv320OGR_F_SetStyleString11OGRFeatureHPKc"></span><span id="_CPPv220OGR_F_SetStyleString11OGRFeatureHPKc"></span><span id="OGR_F_SetStyleString__OGRFeatureH.cCP"></span><span class="target" id="ogr__api_8h_1afbe436a7a48ad5bbfb3aa34f44791a68"></span>void <code class="descname">OGR_F_SetStyleString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <em class="property">const</em> char *<em>pszStyle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_F_SetStyleString11OGRFeatureHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set feature style string. </p>
<p>This method operate exactly as <a class="reference internal" href="#ogr__api_8h_1abc1ab2f6fb7937a8b927e4c1d3fd057c"><span class="std std-ref">OGR_F_SetStyleStringDirectly()</span></a> except that it does not assume ownership of the passed string, but instead makes a copy of it.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5d2c15d00845820e6382d48227ed7ff7"><span class="std std-ref">OGRFeature::SetStyleString()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to set style to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyle</span></code>: the style string to apply to this feature, cannot be NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_F_SetStyleStringDirectly11OGRFeatureHPc">
<span id="_CPPv328OGR_F_SetStyleStringDirectly11OGRFeatureHPc"></span><span id="_CPPv228OGR_F_SetStyleStringDirectly11OGRFeatureHPc"></span><span id="OGR_F_SetStyleStringDirectly__OGRFeatureH.cP"></span><span class="target" id="ogr__api_8h_1abc1ab2f6fb7937a8b927e4c1d3fd057c"></span>void <code class="descname">OGR_F_SetStyleStringDirectly</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, char *<em>pszStyle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_F_SetStyleStringDirectly11OGRFeatureHPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set feature style string. </p>
<p>This method operate exactly as <a class="reference internal" href="#ogr__api_8h_1afbe436a7a48ad5bbfb3aa34f44791a68"><span class="std std-ref">OGR_F_SetStyleString()</span></a> except that it assumes ownership of the passed string.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a7282982663cee5dd2fc18a093c3e386a"><span class="std std-ref">OGRFeature::SetStyleStringDirectly()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to set style to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyle</span></code>: the style string to apply to this feature, cannot be NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_F_GetStyleTable11OGRFeatureH">
<span id="_CPPv319OGR_F_GetStyleTable11OGRFeatureH"></span><span id="_CPPv219OGR_F_GetStyleTable11OGRFeatureH"></span><span id="OGR_F_GetStyleTable__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a82f3bde7b0fe8c5db80d747c5e89d028"></span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <code class="descname">OGR_F_GetStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_F_GetStyleTable11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return style table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427OGR_F_SetStyleTableDirectly11OGRFeatureH14OGRStyleTableH">
<span id="_CPPv327OGR_F_SetStyleTableDirectly11OGRFeatureH14OGRStyleTableH"></span><span id="_CPPv227OGR_F_SetStyleTableDirectly11OGRFeatureH14OGRStyleTableH"></span><span id="OGR_F_SetStyleTableDirectly__OGRFeatureH.OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1a2a936b7f094f4d1047704417465a7279"></span>void <code class="descname">OGR_F_SetStyleTableDirectly</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a>, <a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427OGR_F_SetStyleTableDirectly11OGRFeatureH14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set style table and take ownership. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_F_SetStyleTable11OGRFeatureH14OGRStyleTableH">
<span id="_CPPv319OGR_F_SetStyleTable11OGRFeatureH14OGRStyleTableH"></span><span id="_CPPv219OGR_F_SetStyleTable11OGRFeatureH14OGRStyleTableH"></span><span id="OGR_F_SetStyleTable__OGRFeatureH.OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1aa10c6fd7cce64e03433af2e2ec52676c"></span>void <code class="descname">OGR_F_SetStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a>, <a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_F_SetStyleTable11OGRFeatureH14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set style table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_F_GetNativeData11OGRFeatureH">
<span id="_CPPv319OGR_F_GetNativeData11OGRFeatureH"></span><span id="_CPPv219OGR_F_GetNativeData11OGRFeatureH"></span><span id="OGR_F_GetNativeData__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a3737dec6492741cd11c1767e04edec1f"></span><em class="property">const</em> char *<code class="descname">OGR_F_GetNativeData</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_F_GetNativeData11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the native data for the feature. </p>
<p>The native data is the representation in a “natural” form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by <a class="reference internal" href="#ogr__api_8h_1abcfe5e7897623a97a2bdc0ec32323fa6"><span class="std std-ref">OGR_F_GetNativeMediaType()</span></a>.</p>
<p>Note that most drivers do not support storing the native data in the feature object, and if they do, generally the NATIVE_DATA open option must be passed at dataset opening.</p>
<p>The “native data” does not imply it is something more performant or powerful than what can be obtained with the rest of the API, but it may be useful in round-tripping scenarios where some characteristics of the underlying format are not captured otherwise by the OGR abstraction.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a8f91a40806d4207efb689b9c3cdf8e53"><span class="std std-ref">OGRFeature::GetNativeData()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a string with the native data, or NULL if there is none. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1</p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_F_SetNativeData11OGRFeatureHPKc">
<span id="_CPPv319OGR_F_SetNativeData11OGRFeatureHPKc"></span><span id="_CPPv219OGR_F_SetNativeData11OGRFeatureHPKc"></span><span id="OGR_F_SetNativeData__OGRFeatureH.cCP"></span><span class="target" id="ogr__api_8h_1aeb0f1eb5d248e1d2131b877026cb2a8a"></span>void <code class="descname">OGR_F_SetNativeData</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <em class="property">const</em> char *<em>pszNativeData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_F_SetNativeData11OGRFeatureHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the native data for the feature. </p>
<p>The native data is the representation in a “natural” form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by <a class="reference internal" href="#ogr__api_8h_1abcfe5e7897623a97a2bdc0ec32323fa6"><span class="std std-ref">OGR_F_GetNativeMediaType()</span></a>.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ada90236daf06fa86e8ec9e59ec976908"><span class="std std-ref">OGRFeature::SetNativeData()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1</p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNativeData</span></code>: a string with the native data, or NULL if there is none. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_F_GetNativeMediaType11OGRFeatureH">
<span id="_CPPv324OGR_F_GetNativeMediaType11OGRFeatureH"></span><span id="_CPPv224OGR_F_GetNativeMediaType11OGRFeatureH"></span><span id="OGR_F_GetNativeMediaType__OGRFeatureH"></span><span class="target" id="ogr__api_8h_1abcfe5e7897623a97a2bdc0ec32323fa6"></span><em class="property">const</em> char *<code class="descname">OGR_F_GetNativeMediaType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_F_GetNativeMediaType11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the native media type for the feature. </p>
<p>The native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see <a class="reference external" href="https://en.wikipedia.org/wiki/Media_type">https://en.wikipedia.org/wiki/Media_type</a>), e.g. “application/vnd.geo+json” for JSon.</p>
<p>This function is the same as the C function <a class="reference internal" href="#ogr__api_8h_1abcfe5e7897623a97a2bdc0ec32323fa6"><span class="std std-ref">OGR_F_GetNativeMediaType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a string with the native media type, or NULL if there is none. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1</p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_F_SetNativeMediaType11OGRFeatureHPKc">
<span id="_CPPv324OGR_F_SetNativeMediaType11OGRFeatureHPKc"></span><span id="_CPPv224OGR_F_SetNativeMediaType11OGRFeatureHPKc"></span><span id="OGR_F_SetNativeMediaType__OGRFeatureH.cCP"></span><span class="target" id="ogr__api_8h_1a5e5e7ec78caaa3d0c65acb662fa6161d"></span>void <code class="descname">OGR_F_SetNativeMediaType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, <em class="property">const</em> char *<em>pszNativeMediaType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_F_SetNativeMediaType11OGRFeatureHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the native media type for the feature. </p>
<p>The native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see <a class="reference external" href="https://en.wikipedia.org/wiki/Media_type">https://en.wikipedia.org/wiki/Media_type</a>), e.g. “application/vnd.geo+json” for JSon.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a68476551e589b220eadd02998d5c3a47"><span class="std std-ref">OGRFeature::SetNativeMediaType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1</p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNativeMediaType</span></code>: a string with the native media type, or NULL if there is none. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_F_FillUnsetWithDefault11OGRFeatureHiPPc">
<span id="_CPPv326OGR_F_FillUnsetWithDefault11OGRFeatureHiPPc"></span><span id="_CPPv226OGR_F_FillUnsetWithDefault11OGRFeatureHiPPc"></span><span id="OGR_F_FillUnsetWithDefault__OGRFeatureH.i.cPP"></span><span class="target" id="ogr__api_8h_1ac705f1d608d5e33d03851a7639fdfa1f"></span>void <code class="descname">OGR_F_FillUnsetWithDefault</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>bNotNullableOnly</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_F_FillUnsetWithDefault11OGRFeatureHiPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill unset fields with default values that might be defined. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a2328a84586eda70f44128bd58a89efc4"><span class="std std-ref">OGRFeature::FillUnsetWithDefault()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bNotNullableOnly</span></code>: if we should fill only unset fields with a not-null constraint. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: unused currently. Must be set to NULL. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_F_Validate11OGRFeatureHii">
<span id="_CPPv314OGR_F_Validate11OGRFeatureHii"></span><span id="_CPPv214OGR_F_Validate11OGRFeatureHii"></span><span id="OGR_F_Validate__OGRFeatureH.i.i"></span><span class="target" id="ogr__api_8h_1ab798c73a20f4b311026232badda9701d"></span>int <code class="descname">OGR_F_Validate</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em>, int <em>nValidateFlags</em>, int <em>bEmitError</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_F_Validate11OGRFeatureHii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Validate that a feature meets constraints of its schema. </p>
<p>The scope of test is specified with the nValidateFlags parameter.</p>
<p>Regarding OGR_F_VAL_WIDTH, the test is done assuming the string width must be interpreted as the number of UTF-8 characters. Some drivers might interpret the width as the number of bytes instead. So this test is rather conservative (if it fails, then it will fail for all interpretations).</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a8ddcb9dd93fc92f7c9c0c55cb39349fb"><span class="std std-ref">OGRFeature::Validate()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if all enabled validation tests pass. </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the feature to validate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nValidateFlags</span></code>: OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL, OGR_F_VAL_GEOM_TYPE, OGR_F_VAL_WIDTH and OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with ‘|’ operator </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bEmitError</span></code>: TRUE if a <a class="reference internal" href="cpl.html#cpl__error_8h_1afda4d86428c1c533449ae6a69cdf430d"><span class="std std-ref">CPLError()</span></a> must be emitted when a check fails </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_L_GetName9OGRLayerH">
<span id="_CPPv313OGR_L_GetName9OGRLayerH"></span><span id="_CPPv213OGR_L_GetName9OGRLayerH"></span><span id="OGR_L_GetName__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a88facf4f8e8b32278101d52ae094255c"></span><em class="property">const</em> char *<code class="descname">OGR_L_GetName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_L_GetName9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the layer name. </p>
<p>This returns the same content as OGR_FD_GetName(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="reference internal" href="#ogr__api_8h_1a88facf4f8e8b32278101d52ae094255c"><span class="std std-ref">OGR_L_GetName()</span></a> directly can avoid lengthy layer definition initialization.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a287f5ec7728cacc2f7d94882a9f1a22e"><span class="std std-ref">OGRLayer::GetName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the layer name (must not been freed) </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_L_GetGeomType9OGRLayerH">
<span id="_CPPv317OGR_L_GetGeomType9OGRLayerH"></span><span id="_CPPv217OGR_L_GetGeomType9OGRLayerH"></span><span id="OGR_L_GetGeomType__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a0adea8ce1ca795ce0a6a76505f90f078"></span><a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <code class="descname">OGR_L_GetGeomType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_L_GetGeomType9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the layer geometry type. </p>
<p>This returns the same result as OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="reference internal" href="#ogr__api_8h_1a0adea8ce1ca795ce0a6a76505f90f078"><span class="std std-ref">OGR_L_GetGeomType()</span></a> directly can avoid lengthy layer definition initialization.</p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use OGR_GFld_GetType(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i)). For layers without any geometry field, this method returns wkbNone.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a818a25520ce08d5a681443348e930604"><span class="std std-ref">OGRLayer::GetGeomType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the geometry type </p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_L_GetSpatialFilter9OGRLayerH">
<span id="_CPPv322OGR_L_GetSpatialFilter9OGRLayerH"></span><span id="_CPPv222OGR_L_GetSpatialFilter9OGRLayerH"></span><span id="OGR_L_GetSpatialFilter__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a36d61f311c9f8c172ad118659358c60a"></span><a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <code class="descname">OGR_L_GetSpatialFilter</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_L_GetSpatialFilter9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1adc3735e444204d46f517eec251712f4d"><span class="std std-ref">OGRLayer::GetSpatialFilter()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the spatial filter geometry. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to get the spatial filter from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_L_SetSpatialFilter9OGRLayerH12OGRGeometryH">
<span id="_CPPv322OGR_L_SetSpatialFilter9OGRLayerH12OGRGeometryH"></span><span id="_CPPv222OGR_L_SetSpatialFilter9OGRLayerH12OGRGeometryH"></span><span id="OGR_L_SetSpatialFilter__OGRLayerH.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a678d1735bc82533614ac005691d1138c"></span>void <code class="descname">OGR_L_SetSpatialFilter</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_L_SetSpatialFilter9OGRLayerH12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="reference internal" href="#ogr__api_8h_1a4f6ef6b70fee9f8cea92cb7a0236fcdb"><span class="std std-ref">OGR_L_GetNextFeature()</span></a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features whose envelope (as returned by <a class="reference internal" href="#ogr__api_8h_1a617a9c9ea85157661619a1d8f0a69cf9"><span class="std std-ref">OGR_G_GetEnvelope()</span></a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>Starting with GDAL 2.3, features with null or empty geometries will never be considered as matching a spatial filter.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="reference internal" href="#ogr__api_8h_1a8b2a10085f410aa84172eba413408c39"><span class="std std-ref">OGR_L_GetSpatialRef()</span></a>). In the future this may be generalized.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0b4ab45cf97cbc470f0d60474d3e4169"><span class="std std-ref">OGRLayer::SetSpatialFilter</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer on which to set the spatial filter. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426OGR_L_SetSpatialFilterRect9OGRLayerHdddd">
<span id="_CPPv326OGR_L_SetSpatialFilterRect9OGRLayerHdddd"></span><span id="_CPPv226OGR_L_SetSpatialFilterRect9OGRLayerHdddd"></span><span id="OGR_L_SetSpatialFilterRect__OGRLayerH.double.double.double.double"></span><span class="target" id="ogr__api_8h_1a5cba569e0779a02a95327f041d9f7a13"></span>void <code class="descname">OGR_L_SetSpatialFilterRect</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, double <em>dfMinX</em>, double <em>dfMinY</em>, double <em>dfMaxX</em>, double <em>dfMaxY</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426OGR_L_SetSpatialFilterRect9OGRLayerHdddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="reference internal" href="#ogr__api_8h_1a4f6ef6b70fee9f8cea92cb7a0236fcdb"><span class="std std-ref">OGR_L_GetNextFeature()</span></a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a75c06b4993f8eb76b569f37365cd19ab"><span class="std std-ref">OGRLayer::GetSpatialRef()</span></a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0b4ab45cf97cbc470f0d60474d3e4169"><span class="std std-ref">OGRLayer::SetSpatialFilter()</span></a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1acd16bcdb3e8f720003fb24cd68f25460"><span class="std std-ref">OGRLayer::SetSpatialFilterRect()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer on which to set the spatial filter. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMinX</span></code>: the minimum X coordinate for the rectangular region. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMinY</span></code>: the minimum Y coordinate for the rectangular region. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxX</span></code>: the maximum X coordinate for the rectangular region. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxY</span></code>: the maximum Y coordinate for the rectangular region. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_L_SetSpatialFilterEx9OGRLayerHi12OGRGeometryH">
<span id="_CPPv324OGR_L_SetSpatialFilterEx9OGRLayerHi12OGRGeometryH"></span><span id="_CPPv224OGR_L_SetSpatialFilterEx9OGRLayerHi12OGRGeometryH"></span><span id="OGR_L_SetSpatialFilterEx__OGRLayerH.i.OGRGeometryH"></span><span class="target" id="ogr__api_8h_1a00c8a1a968542d389f86ed1b4edd5823"></span>void <code class="descname">OGR_L_SetSpatialFilterEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int <em>iGeomField</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hGeom</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_L_SetSpatialFilterEx9OGRLayerHi12OGRGeometryH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="reference internal" href="#ogr__api_8h_1a4f6ef6b70fee9f8cea92cb7a0236fcdb"><span class="std std-ref">OGR_L_GetNextFeature()</span></a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who’s envelope (as returned by <a class="reference internal" href="#ogr__api_8h_1a617a9c9ea85157661619a1d8f0a69cf9"><span class="std std-ref">OGR_G_GetEnvelope()</span></a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0b4ab45cf97cbc470f0d60474d3e4169"><span class="std std-ref">OGRLayer::SetSpatialFilter</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer on which to set the spatial filter. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iGeomField</span></code>: index of the geometry field on which the spatial filter operates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGeom</span></code>: handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_L_SetSpatialFilterRectEx9OGRLayerHidddd">
<span id="_CPPv328OGR_L_SetSpatialFilterRectEx9OGRLayerHidddd"></span><span id="_CPPv228OGR_L_SetSpatialFilterRectEx9OGRLayerHidddd"></span><span id="OGR_L_SetSpatialFilterRectEx__OGRLayerH.i.double.double.double.double"></span><span class="target" id="ogr__api_8h_1a489241dfe65d6e089809d3258c4f79f5"></span>void <code class="descname">OGR_L_SetSpatialFilterRectEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int <em>iGeomField</em>, double <em>dfMinX</em>, double <em>dfMinY</em>, double <em>dfMaxX</em>, double <em>dfMaxY</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_L_SetSpatialFilterRectEx9OGRLayerHidddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="reference internal" href="#ogr__api_8h_1a4f6ef6b70fee9f8cea92cb7a0236fcdb"><span class="std std-ref">OGR_L_GetNextFeature()</span></a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0b4ab45cf97cbc470f0d60474d3e4169"><span class="std std-ref">OGRLayer::SetSpatialFilter()</span></a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1acd16bcdb3e8f720003fb24cd68f25460"><span class="std std-ref">OGRLayer::SetSpatialFilterRect()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer on which to set the spatial filter. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iGeomField</span></code>: index of the geometry field on which the spatial filter operates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMinX</span></code>: the minimum X coordinate for the rectangular region. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMinY</span></code>: the minimum Y coordinate for the rectangular region. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxX</span></code>: the maximum X coordinate for the rectangular region. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxY</span></code>: the maximum Y coordinate for the rectangular region.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424OGR_L_SetAttributeFilter9OGRLayerHPKc">
<span id="_CPPv324OGR_L_SetAttributeFilter9OGRLayerHPKc"></span><span id="_CPPv224OGR_L_SetAttributeFilter9OGRLayerHPKc"></span><span id="OGR_L_SetAttributeFilter__OGRLayerH.cCP"></span><span class="target" id="ogr__api_8h_1a4000d426bf26ad7cc7d4012634c93f09"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_SetAttributeFilter</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <em class="property">const</em> char *<em>pszQuery</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424OGR_L_SetAttributeFilter9OGRLayerHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a new attribute query. </p>
<p>This function sets the attribute query string to be used when fetching features via the <a class="reference internal" href="#ogr__api_8h_1a4f6ef6b70fee9f8cea92cb7a0236fcdb"><span class="std std-ref">OGR_L_GetNextFeature()</span></a> function. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance “population &gt; 1000000 and population &lt; 5000000” where population is an attribute in the layer. The query format is a restricted form of SQL WHERE clause as defined “eq_format=restricted_where” about half way through this document:</p>
<p><a class="reference external" href="http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html">http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html</a></p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="reference internal" href="#ogr__api_8h_1ab0383004bf637171648a9d03a80f15a4"><span class="std std-ref">OGR_L_ResetReading()</span></a>).</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1acb2c6cc5fa3577df5be538284c1b0dde"><span class="std std-ref">OGRLayer::SetAttributeFilter()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer on which attribute query will be executed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszQuery</span></code>: query in restricted SQL WHERE format, or NULL to clear the current query.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_L_ResetReading9OGRLayerH">
<span id="_CPPv318OGR_L_ResetReading9OGRLayerH"></span><span id="_CPPv218OGR_L_ResetReading9OGRLayerH"></span><span id="OGR_L_ResetReading__OGRLayerH"></span><span class="target" id="ogr__api_8h_1ab0383004bf637171648a9d03a80f15a4"></span>void <code class="descname">OGR_L_ResetReading</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_L_ResetReading9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset feature reading to start on the first feature. </p>
<p>This affects GetNextFeature().</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aad0f2cd7f0587584b8f382c6a913583c"><span class="std std-ref">OGRLayer::ResetReading()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer on which features are read. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_L_GetNextFeature9OGRLayerH">
<span id="_CPPv320OGR_L_GetNextFeature9OGRLayerH"></span><span id="_CPPv220OGR_L_GetNextFeature9OGRLayerH"></span><span id="OGR_L_GetNextFeature__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a4f6ef6b70fee9f8cea92cb7a0236fcdb"></span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <code class="descname">OGR_L_GetNextFeature</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_L_GetNextFeature9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsibility of the caller to delete with <a class="reference internal" href="#ogr__api_8h_1a16fb8126aa932f4b4acdaca5ea99bbbb"><span class="std std-ref">OGR_F_Destroy()</span></a>. It is critical that all features associated with an <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> (more specifically an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with SetSpatialFilter()) will be returned.</p>
<p>This function implements sequential access to the features of a layer. The <a class="reference internal" href="#ogr__api_8h_1ab0383004bf637171648a9d03a80f15a4"><span class="std std-ref">OGR_L_ResetReading()</span></a> function can be used to start at the beginning again.</p>
<p>Features returned by OGR_GetNextFeature() may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call <a class="reference internal" href="#ogr__api_8h_1ab0383004bf637171648a9d03a80f15a4"><span class="std std-ref">OGR_L_ResetReading()</span></a> on layers where OGR_GetNextFeature() has been called, before reading again. Structural changes in layers (field addition, deletion, …) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to <a class="reference internal" href="#ogr__api_8h_1ab0383004bf637171648a9d03a80f15a4"><span class="std std-ref">OGR_L_ResetReading()</span></a> might be needed.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a466c14ed1b3cca83abda52729d590dd2"><span class="std std-ref">OGRLayer::GetNextFeature()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to a feature, or NULL if no more features are available. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer from which feature are read. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_L_SetNextByIndex9OGRLayerH7GIntBig">
<span id="_CPPv320OGR_L_SetNextByIndex9OGRLayerH7GIntBig"></span><span id="_CPPv220OGR_L_SetNextByIndex9OGRLayerH7GIntBig"></span><span id="OGR_L_SetNextByIndex__OGRLayerH.GIntBig"></span><span class="target" id="ogr__api_8h_1a8b4427a82ea3de3bed7acff19b6e8e33"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_SetNextByIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <em>nIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_L_SetNextByIndex9OGRLayerH7GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move read cursor to the nIndex’th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the GetNextFeature() call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with GetNextFeature() would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is SetNextByIndex() efficiently implemented. In all other cases the default implementation which calls ResetReading() and then calls GetNextFeature() nIndex times is used. To determine if fast seeking is available on the current layer use the TestCapability() method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ac0b0869ff6fcadda35cbac1f3edf8eae"><span class="std std-ref">OGRLayer::SetNextByIndex()</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success or an error code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nIndex</span></code>: the index indicating how many steps into the result set to seek.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_L_GetFeature9OGRLayerH7GIntBig">
<span id="_CPPv316OGR_L_GetFeature9OGRLayerH7GIntBig"></span><span id="_CPPv216OGR_L_GetFeature9OGRLayerH7GIntBig"></span><span id="OGR_L_GetFeature__OGRLayerH.GIntBig"></span><span class="target" id="ogr__api_8h_1abdad5bebd6b71d136ce21e70ef4c63c7"></span><a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <code class="descname">OGR_L_GetFeature</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <em>nFeatureId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_L_GetFeature9OGRLayerH7GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this function returns a non-NULL feature, it is guaranteed that its feature id (<a class="reference internal" href="#ogr__api_8h_1afc99defd1fb1f8f71ff89c38982f2103"><span class="std std-ref">OGR_F_GetFID()</span></a>) will be the same as nFID.</p>
<p>Use OGR_L_TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="reference internal" href="#ogr__api_8h_1abdad5bebd6b71d136ce21e70ef4c63c7"><span class="std std-ref">OGR_L_GetFeature()</span></a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="reference internal" href="#ogr__api_8h_1a4f6ef6b70fee9f8cea92cb7a0236fcdb"><span class="std std-ref">OGR_L_GetNextFeature()</span></a>) are generally considered interrupted by a <a class="reference internal" href="#ogr__api_8h_1abdad5bebd6b71d136ce21e70ef4c63c7"><span class="std std-ref">OGR_L_GetFeature()</span></a> call.</p>
<p>The returned feature should be free with <a class="reference internal" href="#ogr__api_8h_1a16fb8126aa932f4b4acdaca5ea99bbbb"><span class="std std-ref">OGR_F_Destroy()</span></a>.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a7b39284997972eb198ed754594d52ec2"><span class="std std-ref">OGRLayer::GetFeature( )</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to a feature now owned by the caller, or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer that owned the feature. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFeatureId</span></code>: the feature id of the feature to read.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_L_SetFeature9OGRLayerH11OGRFeatureH">
<span id="_CPPv316OGR_L_SetFeature9OGRLayerH11OGRFeatureH"></span><span id="_CPPv216OGR_L_SetFeature9OGRLayerH11OGRFeatureH"></span><span id="OGR_L_SetFeature__OGRLayerH.OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_SetFeature</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_L_SetFeature9OGRLayerH11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Rewrite an existing feature. </p>
<p>This function will write a feature to the layer, based on the feature id within the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a>.</p>
<p>Use OGR_L_TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="reference internal" href="#ogr__api_8h_1a2cccc8cad9a106ee23628ddf6ef6ece4"><span class="std std-ref">OGR_L_SetFeature()</span></a>.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a6e7dfe0f900ac7fb0f457e7a49b3a5e3"><span class="std std-ref">OGRLayer::SetFeature()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to write the feature. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: the feature to write.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_L_CreateFeature9OGRLayerH11OGRFeatureH">
<span id="_CPPv319OGR_L_CreateFeature9OGRLayerH11OGRFeatureH"></span><span id="_CPPv219OGR_L_CreateFeature9OGRLayerH11OGRFeatureH"></span><span id="OGR_L_CreateFeature__OGRLayerH.OGRFeatureH"></span><span class="target" id="ogr__api_8h_1a5009bc8d78d7f00e2745f3e3ad133779"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_CreateFeature</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_L_CreateFeature9OGRLayerH11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create and write a new feature within a layer. </p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a5d6db0be3b8876142d54e8bfd5dc8324"><span class="std std-ref">OGRLayer::CreateFeature()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to write the feature to. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: the handle of the feature to write to disk.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_L_DeleteFeature9OGRLayerH7GIntBig">
<span id="_CPPv319OGR_L_DeleteFeature9OGRLayerH7GIntBig"></span><span id="_CPPv219OGR_L_DeleteFeature9OGRLayerH7GIntBig"></span><span id="OGR_L_DeleteFeature__OGRLayerH.GIntBig"></span><span class="target" id="ogr__api_8h_1a8a575c6bc193aee66e5c8d91eb170bde"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_DeleteFeature</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <em>nFID</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_L_DeleteFeature9OGRLayerH7GIntBig" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="reference internal" href="#ogr__api_8h_1a480adc8b839b04597f49583371d366fd"><span class="std std-ref">OGR_L_TestCapability()</span></a> function may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ab7f892e23860b43aebb544e29845359d"><span class="std std-ref">OGRLayer::DeleteFeature()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFID</span></code>: the feature id to be deleted from the layer</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_L_GetLayerDefn9OGRLayerH">
<span id="_CPPv318OGR_L_GetLayerDefn9OGRLayerH"></span><span id="_CPPv218OGR_L_GetLayerDefn9OGRLayerH"></span><span id="OGR_L_GetLayerDefn__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a7b67ea4ab5892c6720460dc7f66eca2d"></span><a class="reference internal" href="#_CPPv415OGRFeatureDefnH" title="OGRFeatureDefnH">OGRFeatureDefnH</a> <code class="descname">OGR_L_GetLayerDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_L_GetLayerDefn9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the schema information for this layer. </p>
<p>The returned handle to the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> is owned by the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a80473bcfd11341e70dd35bebe94026cf"><span class="std std-ref">OGRLayer::GetLayerDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the feature definition. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to get the schema information. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_L_GetSpatialRef9OGRLayerH">
<span id="_CPPv319OGR_L_GetSpatialRef9OGRLayerH"></span><span id="_CPPv219OGR_L_GetSpatialRef9OGRLayerH"></span><span id="OGR_L_GetSpatialRef__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a8b2a10085f410aa84172eba413408c39"></span><a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <code class="descname">OGR_L_GetSpatialRef</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_L_GetSpatialRef9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> and should not be modified or freed by the application.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a75c06b4993f8eb76b569f37365cd19ab"><span class="std std-ref">OGRLayer::GetSpatialRef()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>spatial reference, or NULL if there isn’t one. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to get the spatial reference from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_L_FindFieldIndex9OGRLayerHPKci">
<span id="_CPPv320OGR_L_FindFieldIndex9OGRLayerHPKci"></span><span id="_CPPv220OGR_L_FindFieldIndex9OGRLayerHPKci"></span><span id="OGR_L_FindFieldIndex__OGRLayerH.cCP.i"></span><span class="target" id="ogr__api_8h_1affc3cef62be82ec4f811a89b1855cbd5"></span>int <code class="descname">OGR_L_FindFieldIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <em class="property">const</em> char *, int <em>bExactMatch</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_L_FindFieldIndex9OGRLayerHPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the index of field in a layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn’t exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn’t exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aef41bcd7adad1ac5ddcef54d6b38713c"><span class="std std-ref">OGRLayer::FindFieldIndex()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>field index, or -1 if the field doesn’t exist </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_L_GetFeatureCount9OGRLayerHi">
<span id="_CPPv321OGR_L_GetFeatureCount9OGRLayerHi"></span><span id="_CPPv221OGR_L_GetFeatureCount9OGRLayerHi"></span><span id="OGR_L_GetFeatureCount__OGRLayerH.i"></span><span class="target" id="ogr__api_8h_1a08524b6961e52e1561308d2b0c598fb2"></span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig">GIntBig</a> <code class="descname">OGR_L_GetFeatureCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int <em>bForce</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_L_GetFeatureCount9OGRLayerHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn’t know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the CPP <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a2d0e1a43fd1a0a6d55d766384da7b6a5"><span class="std std-ref">OGRLayer::GetFeatureCount()</span></a>.</p>
<p>Note: since GDAL 2.0, this method returns a GIntBig (previously a int)</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>feature count, -1 if count not known. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer that owned the features. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bForce</span></code>: Flag indicating whether the count should be computed even if it is expensive.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_L_GetExtent9OGRLayerHP11OGREnvelopei">
<span id="_CPPv315OGR_L_GetExtent9OGRLayerHP11OGREnvelopei"></span><span id="_CPPv215OGR_L_GetExtent9OGRLayerHP11OGREnvelopei"></span><span id="OGR_L_GetExtent__OGRLayerH.OGREnvelopeP.i"></span><span class="target" id="ogr__api_8h_1aa6c495581900c8301dff91d8cd3ee12f"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_GetExtent</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> *<em>psExtent</em>, int <em>bForce</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_L_GetExtent9OGRLayerHP11OGREnvelopei" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn’t know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="reference internal" href="#ogr__api_8h_1aa6c495581900c8301dff91d8cd3ee12f"><span class="std std-ref">OGR_L_GetExtent()</span></a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a753d30a98f1155306f482438af78e6db"><span class="std std-ref">OGRLayer::GetExtent()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer from which to get extent. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psExtent</span></code>: the structure in which the extent value will be returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bForce</span></code>: Flag indicating whether the extent should be computed even if it is expensive.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_L_GetExtentEx9OGRLayerHiP11OGREnvelopei">
<span id="_CPPv317OGR_L_GetExtentEx9OGRLayerHiP11OGREnvelopei"></span><span id="_CPPv217OGR_L_GetExtentEx9OGRLayerHiP11OGREnvelopei"></span><span id="OGR_L_GetExtentEx__OGRLayerH.i.OGREnvelopeP.i"></span><span class="target" id="ogr__api_8h_1ac3dbfd4443c80dca0d93574f0c00d376"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_GetExtentEx</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int <em>iGeomField</em>, <a class="reference internal" href="#_CPPv411OGREnvelope" title="OGREnvelope">OGREnvelope</a> *<em>psExtent</em>, int <em>bForce</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_L_GetExtentEx9OGRLayerHiP11OGREnvelopei" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn’t know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="reference internal" href="#ogr__api_8h_1aa6c495581900c8301dff91d8cd3ee12f"><span class="std std-ref">OGR_L_GetExtent()</span></a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a753d30a98f1155306f482438af78e6db"><span class="std std-ref">OGRLayer::GetExtent()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer from which to get extent. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iGeomField</span></code>: the index of the geometry field on which to compute the extent. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psExtent</span></code>: the structure in which the extent value will be returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bForce</span></code>: Flag indicating whether the extent should be computed even if it is expensive.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_L_TestCapability9OGRLayerHPKc">
<span id="_CPPv320OGR_L_TestCapability9OGRLayerHPKc"></span><span id="_CPPv220OGR_L_TestCapability9OGRLayerHPKc"></span><span id="OGR_L_TestCapability__OGRLayerH.cCP"></span><span class="target" id="ogr__api_8h_1a480adc8b839b04597f49583371d366fd"></span>int <code class="descname">OGR_L_TestCapability</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <em class="property">const</em> char *<em>pszCap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_L_TestCapability9OGRLayerHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can’t generally be discovered by the caller. </p>
<p><ul>
<li><p><strong>OLCRandomRead</strong> / “RandomRead”: TRUE if the GetFeature() method is implemented in an optimized way for this layer, as opposed to the default implementation using ResetReading() and GetNextFeature() to find the requested feature id.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCSequentialWrite</strong> / “SequentialWrite”: TRUE if the CreateFeature() method works for this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCRandomWrite</strong> / “RandomWrite”: TRUE if the SetFeature() method is operational on this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastSpatialFilter</strong> / “FastSpatialFilter”: TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastFeatureCount</strong> / “FastFeatureCount”: TRUE if this layer can return a feature count (via <a class="reference internal" href="#ogr__api_8h_1a08524b6961e52e1561308d2b0c598fb2"><span class="std std-ref">OGR_L_GetFeatureCount()</span></a>) efficiently, i.e. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastGetExtent</strong> / “FastGetExtent”: TRUE if this layer can return its data extent (via <a class="reference internal" href="#ogr__api_8h_1aa6c495581900c8301dff91d8cd3ee12f"><span class="std std-ref">OGR_L_GetExtent()</span></a>) efficiently, i.e. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastSetNextByIndex</strong> / “FastSetNextByIndex”: TRUE if this layer can perform the SetNextByIndex() call efficiently, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCCreateField</strong> / “CreateField”: TRUE if this layer can create new fields on the current layer using CreateField(), otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCCreateGeomField</strong> / “CreateGeomField”: (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using CreateGeomField(), otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCDeleteField</strong> / “DeleteField”: TRUE if this layer can delete existing fields on the current layer using DeleteField(), otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCReorderFields</strong> / “ReorderFields”: TRUE if this layer can reorder existing fields on the current layer using ReorderField() or ReorderFields(), otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCAlterFieldDefn</strong> / “AlterFieldDefn”: TRUE if this layer can alter the definition of an existing field on the current layer using AlterFieldDefn(), otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCDeleteFeature</strong> / “DeleteFeature”: TRUE if the DeleteFeature() method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCStringsAsUTF8</strong> / “StringsAsUTF8”: TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCTransactions</strong> / “Transactions”: TRUE if the StartTransaction(), CommitTransaction() and RollbackTransaction() methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCCurveGeometries</strong> / “CurveGeometries”: TRUE if this layer supports writing curve geometries or may return such geometries. (GDAL 2.0).</p>
<p></p>
<p></p>
<p></p>
</li>
</ul>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aeedbda1a62f9b89b8e5f24332cf22286"><span class="std std-ref">OGRLayer::TestCapability()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to get the capability from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszCap</span></code>: the name of the capability to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_L_CreateField9OGRLayerH13OGRFieldDefnHi">
<span id="_CPPv317OGR_L_CreateField9OGRLayerH13OGRFieldDefnHi"></span><span id="_CPPv217OGR_L_CreateField9OGRLayerH13OGRFieldDefnHi"></span><span id="OGR_L_CreateField__OGRLayerH.OGRFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1aab585ef1166c61c4819f7fd46ee4a275"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_CreateField</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hField</em>, int <em>bApproxOK</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_L_CreateField9OGRLayerH13OGRFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a00b1376a1eabb1298ef278f92f6d84be"><span class="std std-ref">OGRLayer::CreateField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to write the field definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hField</span></code>: handle of the field definition to write to disk. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bApproxOK</span></code>: If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_L_CreateGeomField9OGRLayerH17OGRGeomFieldDefnHi">
<span id="_CPPv321OGR_L_CreateGeomField9OGRLayerH17OGRGeomFieldDefnHi"></span><span id="_CPPv221OGR_L_CreateGeomField9OGRLayerH17OGRGeomFieldDefnHi"></span><span id="OGR_L_CreateGeomField__OGRLayerH.OGRGeomFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1af6908931c4f3ad364fef8d6e831363bc"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_CreateGeomField</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, <a class="reference internal" href="#_CPPv417OGRGeomFieldDefnH" title="OGRGeomFieldDefnH">OGRGeomFieldDefnH</a> <em>hFieldDefn</em>, int <em>bForce</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_L_CreateGeomField9OGRLayerH17OGRGeomFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a00b1376a1eabb1298ef278f92f6d84be"><span class="std std-ref">OGRLayer::CreateField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.11 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer to write the field definition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hField</span></code>: handle of the geometry field definition to write to disk. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bApproxOK</span></code>: If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_L_DeleteField9OGRLayerHi">
<span id="_CPPv317OGR_L_DeleteField9OGRLayerHi"></span><span id="_CPPv217OGR_L_DeleteField9OGRLayerHi"></span><span id="OGR_L_DeleteField__OGRLayerH.i"></span><span class="target" id="ogr__api_8h_1afc861413683418eba5d31e487da2f9e2"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_DeleteField</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int <em>iField</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_L_DeleteField9OGRLayerHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete an existing field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aaebe7c671dca995549543eecf0f7a76a"><span class="std std-ref">OGRLayer::DeleteField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: index of the field to delete.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_L_ReorderFields9OGRLayerHPi">
<span id="_CPPv319OGR_L_ReorderFields9OGRLayerHPi"></span><span id="_CPPv219OGR_L_ReorderFields9OGRLayerHPi"></span><span id="OGR_L_ReorderFields__OGRLayerH.iP"></span><span class="target" id="ogr__api_8h_1a4cc576cb39e1dd4a1f074125199245bb"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_ReorderFields</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int *<em>panMap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_L_ReorderFields9OGRLayerHPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were “0”,”1”,”2”,”3”,”4” initially. ReorderFields([0,2,3,1,4]) will reorder them as “0”,”2”,”3”,”1”,”4”.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aebd364a150d91f8d65d967646e0f92d3"><span class="std std-ref">OGRLayer::ReorderFields()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panMap</span></code>: an array of GetLayerDefn()-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a3abba98e1e957a01b3af0b9e0f73f493"><span class="std std-ref">OGRFeatureDefn::GetFieldCount()</span></a> elements which is a permutation of [0, GetLayerDefn()-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a3abba98e1e957a01b3af0b9e0f73f493"><span class="std std-ref">OGRFeatureDefn::GetFieldCount()</span></a>-1].</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_L_ReorderField9OGRLayerHii">
<span id="_CPPv318OGR_L_ReorderField9OGRLayerHii"></span><span id="_CPPv218OGR_L_ReorderField9OGRLayerHii"></span><span id="OGR_L_ReorderField__OGRLayerH.i.i"></span><span class="target" id="ogr__api_8h_1ad20a3796ee63935285976ee425878927"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_ReorderField</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int <em>iOldFieldPos</em>, int <em>iNewFieldPos</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_L_ReorderField9OGRLayerHii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorder an existing field on a layer. </p>
<p>This function is a convenience wrapper of <a class="reference internal" href="#ogr__api_8h_1a4cc576cb39e1dd4a1f074125199245bb"><span class="std std-ref">OGR_L_ReorderFields()</span></a> dedicated to move a single field.</p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>The field definition that was at initial position iOldFieldPos will be moved at position iNewFieldPos, and elements between will be shuffled accordingly.</p>
<p>For example, let suppose the fields were “0”,”1”,”2”,”3”,”4” initially. ReorderField(1, 3) will reorder them as “0”,”2”,”3”,”1”,”4”.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ab4c02b991bfa78552eeb0cbcdcf1aed8"><span class="std std-ref">OGRLayer::ReorderField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iOldFieldPos</span></code>: previous position of the field to move. Must be in the range [0,GetFieldCount()-1]. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iNewFieldPos</span></code>: new position of the field to move. Must be in the range [0,GetFieldCount()-1].</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_L_AlterFieldDefn9OGRLayerHi13OGRFieldDefnHi">
<span id="_CPPv320OGR_L_AlterFieldDefn9OGRLayerHi13OGRFieldDefnHi"></span><span id="_CPPv220OGR_L_AlterFieldDefn9OGRLayerHi13OGRFieldDefnHi"></span><span id="OGR_L_AlterFieldDefn__OGRLayerH.i.OGRFieldDefnH.i"></span><span class="target" id="ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_AlterFieldDefn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em>, int <em>iField</em>, <a class="reference internal" href="#_CPPv413OGRFieldDefnH" title="OGRFieldDefnH">OGRFieldDefnH</a> <em>hNewFieldDefn</em>, int <em>nFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_L_AlterFieldDefn9OGRLayerHi13OGRFieldDefnHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1af52f539d34466c10b7c031a8270544b4"><span class="std std-ref">OGRLayer::AlterFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iField</span></code>: index of the field whose definition must be altered. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hNewFieldDefn</span></code>: new field definition </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFlags</span></code>: combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG, ALTER_WIDTH_PRECISION_FLAG, ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to indicate which of the name and/or type and/or width and precision fields and/or nullability from the new field definition must be taken into account.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_L_StartTransaction9OGRLayerH">
<span id="_CPPv322OGR_L_StartTransaction9OGRLayerH"></span><span id="_CPPv222OGR_L_StartTransaction9OGRLayerH"></span><span id="OGR_L_StartTransaction__OGRLayerH"></span><span class="target" id="ogr__api_8h_1ab709fc5cdd7a204fe0220e898a981d85"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_StartTransaction</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_L_StartTransaction9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For datasources which support transactions, StartTransaction creates a transaction. </p>
<p>If starting the transaction fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>Note: as of GDAL 2.0, use of this API is discouraged when the dataset offers dataset level transaction with <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1a3e4161f148fac57dac5cfe4900421348"><span class="std std-ref">GDALDataset::StartTransaction()</span></a>. The reason is that most drivers can only offer transactions at dataset level, and not layer level. Very few drivers really support transactions at layer scope.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ac3cdf24212ec4719ade6065dcb63bb37"><span class="std std-ref">OGRLayer::StartTransaction()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_L_CommitTransaction9OGRLayerH">
<span id="_CPPv323OGR_L_CommitTransaction9OGRLayerH"></span><span id="_CPPv223OGR_L_CommitTransaction9OGRLayerH"></span><span id="OGR_L_CommitTransaction__OGRLayerH"></span><span class="target" id="ogr__api_8h_1aa6f2e9557624952c68eaa46d272bd806"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_CommitTransaction</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_L_CommitTransaction9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For datasources which support transactions, CommitTransaction commits a transaction. </p>
<p>If no transaction is active, or the commit fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ae9f7fd669006a858f53115172f14a2eb"><span class="std std-ref">OGRLayer::CommitTransaction()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_L_RollbackTransaction9OGRLayerH">
<span id="_CPPv325OGR_L_RollbackTransaction9OGRLayerH"></span><span id="_CPPv225OGR_L_RollbackTransaction9OGRLayerH"></span><span id="OGR_L_RollbackTransaction__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a823a6c351dccf751777f67801dd7f9c5"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_RollbackTransaction</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_L_RollbackTransaction9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. </p>
<p>If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ab046dbffc4fbd5bacc6ef75da0686d82"><span class="std std-ref">OGRLayer::RollbackTransaction()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_L_SyncToDisk9OGRLayerH">
<span id="_CPPv316OGR_L_SyncToDisk9OGRLayerH"></span><span id="_CPPv216OGR_L_SyncToDisk9OGRLayerH"></span><span id="OGR_L_SyncToDisk__OGRLayerH"></span><span class="target" id="ogr__api_8h_1a9d845a6cf6652756925530418905471a"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_SyncToDisk</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_L_SyncToDisk9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with <a class="reference internal" href="#ogr__api_8h_1a4823e7c3513cd9d57254364de9a1d021"><span class="std std-ref">OGR_DS_Destroy()</span></a> that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aebb07284c734e485d8611b7c8599254f"><span class="std std-ref">OGRLayer::SyncToDisk()</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_L_GetFIDColumn9OGRLayerH">
<span id="_CPPv318OGR_L_GetFIDColumn9OGRLayerH"></span><span id="_CPPv218OGR_L_GetFIDColumn9OGRLayerH"></span><span id="OGR_L_GetFIDColumn__OGRLayerH"></span><span class="target" id="ogr__api_8h_1abfeb6e1258f113c6c45c8d6a43c8cfa5"></span><em class="property">const</em> char *<code class="descname">OGR_L_GetFIDColumn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_L_GetFIDColumn9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This method returns the name of the underlying database column being used as the FID column, or “” if not supported. </p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1af0cb9a05310d7b17d9dfec9e83a18e61"><span class="std std-ref">OGRLayer::GetFIDColumn()</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>fid column name. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_L_GetGeometryColumn9OGRLayerH">
<span id="_CPPv323OGR_L_GetGeometryColumn9OGRLayerH"></span><span id="_CPPv223OGR_L_GetGeometryColumn9OGRLayerH"></span><span id="OGR_L_GetGeometryColumn__OGRLayerH"></span><span class="target" id="ogr__api_8h_1ab060e07e277cebd1d8504c449d97b29f"></span><em class="property">const</em> char *<code class="descname">OGR_L_GetGeometryColumn</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_L_GetGeometryColumn9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This method returns the name of the underlying database column being used as the geometry column, or “” if not supported. </p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use OGR_GFld_GetNameRef(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i)).</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1af68036c23622c954ce3a91861f22b724"><span class="std std-ref">OGRLayer::GetGeometryColumn()</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>geometry column name. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the layer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_L_GetStyleTable9OGRLayerH">
<span id="_CPPv319OGR_L_GetStyleTable9OGRLayerH"></span><span id="_CPPv219OGR_L_GetStyleTable9OGRLayerH"></span><span id="OGR_L_GetStyleTable__OGRLayerH"></span><span class="target" id="ogr__api_8h_1aceae9ba8158efda9d1bd016022c627ca"></span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <code class="descname">OGR_L_GetStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_L_GetStyleTable9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get style table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427OGR_L_SetStyleTableDirectly9OGRLayerH14OGRStyleTableH">
<span id="_CPPv327OGR_L_SetStyleTableDirectly9OGRLayerH14OGRStyleTableH"></span><span id="_CPPv227OGR_L_SetStyleTableDirectly9OGRLayerH14OGRStyleTableH"></span><span id="OGR_L_SetStyleTableDirectly__OGRLayerH.OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1ab6b700a54fb41ade2b3b090b2e0ef4be"></span>void <code class="descname">OGR_L_SetStyleTableDirectly</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a>, <a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427OGR_L_SetStyleTableDirectly9OGRLayerH14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set style table (and take ownership) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_L_SetStyleTable9OGRLayerH14OGRStyleTableH">
<span id="_CPPv319OGR_L_SetStyleTable9OGRLayerH14OGRStyleTableH"></span><span id="_CPPv219OGR_L_SetStyleTable9OGRLayerH14OGRStyleTableH"></span><span id="OGR_L_SetStyleTable__OGRLayerH.OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1a9c5965608098528549e585895cb62e92"></span>void <code class="descname">OGR_L_SetStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a>, <a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_L_SetStyleTable9OGRLayerH14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set style table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_L_SetIgnoredFields9OGRLayerHPPKc">
<span id="_CPPv322OGR_L_SetIgnoredFields9OGRLayerHPPKc"></span><span id="_CPPv222OGR_L_SetIgnoredFields9OGRLayerHPPKc"></span><span id="OGR_L_SetIgnoredFields__OGRLayerH.cCPP"></span><span class="target" id="ogr__api_8h_1a6d43f1474201356bed2e6f92e7d37154"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_SetIgnoredFields</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a>, <em class="property">const</em> char **<em>papszFields</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_L_SetIgnoredFields9OGRLayerHPPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to GetFeature() / GetNextFeature() and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: “OGR_GEOMETRY” to ignore geometry and “OGR_STYLE” to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>This method is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a5e0c3427f64249d1c35cefb487546b10"><span class="std std-ref">OGRLayer::SetIgnoredFields()</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszFields</span></code>: an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_L_Intersection9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv">
<span id="_CPPv318OGR_L_Intersection9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="_CPPv218OGR_L_Intersection9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="OGR_L_Intersection__OGRLayerH.OGRLayerH.OGRLayerH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="ogr__api_8h_1a5c353cc32c9dd02967a7bed1450d2524"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_Intersection</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerInput</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerMethod</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerResult</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_L_Intersection9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Intersection of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are common between features in the input layer and in the method layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<p><p>The recognized list of options is : </p>
<ul class="simple">
<li><p>SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </p></li>
<li><p>PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </p></li>
<li><p>INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </p></li>
<li><p>METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </p></li>
<li><p>USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer. </p></li>
<li><p>PRETEST_CONTAINMENT=YES/NO. Set to YES to pretest the containment of features of method layer within the features of this layer. This will speed up the method significantly in some cases. Requires that the prepared geometries are in effect. </p></li>
<li><p>KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is to add but only if the result layer has an unknown geometry type. </p></li>
</ul>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</p>
</dd>
</dl>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a5202606175f7e7dcd76c3eb237ac8303"><span class="std std-ref">OGRLayer::Intersection()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>The first geometry field is always used.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerInput</span></code>: the input layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerMethod</span></code>: the method layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerResult</span></code>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options (may be NULL).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_L_Union9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv">
<span id="_CPPv311OGR_L_Union9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="_CPPv211OGR_L_Union9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="OGR_L_Union__OGRLayerH.OGRLayerH.OGRLayerH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="ogr__api_8h_1ac8edb8696c2b046370e29efdd73787f7"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_Union</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerInput</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerMethod</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerResult</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_L_Union9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Union of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer, in the method layer, or in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<p><p>The recognized list of options is : </p>
<ul class="simple">
<li><p>SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </p></li>
<li><p>PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </p></li>
<li><p>INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </p></li>
<li><p>METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </p></li>
<li><p>USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer. </p></li>
<li><p>KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is to add but only if the result layer has an unknown geometry type. </p></li>
</ul>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</p>
</dd>
</dl>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1adf0598c7dab1f4dbe3e2735e27450c9c"><span class="std std-ref">OGRLayer::Union()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>The first geometry field is always used.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerInput</span></code>: the input layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerMethod</span></code>: the method layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerResult</span></code>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options (may be NULL).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_L_SymDifference9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv">
<span id="_CPPv319OGR_L_SymDifference9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="_CPPv219OGR_L_SymDifference9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="OGR_L_SymDifference__OGRLayerH.OGRLayerH.OGRLayerH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="ogr__api_8h_1a03249311ff4c88b2fac5f728be63b549"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_SymDifference</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerInput</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerMethod</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerResult</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_L_SymDifference9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Symmetrical difference of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer but not in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<p><p>The recognized list of options is : </p>
<ul class="simple">
<li><p>SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </p></li>
<li><p>PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </p></li>
<li><p>INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </p></li>
<li><p>METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </p></li>
</ul>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</p>
</dd>
</dl>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a781aa76c6b44b19de09f61816e32245b"><span class="std std-ref">OGRLayer::SymDifference()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>The first geometry field is always used.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerInput</span></code>: the input layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerMethod</span></code>: the method layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerResult</span></code>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options (may be NULL).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_L_Identity9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv">
<span id="_CPPv314OGR_L_Identity9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="_CPPv214OGR_L_Identity9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="OGR_L_Identity__OGRLayerH.OGRLayerH.OGRLayerH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="ogr__api_8h_1a67948074f2e2942cebdd0f90bbec8aa9"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_Identity</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerInput</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerMethod</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerResult</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_L_Identity9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Identify the features of this layer with the ones from the identity layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in input and method layers.</p>
<p><p>The recognized list of options is : </p>
<ul class="simple">
<li><p>SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </p></li>
<li><p>PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </p></li>
<li><p>INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </p></li>
<li><p>METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </p></li>
<li><p>USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer. </p></li>
<li><p>KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is to add but only if the result layer has an unknown geometry type. </p></li>
</ul>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</p>
</dd>
</dl>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a385ff64cc8b070819da0a7e121ff07b3"><span class="std std-ref">OGRLayer::Identity()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>The first geometry field is always used.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerInput</span></code>: the input layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerMethod</span></code>: the method layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerResult</span></code>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options (may be NULL).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGR_L_Update9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv">
<span id="_CPPv312OGR_L_Update9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="_CPPv212OGR_L_Update9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="OGR_L_Update__OGRLayerH.OGRLayerH.OGRLayerH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="ogr__api_8h_1a87b478c971619145dee7d8d8deeac702"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_Update</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerInput</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerMethod</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerResult</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGR_L_Update9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update this layer with features from the update layer. </p>
<p>The result layer contains features whose geometries represent areas that are either in the input layer or in the method layer. The features in the result layer have areas of the features of the method layer or those ares of the features of the input layer that are not covered by the method layer. The features of the result layer get their attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<p><p>The recognized list of options is : </p>
<ul class="simple">
<li><p>SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </p></li>
<li><p>PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </p></li>
<li><p>INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </p></li>
<li><p>METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </p></li>
</ul>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>If the schema of the result is set by user and contains fields that have the same name as a field in the method layer, then the attribute in the result feature the originates from the method layer will get the value from the feature of the method layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</p>
</dd>
</dl>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a6b86f3a070fe99e39631c994be4fce08"><span class="std std-ref">OGRLayer::Update()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>The first geometry field is always used.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerInput</span></code>: the input layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerMethod</span></code>: the method layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerResult</span></code>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options (may be NULL).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410OGR_L_Clip9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv">
<span id="_CPPv310OGR_L_Clip9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="_CPPv210OGR_L_Clip9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="OGR_L_Clip__OGRLayerH.OGRLayerH.OGRLayerH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="ogr__api_8h_1ae12dcd5dc6dc5f930218573658f1b5c2"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_Clip</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerInput</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerMethod</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerResult</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410OGR_L_Clip9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clip off areas that are not covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer and in the method layer. The features in the result layer have the (possibly clipped) areas of features in the input layer and the attributes from the same features. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<p><p>The recognized list of options is : </p>
<ul class="simple">
<li><p>SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </p></li>
<li><p>PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </p></li>
<li><p>INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </p></li>
<li><p>METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </p></li>
</ul>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</p>
</dd>
</dl>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a822deb3b2d047185e3a454692619291c"><span class="std std-ref">OGRLayer::Clip()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>The first geometry field is always used.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerInput</span></code>: the input layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerMethod</span></code>: the method layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerResult</span></code>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options (may be NULL).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_L_Erase9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv">
<span id="_CPPv311OGR_L_Erase9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="_CPPv211OGR_L_Erase9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv"></span><span id="OGR_L_Erase__OGRLayerH.OGRLayerH.OGRLayerH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="ogr__api_8h_1a0f8c47bbeae70e609f4e51a239784285"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_L_Erase</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerInput</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerMethod</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>pLayerResult</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_L_Erase9OGRLayerH9OGRLayerH9OGRLayerHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove areas that are covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer but not in the method layer. The features in the result layer have attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<p><p>The recognized list of options is : </p>
<ul class="simple">
<li><p>SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </p></li>
<li><p>PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </p></li>
<li><p>INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </p></li>
<li><p>METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </p></li>
</ul>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</p>
</dd>
</dl>
</p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a23fa292ae87af3bc0d3abb3963a71914"><span class="std std-ref">OGRLayer::Erase()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</p>
</dd>
<dt><strong>Note</strong></dt><dd><p>The first geometry field is always used.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>OGR 1.10 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerInput</span></code>: the input layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerMethod</span></code>: the method layer. Should not be NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pLayerResult</span></code>: the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL terminated list of options (may be NULL).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_DS_Destroy14OGRDataSourceH">
<span id="_CPPv314OGR_DS_Destroy14OGRDataSourceH"></span><span id="_CPPv214OGR_DS_Destroy14OGRDataSourceH"></span><span id="OGR_DS_Destroy__OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1a4823e7c3513cd9d57254364de9a1d021"></span>void <code class="descname">OGR_DS_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDataSource</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_DS_Destroy14OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Closes opened datasource and releases allocated resources. </p>
<p>This method is the same as the C++ method OGRDataSource::DestroyDataSource().</p>
<p></p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDataSource</span></code>: handle to allocated datasource object. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_DS_GetName14OGRDataSourceH">
<span id="_CPPv314OGR_DS_GetName14OGRDataSourceH"></span><span id="_CPPv214OGR_DS_GetName14OGRDataSourceH"></span><span id="OGR_DS_GetName__OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1aea8cc826474b55371b1b4e24a24ba1db"></span><em class="property">const</em> char *<code class="descname">OGR_DS_GetName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_DS_GetName14OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the name of the data source. </p>
<p>This string should be sufficient to open the data source if passed to the same OGRSFDriver that this data source was opened with, but it need not be exactly the same string that was used to open the data source. Normally this is a filename.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to an internal name string which should not be modified or freed by the caller. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source to get the name from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_DS_GetLayerCount14OGRDataSourceH">
<span id="_CPPv320OGR_DS_GetLayerCount14OGRDataSourceH"></span><span id="_CPPv220OGR_DS_GetLayerCount14OGRDataSourceH"></span><span id="OGR_DS_GetLayerCount__OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1ac6da541cb655ab631df729e71da2e762"></span>int <code class="descname">OGR_DS_GetLayerCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_DS_GetLayerCount14OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of layers in this data source. </p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>layer count. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source from which to get the number of layers. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_DS_GetLayer14OGRDataSourceHi">
<span id="_CPPv315OGR_DS_GetLayer14OGRDataSourceHi"></span><span id="_CPPv215OGR_DS_GetLayer14OGRDataSourceHi"></span><span id="OGR_DS_GetLayer__OGRDataSourceH.i"></span><span class="target" id="ogr__api_8h_1a03998029f904d1c3b12de40114e7503e"></span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <code class="descname">OGR_DS_GetLayer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, int <em>iLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_DS_GetLayer14OGRDataSourceHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a layer by index. </p>
<p>The returned layer remains owned by the OGRDataSource and should not be deleted by the application.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the layer, or NULL if iLayer is out of range or an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source from which to get the layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iLayer</span></code>: a layer number between 0 and <a class="reference internal" href="#ogr__api_8h_1ac6da541cb655ab631df729e71da2e762"><span class="std std-ref">OGR_DS_GetLayerCount()</span></a>-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_DS_GetLayerByName14OGRDataSourceHPKc">
<span id="_CPPv321OGR_DS_GetLayerByName14OGRDataSourceHPKc"></span><span id="_CPPv221OGR_DS_GetLayerByName14OGRDataSourceHPKc"></span><span id="OGR_DS_GetLayerByName__OGRDataSourceH.cCP"></span><span class="target" id="ogr__api_8h_1a74af4912b67bf2a7b6e3230711a40d0e"></span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <code class="descname">OGR_DS_GetLayerByName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, <em class="property">const</em> char *<em>pszLayerName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_DS_GetLayerByName14OGRDataSourceHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a layer by name. </p>
<p>The returned layer remains owned by the OGRDataSource and should not be deleted by the application.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the layer, or NULL if the layer is not found or an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source from which to get the layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszLayerName</span></code>: Layer the layer name of the layer to fetch.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_DS_DeleteLayer14OGRDataSourceHi">
<span id="_CPPv318OGR_DS_DeleteLayer14OGRDataSourceHi"></span><span id="_CPPv218OGR_DS_DeleteLayer14OGRDataSourceHi"></span><span id="OGR_DS_DeleteLayer__OGRDataSourceH.i"></span><span class="target" id="ogr__api_8h_1a85827a79cd2ddb5a55126e785bee427d"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_DS_DeleteLayer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, int <em>iLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_DS_DeleteLayer14OGRDataSourceHi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete the indicated layer from the datasource. </p>
<p>If this method is supported the ODsCDeleteLayer capability will test TRUE on the OGRDataSource.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success, or OGRERR_UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the datasource </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iLayer</span></code>: the index of the layer to delete.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_DS_GetDriver14OGRDataSourceH">
<span id="_CPPv316OGR_DS_GetDriver14OGRDataSourceH"></span><span id="_CPPv216OGR_DS_GetDriver14OGRDataSourceH"></span><span id="OGR_DS_GetDriver__OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1a5def9c0aa6f6f60ab96369203330e326"></span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <code class="descname">OGR_DS_GetDriver</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_DS_GetDriver14OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the driver that the dataset was opened with. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL if driver info is not available, or pointer to a driver owned by the OGRSFDriverManager. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the datasource </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_DS_CreateLayer14OGRDataSourceHPKc20OGRSpatialReferenceH18OGRwkbGeometryTypePPc">
<span id="_CPPv318OGR_DS_CreateLayer14OGRDataSourceHPKc20OGRSpatialReferenceH18OGRwkbGeometryTypePPc"></span><span id="_CPPv218OGR_DS_CreateLayer14OGRDataSourceHPKc20OGRSpatialReferenceH18OGRwkbGeometryTypePPc"></span><span id="OGR_DS_CreateLayer__OGRDataSourceH.cCP.OGRSpatialReferenceH.OGRwkbGeometryType.cPP"></span><span class="target" id="ogr__api_8h_1a424d383a37fbeaea58acaea11717f320"></span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <code class="descname">OGR_DS_CreateLayer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, <em class="property">const</em> char *<em>pszName</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSpatialRef</em>, <a class="reference internal" href="#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType">OGRwkbGeometryType</a> <em>eType</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_DS_CreateLayer14OGRDataSourceHPKc20OGRSpatialReferenceH18OGRwkbGeometryTypePPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<p></p>
<p><strong>Example:</strong><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL is returned on failure, or a new <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> handle on success.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: The dataset handle. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name for the new layer. This should ideally not match any existing layer on the datasource. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSpatialRef</span></code>: handle to the coordinate system to use for the new layer, or NULL if no coordinate system is available. The driver might only increase the reference counter of the object to take ownership, and not make a full copy, so do not use <a class="reference internal" href="ogr_srs_api.html#ogr__srs__api_8h_1aa1485e7c17fb7edc15a0dfda63f77333"><span class="std std-ref">OSRDestroySpatialReference()</span></a>, but <a class="reference internal" href="ogr_srs_api.html#ogr__srs__api_8h_1adb5e564701dab4e83b3d353745f4a054"><span class="std std-ref">OSRRelease()</span></a> instead when you are done with the object. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: the geometry type for the layer. Use wkbUnknown if there are no constraints on the types geometry to be written. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a class="reference external" href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></p></li>
</ul>
</dd>
</dl>
</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;ogrsf_frmts.h&quot;</span>
<span class="c1">#include &quot;cpl_string.h&quot;</span>

<span class="o">...</span>

        <span class="n">OGRLayerH</span> <span class="o">*</span><span class="n">hLayer</span><span class="p">;</span>
        <span class="n">char</span>     <span class="o">**</span><span class="n">papszOptions</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">OGR_DS_TestCapability</span><span class="p">(</span> <span class="n">hDS</span><span class="p">,</span> <span class="n">ODsCCreateLayer</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="o">...</span>
        <span class="p">}</span>

        <span class="n">papszOptions</span> <span class="o">=</span> <span class="n">CSLSetNameValue</span><span class="p">(</span> <span class="n">papszOptions</span><span class="p">,</span> <span class="s2">&quot;DIM&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span> <span class="p">);</span>
        <span class="n">hLayer</span> <span class="o">=</span> <span class="n">OGR_DS_CreateLayer</span><span class="p">(</span> <span class="n">hDS</span><span class="p">,</span> <span class="s2">&quot;NewLayer&quot;</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">wkbUnknown</span><span class="p">,</span>
                                     <span class="n">papszOptions</span> <span class="p">);</span>
        <span class="n">CSLDestroy</span><span class="p">(</span> <span class="n">papszOptions</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">hLayer</span> <span class="o">==</span> <span class="n">NULL</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="o">...</span>
        <span class="p">}</span>
</pre></div>
</div>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_DS_CopyLayer14OGRDataSourceH9OGRLayerHPKcPPc">
<span id="_CPPv316OGR_DS_CopyLayer14OGRDataSourceH9OGRLayerHPKcPPc"></span><span id="_CPPv216OGR_DS_CopyLayer14OGRDataSourceH9OGRLayerHPKcPPc"></span><span id="OGR_DS_CopyLayer__OGRDataSourceH.OGRLayerH.cCP.cPP"></span><span class="target" id="ogr__api_8h_1a628d34530517b618696c97b73de31df7"></span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <code class="descname">OGR_DS_CopyLayer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hSrcLayer</em>, <em class="property">const</em> char *<em>pszNewName</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_DS_CopyLayer14OGRDataSourceH9OGRLayerHPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Duplicate an existing layer. </p>
<p>This function creates a new layer, duplicate the field definitions of the source layer and then duplicate each features of the source layer. The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation. The source layer may come from another dataset.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the layer, or NULL if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source where to create the new layer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcLayer</span></code>: handle to the source layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNewName</span></code>: the name of the layer to create. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: a StringList of name=value options. Options are driver specific.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_DS_TestCapability14OGRDataSourceHPKc">
<span id="_CPPv321OGR_DS_TestCapability14OGRDataSourceHPKc"></span><span id="_CPPv221OGR_DS_TestCapability14OGRDataSourceHPKc"></span><span id="OGR_DS_TestCapability__OGRDataSourceH.cCP"></span><span class="target" id="ogr__api_8h_1ad0fefab726442fa71ab5ef74fe8549a6"></span>int <code class="descname">OGR_DS_TestCapability</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, <em class="property">const</em> char *<em>pszCapability</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_DS_TestCapability14OGRDataSourceHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<p><ul>
<li><p><strong>ODsCCreateLayer</strong>: True if this datasource can create new layers. </p></li>
<li><p><strong>ODsCDeleteLayer</strong>: True if this datasource can delete existing layers.</p>
<p></p>
</li>
<li><p><strong>ODsCCreateGeomFieldAfterCreateLayer</strong>: True if the layers of this datasource support CreateGeomField() just after layer creation.</p>
<p></p>
</li>
<li><p><strong>ODsCCurveGeometries</strong>: True if this datasource supports writing curve geometries. (GDAL 2.0). In that case, OLCCurveGeometries must also be declared in layers of that dataset.</p>
<p></p>
<p></p>
</li>
</ul>
</p>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if capability available otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source against which to test the capability. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszCapability</span></code>: the capability to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_DS_ExecuteSQL14OGRDataSourceHPKc12OGRGeometryHPKc">
<span id="_CPPv317OGR_DS_ExecuteSQL14OGRDataSourceHPKc12OGRGeometryHPKc"></span><span id="_CPPv217OGR_DS_ExecuteSQL14OGRDataSourceHPKc12OGRGeometryHPKc"></span><span id="OGR_DS_ExecuteSQL__OGRDataSourceH.cCP.OGRGeometryH.cCP"></span><span class="target" id="ogr__api_8h_1a9892ecb0bf61add295bd9decdb13797a"></span><a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <code class="descname">OGR_DS_ExecuteSQL</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, <em class="property">const</em> char *<em>pszSQLCommand</em>, <a class="reference internal" href="#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> <em>hSpatialFilter</em>, <em class="property">const</em> char *<em>pszDialect</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_DS_ExecuteSQL14OGRDataSourceHPKc12OGRGeometryHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Execute an SQL statement against the data store. </p>
<p>The result of an SQL query is either NULL for statements that are in error, or that have no results set, or an <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> handle representing a results set from the query. Note that this <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> is in addition to the layers in the data store and must be destroyed with <a class="reference internal" href="#ogr__api_8h_1afc7b521a05c1207e298a2b9dbf4a1181"><span class="std std-ref">OGR_DS_ReleaseResultSet()</span></a> before the data source is closed (destroyed).</p>
<p>For more information on the SQL dialect supported internally by OGR review the <a class="reference external" href="ogr_sql.html">OGR SQL</a> document. Some drivers (i.e. Oracle and PostGIS) pass the SQL directly through to the underlying RDBMS.</p>
<p>Starting with OGR 1.10, the <a class="reference external" href="ogr_sql_sqlite.html">SQLITE dialect</a> can also be used.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to a <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> containing the results of the query. Deallocate with <a class="reference internal" href="#ogr__api_8h_1afc7b521a05c1207e298a2b9dbf4a1181"><span class="std std-ref">OGR_DS_ReleaseResultSet()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source on which the SQL query is executed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSQLCommand</span></code>: the SQL statement to execute. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSpatialFilter</span></code>: handle to a geometry which represents a spatial filter. Can be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDialect</span></code>: allows control of the statement dialect. If set to NULL, the OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine, unless OGRSQL is explicitly passed as the dialect. Starting with OGR 1.10, the SQLITE dialect can also be used.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_DS_ReleaseResultSet14OGRDataSourceH9OGRLayerH">
<span id="_CPPv323OGR_DS_ReleaseResultSet14OGRDataSourceH9OGRLayerH"></span><span id="_CPPv223OGR_DS_ReleaseResultSet14OGRDataSourceH9OGRLayerH"></span><span id="OGR_DS_ReleaseResultSet__OGRDataSourceH.OGRLayerH"></span><span class="target" id="ogr__api_8h_1afc7b521a05c1207e298a2b9dbf4a1181"></span>void <code class="descname">OGR_DS_ReleaseResultSet</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em>, <a class="reference internal" href="#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hLayer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_DS_ReleaseResultSet14OGRDataSourceH9OGRLayerH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release results of <a class="reference internal" href="#ogr__api_8h_1a9892ecb0bf61add295bd9decdb13797a"><span class="std std-ref">OGR_DS_ExecuteSQL()</span></a>. </p>
<p>This function should only be used to deallocate OGRLayers resulting from an <a class="reference internal" href="#ogr__api_8h_1a9892ecb0bf61add295bd9decdb13797a"><span class="std std-ref">OGR_DS_ExecuteSQL()</span></a> call on the same OGRDataSource. Failure to deallocate a results set before destroying the OGRDataSource may cause errors.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: an handle to the data source on which was executed an SQL query. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: handle to the result of a previous <a class="reference internal" href="#ogr__api_8h_1a9892ecb0bf61add295bd9decdb13797a"><span class="std std-ref">OGR_DS_ExecuteSQL()</span></a> call. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_DS_SyncToDisk14OGRDataSourceH">
<span id="_CPPv317OGR_DS_SyncToDisk14OGRDataSourceH"></span><span id="_CPPv217OGR_DS_SyncToDisk14OGRDataSourceH"></span><span id="OGR_DS_SyncToDisk__OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1a139ab189c06d9f5f26e21b134928f882"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_DS_SyncToDisk</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_DS_SyncToDisk14OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush pending changes to disk. </p>
<p>See <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1ab6421c7ec7068c274a030e22aa6609e1"><span class="std std-ref">GDALDataset::FlushCache()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_DS_GetStyleTable14OGRDataSourceH">
<span id="_CPPv320OGR_DS_GetStyleTable14OGRDataSourceH"></span><span id="_CPPv220OGR_DS_GetStyleTable14OGRDataSourceH"></span><span id="OGR_DS_GetStyleTable__OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1a6164ac434dcd9660089c97fd59bab558"></span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <code class="descname">OGR_DS_GetStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_DS_GetStyleTable14OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get style table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428OGR_DS_SetStyleTableDirectly14OGRDataSourceH14OGRStyleTableH">
<span id="_CPPv328OGR_DS_SetStyleTableDirectly14OGRDataSourceH14OGRStyleTableH"></span><span id="_CPPv228OGR_DS_SetStyleTableDirectly14OGRDataSourceH14OGRStyleTableH"></span><span id="OGR_DS_SetStyleTableDirectly__OGRDataSourceH.OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1aaf553bb35c9f1707b3c727af166c8a0a"></span>void <code class="descname">OGR_DS_SetStyleTableDirectly</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a>, <a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428OGR_DS_SetStyleTableDirectly14OGRDataSourceH14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set style table (and take ownership) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGR_DS_SetStyleTable14OGRDataSourceH14OGRStyleTableH">
<span id="_CPPv320OGR_DS_SetStyleTable14OGRDataSourceH14OGRStyleTableH"></span><span id="_CPPv220OGR_DS_SetStyleTable14OGRDataSourceH14OGRStyleTableH"></span><span id="OGR_DS_SetStyleTable__OGRDataSourceH.OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1a03947d4ec069a83526274780c8a6f48b"></span>void <code class="descname">OGR_DS_SetStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a>, <a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGR_DS_SetStyleTable14OGRDataSourceH14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set style table. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_Dr_GetName12OGRSFDriverH">
<span id="_CPPv314OGR_Dr_GetName12OGRSFDriverH"></span><span id="_CPPv214OGR_Dr_GetName12OGRSFDriverH"></span><span id="OGR_Dr_GetName__OGRSFDriverH"></span><span class="target" id="ogr__api_8h_1afd11ea603491207a89c75b6b9480e091"></span><em class="property">const</em> char *<code class="descname">OGR_Dr_GetName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <em>hDriver</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_Dr_GetName12OGRSFDriverH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch name of driver (file format). </p>
<p>This name should be relatively short (10-40 characters), and should reflect the underlying file format. For instance “ESRI Shapefile”.</p>
<p>This function is the same as the C++ method OGRSFDriver::GetName().</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>driver name. This is an internal string and should not be modified or freed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDriver</span></code>: handle to the driver to get the name from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411OGR_Dr_Open12OGRSFDriverHPKci">
<span id="_CPPv311OGR_Dr_Open12OGRSFDriverHPKci"></span><span id="_CPPv211OGR_Dr_Open12OGRSFDriverHPKci"></span><span id="OGR_Dr_Open__OGRSFDriverH.cCP.i"></span><span class="target" id="ogr__api_8h_1a464b2210400d91fb9c6fa76595ea3681"></span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <code class="descname">OGR_Dr_Open</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <em>hDriver</em>, <em class="property">const</em> char *<em>pszName</em>, int <em>bUpdate</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411OGR_Dr_Open12OGRSFDriverHPKci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Attempt to open file with this driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a>. This <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a> should be closed by deleting the object when it is no longer needed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDriver</span></code>: handle to the driver that is used to open file. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the file, or data source to try and open. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bUpdate</span></code>: TRUE if update access is required, otherwise FALSE (the default).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_Dr_TestCapability12OGRSFDriverHPKc">
<span id="_CPPv321OGR_Dr_TestCapability12OGRSFDriverHPKc"></span><span id="_CPPv221OGR_Dr_TestCapability12OGRSFDriverHPKc"></span><span id="OGR_Dr_TestCapability__OGRSFDriverH.cCP"></span><span class="target" id="ogr__api_8h_1a9010219bbc2e32627064ed860048d979"></span>int <code class="descname">OGR_Dr_TestCapability</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <em>hDriver</em>, <em class="property">const</em> char *<em>pszCap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_Dr_TestCapability12OGRSFDriverHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<p><ul>
<li><p><strong>ODrCCreateDataSource</strong>: True if this driver can support creating data sources.</p>
<p></p>
</li>
<li><p><strong>ODrCDeleteDataSource</strong>: True if this driver supports deleting data sources.</p>
<p></p>
</li>
</ul>
</p>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if capability available otherwise FALSE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDriver</span></code>: handle to the driver to test the capability against. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszCap</span></code>: the capability to test.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_Dr_CreateDataSource12OGRSFDriverHPKcPPc">
<span id="_CPPv323OGR_Dr_CreateDataSource12OGRSFDriverHPKcPPc"></span><span id="_CPPv223OGR_Dr_CreateDataSource12OGRSFDriverHPKcPPc"></span><span id="OGR_Dr_CreateDataSource__OGRSFDriverH.cCP.cPP"></span><span class="target" id="ogr__api_8h_1ac2b628f8ddc674f72c798829c738bbdd"></span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <code class="descname">OGR_Dr_CreateDataSource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <em>hDriver</em>, <em class="property">const</em> char *<em>pszName</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_Dr_CreateDataSource12OGRSFDriverHPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function attempts to create a new data source based on the passed driver. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<p>It is important to call <a class="reference internal" href="#ogr__api_8h_1a4823e7c3513cd9d57254364de9a1d021"><span class="std std-ref">OGR_DS_Destroy()</span></a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL is returned on failure, or a new OGRDataSource handle on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDriver</span></code>: handle to the driver on which data source creation is based. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name for the new data source. UTF-8 encoded. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a class="reference external" href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_Dr_CopyDataSource12OGRSFDriverH14OGRDataSourceHPKcPPc">
<span id="_CPPv321OGR_Dr_CopyDataSource12OGRSFDriverH14OGRDataSourceHPKcPPc"></span><span id="_CPPv221OGR_Dr_CopyDataSource12OGRSFDriverH14OGRDataSourceHPKcPPc"></span><span id="OGR_Dr_CopyDataSource__OGRSFDriverH.OGRDataSourceH.cCP.cPP"></span><span class="target" id="ogr__api_8h_1ae94a7a1c0cb226c7ce04e0380a12a44e"></span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <code class="descname">OGR_Dr_CopyDataSource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <em>hDriver</em>, <a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hSrcDS</em>, <em class="property">const</em> char *<em>pszNewName</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_Dr_CopyDataSource12OGRSFDriverH14OGRDataSourceHPKcPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function creates a new datasource by copying all the layers from the source datasource. </p>
<p>It is important to call <a class="reference internal" href="#ogr__api_8h_1a4823e7c3513cd9d57254364de9a1d021"><span class="std std-ref">OGR_DS_Destroy()</span></a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL is returned on failure, or a new OGRDataSource handle on success. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDriver</span></code>: handle to the driver on which data source creation is based. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcDS</span></code>: source datasource </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszNewName</span></code>: the name for the new data source. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a class="reference external" href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_Dr_DeleteDataSource12OGRSFDriverHPKc">
<span id="_CPPv323OGR_Dr_DeleteDataSource12OGRSFDriverHPKc"></span><span id="_CPPv223OGR_Dr_DeleteDataSource12OGRSFDriverHPKc"></span><span id="OGR_Dr_DeleteDataSource__OGRSFDriverH.cCP"></span><span class="target" id="ogr__api_8h_1a4d2314e22acd846e7e31ff5a5c5ec27f"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGR_Dr_DeleteDataSource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <em>hDriver</em>, <em class="property">const</em> char *<em>pszDataSource</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_Dr_DeleteDataSource12OGRSFDriverHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete a datasource. </p>
<p>Delete (from the disk, in the database, …) the named datasource. Normally it would be safest if the datasource was not open at the time.</p>
<p>Whether this is a supported operation on this driver case be tested using TestCapability() on ODrCDeleteDataSource.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success, and OGRERR_UNSUPPORTED_OPERATION if this is not supported by this driver. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDriver</span></code>: handle to the driver on which data source deletion is based.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDataSource</span></code>: the name of the datasource to delete.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv47OGROpenPKciP12OGRSFDriverH">
<span id="_CPPv37OGROpenPKciP12OGRSFDriverH"></span><span id="_CPPv27OGROpenPKciP12OGRSFDriverH"></span><span id="OGROpen__cCP.i.OGRSFDriverHP"></span><span class="target" id="ogr__api_8h_1a2da3630231780d519543d1679c83e62f"></span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <code class="descname">OGROpen</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em>, int <em>bUpdate</em>, <a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> *<em>pahDriverList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47OGROpenPKciP12OGRSFDriverH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open a file / data source with one of the registered drivers. </p>
<p>This function loops through all the drivers registered with the driver manager trying each until one succeeds with the given data source.</p>
<p>If this function fails, <a class="reference internal" href="cpl.html#cpl__error_8h_1a7f71ade3bb0a0e9e45802975ec59ff5e"><span class="std std-ref">CPLGetLastErrorMsg()</span></a> can be used to check if there is an error message explaining why.</p>
<p>For drivers supporting the VSI virtual file API, it is possible to open a file in a .zip archive (see <a class="reference internal" href="cpl.html#cpl__vsi_8h_1a884fac3cd6be2c09deb807e959d78b3a"><span class="std std-ref">VSIInstallZipFileHandler()</span></a>), in a .tar/.tar.gz/.tgz archive (see <a class="reference internal" href="cpl.html#cpl__vsi_8h_1ad6dd983338849e7da4eaa88f6458ab64"><span class="std std-ref">VSIInstallTarFileHandler()</span></a>) or on a HTTP / FTP server (see <a class="reference internal" href="cpl.html#cpl__vsi_8h_1a4f791960f2d86713d16e99e9c0c36258"><span class="std std-ref">VSIInstallCurlFileHandler()</span></a>)</p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<p></p>
<p><strong>Example:</strong><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a>. This <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a> should be closed by deleting the object when it is no longer needed.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the file, or data source to open. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bUpdate</span></code>: FALSE for read-only access (the default) or TRUE for read-write access. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pahDriverList</span></code>: if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</p></li>
</ul>
</dd>
</dl>
</p>
<p></p>
<p></p>
<p></p>
<p> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGROpenSharedPKciP12OGRSFDriverH">
<span id="_CPPv313OGROpenSharedPKciP12OGRSFDriverH"></span><span id="_CPPv213OGROpenSharedPKciP12OGRSFDriverH"></span><span id="OGROpenShared__cCP.i.OGRSFDriverHP"></span><span class="target" id="ogr__api_8h_1a2cbd8a95412abe089084c1def2657b15"></span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <code class="descname">OGROpenShared</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em>, int <em>bUpdate</em>, <a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> *<em>pahDriverList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGROpenSharedPKciP12OGRSFDriverH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with <a class="reference internal" href="#ogr__api_8h_1a2cbd8a95412abe089084c1def2657b15"><span class="std std-ref">OGROpenShared()</span></a> </p>
<p>This function loops through all the drivers registered with the driver manager trying each until one succeeds with the given data source.</p>
<p>If this function fails, <a class="reference internal" href="cpl.html#cpl__error_8h_1a7f71ade3bb0a0e9e45802975ec59ff5e"><span class="std std-ref">CPLGetLastErrorMsg()</span></a> can be used to check if there is an error message explaining why.</p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<p></p>
<p><strong>Example:</strong><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a>. This <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a> should be closed by deleting the object when it is no longer needed.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the file, or data source to open. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bUpdate</span></code>: FALSE for read-only access (the default) or TRUE for read-write access. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pahDriverList</span></code>: if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</p></li>
</ul>
</dd>
</dl>
</p>
<p></p>
<p></p>
<p></p>
<p> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420OGRReleaseDataSource14OGRDataSourceH">
<span id="_CPPv320OGRReleaseDataSource14OGRDataSourceH"></span><span id="_CPPv220OGRReleaseDataSource14OGRDataSourceH"></span><span id="OGRReleaseDataSource__OGRDataSourceH"></span><span class="target" id="ogr__api_8h_1ad3abed0c3b232fe55a580726536fe6fa"></span><a class="reference internal" href="#_CPPv46OGRErr" title="OGRErr">OGRErr</a> <code class="descname">OGRReleaseDataSource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRDataSourceH" title="OGRDataSourceH">OGRDataSourceH</a> <em>hDS</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420OGRReleaseDataSource14OGRDataSourceH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource. </p>
<p>Internally this actually calls the OGRSFDriverRegistrar::ReleaseDataSource() method. This method is essentially a convenient alias.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRERR_NONE on success or an error code. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: handle to the data source to release</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGRGetDriverCountv">
<span id="_CPPv317OGRGetDriverCountv"></span><span id="_CPPv217OGRGetDriverCountv"></span><span id="OGRGetDriverCount__void"></span><span class="target" id="ogr__api_8h_1ad0f6d2bbd269b56a61d1c1841dac2575"></span>int <code class="descname">OGRGetDriverCount</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGRGetDriverCountv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the number of registered drivers. </p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the drivers count. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412OGRGetDriveri">
<span id="_CPPv312OGRGetDriveri"></span><span id="_CPPv212OGRGetDriveri"></span><span id="OGRGetDriver__i"></span><span class="target" id="ogr__api_8h_1a3f8080605cad5aeef9519c38fe160b51"></span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <code class="descname">OGRGetDriver</code><span class="sig-paren">(</span>int <em>iDriver</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412OGRGetDriveri" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the indicated driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle to the driver, or NULL if iDriver is out of range. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iDriver</span></code>: the driver index, from 0 to GetDriverCount()-1.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGRGetDriverByNamePKc">
<span id="_CPPv318OGRGetDriverByNamePKc"></span><span id="_CPPv218OGRGetDriverByNamePKc"></span><span id="OGRGetDriverByName__cCP"></span><span class="target" id="ogr__api_8h_1ae814db7e2212b9bbb0fd8c361bee11fe"></span><a class="reference internal" href="#_CPPv412OGRSFDriverH" title="OGRSFDriverH">OGRSFDriverH</a> <code class="descname">OGRGetDriverByName</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGRGetDriverByNamePKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch the indicated driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<p></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the driver, or NULL if no driver with that name is found </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the driver name</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGRRegisterAllv">
<span id="_CPPv314OGRRegisterAllv"></span><span id="_CPPv214OGRRegisterAllv"></span><span id="OGRRegisterAll__void"></span><span class="target" id="ogr__api_8h_1ae904632d0bc86ba5501921ca594e18da"></span>int <code class="descname">OGRRegisterAll</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGRRegisterAllv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register all drivers. </p>
<p></p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGRCleanupAllv">
<span id="_CPPv313OGRCleanupAllv"></span><span id="_CPPv213OGRCleanupAllv"></span><span id="OGRCleanupAll__void"></span><span class="target" id="ogr__api_8h_1ae5d5a052ed1046ec85236fe4a92733e2"></span>void <code class="descname">OGRCleanupAll</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGRCleanupAllv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean-up all drivers (including raster ones starting with GDAL 2.0. </p>
<p>See <a class="reference internal" href="raster_c_api.html#gdal_8h_1a4769d3eda338f797b30405062deb9180"><span class="std std-ref">GDALDestroyDriverManager()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_SM_Create14OGRStyleTableH">
<span id="_CPPv313OGR_SM_Create14OGRStyleTableH"></span><span id="_CPPv213OGR_SM_Create14OGRStyleTableH"></span><span id="OGR_SM_Create__OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1aba4d31b48c3c9ea6c1edbe4f0aa65866"></span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <code class="descname">OGR_SM_Create</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_SM_Create14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr"><span class="std std-ref">OGRStyleMgr</span></a> factory. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1af360b6a3d0fee4af9a7716fb2a563269"><span class="std std-ref">OGRStyleMgr::OGRStyleMgr()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the new style manager object. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: pointer to <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable"><span class="std std-ref">OGRStyleTable</span></a> or NULL if not working with a style table.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_SM_Destroy12OGRStyleMgrH">
<span id="_CPPv314OGR_SM_Destroy12OGRStyleMgrH"></span><span id="_CPPv214OGR_SM_Destroy12OGRStyleMgrH"></span><span id="OGR_SM_Destroy__OGRStyleMgrH"></span><span class="target" id="ogr__api_8h_1a474fca7d9327da916305ec1276a57443"></span>void <code class="descname">OGR_SM_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <em>hSM</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_SM_Destroy12OGRStyleMgrH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy Style Manager. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1a534a68c59c66901a6fc01d72130337ae"><span class="std std-ref">OGRStyleMgr::~OGRStyleMgr()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSM</span></code>: handle to the style manager to destroy. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_SM_InitFromFeature12OGRStyleMgrH11OGRFeatureH">
<span id="_CPPv322OGR_SM_InitFromFeature12OGRStyleMgrH11OGRFeatureH"></span><span id="_CPPv222OGR_SM_InitFromFeature12OGRStyleMgrH11OGRFeatureH"></span><span id="OGR_SM_InitFromFeature__OGRStyleMgrH.OGRFeatureH"></span><span class="target" id="ogr__api_8h_1afca737ee6586ce8078b52108707b0b6a"></span><em class="property">const</em> char *<code class="descname">OGR_SM_InitFromFeature</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <em>hSM</em>, <a class="reference internal" href="#_CPPv411OGRFeatureH" title="OGRFeatureH">OGRFeatureH</a> <em>hFeat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_SM_InitFromFeature12OGRStyleMgrH11OGRFeatureH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize style manager from the style string of a feature. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1adadbb0a44c3ca3bd11801ee64568d2a6"><span class="std std-ref">OGRStyleMgr::InitFromFeature()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a reference to the style string read from the feature, or NULL in case of error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSM</span></code>: handle to the style manager. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hFeat</span></code>: handle to the new feature from which to read the style.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422OGR_SM_InitStyleString12OGRStyleMgrHPKc">
<span id="_CPPv322OGR_SM_InitStyleString12OGRStyleMgrHPKc"></span><span id="_CPPv222OGR_SM_InitStyleString12OGRStyleMgrHPKc"></span><span id="OGR_SM_InitStyleString__OGRStyleMgrH.cCP"></span><span class="target" id="ogr__api_8h_1ade49bffec1e796ddf4419f5cbe34fda8"></span>int <code class="descname">OGR_SM_InitStyleString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <em>hSM</em>, <em class="property">const</em> char *<em>pszStyleString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422OGR_SM_InitStyleString12OGRStyleMgrHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize style manager from the style string. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1a31e29e999940de709c00f3e985ab3365"><span class="std std-ref">OGRStyleMgr::InitStyleString()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success, FALSE on errors. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSM</span></code>: handle to the style manager. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyleString</span></code>: the style string to use (can be NULL).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419OGR_SM_GetPartCount12OGRStyleMgrHPKc">
<span id="_CPPv319OGR_SM_GetPartCount12OGRStyleMgrHPKc"></span><span id="_CPPv219OGR_SM_GetPartCount12OGRStyleMgrHPKc"></span><span id="OGR_SM_GetPartCount__OGRStyleMgrH.cCP"></span><span class="target" id="ogr__api_8h_1ad272704a535c0fa8cfd7b097eb4968dc"></span>int <code class="descname">OGR_SM_GetPartCount</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <em>hSM</em>, <em class="property">const</em> char *<em>pszStyleString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419OGR_SM_GetPartCount12OGRStyleMgrHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of parts in a style. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1a5745b19d32448c321fcb0e0e9c88843b"><span class="std std-ref">OGRStyleMgr::GetPartCount()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of parts (style tools) in the style. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSM</span></code>: handle to the style manager. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyleString</span></code>: (optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_SM_GetPart12OGRStyleMgrHiPKc">
<span id="_CPPv314OGR_SM_GetPart12OGRStyleMgrHiPKc"></span><span id="_CPPv214OGR_SM_GetPart12OGRStyleMgrHiPKc"></span><span id="OGR_SM_GetPart__OGRStyleMgrH.i.cCP"></span><span class="target" id="ogr__api_8h_1a61d4e04abb6e3c59ed570c62dffc4164"></span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <code class="descname">OGR_SM_GetPart</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <em>hSM</em>, int <em>nPartId</em>, <em class="property">const</em> char *<em>pszStyleString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_SM_GetPart12OGRStyleMgrHiPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch a part (style tool) from the current style. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1a49a82adac48cbd82bfe5c7bb2ccf8376"><span class="std std-ref">OGRStyleMgr::GetPart()</span></a>.</p>
<p>This function instantiates a new object that should be freed with <a class="reference internal" href="#ogr__api_8h_1a5d1ecf398ee062f3f5a297f70244497a"><span class="std std-ref">OGR_ST_Destroy()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>OGRStyleToolH of the requested part (style tools) or NULL on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSM</span></code>: handle to the style manager. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPartId</span></code>: the part number (0-based index). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyleString</span></code>: (optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_SM_AddPart12OGRStyleMgrH13OGRStyleToolH">
<span id="_CPPv314OGR_SM_AddPart12OGRStyleMgrH13OGRStyleToolH"></span><span id="_CPPv214OGR_SM_AddPart12OGRStyleMgrH13OGRStyleToolH"></span><span id="OGR_SM_AddPart__OGRStyleMgrH.OGRStyleToolH"></span><span class="target" id="ogr__api_8h_1af358ec087124f355fca02bf33a1e0027"></span>int <code class="descname">OGR_SM_AddPart</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <em>hSM</em>, <a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_SM_AddPart12OGRStyleMgrH13OGRStyleToolH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a part (style tool) to the current style. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1a3b893dd11e0f009fca53bf42d16abf47"><span class="std std-ref">OGRStyleMgr::AddPart()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success, FALSE on errors. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSM</span></code>: handle to the style manager. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: the style tool defining the part to add.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_SM_AddStyle12OGRStyleMgrHPKcPKc">
<span id="_CPPv315OGR_SM_AddStyle12OGRStyleMgrHPKcPKc"></span><span id="_CPPv215OGR_SM_AddStyle12OGRStyleMgrHPKcPKc"></span><span id="OGR_SM_AddStyle__OGRStyleMgrH.cCP.cCP"></span><span class="target" id="ogr__api_8h_1a358c1558e61951b2e1e338ead8401ad8"></span>int <code class="descname">OGR_SM_AddStyle</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRStyleMgrH" title="OGRStyleMgrH">OGRStyleMgrH</a> <em>hSM</em>, <em class="property">const</em> char *<em>pszStyleName</em>, <em class="property">const</em> char *<em>pszStyleString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_SM_AddStyle12OGRStyleMgrHPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a style to the current style table. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleMgr_1ae0846db4a996586b38ea31e69e71b697"><span class="std std-ref">OGRStyleMgr::AddStyle()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success, FALSE on errors. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSM</span></code>: handle to the style manager. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyleName</span></code>: the name of the style to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyleString</span></code>: the style string to use, or NULL to use the style stored in the manager.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_ST_Create12OGRSTClassId">
<span id="_CPPv313OGR_ST_Create12OGRSTClassId"></span><span id="_CPPv213OGR_ST_Create12OGRSTClassId"></span><span id="OGR_ST_Create__OGRSTClassId"></span><span class="target" id="ogr__api_8h_1a4cc7bc2b21febd7a78d44727ad7de30f"></span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <code class="descname">OGR_ST_Create</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412OGRSTClassId" title="OGRSTClassId">OGRSTClassId</a> <em>eClassId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_ST_Create12OGRSTClassId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> factory. </p>
<p>This function is a constructor for <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> derived classes.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the new style tool object or NULL if the creation failed. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eClassId</span></code>: subclass of style tool to create. One of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_ST_Destroy13OGRStyleToolH">
<span id="_CPPv314OGR_ST_Destroy13OGRStyleToolH"></span><span id="_CPPv214OGR_ST_Destroy13OGRStyleToolH"></span><span id="OGR_ST_Destroy__OGRStyleToolH"></span><span class="target" id="ogr__api_8h_1a5d1ecf398ee062f3f5a297f70244497a"></span>void <code class="descname">OGR_ST_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_ST_Destroy13OGRStyleToolH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy Style Tool. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool to destroy. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_ST_GetType13OGRStyleToolH">
<span id="_CPPv314OGR_ST_GetType13OGRStyleToolH"></span><span id="_CPPv214OGR_ST_GetType13OGRStyleToolH"></span><span id="OGR_ST_GetType__OGRStyleToolH"></span><span class="target" id="ogr__api_8h_1aae8d0ee36b82c9d1d8d1a0e9b36f2d35"></span><a class="reference internal" href="#_CPPv412OGRSTClassId" title="OGRSTClassId">OGRSTClassId</a> <code class="descname">OGR_ST_GetType</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_ST_GetType13OGRStyleToolH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine type of Style Tool. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the style tool type, one of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4). Returns OGRSTCNone (0) if the OGRStyleToolH is invalid. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_ST_GetUnit13OGRStyleToolH">
<span id="_CPPv314OGR_ST_GetUnit13OGRStyleToolH"></span><span id="_CPPv214OGR_ST_GetUnit13OGRStyleToolH"></span><span id="OGR_ST_GetUnit__OGRStyleToolH"></span><span class="target" id="ogr__api_8h_1afb52e40f289848d1f228849b6dae2463"></span><a class="reference internal" href="#_CPPv411OGRSTUnitId" title="OGRSTUnitId">OGRSTUnitId</a> <code class="descname">OGR_ST_GetUnit</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_ST_GetUnit13OGRStyleToolH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get Style Tool units. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the style tool units. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414OGR_ST_SetUnit13OGRStyleToolH11OGRSTUnitIdd">
<span id="_CPPv314OGR_ST_SetUnit13OGRStyleToolH11OGRSTUnitIdd"></span><span id="_CPPv214OGR_ST_SetUnit13OGRStyleToolH11OGRSTUnitIdd"></span><span id="OGR_ST_SetUnit__OGRStyleToolH.OGRSTUnitId.double"></span><span class="target" id="ogr__api_8h_1ac9c5b94e6ca32cd53c6a7a9ebc73012c"></span>void <code class="descname">OGR_ST_SetUnit</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, <a class="reference internal" href="#_CPPv411OGRSTUnitId" title="OGRSTUnitId">OGRSTUnitId</a> <em>eUnit</em>, double <em>dfGroundPaperScale</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414OGR_ST_SetUnit13OGRStyleToolH11OGRSTUnitIdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set Style Tool units. </p>
<p>This function is the same as <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool_1abfc35434fef971aa98be8f15059a81da"><span class="std std-ref">OGRStyleTool::SetUnit()</span></a></p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eUnit</span></code>: the new unit. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfGroundPaperScale</span></code>: ground to paper scale factor. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_ST_GetParamStr13OGRStyleToolHiPi">
<span id="_CPPv318OGR_ST_GetParamStr13OGRStyleToolHiPi"></span><span id="_CPPv218OGR_ST_GetParamStr13OGRStyleToolHiPi"></span><span id="OGR_ST_GetParamStr__OGRStyleToolH.i.iP"></span><span class="target" id="ogr__api_8h_1aecadf5738c3b96093605b352a95869f1"></span><em class="property">const</em> char *<code class="descname">OGR_ST_GetParamStr</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, int <em>eParam</em>, int *<em>bValueIsNull</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_ST_GetParamStr13OGRStyleToolHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get Style Tool parameter value as string. </p>
<p>Maps to the <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> subclasses’ GetParamStr() methods.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the parameter value as string and sets bValueIsNull. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eParam</span></code>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bValueIsNull</span></code>: pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_ST_GetParamNum13OGRStyleToolHiPi">
<span id="_CPPv318OGR_ST_GetParamNum13OGRStyleToolHiPi"></span><span id="_CPPv218OGR_ST_GetParamNum13OGRStyleToolHiPi"></span><span id="OGR_ST_GetParamNum__OGRStyleToolH.i.iP"></span><span class="target" id="ogr__api_8h_1ad4168832561881cb75dcc7c35935cdd3"></span>int <code class="descname">OGR_ST_GetParamNum</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, int <em>eParam</em>, int *<em>bValueIsNull</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_ST_GetParamNum13OGRStyleToolHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get Style Tool parameter value as an integer. </p>
<p>Maps to the <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> subclasses’ GetParamNum() methods.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the parameter value as integer and sets bValueIsNull. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eParam</span></code>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bValueIsNull</span></code>: pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_ST_GetParamDbl13OGRStyleToolHiPi">
<span id="_CPPv318OGR_ST_GetParamDbl13OGRStyleToolHiPi"></span><span id="_CPPv218OGR_ST_GetParamDbl13OGRStyleToolHiPi"></span><span id="OGR_ST_GetParamDbl__OGRStyleToolH.i.iP"></span><span class="target" id="ogr__api_8h_1a96082cdf432271acfa3b3777c3be853b"></span>double <code class="descname">OGR_ST_GetParamDbl</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, int <em>eParam</em>, int *<em>bValueIsNull</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_ST_GetParamDbl13OGRStyleToolHiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get Style Tool parameter value as a double. </p>
<p>Maps to the <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> subclasses’ GetParamDbl() methods.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the parameter value as double and sets bValueIsNull. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eParam</span></code>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bValueIsNull</span></code>: pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_ST_SetParamStr13OGRStyleToolHiPKc">
<span id="_CPPv318OGR_ST_SetParamStr13OGRStyleToolHiPKc"></span><span id="_CPPv218OGR_ST_SetParamStr13OGRStyleToolHiPKc"></span><span id="OGR_ST_SetParamStr__OGRStyleToolH.i.cCP"></span><span class="target" id="ogr__api_8h_1a88e9561d9a62d6f8368d526eb0468b3a"></span>void <code class="descname">OGR_ST_SetParamStr</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, int <em>eParam</em>, <em class="property">const</em> char *<em>pszValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_ST_SetParamStr13OGRStyleToolHiPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set Style Tool parameter value from a string. </p>
<p>Maps to the <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> subclasses’ SetParamStr() methods.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eParam</span></code>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszValue</span></code>: the new parameter value </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_ST_SetParamNum13OGRStyleToolHii">
<span id="_CPPv318OGR_ST_SetParamNum13OGRStyleToolHii"></span><span id="_CPPv218OGR_ST_SetParamNum13OGRStyleToolHii"></span><span id="OGR_ST_SetParamNum__OGRStyleToolH.i.i"></span><span class="target" id="ogr__api_8h_1ac0397850aed3282865b444d65d2deb0e"></span>void <code class="descname">OGR_ST_SetParamNum</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, int <em>eParam</em>, int <em>nValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_ST_SetParamNum13OGRStyleToolHii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set Style Tool parameter value from an integer. </p>
<p>Maps to the <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> subclasses’ SetParamNum() methods.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eParam</span></code>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nValue</span></code>: the new parameter value </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418OGR_ST_SetParamDbl13OGRStyleToolHid">
<span id="_CPPv318OGR_ST_SetParamDbl13OGRStyleToolHid"></span><span id="_CPPv218OGR_ST_SetParamDbl13OGRStyleToolHid"></span><span id="OGR_ST_SetParamDbl__OGRStyleToolH.i.double"></span><span class="target" id="ogr__api_8h_1a764f52f8a72e950d0a5d84b7a7b37fc8"></span>void <code class="descname">OGR_ST_SetParamDbl</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, int <em>eParam</em>, double <em>dfValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418OGR_ST_SetParamDbl13OGRStyleToolHid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set Style Tool parameter value from a double. </p>
<p>Maps to the <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> subclasses’ SetParamDbl() methods.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eParam</span></code>: the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfValue</span></code>: the new parameter value </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_ST_GetStyleString13OGRStyleToolH">
<span id="_CPPv321OGR_ST_GetStyleString13OGRStyleToolH"></span><span id="_CPPv221OGR_ST_GetStyleString13OGRStyleToolH"></span><span id="OGR_ST_GetStyleString__OGRStyleToolH"></span><span class="target" id="ogr__api_8h_1a4089c70ce3b1cbea0e45c3375d5093f0"></span><em class="property">const</em> char *<code class="descname">OGR_ST_GetStyleString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_ST_GetStyleString13OGRStyleToolH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the style string for this Style Tool. </p>
<p>Maps to the <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool"><span class="std std-ref">OGRStyleTool</span></a> subclasses’ GetStyleString() methods.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the style string for this style tool or “” if the hST is invalid. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_ST_GetRGBFromString13OGRStyleToolHPKcPiPiPiPi">
<span id="_CPPv323OGR_ST_GetRGBFromString13OGRStyleToolHPKcPiPiPiPi"></span><span id="_CPPv223OGR_ST_GetRGBFromString13OGRStyleToolHPKcPiPiPiPi"></span><span id="OGR_ST_GetRGBFromString__OGRStyleToolH.cCP.iP.iP.iP.iP"></span><span class="target" id="ogr__api_8h_1a906f5e2b901413a0ab5fa35d649847fc"></span>int <code class="descname">OGR_ST_GetRGBFromString</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413OGRStyleToolH" title="OGRStyleToolH">OGRStyleToolH</a> <em>hST</em>, <em class="property">const</em> char *<em>pszColor</em>, int *<em>pnRed</em>, int *<em>pnGreen</em>, int *<em>pnBlue</em>, int *<em>pnAlpha</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_ST_GetRGBFromString13OGRStyleToolHPKcPiPiPiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format. </p>
<p>Maps to <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTool_1ac52668cd3fe4b74860137d36f6e9f0d4"><span class="std std-ref">OGRStyleTool::GetRGBFromString()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the color could be successfully parsed, or FALSE in case of errors. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hST</span></code>: handle to the style tool. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszColor</span></code>: the color to parse </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnRed</span></code>: pointer to an int in which the red value will be returned </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnGreen</span></code>: pointer to an int in which the green value will be returned </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnBlue</span></code>: pointer to an int in which the blue value will be returned </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnAlpha</span></code>: pointer to an int in which the (optional) alpha value will be returned</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415OGR_STBL_Createv">
<span id="_CPPv315OGR_STBL_Createv"></span><span id="_CPPv215OGR_STBL_Createv"></span><span id="OGR_STBL_Create__void"></span><span class="target" id="ogr__api_8h_1a9c2d216b17d9f09ad6285ce61dcbe826"></span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <code class="descname">OGR_STBL_Create</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415OGR_STBL_Createv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable"><span class="std std-ref">OGRStyleTable</span></a> factory. </p>
<p>This function is the same as the C++ method OGRStyleTable::OGRStyleTable().</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an handle to the new style table object. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416OGR_STBL_Destroy14OGRStyleTableH">
<span id="_CPPv316OGR_STBL_Destroy14OGRStyleTableH"></span><span id="_CPPv216OGR_STBL_Destroy14OGRStyleTableH"></span><span id="OGR_STBL_Destroy__OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1a5cf4e22eb7ef07c4a3249c21dce48764"></span>void <code class="descname">OGR_STBL_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hSTBL</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416OGR_STBL_Destroy14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy Style Table. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSTBL</span></code>: handle to the style table to destroy. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417OGR_STBL_AddStyle14OGRStyleTableHPKcPKc">
<span id="_CPPv317OGR_STBL_AddStyle14OGRStyleTableHPKcPKc"></span><span id="_CPPv217OGR_STBL_AddStyle14OGRStyleTableHPKcPKc"></span><span id="OGR_STBL_AddStyle__OGRStyleTableH.cCP.cCP"></span><span class="target" id="ogr__api_8h_1aacd2a4f109627f282c42229eaad7cdfd"></span>int <code class="descname">OGR_STBL_AddStyle</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em>, <em class="property">const</em> char *<em>pszName</em>, <em class="property">const</em> char *<em>pszStyleString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417OGR_STBL_AddStyle14OGRStyleTableHPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a new style in the table. </p>
<p>No comparison will be done on the Style string, only on the name. This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable_1aff722d3fc7c167259dd79986a2574993"><span class="std std-ref">OGRStyleTable::AddStyle()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success, FALSE on error </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: handle to the style table. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name the style to add. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszStyleString</span></code>: the style string to add.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_STBL_SaveStyleTable14OGRStyleTableHPKc">
<span id="_CPPv323OGR_STBL_SaveStyleTable14OGRStyleTableHPKc"></span><span id="_CPPv223OGR_STBL_SaveStyleTable14OGRStyleTableHPKc"></span><span id="OGR_STBL_SaveStyleTable__OGRStyleTableH.cCP"></span><span class="target" id="ogr__api_8h_1aa3e3aca0d4f3fefe3dd64da65814dda7"></span>int <code class="descname">OGR_STBL_SaveStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em>, <em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_STBL_SaveStyleTable14OGRStyleTableHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save a style table to a file. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable_1a5395e712fa91a3d26f6aed779760983c"><span class="std std-ref">OGRStyleTable::SaveStyleTable()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success, FALSE on error </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: handle to the style table. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the name of the file to save to.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423OGR_STBL_LoadStyleTable14OGRStyleTableHPKc">
<span id="_CPPv323OGR_STBL_LoadStyleTable14OGRStyleTableHPKc"></span><span id="_CPPv223OGR_STBL_LoadStyleTable14OGRStyleTableHPKc"></span><span id="OGR_STBL_LoadStyleTable__OGRStyleTableH.cCP"></span><span class="target" id="ogr__api_8h_1aed731a5a6fbedde73ed5063d62f3004e"></span>int <code class="descname">OGR_STBL_LoadStyleTable</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em>, <em class="property">const</em> char *<em>pszFilename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423OGR_STBL_LoadStyleTable14OGRStyleTableHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Load a style table from a file. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable_1a1d8b2702ca6c6469d03316b6c9341739"><span class="std std-ref">OGRStyleTable::LoadStyleTable()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE on success, FALSE on error </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: handle to the style table. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszFilename</span></code>: the name of the file to load from.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413OGR_STBL_Find14OGRStyleTableHPKc">
<span id="_CPPv313OGR_STBL_Find14OGRStyleTableHPKc"></span><span id="_CPPv213OGR_STBL_Find14OGRStyleTableHPKc"></span><span id="OGR_STBL_Find__OGRStyleTableH.cCP"></span><span class="target" id="ogr__api_8h_1a57ca305147b3b5a6c3f5fafaee7bc06a"></span><em class="property">const</em> char *<code class="descname">OGR_STBL_Find</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em>, <em class="property">const</em> char *<em>pszName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413OGR_STBL_Find14OGRStyleTableHPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a style string by name. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable_1a83347c8a447e454b825784c8f7ce1661"><span class="std std-ref">OGRStyleTable::Find()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the style string matching the name or NULL if not found or error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: handle to the style table. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszName</span></code>: the name of the style string to find.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432OGR_STBL_ResetStyleStringReading14OGRStyleTableH">
<span id="_CPPv332OGR_STBL_ResetStyleStringReading14OGRStyleTableH"></span><span id="_CPPv232OGR_STBL_ResetStyleStringReading14OGRStyleTableH"></span><span id="OGR_STBL_ResetStyleStringReading__OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1a69ccd53d6d374d66d42266b3543509f7"></span>void <code class="descname">OGR_STBL_ResetStyleStringReading</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432OGR_STBL_ResetStyleStringReading14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset the next style pointer to 0. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable_1aeb0398e3eb69ff4bacebf5fb928f5482"><span class="std std-ref">OGRStyleTable::ResetStyleStringReading()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: handle to the style table. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421OGR_STBL_GetNextStyle14OGRStyleTableH">
<span id="_CPPv321OGR_STBL_GetNextStyle14OGRStyleTableH"></span><span id="_CPPv221OGR_STBL_GetNextStyle14OGRStyleTableH"></span><span id="OGR_STBL_GetNextStyle__OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1ad901a29f17b139108cc6390b9a075e89"></span><em class="property">const</em> char *<code class="descname">OGR_STBL_GetNextStyle</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421OGR_STBL_GetNextStyle14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the next style string from the table. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable_1a51ec658481656b3a3c7748622924eaf5"><span class="std std-ref">OGRStyleTable::GetNextStyle()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the next style string or NULL on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: handle to the style table.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425OGR_STBL_GetLastStyleName14OGRStyleTableH">
<span id="_CPPv325OGR_STBL_GetLastStyleName14OGRStyleTableH"></span><span id="_CPPv225OGR_STBL_GetLastStyleName14OGRStyleTableH"></span><span id="OGR_STBL_GetLastStyleName__OGRStyleTableH"></span><span class="target" id="ogr__api_8h_1af8214328c6866f0eb85bba376d94a05e"></span><em class="property">const</em> char *<code class="descname">OGR_STBL_GetLastStyleName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414OGRStyleTableH" title="OGRStyleTableH">OGRStyleTableH</a> <em>hStyleTable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425OGR_STBL_GetLastStyleName14OGRStyleTableH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the style name of the last style string fetched with OGR_STBL_GetNextStyle. </p>
<p>This function is the same as the C++ method <a class="reference internal" href="ogrfeaturestyle_cpp.html#classOGRStyleTable_1afc78310da48449b9f6a79d20d73e5944"><span class="std std-ref">OGRStyleTable::GetStyleName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the Name of the last style string or NULL on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hStyleTable</span></code>: handle to the style table.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gdal_alg.html" class="btn btn-neutral float-right" title="gdal_alg.h: GDAL Algorithms C API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="raster_c_api.html" class="btn btn-neutral float-left" title="gdal.h: Raster C API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://osgeo.org">
        <div class="osgeo-logo"></div>
      </a>
      <div class="copyright">
      

      &copy; 1998-2020 <a href="https://github.com/warmerdam">Frank Warmerdam</a>,
      <a href="https://github.com/rouault">Even Rouault</a>, and
      <a href="https://github.com/OSGeo/gdal/graphs/contributors">others</a>


      
      </div>
    </div>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>