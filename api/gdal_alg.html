

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gdal_alg.h: GDAL Algorithms C API &mdash; GDAL  documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://gdal.orgapi/gdal_alg.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/gdal.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ogr_srs_api.h: Spatial Reference System C API" href="ogr_srs_api.html" />
    <link rel="prev" title="ogr_core.h and ogr_api.h: Vector C API" href="vector_c_api.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/gdalicon.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programs/index.html">Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/raster/index.html">Raster drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/vector/index.html">Vector drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#id2">Full Doxygen output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#c-api">C API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="cpl.html">Common Portability Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="raster_c_api.html">gdal.h: Raster C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="vector_c_api.html">ogr_core.h and ogr_api.h: Vector C API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">gdal_alg.h: GDAL Algorithms C API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gdal-alg-h">gdal_alg.h</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ogr_srs_api.html">ogr_srs_api.h: Spatial Reference System C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gdal_utils.html">gdal_utils.h: GDAL Algorithms C API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id3">C++ API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#python-api">Python API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#id4">Java API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">How to contribute?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDAL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html"> GDAL  documentation </a> &raquo;</li>
      
          <li><a href="index.html">API</a> &raquo;</li>
      
      <li>gdal_alg.h: GDAL Algorithms C API</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/OSGeo/gdal/edit//master/gdal/doc/source/api/gdal_alg.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="ogr_srs_api.html" class="btn btn-neutral float-right" title="ogr_srs_api.h: Spatial Reference System C API" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="vector_c_api.html" class="btn btn-neutral float-left" title="ogr_core.h and ogr_api.h: Vector C API" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gdal-alg-h-gdal-algorithms-c-api">
<span id="gdal-alg"></span><h1>gdal_alg.h: GDAL Algorithms C API<a class="headerlink" href="#gdal-alg-h-gdal-algorithms-c-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="gdal-alg-h">
<h2>gdal_alg.h<a class="headerlink" href="#gdal-alg-h" title="Permalink to this headline">¶</a></h2>
<p>Public (C callable) GDAL algorithm entry points, and definitions. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv419GDALTransformerFunc">
<span id="_CPPv319GDALTransformerFunc"></span><span id="_CPPv219GDALTransformerFunc"></span><span id="GDALTransformerFunc"></span><span class="target" id="gdal__alg_8h_1aaede67ca444a06f0a6fed538e05d2220"></span><em class="property">typedef </em>int (*<code class="descname">GDALTransformerFunc</code>)<span class="sig-paren">(</span>void *pTransformerArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GDALTransformerFunc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Generic signature for spatial point transformers.</p>
<p>This function signature is used for a variety of functions that accept passed in functions used to transform point locations between two coordinate spaces.</p>
<p>The <a class="reference internal" href="#gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"><span class="std std-ref">GDALCreateGenImgProjTransformer()</span></a>, <a class="reference internal" href="#gdal__alg_8h_1ac026c145117134bc754bf25c84b207e1"><span class="std std-ref">GDALCreateReprojectionTransformerEx()</span></a>, <a class="reference internal" href="#gdal__alg_8h_1ac57c80f7bf6752fac1dff8c2a21a15a3"><span class="std std-ref">GDALCreateGCPTransformer()</span></a> and <a class="reference internal" href="#gdal__alg_8h_1a4ec403b75384f0a71130eb009078426f"><span class="std std-ref">GDALCreateApproxTransformer()</span></a> functions can be used to prepare argument data for some built-in transformers. As well, applications can implement their own transformers to the following signature.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="nb">int</span>
<span class="p">(</span><span class="o">*</span><span class="n">GDALTransformerFunc</span><span class="p">)(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pTransformerArg</span><span class="p">,</span>
                        <span class="nb">int</span> <span class="n">bDstToSrc</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nPointCount</span><span class="p">,</span>
                        <span class="n">double</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">panSuccess</span> <span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the overall transformation succeeds (though some individual points may have failed) or FALSE if the overall transformation fails. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformerArg</span></code>: application supplied callback data used by the transformer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDstToSrc</span></code>: if TRUE the transformation will be from the destination coordinate space to the source coordinate system, otherwise the transformation will be from the source coordinate system to the destination coordinate system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPointCount</span></code>: number of points in the x, y and z arrays.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code>: input X coordinates. Results returned in same array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: input Y coordinates. Results returned in same array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code>: input Z coordinates. Results returned in same array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panSuccess</span></code>: array of ints in which success (TRUE) or failure (FALSE) flags are returned for the translation of each point.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv417GDALContourWriter">
<span id="_CPPv317GDALContourWriter"></span><span id="_CPPv217GDALContourWriter"></span><span id="GDALContourWriter"></span><span class="target" id="gdal__alg_8h_1aadc7569c65e4b14e36a2173143e6beea"></span><em class="property">typedef </em><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> (*<code class="descname">GDALContourWriter</code>)<span class="sig-paren">(</span>double dfLevel, int nPoints, double *padfX, double *padfY, void *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417GDALContourWriter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Contour writer callback type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv421GDALContourGeneratorH">
<span id="_CPPv321GDALContourGeneratorH"></span><span id="_CPPv221GDALContourGeneratorH"></span><span id="GDALContourGeneratorH"></span><span class="target" id="gdal__alg_8h_1ac929ac526110faa3f666d18f7a680958"></span><em class="property">typedef </em>void *<code class="descname">GDALContourGeneratorH</code><a class="headerlink" href="#_CPPv421GDALContourGeneratorH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Contour generator opaque type. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv415GDALGridContext">
<span id="_CPPv315GDALGridContext"></span><span id="_CPPv215GDALGridContext"></span><span id="GDALGridContext"></span><span class="target" id="gdal__alg_8h_1a081f51e38cd0ac6d9e8a6e20a9a3332b"></span><em class="property">typedef </em><em class="property">struct</em> <a class="reference internal" href="#_CPPv415GDALGridContext" title="GDALGridContext">GDALGridContext</a> <code class="descname">GDALGridContext</code><a class="headerlink" href="#_CPPv415GDALGridContext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Grid context opaque type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="enum">
<dt id="_CPPv416GDALViewshedMode">
<span id="_CPPv316GDALViewshedMode"></span><span id="_CPPv216GDALViewshedMode"></span><span class="target" id="gdal__alg_8h_1a49244316dfeefdbbb188f2570911717d"></span><em class="property">enum </em><code class="descname">GDALViewshedMode</code><a class="headerlink" href="#_CPPv416GDALViewshedMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Viewshed Modes. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv412GVM_Diagonal">
<span id="_CPPv312GVM_Diagonal"></span><span id="_CPPv212GVM_Diagonal"></span><span class="target" id="gdal__alg_8h_1a49244316dfeefdbbb188f2570911717da4f5c3e01151e475d39492c466cb56711"></span><code class="descname">GVM_Diagonal</code> = 1<a class="headerlink" href="#_CPPv412GVM_Diagonal" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv48GVM_Edge">
<span id="_CPPv38GVM_Edge"></span><span id="_CPPv28GVM_Edge"></span><span class="target" id="gdal__alg_8h_1a49244316dfeefdbbb188f2570911717da6b2bb65cfb076641d37d90d2cc51218c"></span><code class="descname">GVM_Edge</code> = 2<a class="headerlink" href="#_CPPv48GVM_Edge" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv47GVM_Max">
<span id="_CPPv37GVM_Max"></span><span id="_CPPv27GVM_Max"></span><span class="target" id="gdal__alg_8h_1a49244316dfeefdbbb188f2570911717dab443c04b26656636f4febfd383a73d9d"></span><code class="descname">GVM_Max</code> = 3<a class="headerlink" href="#_CPPv47GVM_Max" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv47GVM_Min">
<span id="_CPPv37GVM_Min"></span><span id="_CPPv27GVM_Min"></span><span class="target" id="gdal__alg_8h_1a49244316dfeefdbbb188f2570911717dae83191875a24a689cc0a9f4374169ba2"></span><code class="descname">GVM_Min</code> = 4<a class="headerlink" href="#_CPPv47GVM_Min" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv422GDALViewshedOutputType">
<span id="_CPPv322GDALViewshedOutputType"></span><span id="_CPPv222GDALViewshedOutputType"></span><span class="target" id="gdal__alg_8h_1aa5ee2833f6486e61e24903fe0f4dad4a"></span><em class="property">enum </em><code class="descname">GDALViewshedOutputType</code><a class="headerlink" href="#_CPPv422GDALViewshedOutputType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Viewshed output types. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv411GVOT_NORMAL">
<span id="_CPPv311GVOT_NORMAL"></span><span id="_CPPv211GVOT_NORMAL"></span><span class="target" id="gdal__alg_8h_1aa5ee2833f6486e61e24903fe0f4dad4aaa2ab3fe021cde0db423693d89db235cb"></span><code class="descname">GVOT_NORMAL</code> = 1<a class="headerlink" href="#_CPPv411GVOT_NORMAL" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv431GVOT_MIN_TARGET_HEIGHT_FROM_DEM">
<span id="_CPPv331GVOT_MIN_TARGET_HEIGHT_FROM_DEM"></span><span id="_CPPv231GVOT_MIN_TARGET_HEIGHT_FROM_DEM"></span><span class="target" id="gdal__alg_8h_1aa5ee2833f6486e61e24903fe0f4dad4aaba1cfb9366a238361848bad8e60d34a4"></span><code class="descname">GVOT_MIN_TARGET_HEIGHT_FROM_DEM</code> = 2<a class="headerlink" href="#_CPPv431GVOT_MIN_TARGET_HEIGHT_FROM_DEM" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv434GVOT_MIN_TARGET_HEIGHT_FROM_GROUND">
<span id="_CPPv334GVOT_MIN_TARGET_HEIGHT_FROM_GROUND"></span><span id="_CPPv234GVOT_MIN_TARGET_HEIGHT_FROM_GROUND"></span><span class="target" id="gdal__alg_8h_1aa5ee2833f6486e61e24903fe0f4dad4aa71dbc2c32dc472c1b8ab38413069efa8"></span><code class="descname">GVOT_MIN_TARGET_HEIGHT_FROM_GROUND</code> = 3<a class="headerlink" href="#_CPPv434GVOT_MIN_TARGET_HEIGHT_FROM_GROUND" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="enum">
<dt id="_CPPv417GDALGridAlgorithm">
<span id="_CPPv317GDALGridAlgorithm"></span><span id="_CPPv217GDALGridAlgorithm"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21"></span><em class="property">enum </em><code class="descname">GDALGridAlgorithm</code><a class="headerlink" href="#_CPPv417GDALGridAlgorithm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gridding Algorithms. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv427GGA_InverseDistanceToAPower">
<span id="_CPPv327GGA_InverseDistanceToAPower"></span><span id="_CPPv227GGA_InverseDistanceToAPower"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21a5955211b72d8b07518815d544e5fa192"></span><code class="descname">GGA_InverseDistanceToAPower</code> = 1<a class="headerlink" href="#_CPPv427GGA_InverseDistanceToAPower" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inverse distance to a power </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417GGA_MovingAverage">
<span id="_CPPv317GGA_MovingAverage"></span><span id="_CPPv217GGA_MovingAverage"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21aaafac5453ea6a64e9c84c5143cfbdcaf"></span><code class="descname">GGA_MovingAverage</code> = 2<a class="headerlink" href="#_CPPv417GGA_MovingAverage" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moving Average </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv419GGA_NearestNeighbor">
<span id="_CPPv319GGA_NearestNeighbor"></span><span id="_CPPv219GGA_NearestNeighbor"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21a70c30cb508518172fbce051a7927eb68"></span><code class="descname">GGA_NearestNeighbor</code> = 3<a class="headerlink" href="#_CPPv419GGA_NearestNeighbor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Nearest Neighbor </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417GGA_MetricMinimum">
<span id="_CPPv317GGA_MetricMinimum"></span><span id="_CPPv217GGA_MetricMinimum"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21a114443c69d10fafd0e4a6195cb178e75"></span><code class="descname">GGA_MetricMinimum</code> = 4<a class="headerlink" href="#_CPPv417GGA_MetricMinimum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum Value (Data Metric) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv417GGA_MetricMaximum">
<span id="_CPPv317GGA_MetricMaximum"></span><span id="_CPPv217GGA_MetricMaximum"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21a62e4fcf09890e32a287364ca165f78e2"></span><code class="descname">GGA_MetricMaximum</code> = 5<a class="headerlink" href="#_CPPv417GGA_MetricMaximum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Maximum Value (Data Metric) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415GGA_MetricRange">
<span id="_CPPv315GGA_MetricRange"></span><span id="_CPPv215GGA_MetricRange"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21aed976fb5778362e9c51e5859d19ac917"></span><code class="descname">GGA_MetricRange</code> = 6<a class="headerlink" href="#_CPPv415GGA_MetricRange" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Data Range (Data Metric) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv415GGA_MetricCount">
<span id="_CPPv315GGA_MetricCount"></span><span id="_CPPv215GGA_MetricCount"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21ac41203ffb292f6fadf155a5d3ff80219"></span><code class="descname">GGA_MetricCount</code> = 7<a class="headerlink" href="#_CPPv415GGA_MetricCount" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Number of Points (Data Metric) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv425GGA_MetricAverageDistance">
<span id="_CPPv325GGA_MetricAverageDistance"></span><span id="_CPPv225GGA_MetricAverageDistance"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21a90cfa34b606733fcbc4c7b15e36fefcf"></span><code class="descname">GGA_MetricAverageDistance</code> = 8<a class="headerlink" href="#_CPPv425GGA_MetricAverageDistance" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Average Distance (Data Metric) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv428GGA_MetricAverageDistancePts">
<span id="_CPPv328GGA_MetricAverageDistancePts"></span><span id="_CPPv228GGA_MetricAverageDistancePts"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21a5c0dc83a00305d4a1beda88406aefbb6"></span><code class="descname">GGA_MetricAverageDistancePts</code> = 9<a class="headerlink" href="#_CPPv428GGA_MetricAverageDistancePts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Average Distance Between Data Points (Data Metric) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410GGA_Linear">
<span id="_CPPv310GGA_Linear"></span><span id="_CPPv210GGA_Linear"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21af36d730cc83998d3dd4c6bb8128e9f5e"></span><code class="descname">GGA_Linear</code> = 10<a class="headerlink" href="#_CPPv410GGA_Linear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Linear interpolation (from Delaunay triangulation. Since GDAL 2.1 </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv442GGA_InverseDistanceToAPowerNearestNeighbor">
<span id="_CPPv342GGA_InverseDistanceToAPowerNearestNeighbor"></span><span id="_CPPv242GGA_InverseDistanceToAPowerNearestNeighbor"></span><span class="target" id="gdal__alg_8h_1a590d1a2d0bac1d34b95034c1f616de21a147a475881c01b46c1371f576310cfe2"></span><code class="descname">GGA_InverseDistanceToAPowerNearestNeighbor</code> = 11<a class="headerlink" href="#_CPPv442GGA_InverseDistanceToAPowerNearestNeighbor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inverse distance to a power with nearest neighbor search for max points </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv423GDALComputeMedianCutPCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHPFiiiPvEi15GDALColorTableH16GDALProgressFuncPv">
<span id="_CPPv323GDALComputeMedianCutPCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHPFiiiPvEi15GDALColorTableH16GDALProgressFuncPv"></span><span id="_CPPv223GDALComputeMedianCutPCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHPFiiiPvEi15GDALColorTableH16GDALProgressFuncPv"></span><span class="target" id="gdal__alg_8h_1a61e48f88c3b4b3cf7957c61dc7bd1ead"></span>int <code class="descname">GDALComputeMedianCutPCT</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hRed</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hGreen</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hBlue</em>, int (*<em>pfnIncludePixel</em>)<span class="sig-paren">(</span>int, int, void *<span class="sig-paren">)</span>, int <em>nColors</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALColorTableH" title="GDALColorTableH">GDALColorTableH</a> <em>hColorTable</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423GDALComputeMedianCutPCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHPFiiiPvEi15GDALColorTableH16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute optimal PCT for RGB image. </p>
<p>This function implements a median cut algorithm to compute an “optimal” pseudocolor table for representing an input RGB image. This PCT could then be used with <a class="reference internal" href="#gdal__alg_8h_1a284dbcc27295b7e678b1f7d4fa1506cb"><span class="std std-ref">GDALDitherRGB2PCT()</span></a> to convert a 24bit RGB image into an eightbit pseudo-colored image.</p>
<p>This code was based on the tiffmedian.c code from libtiff (www.libtiff.org) which was based on a paper by Paul Heckbert:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span>   <span class="s2">&quot;Color  Image Quantization for Frame Buffer Display&quot;</span><span class="p">,</span> <span class="n">Paul</span>
<span class="o">*</span>   <span class="n">Heckbert</span><span class="p">,</span> <span class="n">SIGGRAPH</span> <span class="n">proceedings</span><span class="p">,</span> <span class="mi">1982</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span> <span class="mi">297</span><span class="o">-</span><span class="mf">307.</span>
<span class="o">*</span>
</pre></div>
</div>
</p>
<p>The red, green and blue input bands do not necessarily need to come from the same file, but they must be the same width and height. They will be clipped to 8bit during reading, so non-eight bit bands are generally inappropriate.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>returns CE_None on success or CE_Failure if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hRed</span></code>: Red input band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGreen</span></code>: Green input band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hBlue</span></code>: Blue input band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnIncludePixel</span></code>: function used to test which pixels should be included in the analysis. At this time this argument is ignored and all pixels are utilized. This should normally be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nColors</span></code>: the desired number of colors to be returned (2-256). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hColorTable</span></code>: the colors will be returned in this color table object. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback argument passed to pfnProgress.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417GDALDitherRGB2PCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALColorTableH16GDALProgressFuncPv">
<span id="_CPPv317GDALDitherRGB2PCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALColorTableH16GDALProgressFuncPv"></span><span id="_CPPv217GDALDitherRGB2PCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALColorTableH16GDALProgressFuncPv"></span><span id="GDALDitherRGB2PCT__GDALRasterBandH.GDALRasterBandH.GDALRasterBandH.GDALRasterBandH.GDALColorTableH.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a284dbcc27295b7e678b1f7d4fa1506cb"></span>int <code class="descname">GDALDitherRGB2PCT</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hRed</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hGreen</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hBlue</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hTarget</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALColorTableH" title="GDALColorTableH">GDALColorTableH</a> <em>hColorTable</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417GDALDitherRGB2PCT15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH15GDALColorTableH16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>24bit to 8bit conversion with dithering. </p>
<p>This functions utilizes Floyd-Steinberg dithering in the process of converting a 24bit RGB image into a pseudocolored 8bit image using a provided color table.</p>
<p>The red, green and blue input bands do not necessarily need to come from the same file, but they must be the same width and height. They will be clipped to 8bit during reading, so non-eight bit bands are generally inappropriate. Likewise the hTarget band will be written with 8bit values and must match the width and height of the source bands.</p>
<p>The color table cannot have more than 256 entries.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hRed</span></code>: Red input band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGreen</span></code>: Green input band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hBlue</span></code>: Blue input band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hTarget</span></code>: Output band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hColorTable</span></code>: the color table to use with the output band. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback argument passed to pfnProgress.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417GDALChecksumImage15GDALRasterBandHiiii">
<span id="_CPPv317GDALChecksumImage15GDALRasterBandHiiii"></span><span id="_CPPv217GDALChecksumImage15GDALRasterBandHiiii"></span><span id="GDALChecksumImage__GDALRasterBandH.i.i.i.i"></span><span class="target" id="gdal__alg_8h_1abe2846ac3a350c24f07dc9ceac8f4d14"></span>int <code class="descname">GDALChecksumImage</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hBand</em>, int <em>nXOff</em>, int <em>nYOff</em>, int <em>nXSize</em>, int <em>nYSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417GDALChecksumImage15GDALRasterBandHiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute checksum for image region. </p>
<p>Computes a 16bit (0-65535) checksum from a region of raster data on a GDAL supported band. Floating point data is converted to 32bit integer so decimal portions of such raster data will not affect the checksum. Real and Imaginary components of complex bands influence the result.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Checksum value. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hBand</span></code>: the raster band to read from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXOff</span></code>: pixel offset of window to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYOff</span></code>: line offset of window to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXSize</span></code>: pixel size of window to read. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYSize</span></code>: line size of window to read.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420GDALComputeProximity15GDALRasterBandH15GDALRasterBandHPPc16GDALProgressFuncPv">
<span id="_CPPv320GDALComputeProximity15GDALRasterBandH15GDALRasterBandHPPc16GDALProgressFuncPv"></span><span id="_CPPv220GDALComputeProximity15GDALRasterBandH15GDALRasterBandHPPc16GDALProgressFuncPv"></span><span id="GDALComputeProximity__GDALRasterBandH.GDALRasterBandH.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a851815400a579aae9de01199b416fa42"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALComputeProximity</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hSrcBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hProximityBand</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420GDALComputeProximity15GDALRasterBandH15GDALRasterBandHPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the proximity of all pixels in the image to a set of pixels in the source image. </p>
<p>This function attempts to compute the proximity of all pixels in the image to a set of pixels in the source image. The following options are used to define the behavior of the function. By default all non-zero pixels in hSrcBand will be considered the “target”, and all proximities will be computed in pixels. Note that target pixels are set to the value corresponding to a distance of zero.</p>
<p>The progress function args may be NULL or a valid progress reporting function such as GDALTermProgress/NULL.</p>
<p>Options:</p>
<p>VALUES=n[,n]*</p>
<p>A list of target pixel values to measure the distance from. If this option is not provided proximity will be computed from non-zero pixel values. Currently pixel values are internally processed as integers.</p>
<p>DISTUNITS=[PIXEL]/GEO</p>
<p>Indicates whether distances will be computed in pixel units or in georeferenced units. The default is pixel units. This also determines the interpretation of MAXDIST.</p>
<p>MAXDIST=n</p>
<p>The maximum distance to search. Proximity distances greater than this value will not be computed. Instead output pixels will be set to a nodata value.</p>
<p>NODATA=n</p>
<p>The NODATA value to use on the output band for pixels that are beyond MAXDIST. If not provided, the hProximityBand will be queried for a nodata value. If one is not found, 65535 will be used.</p>
<p>USE_INPUT_NODATA=YES/NO</p>
<p>If this option is set, the input data set no-data value will be respected. Leaving no data pixels in the input as no data pixels in the proximity output.</p>
<p>FIXED_BUF_VAL=n</p>
<p>If this option is set, all pixels within the MAXDIST threadhold are set to this fixed value instead of to a proximity distance. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414GDALFillNodata15GDALRasterBandH15GDALRasterBandHdiiPPc16GDALProgressFuncPv">
<span id="_CPPv314GDALFillNodata15GDALRasterBandH15GDALRasterBandHdiiPPc16GDALProgressFuncPv"></span><span id="_CPPv214GDALFillNodata15GDALRasterBandH15GDALRasterBandHdiiPPc16GDALProgressFuncPv"></span><span id="GDALFillNodata__GDALRasterBandH.GDALRasterBandH.double.i.i.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a0a079afef61968f224b159d48423d1c6"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALFillNodata</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hTargetBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hMaskBand</em>, double <em>dfMaxSearchDist</em>, int <em>bDeprecatedOption</em>, int <em>nSmoothingIterations</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414GDALFillNodata15GDALRasterBandH15GDALRasterBandHdiiPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill selected raster regions by interpolation from the edges. </p>
<p>This algorithm will interpolate values for all designated nodata pixels (marked by zeros in hMaskBand). For each pixel a four direction conic search is done to find values to interpolate from (using inverse distance weighting). Once all values are interpolated, zero or more smoothing iterations (3x3 average filters on interpolated pixels) are applied to smooth out artifacts.</p>
<p>This algorithm is generally suitable for interpolating missing regions of fairly continuously varying rasters (such as elevation models for instance). It is also suitable for filling small holes and cracks in more irregularly varying images (like airphotos). It is generally not so great for interpolating a raster from sparse point data - see the algorithms defined in gdal_grid.h for that case.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if something goes wrong. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTargetBand</span></code>: the raster band to be modified in place. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hMaskBand</span></code>: a mask band indicating pixels to be interpolated (zero valued). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxSearchDist</span></code>: the maximum number of pixels to search in all directions to find values to interpolate from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDeprecatedOption</span></code>: unused argument, should be zero. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSmoothingIterations</span></code>: the number of 3x3 smoothing filter passes to run (0 or more). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: additional name=value options in a string list. <ul>
<li><p>TEMP_FILE_DRIVER=gdal_driver_name. For example MEM. </p></li>
<li><p>NODATA=value (starting with GDAL 2.4). Source pixels at that value will be ignored by the interpolator. Warning: currently this will not be honored by smoothing passes. </p></li>
</ul>
</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: the progress function to report completion. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback data for progress function.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414GDALPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv">
<span id="_CPPv314GDALPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv"></span><span id="_CPPv214GDALPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv"></span><span id="GDALPolygonize__GDALRasterBandH.GDALRasterBandH.OGRLayerH.i.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a3f522a9035d3512b5d414fb4752671b1"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALPolygonize</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hSrcBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hMaskBand</em>, <a class="reference internal" href="vector_c_api.html#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hOutLayer</em>, int <em>iPixValField</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414GDALPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create polygon coverage from raster data. </p>
<p>This function creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Optionally each polygon may be labeled with the pixel value in an attribute. Optionally a mask band can be provided to determine which pixels are eligible for processing.</p>
<p>Note that currently the source pixel band values are read into a signed 32bit integer buffer (Int32), so floating point or complex bands will be implicitly truncated before processing. If you want to use a version using 32bit float buffers, see <a class="reference internal" href="#gdal__alg_8h_1a7a789015334d677afcbef67e5a6b4a7c"><span class="std std-ref">GDALFPolygonize()</span></a>.</p>
<p>Polygon features will be created on the output layer, with polygon geometries representing the polygons. The polygon geometries will be in the georeferenced coordinate system of the image (based on the geotransform of the source dataset). It is acceptable for the output layer to already have features. Note that <a class="reference internal" href="#gdal__alg_8h_1a3f522a9035d3512b5d414fb4752671b1"><span class="std std-ref">GDALPolygonize()</span></a> does not set the coordinate system on the output layer. Application code should do this when the layer is created, presumably matching the raster coordinate system.</p>
<p>The algorithm used attempts to minimize memory use so that very large rasters can be processed. However, if the raster has many polygons or very large/complex polygons, the memory use for holding polygon enumerations and active polygon geometries may grow to be quite large.</p>
<p>The algorithm will generally produce very dense polygon geometries, with edges that follow exactly on pixel boundaries for all non-interior pixels. For non-thematic raster data (such as satellite images) the result will essentially be one small polygon per pixel, and memory and output layer sizes will be substantial. The algorithm is primarily intended for relatively simple thematic imagery, masks, and classification results.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure on a failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcBand</span></code>: the source raster band to be processed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hMaskBand</span></code>: an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOutLayer</span></code>: the vector feature layer to which the polygons should be written. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iPixValField</span></code>: the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: a name/value list of additional options </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback argument passed to pfnProgress.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415GDALFPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv">
<span id="_CPPv315GDALFPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv"></span><span id="_CPPv215GDALFPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv"></span><span id="GDALFPolygonize__GDALRasterBandH.GDALRasterBandH.OGRLayerH.i.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a7a789015334d677afcbef67e5a6b4a7c"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALFPolygonize</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hSrcBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hMaskBand</em>, <a class="reference internal" href="vector_c_api.html#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> <em>hOutLayer</em>, int <em>iPixValField</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415GDALFPolygonize15GDALRasterBandH15GDALRasterBandH9OGRLayerHiPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create polygon coverage from raster data. </p>
<p>This function creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Optionally each polygon may be labeled with the pixel value in an attribute. Optionally a mask band can be provided to determine which pixels are eligible for processing.</p>
<p>The source pixel band values are read into a 32bit float buffer. If you want to use a (probably faster) version using signed 32bit integer buffer, see <a class="reference internal" href="#gdal__alg_8h_1a3f522a9035d3512b5d414fb4752671b1"><span class="std std-ref">GDALPolygonize()</span></a>.</p>
<p>Polygon features will be created on the output layer, with polygon geometries representing the polygons. The polygon geometries will be in the georeferenced coordinate system of the image (based on the geotransform of the source dataset). It is acceptable for the output layer to already have features. Note that <a class="reference internal" href="#gdal__alg_8h_1a7a789015334d677afcbef67e5a6b4a7c"><span class="std std-ref">GDALFPolygonize()</span></a> does not set the coordinate system on the output layer. Application code should do this when the layer is created, presumably matching the raster coordinate system.</p>
<p>The algorithm used attempts to minimize memory use so that very large rasters can be processed. However, if the raster has many polygons or very large/complex polygons, the memory use for holding polygon enumerations and active polygon geometries may grow to be quite large.</p>
<p>The algorithm will generally produce very dense polygon geometries, with edges that follow exactly on pixel boundaries for all non-interior pixels. For non-thematic raster data (such as satellite images) the result will essentially be one small polygon per pixel, and memory and output layer sizes will be substantial. The algorithm is primarily intended for relatively simple thematic imagery, masks, and classification results.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure on a failure.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 1.9.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcBand</span></code>: the source raster band to be processed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hMaskBand</span></code>: an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hOutLayer</span></code>: the vector feature layer to which the polygons should be written. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iPixValField</span></code>: the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: a name/value list of additional options </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback argument passed to pfnProgress.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415GDALSieveFilter15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHiiPPc16GDALProgressFuncPv">
<span id="_CPPv315GDALSieveFilter15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHiiPPc16GDALProgressFuncPv"></span><span id="_CPPv215GDALSieveFilter15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHiiPPc16GDALProgressFuncPv"></span><span id="GDALSieveFilter__GDALRasterBandH.GDALRasterBandH.GDALRasterBandH.i.i.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a33309c0a316b223bd33ae5753cc7f616"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALSieveFilter</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hSrcBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hMaskBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hDstBand</em>, int <em>nSizeThreshold</em>, int <em>nConnectedness</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415GDALSieveFilter15GDALRasterBandH15GDALRasterBandH15GDALRasterBandHiiPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes small raster polygons. </p>
<p>The function removes raster polygons smaller than a provided threshold size (in pixels) and replaces replaces them with the pixel value of the largest neighbour polygon.</p>
<p>Polygon are determined (per GDALRasterPolygonEnumerator) as regions of the raster where the pixels all have the same value, and that are contiguous (connected).</p>
<p>Pixels determined to be “nodata” per hMaskBand will not be treated as part of a polygon regardless of their pixel values. Nodata areas will never be changed nor affect polygon sizes.</p>
<p>Polygons smaller than the threshold with no neighbours that are as large as the threshold will not be altered. Polygons surrounded by nodata areas will therefore not be altered.</p>
<p>The algorithm makes three passes over the input file to enumerate the polygons and collect limited information about them. Memory use is proportional to the number of polygons (roughly 24 bytes per polygon), but is not directly related to the size of the raster. So very large raster files can be processed effectively if there aren’t too many polygons. But extremely noisy rasters with many one pixel polygons will end up being expensive (in memory) to process.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcBand</span></code>: the source raster band to be processed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hMaskBand</span></code>: an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for inclusion in polygons. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hDstBand</span></code>: the output raster band. It may be the same as hSrcBand to update the source in place. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nSizeThreshold</span></code>: raster polygons with sizes smaller than this will be merged into their largest neighbour. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nConnectedness</span></code>: either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: algorithm options in name=value list form. None currently supported. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback argument passed to pfnProgress.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv431GDALCreateGenImgProjTransformer12GDALDatasetHPKc12GDALDatasetHPKcidi">
<span id="_CPPv331GDALCreateGenImgProjTransformer12GDALDatasetHPKc12GDALDatasetHPKcidi"></span><span id="_CPPv231GDALCreateGenImgProjTransformer12GDALDatasetHPKc12GDALDatasetHPKcidi"></span><span id="GDALCreateGenImgProjTransformer__GDALDatasetH.cCP.GDALDatasetH.cCP.i.double.i"></span><span class="target" id="gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"></span>void *<code class="descname">GDALCreateGenImgProjTransformer</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hSrcDS</em>, <em class="property">const</em> char *<em>pszSrcWKT</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hDstDS</em>, <em class="property">const</em> char *<em>pszDstWKT</em>, int <em>bGCPUseOK</em>, double <em>dfGCPErrorThreshold</em>, int <em>nOrder</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431GDALCreateGenImgProjTransformer12GDALDatasetHPKc12GDALDatasetHPKcidi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="reference internal" href="#gdal__alg_8h_1a9acdfd7db1541c1df5e29a031994d61b"><span class="std std-ref">GDALGCPTransform()</span></a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="reference internal" href="#gdal__alg_8h_1af00f74e03c57842b359130ca73857521"><span class="std std-ref">GDALReprojectionTransform()</span></a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="reference internal" href="#gdal__alg_8h_1a9acdfd7db1541c1df5e29a031994d61b"><span class="std std-ref">GDALGCPTransform()</span></a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle suitable for use <a class="reference internal" href="#gdal__alg_8h_1a109c26234c2f934164e29649353532b6"><span class="std std-ref">GDALGenImgProjTransform()</span></a>, and to be deallocated with <a class="reference internal" href="#gdal__alg_8h_1a5fb383c4e5197e8e37ae1265cca8124d"><span class="std std-ref">GDALDestroyGenImgProjTransformer()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcDS</span></code>: source dataset, or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrcWKT</span></code>: the coordinate system for the source dataset. If NULL, it will be read from the dataset itself. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hDstDS</span></code>: destination dataset (or NULL). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstWKT</span></code>: the coordinate system for the destination dataset. If NULL, and hDstDS not NULL, it will be read from the destination dataset. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bGCPUseOK</span></code>: TRUE if GCPs should be used if the geotransform is not available on the source dataset (not destination). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfGCPErrorThreshold</span></code>: ignored/deprecated. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOrder</span></code>: the maximum order to use for GCP derived polynomials if possible. Use 0 to autoselect, or -1 for thin plate splines.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432GDALCreateGenImgProjTransformer212GDALDatasetH12GDALDatasetHPPc">
<span id="_CPPv332GDALCreateGenImgProjTransformer212GDALDatasetH12GDALDatasetHPPc"></span><span id="_CPPv232GDALCreateGenImgProjTransformer212GDALDatasetH12GDALDatasetHPPc"></span><span id="GDALCreateGenImgProjTransformer2__GDALDatasetH.GDALDatasetH.cPP"></span><span class="target" id="gdal__alg_8h_1a94cd172f78dbc41d6f407d662914f2e3"></span>void *<code class="descname">GDALCreateGenImgProjTransformer2</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hSrcDS</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hDstDS</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432GDALCreateGenImgProjTransformer212GDALDatasetH12GDALDatasetHPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="reference internal" href="#gdal__alg_8h_1a9acdfd7db1541c1df5e29a031994d61b"><span class="std std-ref">GDALGCPTransform()</span></a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="reference internal" href="#gdal__alg_8h_1af00f74e03c57842b359130ca73857521"><span class="std std-ref">GDALReprojectionTransform()</span></a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="reference internal" href="#gdal__alg_8h_1a9acdfd7db1541c1df5e29a031994d61b"><span class="std std-ref">GDALGCPTransform()</span></a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<p>Supported Options (specified with the -to switch of gdalwarp for example): <ul class="simple">
<li><p>SRC_SRS: WKT SRS, or any string recognized by <a class="reference internal" href="ogrspatialref.html#classOGRSpatialReference_1aec3c6a49533fe457ddc763d699ff8796"><span class="std std-ref">OGRSpatialReference::SetFromUserInput()</span></a>, to be used as an override for hSrcDS. </p></li>
<li><p>DST_SRS: WKT SRS, or any string recognized by <a class="reference internal" href="ogrspatialref.html#classOGRSpatialReference_1aec3c6a49533fe457ddc763d699ff8796"><span class="std std-ref">OGRSpatialReference::SetFromUserInput()</span></a>, to be used as an override for hDstDS. </p></li>
<li><p>COORDINATE_OPERATION: (GDAL &gt;= 3.0) Coordinate operation, as a PROJ or WKT string, used as an override over the normally computed pipeline. The pipeline must take into account the axis order of the source and target SRS. </p></li>
<li><p>COORDINATE_EPOCH: (GDAL &gt;= 3.0) Coordinate epoch, expressed as a decimal year. Useful for time-dependant coordinate operations. </p></li>
<li><p>GCPS_OK: If false, GCPs will not be used, default is TRUE. </p></li>
<li><p>REFINE_MINIMUM_GCPS: The minimum amount of GCPs that should be available after the refinement. </p></li>
<li><p>REFINE_TOLERANCE: The tolerance that specifies when a GCP will be eliminated. </p></li>
<li><p>MAX_GCP_ORDER: the maximum order to use for GCP derived polynomials if possible. The default is to autoselect based on the number of GCPs. A value of -1 triggers use of Thin Plate Spline instead of polynomials. </p></li>
<li><p>SRC_METHOD: may have a value which is one of GEOTRANSFORM, GCP_POLYNOMIAL, GCP_TPS, GEOLOC_ARRAY, RPC to force only one geolocation method to be considered on the source dataset. Will be used for pixel/line to georef transformation on the source dataset. NO_GEOTRANSFORM can be used to specify the identity geotransform (ungeoreference image) </p></li>
<li><p>DST_METHOD: may have a value which is one of GEOTRANSFORM, GCP_POLYNOMIAL, GCP_TPS, GEOLOC_ARRAY, RPC to force only one geolocation method to be considered on the target dataset. Will be used for pixel/line to georef transformation on the destination dataset. NO_GEOTRANSFORM can be used to specify the identity geotransform (ungeoreference image) </p></li>
<li><p>RPC_HEIGHT: A fixed height to be used with RPC calculations. </p></li>
<li><p>RPC_DEM: The name of a DEM file to be used with RPC calculations. </p></li>
<li><p>Other RPC related options. See <a class="reference internal" href="#gdal__alg_8h_1af4c3c0d4c79218995b3a1f0bac3700a0"><span class="std std-ref">GDALCreateRPCTransformer()</span></a> </p></li>
<li><p>INSERT_CENTER_LONG: May be set to FALSE to disable setting up a CENTER_LONG value on the coordinate system to rewrap things around the center of the image. </p></li>
<li><p>SRC_APPROX_ERROR_IN_SRS_UNIT=err_threshold_in_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the source transformer. Must be defined together with SRC_APPROX_ERROR_IN_PIXEL to be taken into account. </p></li>
<li><p>SRC_APPROX_ERROR_IN_PIXEL=err_threshold_in_pixel. (GDAL &gt;= 2.2) Use an approximate transformer for the source transformer.. Must be defined together with SRC_APPROX_ERROR_IN_SRS_UNIT to be taken into account. </p></li>
<li><p>DST_APPROX_ERROR_IN_SRS_UNIT=err_threshold_in_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the destination transformer. Must be defined together with DST_APPROX_ERROR_IN_PIXEL to be taken into account. </p></li>
<li><p>DST_APPROX_ERROR_IN_PIXEL=err_threshold_in_pixel. (GDAL &gt;= 2.2) Use an approximate transformer for the destination transformer. Must be defined together with DST_APPROX_ERROR_IN_SRS_UNIT to be taken into account. </p></li>
<li><p>REPROJECTION_APPROX_ERROR_IN_SRC_SRS_UNIT=err_threshold_in_src_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the coordinate reprojection. Must be used together with REPROJECTION_APPROX_ERROR_IN_DST_SRS_UNIT to be taken into account. </p></li>
<li><p>REPROJECTION_APPROX_ERROR_IN_DST_SRS_UNIT=err_threshold_in_dst_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the coordinate reprojection. Must be used together with REPROJECTION_APPROX_ERROR_IN_SRC_SRS_UNIT to be taken into account. </p></li>
<li><p>AREA_OF_INTEREST=west_lon_deg,south_lat_deg,east_lon_deg,north_lat_deg. (GDAL &gt;= 3.0) Area of interest, used to compute the best coordinate operation between the source and target SRS. If not specified, the bounding box of the source raster will be used. </p></li>
</ul>
</p>
<p>The use case for the *_APPROX_ERROR_* options is when defining an approximate transformer on top of the GenImgProjTransformer globally is not practical. Such a use case is when the source dataset has RPC with a RPC DEM. In such case we don’t want to use the approximate transformer on the RPC transformation, as the RPC DEM generally involves non-linearities that the approximate transformer will not detect. In such case, we must a non-approximated GenImgProjTransformer, but it might be worthwile to use approximate sub- transformers, for example on coordinate reprojection. For example if warping from a source dataset with RPC to a destination dataset with a UTM projection, since the inverse UTM transformation is rather costly. In which case, one can use the REPROJECTION_APPROX_ERROR_IN_SRC_SRS_UNIT and REPROJECTION_APPROX_ERROR_IN_DST_SRS_UNIT options.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle suitable for use <a class="reference internal" href="#gdal__alg_8h_1a109c26234c2f934164e29649353532b6"><span class="std std-ref">GDALGenImgProjTransform()</span></a>, and to be deallocated with <a class="reference internal" href="#gdal__alg_8h_1a5fb383c4e5197e8e37ae1265cca8124d"><span class="std std-ref">GDALDestroyGenImgProjTransformer()</span></a> or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcDS</span></code>: source dataset, or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hDstDS</span></code>: destination dataset (or NULL). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL-terminated list of string options (or NULL).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432GDALCreateGenImgProjTransformer3PKcPKdPKcPKd">
<span id="_CPPv332GDALCreateGenImgProjTransformer3PKcPKdPKcPKd"></span><span id="_CPPv232GDALCreateGenImgProjTransformer3PKcPKdPKcPKd"></span><span id="GDALCreateGenImgProjTransformer3__cCP.doubleCP.cCP.doubleCP"></span><span class="target" id="gdal__alg_8h_1a05f5de51947234a0481088bed2d7ce53"></span>void *<code class="descname">GDALCreateGenImgProjTransformer3</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszSrcWKT</em>, <em class="property">const</em> double *<em>padfSrcGeoTransform</em>, <em class="property">const</em> char *<em>pszDstWKT</em>, <em class="property">const</em> double *<em>padfDstGeoTransform</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432GDALCreateGenImgProjTransformer3PKcPKdPKcPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="reference internal" href="#gdal__alg_8h_1a9acdfd7db1541c1df5e29a031994d61b"><span class="std std-ref">GDALGCPTransform()</span></a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="reference internal" href="#gdal__alg_8h_1af00f74e03c57842b359130ca73857521"><span class="std std-ref">GDALReprojectionTransform()</span></a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="reference internal" href="#gdal__alg_8h_1a9acdfd7db1541c1df5e29a031994d61b"><span class="std std-ref">GDALGCPTransform()</span></a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>handle suitable for use <a class="reference internal" href="#gdal__alg_8h_1a109c26234c2f934164e29649353532b6"><span class="std std-ref">GDALGenImgProjTransform()</span></a>, and to be deallocated with <a class="reference internal" href="#gdal__alg_8h_1a5fb383c4e5197e8e37ae1265cca8124d"><span class="std std-ref">GDALDestroyGenImgProjTransformer()</span></a> or NULL on failure. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrcWKT</span></code>: source WKT (or NULL). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfSrcGeoTransform</span></code>: source geotransform (or NULL). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstWKT</span></code>: destination WKT (or NULL). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfDstGeoTransform</span></code>: destination geotransform (or NULL).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432GDALCreateGenImgProjTransformer420OGRSpatialReferenceHPKd20OGRSpatialReferenceHPKdPPCKc">
<span id="_CPPv332GDALCreateGenImgProjTransformer420OGRSpatialReferenceHPKd20OGRSpatialReferenceHPKdPPCKc"></span><span id="_CPPv232GDALCreateGenImgProjTransformer420OGRSpatialReferenceHPKd20OGRSpatialReferenceHPKdPPCKc"></span><span id="GDALCreateGenImgProjTransformer4__OGRSpatialReferenceH.doubleCP.OGRSpatialReferenceH.doubleCP.cCPCP"></span><span class="target" id="gdal__alg_8h_1a7307bae38fe0f59679172f82492cc02d"></span>void *<code class="descname">GDALCreateGenImgProjTransformer4</code><span class="sig-paren">(</span><a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSrcSRS</em>, <em class="property">const</em> double *<em>padfSrcGeoTransform</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hDstSRS</em>, <em class="property">const</em> double *<em>padfDstGeoTransform</em>, <em class="property">const</em> char *<em class="property">const</em> *<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432GDALCreateGenImgProjTransformer420OGRSpatialReferenceHPKd20OGRSpatialReferenceHPKdPPCKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create image to image transformer. </p>
<p>Similar to <a class="reference internal" href="#gdal__alg_8h_1a05f5de51947234a0481088bed2d7ce53"><span class="std std-ref">GDALCreateGenImgProjTransformer3()</span></a>, except that it takes OGRSpatialReferenceH objects and options. The options are the ones supported by <a class="reference internal" href="#gdal__alg_8h_1ac026c145117134bc754bf25c84b207e1"><span class="std std-ref">GDALCreateReprojectionTransformerEx()</span></a></p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 3.0 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv443GDALSetGenImgProjTransformerDstGeoTransformPvPKd">
<span id="_CPPv343GDALSetGenImgProjTransformerDstGeoTransformPvPKd"></span><span id="_CPPv243GDALSetGenImgProjTransformerDstGeoTransformPvPKd"></span><span id="GDALSetGenImgProjTransformerDstGeoTransform__voidP.doubleCP"></span><span class="target" id="gdal__alg_8h_1a18e841864cf6d93596626981d26c3000"></span>void <code class="descname">GDALSetGenImgProjTransformerDstGeoTransform</code><span class="sig-paren">(</span>void *<em>hTransformArg</em>, <em class="property">const</em> double *<em>padfGeoTransform</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv443GDALSetGenImgProjTransformerDstGeoTransformPvPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set GenImgProj output geotransform. </p>
<p>Normally the “destination geotransform”, or transformation between georeferenced output coordinates and pixel/line coordinates on the destination file is extracted from the destination file by <a class="reference internal" href="#gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"><span class="std std-ref">GDALCreateGenImgProjTransformer()</span></a> and stored in the GenImgProj private info. However, sometimes it is inconvenient to have an output file handle with appropriate geotransform information when creating the transformation. For these cases, this function can be used to apply the destination geotransform.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTransformArg</span></code>: the handle to update. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfGeoTransform</span></code>: the destination geotransform to apply (six doubles). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432GDALDestroyGenImgProjTransformerPv">
<span id="_CPPv332GDALDestroyGenImgProjTransformerPv"></span><span id="_CPPv232GDALDestroyGenImgProjTransformerPv"></span><span id="GDALDestroyGenImgProjTransformer__voidP"></span><span class="target" id="gdal__alg_8h_1a5fb383c4e5197e8e37ae1265cca8124d"></span>void <code class="descname">GDALDestroyGenImgProjTransformer</code><span class="sig-paren">(</span>void *<em>hTransformArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432GDALDestroyGenImgProjTransformerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GenImgProjTransformer deallocator. </p>
<p>This function is used to deallocate the handle created with <a class="reference internal" href="#gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"><span class="std std-ref">GDALCreateGenImgProjTransformer()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hTransformArg</span></code>: the handle to deallocate. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423GDALGenImgProjTransformPviiPdPdPdPi">
<span id="_CPPv323GDALGenImgProjTransformPviiPdPdPdPi"></span><span id="_CPPv223GDALGenImgProjTransformPviiPdPdPdPi"></span><span id="GDALGenImgProjTransform__voidP.i.i.doubleP.doubleP.doubleP.iP"></span><span class="target" id="gdal__alg_8h_1a109c26234c2f934164e29649353532b6"></span>int <code class="descname">GDALGenImgProjTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, int <em>bDstToSrc</em>, int <em>nPointCount</em>, double *<em>x</em>, double *<em>y</em>, double *<em>z</em>, int *<em>panSuccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423GDALGenImgProjTransformPviiPdPdPdPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform general image reprojection transformation. </p>
<p>Actually performs the transformation setup in <a class="reference internal" href="#gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"><span class="std std-ref">GDALCreateGenImgProjTransformer()</span></a>. This function matches the signature required by the <a class="reference internal" href="#gdal__alg_8h_1aaede67ca444a06f0a6fed538e05d2220"><span class="std std-ref">GDALTransformerFunc()</span></a>, and more details on the arguments can be found in that topic. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv433GDALSetTransformerDstGeoTransformPvPKd">
<span id="_CPPv333GDALSetTransformerDstGeoTransformPvPKd"></span><span id="_CPPv233GDALSetTransformerDstGeoTransformPvPKd"></span><span id="GDALSetTransformerDstGeoTransform__voidP.doubleCP"></span><span class="target" id="gdal__alg_8h_1ac55a29540c5af804a75818eeaabfbfd4"></span>void <code class="descname">GDALSetTransformerDstGeoTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, <em class="property">const</em> double *<em>padfGeoTransform</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433GDALSetTransformerDstGeoTransformPvPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set ApproxTransformer or GenImgProj output geotransform. </p>
<p>This is a layer above <a class="reference internal" href="#gdal__alg_8h_1a18e841864cf6d93596626981d26c3000"><span class="std std-ref">GDALSetGenImgProjTransformerDstGeoTransform()</span></a> that checks that the passed hTransformArg is compatible.</p>
<p>Normally the “destination geotransform”, or transformation between georeferenced output coordinates and pixel/line coordinates on the destination file is extracted from the destination file by <a class="reference internal" href="#gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"><span class="std std-ref">GDALCreateGenImgProjTransformer()</span></a> and stored in the GenImgProj private info. However, sometimes it is inconvenient to have an output file handle with appropriate geotransform information when creating the transformation. For these cases, this function can be used to apply the destination geotransform.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the handle to update. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfGeoTransform</span></code>: the destination geotransform to apply (six doubles). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv433GDALGetTransformerDstGeoTransformPvPd">
<span id="_CPPv333GDALGetTransformerDstGeoTransformPvPd"></span><span id="_CPPv233GDALGetTransformerDstGeoTransformPvPd"></span><span id="GDALGetTransformerDstGeoTransform__voidP.doubleP"></span><span class="target" id="gdal__alg_8h_1a8a032e9bf590c95781321115df855cd2"></span>void <code class="descname">GDALGetTransformerDstGeoTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, double *<em>padfGeoTransform</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433GDALGetTransformerDstGeoTransformPvPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get ApproxTransformer or GenImgProj output geotransform. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: transformer handle. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfGeoTransform</span></code>: (output) the destination geotransform to return (six doubles). </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv433GDALCreateReprojectionTransformerPKcPKc">
<span id="_CPPv333GDALCreateReprojectionTransformerPKcPKc"></span><span id="_CPPv233GDALCreateReprojectionTransformerPKcPKc"></span><span id="GDALCreateReprojectionTransformer__cCP.cCP"></span><span class="target" id="gdal__alg_8h_1adce63548b884096e55d1685d4bbd7e63"></span>void *<code class="descname">GDALCreateReprojectionTransformer</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszSrcWKT</em>, <em class="property">const</em> char *<em>pszDstWKT</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433GDALCreateReprojectionTransformerPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create reprojection transformer. </p>
<p>Creates a callback data structure suitable for use with GDALReprojectionTransformation() to represent a transformation from one geographic or projected coordinate system to another. On input the coordinate systems are described in OpenGIS WKT format.</p>
<p>Internally the <a class="reference internal" href="ogrspatialref.html#classOGRCoordinateTransformation"><span class="std std-ref">OGRCoordinateTransformation</span></a> object is used to implement the reprojection.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Handle for use with <a class="reference internal" href="#gdal__alg_8h_1af00f74e03c57842b359130ca73857521"><span class="std std-ref">GDALReprojectionTransform()</span></a>, or NULL if the system fails to initialize the reprojection. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszSrcWKT</span></code>: the coordinate system for the source coordinate system. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstWKT</span></code>: the coordinate system for the destination coordinate system.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv435GDALCreateReprojectionTransformerEx20OGRSpatialReferenceH20OGRSpatialReferenceHPPCKc">
<span id="_CPPv335GDALCreateReprojectionTransformerEx20OGRSpatialReferenceH20OGRSpatialReferenceHPPCKc"></span><span id="_CPPv235GDALCreateReprojectionTransformerEx20OGRSpatialReferenceH20OGRSpatialReferenceHPPCKc"></span><span id="GDALCreateReprojectionTransformerEx__OGRSpatialReferenceH.OGRSpatialReferenceH.cCPCP"></span><span class="target" id="gdal__alg_8h_1ac026c145117134bc754bf25c84b207e1"></span>void *<code class="descname">GDALCreateReprojectionTransformerEx</code><span class="sig-paren">(</span><a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hSrcSRS</em>, <a class="reference internal" href="ogr_srs_api.html#_CPPv420OGRSpatialReferenceH" title="OGRSpatialReferenceH">OGRSpatialReferenceH</a> <em>hDstSRS</em>, <em class="property">const</em> char *<em class="property">const</em> *<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv435GDALCreateReprojectionTransformerEx20OGRSpatialReferenceH20OGRSpatialReferenceHPPCKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create reprojection transformer. </p>
<p>Creates a callback data structure suitable for use with GDALReprojectionTransformation() to represent a transformation from one geographic or projected coordinate system to another.</p>
<p>Internally the <a class="reference internal" href="ogrspatialref.html#classOGRCoordinateTransformation"><span class="std std-ref">OGRCoordinateTransformation</span></a> object is used to implement the reprojection.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Handle for use with <a class="reference internal" href="#gdal__alg_8h_1af00f74e03c57842b359130ca73857521"><span class="std std-ref">GDALReprojectionTransform()</span></a>, or NULL if the system fails to initialize the reprojection.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.0 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcSRS</span></code>: the coordinate system for the source coordinate system. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hDstSRS</span></code>: the coordinate system for the destination coordinate system. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: NULL-terminated list of options, or NULL. Currrently supported options are: <ul>
<li><p>AREA_OF_INTEREST=west_long,south_lat,east_long,north_lat: Values in degrees. longitudes in [-180,180], latitudes in [-90,90]. </p></li>
<li><p>COORDINATE_OPERATION=string: PROJ or WKT string representing a coordinate operation, overriding the default computed transformation. </p></li>
<li><p>COORDINATE_EPOCH=decimal_year: Coordinate epoch, expressed as a decimal year. Useful for time-dependant coordinate operations. </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv434GDALDestroyReprojectionTransformerPv">
<span id="_CPPv334GDALDestroyReprojectionTransformerPv"></span><span id="_CPPv234GDALDestroyReprojectionTransformerPv"></span><span id="GDALDestroyReprojectionTransformer__voidP"></span><span class="target" id="gdal__alg_8h_1ae6cffb245df6fba275423f1333d89f08"></span>void <code class="descname">GDALDestroyReprojectionTransformer</code><span class="sig-paren">(</span>void *<em>pTransformArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434GDALDestroyReprojectionTransformerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy reprojection transformation. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the transformation handle returned by <a class="reference internal" href="#gdal__alg_8h_1adce63548b884096e55d1685d4bbd7e63"><span class="std std-ref">GDALCreateReprojectionTransformer()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALReprojectionTransformPviiPdPdPdPi">
<span id="_CPPv325GDALReprojectionTransformPviiPdPdPdPi"></span><span id="_CPPv225GDALReprojectionTransformPviiPdPdPdPi"></span><span id="GDALReprojectionTransform__voidP.i.i.doubleP.doubleP.doubleP.iP"></span><span class="target" id="gdal__alg_8h_1af00f74e03c57842b359130ca73857521"></span>int <code class="descname">GDALReprojectionTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, int <em>bDstToSrc</em>, int <em>nPointCount</em>, double *<em>x</em>, double *<em>y</em>, double *<em>z</em>, int *<em>panSuccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALReprojectionTransformPviiPdPdPdPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform reprojection transformation. </p>
<p>Actually performs the reprojection transformation described in <a class="reference internal" href="#gdal__alg_8h_1adce63548b884096e55d1685d4bbd7e63"><span class="std std-ref">GDALCreateReprojectionTransformer()</span></a>. This function matches the <a class="reference internal" href="#gdal__alg_8h_1aaede67ca444a06f0a6fed538e05d2220"><span class="std std-ref">GDALTransformerFunc()</span></a> signature. Details of the arguments are described there. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424GDALCreateGCPTransformeriPK8GDAL_GCPii">
<span id="_CPPv324GDALCreateGCPTransformeriPK8GDAL_GCPii"></span><span id="_CPPv224GDALCreateGCPTransformeriPK8GDAL_GCPii"></span><span id="GDALCreateGCPTransformer__i.GDAL_GCPCP.i.i"></span><span class="target" id="gdal__alg_8h_1ac57c80f7bf6752fac1dff8c2a21a15a3"></span>void *<code class="descname">GDALCreateGCPTransformer</code><span class="sig-paren">(</span>int <em>nGCPCount</em>, <em class="property">const</em> <a class="reference internal" href="raster_c_api.html#_CPPv48GDAL_GCP" title="GDAL_GCP">GDAL_GCP</a> *<em>pasGCPList</em>, int <em>nReqOrder</em>, int <em>bReversed</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424GDALCreateGCPTransformeriPK8GDAL_GCPii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create GCP based polynomial transformer. </p>
<p>Computes least squares fit polynomials from a provided set of GCPs, and stores the coefficients for later transformation of points between pixel/line and georeferenced coordinates.</p>
<p>The return value should be used as a TransformArg in combination with the transformation function GDALGCPTransform which fits the GDALTransformerFunc signature. The returned transform argument should be deallocated with GDALDestroyGCPTransformer when no longer needed.</p>
<p>This function may fail (returning nullptr) if the provided set of GCPs are inadequate for the requested order, the determinate is zero or they are otherwise “ill conditioned”.</p>
<p>Note that 2nd order requires at least 6 GCPs, and 3rd order requires at least 10 gcps. If nReqOrder is 0 the highest order possible (limited to 2) with the provided gcp count will be used.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the transform argument or nullptr if creation fails. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nGCPCount</span></code>: the number of GCPs in pasGCPList. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pasGCPList</span></code>: an array of GCPs to be used as input. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nReqOrder</span></code>: the requested polynomial order. It should be 1, 2 or 3. Using 3 is not recommended due to potential numeric instabilities issues. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bReversed</span></code>: set it to TRUE to compute the reversed transformation.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430GDALCreateGCPRefineTransformeriPK8GDAL_GCPiidi">
<span id="_CPPv330GDALCreateGCPRefineTransformeriPK8GDAL_GCPiidi"></span><span id="_CPPv230GDALCreateGCPRefineTransformeriPK8GDAL_GCPiidi"></span><span id="GDALCreateGCPRefineTransformer__i.GDAL_GCPCP.i.i.double.i"></span><span class="target" id="gdal__alg_8h_1ac936c02335b159a70d940b725a0d3160"></span>void *<code class="descname">GDALCreateGCPRefineTransformer</code><span class="sig-paren">(</span>int <em>nGCPCount</em>, <em class="property">const</em> <a class="reference internal" href="raster_c_api.html#_CPPv48GDAL_GCP" title="GDAL_GCP">GDAL_GCP</a> *<em>pasGCPList</em>, int <em>nReqOrder</em>, int <em>bReversed</em>, double <em>tolerance</em>, int <em>minimumGcps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430GDALCreateGCPRefineTransformeriPK8GDAL_GCPiidi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create GCP based polynomial transformer, with a tolerance threshold to discard GCPs that transform badly. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALDestroyGCPTransformerPv">
<span id="_CPPv325GDALDestroyGCPTransformerPv"></span><span id="_CPPv225GDALDestroyGCPTransformerPv"></span><span id="GDALDestroyGCPTransformer__voidP"></span><span class="target" id="gdal__alg_8h_1a4b1acbe5387ac769f7fee1de93b81011"></span>void <code class="descname">GDALDestroyGCPTransformer</code><span class="sig-paren">(</span>void *<em>pTransformArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALDestroyGCPTransformerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy GCP transformer. </p>
<p>This function is used to destroy information about a GCP based polynomial transformation created with <a class="reference internal" href="#gdal__alg_8h_1ac57c80f7bf6752fac1dff8c2a21a15a3"><span class="std std-ref">GDALCreateGCPTransformer()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the transform arg previously returned by <a class="reference internal" href="#gdal__alg_8h_1ac57c80f7bf6752fac1dff8c2a21a15a3"><span class="std std-ref">GDALCreateGCPTransformer()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416GDALGCPTransformPviiPdPdPdPi">
<span id="_CPPv316GDALGCPTransformPviiPdPdPdPi"></span><span id="_CPPv216GDALGCPTransformPviiPdPdPdPi"></span><span id="GDALGCPTransform__voidP.i.i.doubleP.doubleP.doubleP.iP"></span><span class="target" id="gdal__alg_8h_1a9acdfd7db1541c1df5e29a031994d61b"></span>int <code class="descname">GDALGCPTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, int <em>bDstToSrc</em>, int <em>nPointCount</em>, double *<em>x</em>, double *<em>y</em>, double *<em>z</em>, int *<em>panSuccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416GDALGCPTransformPviiPdPdPdPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transforms point based on GCP derived polynomial model. </p>
<p>This function matches the GDALTransformerFunc signature, and can be used to transform one or more points from pixel/line coordinates to georeferenced coordinates (SrcToDst) or vice versa (DstToSrc).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: return value from <a class="reference internal" href="#gdal__alg_8h_1ac57c80f7bf6752fac1dff8c2a21a15a3"><span class="std std-ref">GDALCreateGCPTransformer()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDstToSrc</span></code>: TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPointCount</span></code>: the number of values in the x, y and z arrays. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code>: array containing the X values to be transformed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: array containing the Y values to be transformed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code>: array containing the Z values to be transformed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panSuccess</span></code>: array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424GDALCreateTPSTransformeriPK8GDAL_GCPi">
<span id="_CPPv324GDALCreateTPSTransformeriPK8GDAL_GCPi"></span><span id="_CPPv224GDALCreateTPSTransformeriPK8GDAL_GCPi"></span><span id="GDALCreateTPSTransformer__i.GDAL_GCPCP.i"></span><span class="target" id="gdal__alg_8h_1a245802b88a8126c138d24febe6c9822a"></span>void *<code class="descname">GDALCreateTPSTransformer</code><span class="sig-paren">(</span>int <em>nGCPCount</em>, <em class="property">const</em> <a class="reference internal" href="raster_c_api.html#_CPPv48GDAL_GCP" title="GDAL_GCP">GDAL_GCP</a> *<em>pasGCPList</em>, int <em>bReversed</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424GDALCreateTPSTransformeriPK8GDAL_GCPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create Thin Plate Spline transformer from GCPs. </p>
<p>The thin plate spline transformer produces exact transformation at all control points and smoothly varying transformations between control points with greatest influence from local control points. It is suitable for for many applications not well modeled by polynomial transformations.</p>
<p>Creating the TPS transformer involves solving systems of linear equations related to the number of control points involved. This solution is computed within this function call. It can be quite an expensive operation for large numbers of GCPs. For instance, for reference, it takes on the order of 10s for 400 GCPs on a 2GHz Athlon processor.</p>
<p>TPS Transformers are serializable.</p>
<p>The GDAL Thin Plate Spline transformer is based on code provided by Gilad Ronnen on behalf of VIZRT Inc (<a class="reference external" href="http://www.visrt.com">http://www.visrt.com</a>). Incorporation of the algorithm into GDAL was supported by the Centro di Ecologia Alpina (<a class="reference external" href="http://www.cealp.it">http://www.cealp.it</a>).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the transform argument or NULL if creation fails. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nGCPCount</span></code>: the number of GCPs in pasGCPList. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pasGCPList</span></code>: an array of GCPs to be used as input. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bReversed</span></code>: set it to TRUE to compute the reversed transformation.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALDestroyTPSTransformerPv">
<span id="_CPPv325GDALDestroyTPSTransformerPv"></span><span id="_CPPv225GDALDestroyTPSTransformerPv"></span><span id="GDALDestroyTPSTransformer__voidP"></span><span class="target" id="gdal__alg_8h_1afe5fccffbcc853230bc631441dc38469"></span>void <code class="descname">GDALDestroyTPSTransformer</code><span class="sig-paren">(</span>void *<em>pTransformArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALDestroyTPSTransformerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy TPS transformer. </p>
<p>This function is used to destroy information about a GCP based polynomial transformation created with <a class="reference internal" href="#gdal__alg_8h_1a245802b88a8126c138d24febe6c9822a"><span class="std std-ref">GDALCreateTPSTransformer()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the transform arg previously returned by <a class="reference internal" href="#gdal__alg_8h_1a245802b88a8126c138d24febe6c9822a"><span class="std std-ref">GDALCreateTPSTransformer()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416GDALTPSTransformPviiPdPdPdPi">
<span id="_CPPv316GDALTPSTransformPviiPdPdPdPi"></span><span id="_CPPv216GDALTPSTransformPviiPdPdPdPi"></span><span id="GDALTPSTransform__voidP.i.i.doubleP.doubleP.doubleP.iP"></span><span class="target" id="gdal__alg_8h_1ab8ba2028a33f1f4eede6fc05ded7cbd6"></span>int <code class="descname">GDALTPSTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, int <em>bDstToSrc</em>, int <em>nPointCount</em>, double *<em>x</em>, double *<em>y</em>, double *<em>z</em>, int *<em>panSuccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416GDALTPSTransformPviiPdPdPdPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transforms point based on GCP derived polynomial model. </p>
<p>This function matches the GDALTransformerFunc signature, and can be used to transform one or more points from pixel/line coordinates to georeferenced coordinates (SrcToDst) or vice versa (DstToSrc).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: return value from <a class="reference internal" href="#gdal__alg_8h_1a245802b88a8126c138d24febe6c9822a"><span class="std std-ref">GDALCreateTPSTransformer()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bDstToSrc</span></code>: TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPointCount</span></code>: the number of values in the x, y and z arrays. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code>: array containing the X values to be transformed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: array containing the Y values to be transformed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code>: array containing the Z values to be transformed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panSuccess</span></code>: array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424GDALCreateRPCTransformerP11GDALRPCInfoidPPc">
<span id="_CPPv324GDALCreateRPCTransformerP11GDALRPCInfoidPPc"></span><span id="_CPPv224GDALCreateRPCTransformerP11GDALRPCInfoidPPc"></span><span id="GDALCreateRPCTransformer__GDALRPCInfoP.i.double.cPP"></span><span class="target" id="gdal__alg_8h_1af4c3c0d4c79218995b3a1f0bac3700a0"></span>void *<code class="descname">GDALCreateRPCTransformer</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv411GDALRPCInfo" title="GDALRPCInfo">GDALRPCInfo</a> *<em>psRPC</em>, int <em>bReversed</em>, double <em>dfPixErrThreshold</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424GDALCreateRPCTransformerP11GDALRPCInfoidPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an RPC based transformer. </p>
<p>The geometric sensor model describing the physical relationship between image coordinates and ground coordinate is known as a Rigorous Projection Model. A Rigorous Projection Model expresses the mapping of the image space coordinates of rows and columns (r,c) onto the object space reference surface geodetic coordinates (long, lat, height).</p>
<p>RPC supports a generic description of the Rigorous Projection Models. The approximation used by GDAL (RPC00) is a set of rational polynomials expressing the normalized row and column values, (rn , cn), as a function of normalized geodetic latitude, longitude, and height, (P, L, H), given a set of normalized polynomial coefficients (LINE_NUM_COEF_n, LINE_DEN_COEF_n, SAMP_NUM_COEF_n, SAMP_DEN_COEF_n). Normalized values, rather than actual values are used in order to minimize introduction of errors during the calculations. The transformation between row and column values (r,c), and normalized row and column values (rn, cn), and between the geodetic latitude, longitude, and height and normalized geodetic latitude, longitude, and height (P, L, H), is defined by a set of normalizing translations (offsets) and scales that ensure all values are contained i the range -1 to +1.</p>
<p>This function creates a GDALTransformFunc compatible transformer for going between image pixel/line and long/lat/height coordinates using RPCs. The RPCs are provided in a <a class="reference internal" href="raster_c_api.html#structGDALRPCInfo"><span class="std std-ref">GDALRPCInfo</span></a> structure which is normally read from metadata using <a class="reference internal" href="raster_c_api.html#gdal_8h_1a4f17f42304d641278fa57cae0aaa449f"><span class="std std-ref">GDALExtractRPCInfo()</span></a>.</p>
<p>GDAL RPC Metadata has the following entries (also described in GDAL RFC 22 and the GeoTIFF RPC document <a class="reference external" href="http://geotiff.maptools.org/rpc_prop.html">http://geotiff.maptools.org/rpc_prop.html</a> .</p>
<p><ul>
<li><p>ERR_BIAS: Error - Bias. The RMS bias error in meters per horizontal axis of all points in the image (-1.0 if unknown) </p></li>
<li><p>ERR_RAND: Error - Random. RMS random error in meters per horizontal axis of each point in the image (-1.0 if unknown) </p></li>
<li><p>LINE_OFF: Line Offset </p></li>
<li><p>SAMP_OFF: Sample Offset </p></li>
<li><p>LAT_OFF: Geodetic Latitude Offset </p></li>
<li><p>LONG_OFF: Geodetic Longitude Offset </p></li>
<li><p>HEIGHT_OFF: Geodetic Height Offset </p></li>
<li><p>LINE_SCALE: Line Scale </p></li>
<li><p>SAMP_SCALE: Sample Scale </p></li>
<li><p>LAT_SCALE: Geodetic Latitude Scale </p></li>
<li><p>LONG_SCALE: Geodetic Longitude Scale </p></li>
<li><p>HEIGHT_SCALE: Geodetic Height Scale</p>
<p></p>
</li>
<li><p>LINE_NUM_COEFF (1-20): Line Numerator Coefficients. Twenty coefficients for the polynomial in the Numerator of the rn equation. (space separated) </p></li>
<li><p>LINE_DEN_COEFF (1-20): Line Denominator Coefficients. Twenty coefficients for the polynomial in the Denominator of the rn equation. (space separated) </p></li>
<li><p>SAMP_NUM_COEFF (1-20): Sample Numerator Coefficients. Twenty coefficients for the polynomial in the Numerator of the cn equation. (space separated) </p></li>
<li><p>SAMP_DEN_COEFF (1-20): Sample Denominator Coefficients. Twenty coefficients for the polynomial in the Denominator of the cn equation. (space separated) </p></li>
</ul>
</p>
<p>The transformer normally maps from pixel/line/height to long/lat/height space as a forward transformation though in RPC terms that would be considered an inverse transformation (and is solved by iterative approximation using long/lat/height to pixel/line transformations). The default direction can be reversed by passing bReversed=TRUE.</p>
<p>The iterative solution of pixel/line to lat/long/height is currently run for up to 10 iterations or until the apparent error is less than dfPixErrThreshold pixels. Passing zero will not avoid all error, but will cause the operation to run for the maximum number of iterations.</p>
<p>Starting with GDAL 2.1, debugging of the RPC inverse transformer can be done by setting the RPC_INVERSE_VERBOSE configuration option to YES (in which case extra debug information will be displayed in the “RPC” debug category, so requiring CPL_DEBUG to be also set) and/or by setting RPC_INVERSE_LOG to a filename that will contain the content of iterations (this last option only makes sense when debugging point by point, since each time RPCInverseTransformPoint() is called, the file is rewritten).</p>
<p>Additional options to the transformer can be supplied in papszOptions.</p>
<p>Options:</p>
<p><ul>
<li><p>RPC_HEIGHT: a fixed height offset to be applied to all points passed in. In this situation the Z passed into the transformation function is assumed to be height above ground, and the RPC_HEIGHT is assumed to be an average height above sea level for ground in the target scene.</p>
<p></p>
</li>
<li><p>RPC_HEIGHT_SCALE: a factor used to multiply heights above ground. Useful when elevation offsets of the DEM are not expressed in meters.</p>
<p></p>
</li>
<li><p>RPC_DEM: the name of a GDAL dataset (a DEM file typically) used to extract elevation offsets from. In this situation the Z passed into the transformation function is assumed to be height above ground. This option should be used in replacement of RPC_HEIGHT to provide a way of defining a non uniform ground for the target scene</p>
<p></p>
</li>
<li><p>RPC_DEMINTERPOLATION: the DEM interpolation (“near”, “bilinear” or “cubic”). Default is “bilinear”.</p>
<p></p>
</li>
<li><p>RPC_DEM_MISSING_VALUE: value of DEM height that must be used in case the DEM has nodata value at the sampling point, or if its extent does not cover the requested coordinate. When not specified, missing values will cause a failed transform.</p>
<p></p>
</li>
<li><p>RPC_DEM_APPLY_VDATUM_SHIFT: whether the vertical component of a compound SRS for the DEM should be used (when it is present). This is useful so as to be able to transform the “raw” values from the DEM expressed with respect to a geoid to the heights with respect to the WGS84 ellipsoid. When this is enabled, the GTIFF_REPORT_COMPD_CS configuration option will be also set temporarily so as to get the vertical information from GeoTIFF files. Defaults to TRUE. (GDAL &gt;= 2.1.0)</p>
<p></p>
</li>
<li><p>RPC_PIXEL_ERROR_THRESHOLD: overrides the dfPixErrThreshold parameter, ie the error (measured in pixels) allowed in the iterative solution of pixel/line to lat/long computations (the other way is always exact given the equations). (GDAL &gt;= 2.1.0)</p>
<p></p>
</li>
<li><p>RPC_MAX_ITERATIONS: maximum number of iterations allowed in the iterative solution of pixel/line to lat/long computations. Default value is 10 in the absence of a DEM, or 20 if there is a DEM. (GDAL &gt;= 2.1.0)</p>
<p></p>
</li>
<li><p>RPC_FOOTPRINT: WKT or GeoJSON polygon (in long / lat coordinate space) with a validity footprint for the RPC. Any coordinate transformation that goes from or arrive outside this footprint will be considered invalid. This is useful in situations where the RPC values become highly unstable outside of the area on which they have been computed for, potentially leading to undesirable “echoes” / false positives. This requires GDAL to be built against GEOS.</p>
<p></p>
</li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>transformer callback data (deallocate with GDALDestroyTransformer()). </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psRPCInfo</span></code>: Definition of the RPC parameters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bReversed</span></code>: If true “forward” transformation will be lat/long to pixel/line instead of the normal pixel/line to lat/long.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfPixErrThreshold</span></code>: the error (measured in pixels) allowed in the iterative solution of pixel/line to lat/long computations (the other way is always exact given the equations). Starting with GDAL 2.1, this may also be set through the RPC_PIXEL_ERROR_THRESHOLD transformer option. If a negative or null value is provided, then this defaults to 0.1 pixel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: Other transformer options (i.e. RPC_HEIGHT=z).</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALDestroyRPCTransformerPv">
<span id="_CPPv325GDALDestroyRPCTransformerPv"></span><span id="_CPPv225GDALDestroyRPCTransformerPv"></span><span id="GDALDestroyRPCTransformer__voidP"></span><span class="target" id="gdal__alg_8h_1ad63aa70d17c44424eb17ee550e5f4c8e"></span>void <code class="descname">GDALDestroyRPCTransformer</code><span class="sig-paren">(</span>void *<em>pTransformArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALDestroyRPCTransformerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy RPC tranformer. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416GDALRPCTransformPviiPdPdPdPi">
<span id="_CPPv316GDALRPCTransformPviiPdPdPdPi"></span><span id="_CPPv216GDALRPCTransformPviiPdPdPdPi"></span><span id="GDALRPCTransform__voidP.i.i.doubleP.doubleP.doubleP.iP"></span><span class="target" id="gdal__alg_8h_1a60b22697860cbdf1fe6f93e57c22bc7c"></span>int <code class="descname">GDALRPCTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, int <em>bDstToSrc</em>, int <em>nPointCount</em>, double *<em>x</em>, double *<em>y</em>, double *<em>z</em>, int *<em>panSuccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416GDALRPCTransformPviiPdPdPdPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>RPC transform. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427GDALCreateGeoLocTransformer12GDALDatasetHPPci">
<span id="_CPPv327GDALCreateGeoLocTransformer12GDALDatasetHPPci"></span><span id="_CPPv227GDALCreateGeoLocTransformer12GDALDatasetHPPci"></span><span id="GDALCreateGeoLocTransformer__GDALDatasetH.cPP.i"></span><span class="target" id="gdal__alg_8h_1ab1418a2caa399b1278516d0a3d99543b"></span>void *<code class="descname">GDALCreateGeoLocTransformer</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hBaseDS</em>, char **<em>papszGeolocationInfo</em>, int <em>bReversed</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427GDALCreateGeoLocTransformer12GDALDatasetHPPci" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create GeoLocation transformer. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428GDALDestroyGeoLocTransformerPv">
<span id="_CPPv328GDALDestroyGeoLocTransformerPv"></span><span id="_CPPv228GDALDestroyGeoLocTransformerPv"></span><span id="GDALDestroyGeoLocTransformer__voidP"></span><span class="target" id="gdal__alg_8h_1a1d06a68980e94b6ccb6397046a97e6bf"></span>void <code class="descname">GDALDestroyGeoLocTransformer</code><span class="sig-paren">(</span>void *<em>pTransformArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428GDALDestroyGeoLocTransformerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy GeoLocation transformer. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419GDALGeoLocTransformPviiPdPdPdPi">
<span id="_CPPv319GDALGeoLocTransformPviiPdPdPdPi"></span><span id="_CPPv219GDALGeoLocTransformPviiPdPdPdPi"></span><span id="GDALGeoLocTransform__voidP.i.i.doubleP.doubleP.doubleP.iP"></span><span class="target" id="gdal__alg_8h_1af2a535116fb06e20871fe52c0efb6a77"></span>int <code class="descname">GDALGeoLocTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, int <em>bDstToSrc</em>, int <em>nPointCount</em>, double *<em>x</em>, double *<em>y</em>, double *<em>z</em>, int *<em>panSuccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GDALGeoLocTransformPviiPdPdPdPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Use GeoLocation transformer. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427GDALCreateApproxTransformer19GDALTransformerFuncPvd">
<span id="_CPPv327GDALCreateApproxTransformer19GDALTransformerFuncPvd"></span><span id="_CPPv227GDALCreateApproxTransformer19GDALTransformerFuncPvd"></span><span id="GDALCreateApproxTransformer__GDALTransformerFunc.voidP.double"></span><span class="target" id="gdal__alg_8h_1a4ec403b75384f0a71130eb009078426f"></span>void *<code class="descname">GDALCreateApproxTransformer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnRawTransformer</em>, void *<em>pRawTransformerArg</em>, double <em>dfMaxError</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427GDALCreateApproxTransformer19GDALTransformerFuncPvd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an approximating transformer. </p>
<p>This function creates a context for an approximated transformer. Basically a high precision transformer is supplied as input and internally linear approximations are computed to generate results to within a defined precision.</p>
<p>The approximation is actually done at the point where <a class="reference internal" href="#gdal__alg_8h_1a766ccb23b021d30d86908c08ad8d1668"><span class="std std-ref">GDALApproxTransform()</span></a> calls are made, and depend on the assumption that the roughly linear. The first and last point passed in must be the extreme values and the intermediate values should describe a curve between the end points. The approximator transforms and center using the approximate transformer, and then compares the true middle transformed value to a linear approximation based on the end points. If the error is within the supplied threshold then the end points are used to linearly approximate all the values otherwise the inputs points are split into two smaller sets, and the function recursively called till a sufficiently small set of points if found that the linear approximation is OK, or that all the points are exactly computed.</p>
<p>This function is very suitable for approximating transformation results from output pixel/line space to input coordinates for warpers that operate on one input scanline at a time. Care should be taken using it in other circumstances as little internal validation is done, in order to keep things fast.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>callback pointer suitable for use with <a class="reference internal" href="#gdal__alg_8h_1a766ccb23b021d30d86908c08ad8d1668"><span class="std std-ref">GDALApproxTransform()</span></a>. It should be deallocated with <a class="reference internal" href="#gdal__alg_8h_1aa8a1fd0719f5405e856e2103b23f1d9c"><span class="std std-ref">GDALDestroyApproxTransformer()</span></a>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pfnBaseTransformer</span></code>: the high precision transformer which should be approximated. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pBaseTransformArg</span></code>: the callback argument for the high precision transformer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxError</span></code>: the maximum cartesian error in the “output” space that is to be accepted in the linear approximation.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv439GDALApproxTransformerOwnsSubtransformerPvi">
<span id="_CPPv339GDALApproxTransformerOwnsSubtransformerPvi"></span><span id="_CPPv239GDALApproxTransformerOwnsSubtransformerPvi"></span><span id="GDALApproxTransformerOwnsSubtransformer__voidP.i"></span><span class="target" id="gdal__alg_8h_1a6d60f9a27bad206047e6ef1a75bc7fc0"></span>void <code class="descname">GDALApproxTransformerOwnsSubtransformer</code><span class="sig-paren">(</span>void *<em>pCBData</em>, int <em>bOwnFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv439GDALApproxTransformerOwnsSubtransformerPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set bOwnSubtransformer flag. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428GDALDestroyApproxTransformerPv">
<span id="_CPPv328GDALDestroyApproxTransformerPv"></span><span id="_CPPv228GDALDestroyApproxTransformerPv"></span><span id="GDALDestroyApproxTransformer__voidP"></span><span class="target" id="gdal__alg_8h_1aa8a1fd0719f5405e856e2103b23f1d9c"></span>void <code class="descname">GDALDestroyApproxTransformer</code><span class="sig-paren">(</span>void *<em>pApproxArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428GDALDestroyApproxTransformerPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cleanup approximate transformer. </p>
<p>Deallocates the resources allocated by <a class="reference internal" href="#gdal__alg_8h_1a4ec403b75384f0a71130eb009078426f"><span class="std std-ref">GDALCreateApproxTransformer()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pCBData</span></code>: callback data originally returned by <a class="reference internal" href="#gdal__alg_8h_1a4ec403b75384f0a71130eb009078426f"><span class="std std-ref">GDALCreateApproxTransformer()</span></a>. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419GDALApproxTransformPviiPdPdPdPi">
<span id="_CPPv319GDALApproxTransformPviiPdPdPdPi"></span><span id="_CPPv219GDALApproxTransformPviiPdPdPdPi"></span><span id="GDALApproxTransform__voidP.i.i.doubleP.doubleP.doubleP.iP"></span><span class="target" id="gdal__alg_8h_1a766ccb23b021d30d86908c08ad8d1668"></span>int <code class="descname">GDALApproxTransform</code><span class="sig-paren">(</span>void *<em>pTransformArg</em>, int <em>bDstToSrc</em>, int <em>nPointCount</em>, double *<em>x</em>, double *<em>y</em>, double *<em>z</em>, int *<em>panSuccess</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GDALApproxTransformPviiPdPdPdPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform approximate transformation. </p>
<p>Actually performs the approximate transformation described in <a class="reference internal" href="#gdal__alg_8h_1a4ec403b75384f0a71130eb009078426f"><span class="std std-ref">GDALCreateApproxTransformer()</span></a>. This function matches the <a class="reference internal" href="#gdal__alg_8h_1aaede67ca444a06f0a6fed538e05d2220"><span class="std std-ref">GDALTransformerFunc()</span></a> signature. Details of the arguments are described there. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419GDALSimpleImageWarp12GDALDatasetH12GDALDatasetHiPi19GDALTransformerFuncPv16GDALProgressFuncPvPPc">
<span id="_CPPv319GDALSimpleImageWarp12GDALDatasetH12GDALDatasetHiPi19GDALTransformerFuncPv16GDALProgressFuncPvPPc"></span><span id="_CPPv219GDALSimpleImageWarp12GDALDatasetH12GDALDatasetHiPi19GDALTransformerFuncPv16GDALProgressFuncPvPPc"></span><span id="GDALSimpleImageWarp__GDALDatasetH.GDALDatasetH.i.iP.GDALTransformerFunc.voidP.GDALProgressFunc.voidP.cPP"></span><span class="target" id="gdal__alg_8h_1ae15910acb317cef94f3fd49dca6e4bab"></span>int <code class="descname">GDALSimpleImageWarp</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hSrcDS</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hDstDS</em>, int <em>nBandCount</em>, int *<em>panBandList</em>, <a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnTransform</em>, void *<em>pTransformArg</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em>, char **<em>papszWarpOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GDALSimpleImageWarp12GDALDatasetH12GDALDatasetHiPi19GDALTransformerFuncPv16GDALProgressFuncPvPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform simple image warp. </p>
<p>Copies an image from a source dataset to a destination dataset applying an application defined transformation. This algorithm is called simple because it lacks many options such as resampling kernels (other than nearest neighbour), support for data types other than 8bit, and the ability to warp images without holding the entire source and destination image in memory.</p>
<p>The following option(s) may be passed in papszWarpOptions. <ul class="simple">
<li><p>“INIT=v[,v…]”: This option indicates that the output dataset should be initialized to the indicated value in any area valid data is not written. Distinct values may be listed for each band separated by columns. </p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if the operation completes, or FALSE if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcDS</span></code>: the source image dataset. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hDstDS</span></code>: the destination image dataset. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBandCount</span></code>: the number of bands to be warped. If zero, all bands will be processed. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panBandList</span></code>: the list of bands to translate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnTransform</span></code>: the transformation function to call. See <a class="reference internal" href="#gdal__alg_8h_1aaede67ca444a06f0a6fed538e05d2220"><span class="std std-ref">GDALTransformerFunc()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the callback handle to pass to pfnTransform. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: the function used to report progress. See GDALProgressFunc(). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: the callback handle to pass to pfnProgress. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszWarpOptions</span></code>: additional options controlling the warp.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423GDALSuggestedWarpOutput12GDALDatasetH19GDALTransformerFuncPvPdPiPi">
<span id="_CPPv323GDALSuggestedWarpOutput12GDALDatasetH19GDALTransformerFuncPvPdPiPi"></span><span id="_CPPv223GDALSuggestedWarpOutput12GDALDatasetH19GDALTransformerFuncPvPdPiPi"></span><span id="GDALSuggestedWarpOutput__GDALDatasetH.GDALTransformerFunc.voidP.doubleP.iP.iP"></span><span class="target" id="gdal__alg_8h_1a816819e7495bfce06dbd110f7c57af65"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALSuggestedWarpOutput</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hSrcDS</em>, <a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnTransformer</em>, void *<em>pTransformArg</em>, double *<em>padfGeoTransformOut</em>, int *<em>pnPixels</em>, int *<em>pnLines</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423GDALSuggestedWarpOutput12GDALDatasetH19GDALTransformerFuncPvPdPiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suggest output file size. </p>
<p>This function is used to suggest the size, and georeferenced extents appropriate given the indicated transformation and input file. It walks the edges of the input file (approximately 20 sample points along each edge) transforming into output coordinates in order to get an extents box.</p>
<p>Then a resolution is computed with the intent that the length of the distance from the top left corner of the output imagery to the bottom right corner would represent the same number of pixels as in the source image. Note that if the image is somewhat rotated the diagonal taken isn’t of the whole output bounding rectangle, but instead of the locations where the top/left and bottom/right corners transform. The output pixel size is always square. This is intended to approximately preserve the resolution of the input data in the output file.</p>
<p>The values returned in padfGeoTransformOut, pnPixels and pnLines are the suggested number of pixels and lines for the output file, and the geotransform relating those pixels to the output georeferenced coordinates.</p>
<p>The trickiest part of using the function is ensuring that the transformer created is from source file pixel/line coordinates to output file georeferenced coordinates. This can be accomplished with <a class="reference internal" href="#gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"><span class="std std-ref">GDALCreateGenImgProjTransformer()</span></a> by passing a NULL for the hDstDS.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None if successful or CE_Failure otherwise. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcDS</span></code>: the input image (it is assumed the whole input images is being transformed). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnTransformer</span></code>: the transformer function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the callback data for the transformer function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfGeoTransformOut</span></code>: the array of six doubles in which the suggested geotransform is returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnPixels</span></code>: int in which the suggest pixel width of output is returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnLines</span></code>: int in which the suggest pixel height of output is returned.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424GDALSuggestedWarpOutput212GDALDatasetH19GDALTransformerFuncPvPdPiPiPdi">
<span id="_CPPv324GDALSuggestedWarpOutput212GDALDatasetH19GDALTransformerFuncPvPdPiPiPdi"></span><span id="_CPPv224GDALSuggestedWarpOutput212GDALDatasetH19GDALTransformerFuncPvPdPiPiPdi"></span><span id="GDALSuggestedWarpOutput2__GDALDatasetH.GDALTransformerFunc.voidP.doubleP.iP.iP.doubleP.i"></span><span class="target" id="gdal__alg_8h_1a8ae26881b86e42ff958a8e81c4976fb3"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALSuggestedWarpOutput2</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hSrcDS</em>, <a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnTransformer</em>, void *<em>pTransformArg</em>, double *<em>padfGeoTransformOut</em>, int *<em>pnPixels</em>, int *<em>pnLines</em>, double *<em>padfExtents</em>, int <em>nOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424GDALSuggestedWarpOutput212GDALDatasetH19GDALTransformerFuncPvPdPiPiPdi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suggest output file size. </p>
<p>This function is used to suggest the size, and georeferenced extents appropriate given the indicated transformation and input file. It walks the edges of the input file (approximately 20 sample points along each edge) transforming into output coordinates in order to get an extents box.</p>
<p>Then a resolution is computed with the intent that the length of the distance from the top left corner of the output imagery to the bottom right corner would represent the same number of pixels as in the source image. Note that if the image is somewhat rotated the diagonal taken isn’t of the whole output bounding rectangle, but instead of the locations where the top/left and bottom/right corners transform. The output pixel size is always square. This is intended to approximately preserve the resolution of the input data in the output file.</p>
<p>The values returned in padfGeoTransformOut, pnPixels and pnLines are the suggested number of pixels and lines for the output file, and the geotransform relating those pixels to the output georeferenced coordinates.</p>
<p>The trickiest part of using the function is ensuring that the transformer created is from source file pixel/line coordinates to output file georeferenced coordinates. This can be accomplished with <a class="reference internal" href="#gdal__alg_8h_1a7671696d085085a0bfba3c3df9ffcc0a"><span class="std std-ref">GDALCreateGenImgProjTransformer()</span></a> by passing a NULL for the hDstDS.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None if successful or CE_Failure otherwise. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcDS</span></code>: the input image (it is assumed the whole input images is being transformed). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnTransformer</span></code>: the transformer function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the callback data for the transformer function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfGeoTransformOut</span></code>: the array of six doubles in which the suggested geotransform is returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnPixels</span></code>: int in which the suggest pixel width of output is returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pnLines</span></code>: int in which the suggest pixel height of output is returned. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfExtent</span></code>: Four entry array to return extents as (xmin, ymin, xmax, ymax). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nOptions</span></code>: Options, currently always zero.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALTransformGeolocations15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH19GDALTransformerFuncPv16GDALProgressFuncPvPPc">
<span id="_CPPv325GDALTransformGeolocations15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH19GDALTransformerFuncPv16GDALProgressFuncPvPPc"></span><span id="_CPPv225GDALTransformGeolocations15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH19GDALTransformerFuncPv16GDALProgressFuncPvPPc"></span><span id="GDALTransformGeolocations__GDALRasterBandH.GDALRasterBandH.GDALRasterBandH.GDALTransformerFunc.voidP.GDALProgressFunc.voidP.cPP"></span><span class="target" id="gdal__alg_8h_1a89ce288fe21fe395fc93c0026419f494"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALTransformGeolocations</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hXBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hYBand</em>, <a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hZBand</em>, <a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnTransformer</em>, void *<em>pTransformArg</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em>, char **<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALTransformGeolocations15GDALRasterBandH15GDALRasterBandH15GDALRasterBandH19GDALTransformerFuncPv16GDALProgressFuncPvPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transform locations held in bands. </p>
<p>The X/Y and possibly Z values in the identified bands are transformed using a spatial transformer. The changes values are written back to the source bands so they need to updatable.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hXBand</span></code>: the band containing the X locations (usually long/easting). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hYBand</span></code>: the band containing the Y locations (usually lat/northing). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hZBand</span></code>: the band containing the Z locations (may be NULL). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnTransformer</span></code>: the transformer function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: the callback data for the transformer function. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback argument passed to pfnProgress. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: list of name/value options - none currently supported.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414GDAL_CG_Createiiiddd17GDALContourWriterPv">
<span id="_CPPv314GDAL_CG_Createiiiddd17GDALContourWriterPv"></span><span id="_CPPv214GDAL_CG_Createiiiddd17GDALContourWriterPv"></span><span id="GDAL_CG_Create__i.i.i.double.double.double.GDALContourWriter.voidP"></span><span class="target" id="gdal__alg_8h_1a11f8f668cbacea097c06cece3ef522ef"></span><a class="reference internal" href="#_CPPv421GDALContourGeneratorH" title="GDALContourGeneratorH">GDALContourGeneratorH</a> <code class="descname">GDAL_CG_Create</code><span class="sig-paren">(</span>int <em>nWidth</em>, int <em>nHeight</em>, int <em>bNoDataSet</em>, double <em>dfNoDataValue</em>, double <em>dfContourInterval</em>, double <em>dfContourBase</em>, <a class="reference internal" href="#_CPPv417GDALContourWriter" title="GDALContourWriter">GDALContourWriter</a> <em>pfnWriter</em>, void *<em>pCBData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414GDAL_CG_Createiiiddd17GDALContourWriterPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create contour generator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416GDAL_CG_FeedLine21GDALContourGeneratorHPd">
<span id="_CPPv316GDAL_CG_FeedLine21GDALContourGeneratorHPd"></span><span id="_CPPv216GDAL_CG_FeedLine21GDALContourGeneratorHPd"></span><span id="GDAL_CG_FeedLine__GDALContourGeneratorH.doubleP"></span><span class="target" id="gdal__alg_8h_1a979fe84abd948839e911202daf0136e3"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDAL_CG_FeedLine</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv421GDALContourGeneratorH" title="GDALContourGeneratorH">GDALContourGeneratorH</a> <em>hCG</em>, double *<em>padfScanline</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416GDAL_CG_FeedLine21GDALContourGeneratorHPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Feed a line to the contour generator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415GDAL_CG_Destroy21GDALContourGeneratorH">
<span id="_CPPv315GDAL_CG_Destroy21GDALContourGeneratorH"></span><span id="_CPPv215GDAL_CG_Destroy21GDALContourGeneratorH"></span><span id="GDAL_CG_Destroy__GDALContourGeneratorH"></span><span class="target" id="gdal__alg_8h_1a662f0efbbd5fbe4cc01338272ab84c9e"></span>void <code class="descname">GDAL_CG_Destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv421GDALContourGeneratorH" title="GDALContourGeneratorH">GDALContourGeneratorH</a> <em>hCG</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415GDAL_CG_Destroy21GDALContourGeneratorH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy contour generator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419GDALContourGenerate15GDALRasterBandHddiPdidPvii16GDALProgressFuncPv">
<span id="_CPPv319GDALContourGenerate15GDALRasterBandHddiPdidPvii16GDALProgressFuncPv"></span><span id="_CPPv219GDALContourGenerate15GDALRasterBandHddiPdidPvii16GDALProgressFuncPv"></span><span id="GDALContourGenerate__GDALRasterBandH.double.double.i.doubleP.i.double.voidP.i.i.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1aceaf98ad40f159cbfb626988c054c085"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALContourGenerate</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hBand</em>, double <em>dfContourInterval</em>, double <em>dfContourBase</em>, int <em>nFixedLevelCount</em>, double *<em>padfFixedLevels</em>, int <em>bUseNoData</em>, double <em>dfNoDataValue</em>, void *<em>hLayer</em>, int <em>iIDField</em>, int <em>iElevField</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GDALContourGenerate15GDALRasterBandHddiPdidPvii16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create vector contours from raster DEM. </p>
<p>This function is kept for compatibility reason and will call the new variant GDALContourGenerateEx that is more extensible and provide more options.</p>
<p>Details about the algorithm are also given in the documentation of the new GDALContourenerateEx function.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if an error occurs. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hBand</span></code>: The band to read raster data from. The whole band will be processed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfContourInterval</span></code>: The elevation interval between contours generated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfContourBase</span></code>: The “base” relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, … the ContourBase would be 5.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFixedLevelCount</span></code>: The number of fixed levels. If this is greater than zero, then fixed levels will be used, and ContourInterval and ContourBase are ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfFixedLevels</span></code>: The list of fixed contour levels at which contours should be generated. It will contain FixedLevelCount entries, and may be NULL if fixed levels are disabled (FixedLevelCount = 0).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bUseNoData</span></code>: If TRUE the dfNoDataValue will be used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfNoDataValue</span></code>: The value to use as a “nodata” value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: The layer to which new contour vectors will be written. Each contour will have a LINESTRING geometry attached to it. This is really of type OGRLayerH, but void * is used to avoid pulling the ogr_api.h file in here.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iIDField</span></code>: If not -1 this will be used as a field index to indicate where a unique id should be written for each feature (contour) written.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iElevField</span></code>: If not -1 this will be used as a field index to indicate where the elevation value of the contour should be written.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: The callback data for the pfnProgress function.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421GDALContourGenerateEx15GDALRasterBandHPv12CSLConstList16GDALProgressFuncPv">
<span id="_CPPv321GDALContourGenerateEx15GDALRasterBandHPv12CSLConstList16GDALProgressFuncPv"></span><span id="_CPPv221GDALContourGenerateEx15GDALRasterBandHPv12CSLConstList16GDALProgressFuncPv"></span><span id="GDALContourGenerateEx__GDALRasterBandH.voidP.CSLConstList.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a03b3ec0026fe8b23d85c7c4d920613d9"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALContourGenerateEx</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hBand</em>, void *<em>hLayer</em>, <a class="reference internal" href="cpl.html#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>options</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421GDALContourGenerateEx15GDALRasterBandHPv12CSLConstList16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create vector contours from raster DEM. </p>
<p>This algorithm is an implementation of “Marching squares” [1] that will generate contour vectors for the input raster band on the requested set of contour levels. The vector contours are written to the passed in OGR vector layer. Also, a NODATA value may be specified to identify pixels that should not be considered in contour line generation.</p>
<p>The gdal/apps/gdal_contour.cpp mainline can be used as an example of how to use this function.</p>
<p>[1] see <a class="reference external" href="https://en.wikipedia.org/wiki/Marching_squares">https://en.wikipedia.org/wiki/Marching_squares</a></p>
<p>ALGORITHM RULES</p>
<p>For contouring purposes raster pixel values are assumed to represent a point value at the center of the corresponding pixel region. For the purpose of contour generation we virtually connect each pixel center to the values to the left, right, top and bottom. We assume that the pixel value is linearly interpolated between the pixel centers along each line, and determine where (if any) contour lines will appear along these line segments. Then the contour crossings are connected.</p>
<p>This means that contour lines’ nodes will not actually be on pixel edges, but rather along vertical and horizontal lines connecting the pixel centers.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">General</span> <span class="n">Case</span><span class="p">:</span>

      <span class="mi">5</span> <span class="o">|</span>                  <span class="o">|</span> <span class="mi">3</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">----------------</span> <span class="o">+</span> <span class="o">--</span>
        <span class="o">|</span>                  <span class="o">|</span>
        <span class="o">|</span>                  <span class="o">|</span>
        <span class="o">|</span>                  <span class="o">|</span>
        <span class="o">|</span>                  <span class="o">|</span>
     <span class="mi">10</span> <span class="o">+</span>                  <span class="o">|</span>
        <span class="o">|</span>\                 <span class="o">|</span>
        <span class="o">|</span> \                <span class="o">|</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">-+--------------</span> <span class="o">+</span> <span class="o">--</span>
     <span class="mi">12</span> <span class="o">|</span>  <span class="mi">10</span>              <span class="o">|</span> <span class="mi">1</span>

<span class="n">Saddle</span> <span class="n">Point</span><span class="p">:</span>

      <span class="mi">5</span> <span class="o">|</span>                  <span class="o">|</span> <span class="mi">12</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">-------------+--</span> <span class="o">+</span> <span class="o">--</span>
        <span class="o">|</span>               \  <span class="o">|</span>
        <span class="o">|</span>                 \<span class="o">|</span>
        <span class="o">|</span>                  <span class="o">+</span>
        <span class="o">|</span>                  <span class="o">|</span>
        <span class="o">+</span>                  <span class="o">|</span>
        <span class="o">|</span>\                 <span class="o">|</span>
        <span class="o">|</span> \                <span class="o">|</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">-+--------------</span> <span class="o">+</span> <span class="o">--</span>
     <span class="mi">12</span> <span class="o">|</span>                  <span class="o">|</span> <span class="mi">1</span>

<span class="ow">or</span><span class="p">:</span>

      <span class="mi">5</span> <span class="o">|</span>                  <span class="o">|</span> <span class="mi">12</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">-------------+--</span> <span class="o">+</span> <span class="o">--</span>
        <span class="o">|</span>          <span class="n">__</span><span class="o">/</span>     <span class="o">|</span>
        <span class="o">|</span>      <span class="n">___</span><span class="o">/</span>        <span class="o">|</span>
        <span class="o">|</span>  <span class="n">___</span><span class="o">/</span>          <span class="n">__</span><span class="o">+</span>
        <span class="o">|</span> <span class="o">/</span>           <span class="n">__</span><span class="o">/</span>  <span class="o">|</span>
        <span class="o">+</span><span class="s1">&#39;         __/     |</span>
        <span class="o">|</span>       <span class="n">__</span><span class="o">/</span>        <span class="o">|</span>
        <span class="o">|</span>   <span class="p">,</span><span class="n">__</span><span class="o">/</span>           <span class="o">|</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">-+--------------</span> <span class="o">+</span> <span class="o">--</span>
     <span class="mi">12</span> <span class="o">|</span>                  <span class="o">|</span> <span class="mi">1</span>
</pre></div>
</div>
</p>
<p>Nodata:</p>
<p>In the “nodata” case we treat the whole nodata pixel as a no-mans land. We extend the corner pixels near the nodata out to half way and then construct extra lines from those points to the center which is assigned an averaged value from the two nearby points (in this case (12+3+5)/3).</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="mi">5</span> <span class="o">|</span>                  <span class="o">|</span> <span class="mi">3</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">----------------</span> <span class="o">+</span> <span class="o">--</span>
        <span class="o">|</span>                  <span class="o">|</span>
        <span class="o">|</span>                  <span class="o">|</span>
        <span class="o">|</span>      <span class="mf">6.7</span>         <span class="o">|</span>
        <span class="o">|</span>        <span class="o">+---------+</span> <span class="mi">3</span>
     <span class="mi">10</span> <span class="o">+</span><span class="n">___</span>     <span class="o">|</span>
        <span class="o">|</span>   \<span class="n">____</span><span class="o">+</span> <span class="mi">10</span>
        <span class="o">|</span>        <span class="o">|</span>
     <span class="o">--</span> <span class="o">+</span> <span class="o">-------+</span>        <span class="o">+</span>
     <span class="mi">12</span> <span class="o">|</span>       <span class="mi">12</span>           <span class="p">(</span><span class="n">nodata</span><span class="p">)</span>
</pre></div>
</div>
</p>
<p><p>Options:</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hBand</span></code>: The band to read raster data from. The whole band will be processed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hLayer</span></code>: The layer to which new contour vectors will be written. Each contour will have a LINESTRING geometry attached to it (or POLYGON if POLYGONIZE=YES). This is really of type OGRLayerH, but void * is used to avoid pulling the ogr_api.h file in here.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: The callback data for the pfnProgress function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">options</span></code>: List of options</p></li>
</ul>
</dd>
</dl>
</p>
<p>LEVEL_INTERVAL=f</p>
<p>The elevation interval between contours generated.</p>
<p>LEVEL_BASE=f</p>
<p>The “base” relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, … the LEVEL_BASE would be 5.</p>
<p>LEVEL_EXP_BASE=f</p>
<p>If greater than 0, contour levels are generated on an exponential scale. Levels will then be generated by LEVEL_EXP_BASE^k where k is a positive integer.</p>
<p>FIXED_LEVELS=f[,f]*</p>
<p>The list of fixed contour levels at which contours should be generated. This option has precedence on LEVEL_INTERVAL</p>
<p>NODATA=f</p>
<p>The value to use as a “nodata” value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.</p>
<p>ID_FIELD=d</p>
<p>This will be used as a field index to indicate where a unique id should be written for each feature (contour) written.</p>
<p>ELEV_FIELD=d</p>
<p>This will be used as a field index to indicate where the elevation value of the contour should be written. Only used in line contouring mode.</p>
<p>ELEV_FIELD_MIN=d</p>
<p>This will be used as a field index to indicate where the minimum elevation value of the polygon contour should be written. Only used in polygonal contouring mode.</p>
<p>ELEV_FIELD_MAX=d</p>
<p>This will be used as a field index to indicate where the maximum elevation value of the polygon contour should be written. Only used in polygonal contouring mode.</p>
<p>POLYGONIZE=YES|NO</p>
<p>If YES, contour polygons will be created, rather than polygon lines.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if an error occurs. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420GDALViewshedGenerate15GDALRasterBandHPKcPKc12CSLConstListddddddddd16GDALViewshedModed16GDALProgressFuncPv22GDALViewshedOutputType12CSLConstList">
<span id="_CPPv320GDALViewshedGenerate15GDALRasterBandHPKcPKc12CSLConstListddddddddd16GDALViewshedModed16GDALProgressFuncPv22GDALViewshedOutputType12CSLConstList"></span><span id="_CPPv220GDALViewshedGenerate15GDALRasterBandHPKcPKc12CSLConstListddddddddd16GDALViewshedModed16GDALProgressFuncPv22GDALViewshedOutputType12CSLConstList"></span><span id="GDALViewshedGenerate__GDALRasterBandH.cCP.cCP.CSLConstList.double.double.double.double.double.double.double.double.double.GDALViewshedMode.double.GDALProgressFunc.voidP.GDALViewshedOutputType.CSLConstList"></span><span class="target" id="gdal__alg_8h_1a95f01fd3f2e027e04f7b4f964c5fc3fb"></span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <code class="descname">GDALViewshedGenerate</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv415GDALRasterBandH" title="GDALRasterBandH">GDALRasterBandH</a> <em>hBand</em>, <em class="property">const</em> char *<em>pszDriverName</em>, <em class="property">const</em> char *<em>pszTargetRasterName</em>, <a class="reference internal" href="cpl.html#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszCreationOptions</em>, double <em>dfObserverX</em>, double <em>dfObserverY</em>, double <em>dfObserverHeight</em>, double <em>dfTargetHeight</em>, double <em>dfVisibleVal</em>, double <em>dfInvisibleVal</em>, double <em>dfOutOfRangeVal</em>, double <em>dfNoDataVal</em>, double <em>dfCurvCoeff</em>, <a class="reference internal" href="#_CPPv416GDALViewshedMode" title="GDALViewshedMode">GDALViewshedMode</a> <em>eMode</em>, double <em>dfMaxDistance</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em>, <a class="reference internal" href="#_CPPv422GDALViewshedOutputType" title="GDALViewshedOutputType">GDALViewshedOutputType</a> <em>heightMode</em>, <a class="reference internal" href="cpl.html#_CPPv412CSLConstList" title="CSLConstList">CSLConstList</a> <em>papszExtraOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420GDALViewshedGenerate15GDALRasterBandHPKcPKc12CSLConstListddddddddd16GDALViewshedModed16GDALProgressFuncPv22GDALViewshedOutputType12CSLConstList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create viewshed from raster DEM. </p>
<p>This algorithm will generate a viewshed raster from an input DEM raster by using a modified algorithm of “Generating Viewsheds without Using Sightlines” published at <a class="reference external" href="https://www.asprs.org/wp-content/uploads/pers/2000journal/january/2000_jan_87-90.pdf">https://www.asprs.org/wp-content/uploads/pers/2000journal/january/2000_jan_87-90.pdf</a> This appoach provides a relatively fast calculation, since the output raster is generated in a single scan. The gdal/apps/gdal_viewshed.cpp mainline can be used as an example of how to use this function. The output raster will be of type Byte or Float64.</p>
<p><p>GVOT_NORMAL returns a raster of type Byte containing visible locations.</p>
<dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The algorithm as implemented currently will only output meaningful results if the georeferencing is in a projected coordinate reference system.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hBand</span></code>: The band to read the DEM data from. Only the part of the raster within the specified maxdistance around the observer point is processed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDriverName</span></code>: Driver name (GTiff if set to NULL)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszTargetRasterName</span></code>: The name of the target raster to be generated. Must not be NULL</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszCreationOptions</span></code>: creation options.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfObserverX</span></code>: observer X value (in SRS units)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfObserverY</span></code>: observer Y value (in SRS units)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfObserverHeight</span></code>: The height of the observer above the DEM surface.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfTargetHeight</span></code>: The height of the target above the DEM surface. (default 0)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfVisibleVal</span></code>: pixel value for visibility (default 255)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfInvisibleVal</span></code>: pixel value for invisibility (default 0)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfOutOfRangeVal</span></code>: The value to be set for the cells that fall outside of the range specified by dfMaxDistance.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfNoDataVal</span></code>: The value to be set for the cells that have no data. If set to a negative value, nodata is not set. Note: currently, no special processing of input cells at a nodata value is done (which may result in erroneous results).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfCurvCoeff</span></code>: Coefficient to consider the effect of the curvature and refraction. The height of the DEM is corrected according to the following formula: [Height] -= dfCurvCoeff * [Target Distance]^2 / [Earth Diameter] For the effect of the atmospheric refraction we can use 0.85714‬.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eMode</span></code>: The mode of the viewshed calculation. Possible values GVM_Diagonal = 1, GVM_Edge = 2 (default), GVM_Max = 3, GVM_Min = 4.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfMaxDistance</span></code>: maximum distance range to compute viewshed. It is also used to clamp the extent of the output raster. If set to 0, then unlimited range is assumed, that is to say the computation is performed on the extent of the whole raster.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: The callback data for the pfnProgress function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">heightMode</span></code>: Type of information contained in output raster. Possible values GVOT_NORMAL = 1 (default), GVOT_MIN_TARGET_HEIGHT_FROM_DEM = 2, GVOT_MIN_TARGET_HEIGHT_FROM_GROUND = 3</p></li>
</ul>
</dd>
</dl>
</p>
<p>GVOT_MIN_TARGET_HEIGHT_FROM_DEM and GVOT_MIN_TARGET_HEIGHT_FROM_GROUND will return a raster of type Float64 containing the minimum target height for target to be visible from the DEM surface or ground level respectively. Parameters dfTargetHeight, dfVisibleVal and dfInvisibleVal will be ignored.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>not NULL output dataset on success (to be closed with <a class="reference internal" href="raster_c_api.html#gdal_8h_1a0984222d45a72028fcbbf1f44831ffbc"><span class="std std-ref">GDALClose()</span></a>) or NULL if an error occurs.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 3.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">papszExtraOptions</span></code>: Future extra options. Must be set to NULL currently.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423GDALRasterizeGeometries12GDALDatasetHiPiiP12OGRGeometryH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv">
<span id="_CPPv323GDALRasterizeGeometries12GDALDatasetHiPiiP12OGRGeometryH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv"></span><span id="_CPPv223GDALRasterizeGeometries12GDALDatasetHiPiiP12OGRGeometryH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv"></span><span id="GDALRasterizeGeometries__GDALDatasetH.i.iP.i.OGRGeometryHP.GDALTransformerFunc.voidP.doubleP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a50caf4bc34703f0bcf515ecbe5061a0a"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALRasterizeGeometries</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hDS</em>, int <em>nBandCount</em>, int *<em>panBandList</em>, int <em>nGeomCount</em>, <a class="reference internal" href="vector_c_api.html#_CPPv412OGRGeometryH" title="OGRGeometryH">OGRGeometryH</a> *<em>pahGeometries</em>, <a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnTransformer</em>, void *<em>pTransformArg</em>, double *<em>padfGeomBurnValue</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423GDALRasterizeGeometries12GDALDatasetHiPiiP12OGRGeometryH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Burn geometries into raster. </p>
<p>Rasterize a list of geometric objects into a raster dataset. The geometries are passed as an array of OGRGeometryH handlers.</p>
<p>If the geometries are in the georeferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates on the raster dataset.</p>
<p>The output raster may be of any GDAL supported datatype, though currently internally the burning is done either as GDT_Byte or GDT_Float32. This may be improved in the future. An explicit list of burn values for each geometry for each band must be passed in.</p>
<p>The papszOption list of options currently only supports one option. The “ALL_TOUCHED” option may be enabled by setting it to “TRUE”.</p>
<p><strong>Example</strong><p> GDALRasterizeGeometries rasterize output to MEM Dataset :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">nBufXSize</span>      <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">nBufYSize</span>      <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">nBandCount</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">GDALDataType</span> <span class="n">eType</span> <span class="o">=</span> <span class="n">GDT_Byte</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">nDataTypeSize</span>  <span class="o">=</span> <span class="n">GDALGetDataTypeSizeBytes</span><span class="p">(</span><span class="n">eType</span><span class="p">);</span>

<span class="n">void</span><span class="o">*</span> <span class="n">pData</span> <span class="o">=</span> <span class="n">CPLCalloc</span><span class="p">(</span> <span class="n">nBufXSize</span><span class="o">*</span><span class="n">nBufYSize</span><span class="o">*</span><span class="n">nBandCount</span><span class="p">,</span> <span class="n">nDataTypeSize</span> <span class="p">);</span>
<span class="n">char</span> <span class="n">memdsetpath</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">memdsetpath</span><span class="p">,</span><span class="s2">&quot;MEM:::DATAPOINTER=0x%p,PIXELS=</span><span class="si">%d</span><span class="s2">,LINES=</span><span class="si">%d</span><span class="s2">,&quot;</span>
        <span class="s2">&quot;BANDS=</span><span class="si">%d</span><span class="s2">,DATATYPE=</span><span class="si">%s</span><span class="s2">,PIXELOFFSET=</span><span class="si">%d</span><span class="s2">,LINEOFFSET=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">pData</span><span class="p">,</span><span class="n">nBufXSize</span><span class="p">,</span><span class="n">nBufYSize</span><span class="p">,</span><span class="n">nBandCount</span><span class="p">,</span><span class="n">GDALGetDataTypeName</span><span class="p">(</span><span class="n">eType</span><span class="p">),</span>
        <span class="n">nBandCount</span><span class="o">*</span><span class="n">nDataTypeSize</span><span class="p">,</span> <span class="n">nBufXSize</span><span class="o">*</span><span class="n">nBandCount</span><span class="o">*</span><span class="n">nDataTypeSize</span> <span class="p">);</span>

 <span class="o">//</span> <span class="n">Open</span> <span class="n">Memory</span> <span class="n">Dataset</span>
 <span class="n">GDALDatasetH</span> <span class="n">hMemDset</span> <span class="o">=</span> <span class="n">GDALOpen</span><span class="p">(</span><span class="n">memdsetpath</span><span class="p">,</span> <span class="n">GA_Update</span><span class="p">);</span>
 <span class="o">//</span> <span class="ow">or</span> <span class="n">create</span> <span class="n">it</span> <span class="k">as</span> <span class="n">follows</span>
 <span class="o">//</span> <span class="n">GDALDriverH</span> <span class="n">hMemDriver</span> <span class="o">=</span> <span class="n">GDALGetDriverByName</span><span class="p">(</span><span class="s2">&quot;MEM&quot;</span><span class="p">);</span>
 <span class="o">//</span> <span class="n">GDALDatasetH</span> <span class="n">hMemDset</span> <span class="o">=</span> <span class="n">GDALCreate</span><span class="p">(</span><span class="n">hMemDriver</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">nBufXSize</span><span class="p">,</span> <span class="n">nBufYSize</span><span class="p">,</span> <span class="n">nBandCount</span><span class="p">,</span> <span class="n">eType</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

 <span class="n">double</span> <span class="n">adfGeoTransform</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
 <span class="o">//</span> <span class="n">Assign</span> <span class="n">GeoTransform</span> <span class="n">parameters</span><span class="p">,</span><span class="n">Omitted</span> <span class="n">here</span><span class="o">.</span>

 <span class="n">GDALSetGeoTransform</span><span class="p">(</span><span class="n">hMemDset</span><span class="p">,</span><span class="n">adfGeoTransform</span><span class="p">);</span>
 <span class="n">GDALSetProjection</span><span class="p">(</span><span class="n">hMemDset</span><span class="p">,</span><span class="n">pszProjection</span><span class="p">);</span> <span class="o">//</span> <span class="n">Can</span> <span class="ow">not</span>
 
 <span class="o">//</span> <span class="n">Do</span> <span class="n">something</span> <span class="o">...</span>
 <span class="o">//</span> <span class="n">Need</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">OGRGeometry</span> <span class="n">objects</span><span class="p">,</span><span class="n">The</span> <span class="n">assumption</span> <span class="n">here</span> <span class="ow">is</span> <span class="n">pahGeoms</span>
 
 <span class="nb">int</span> <span class="n">bandList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
 <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">geomBurnValue</span><span class="p">(</span><span class="n">nGeomCount</span><span class="o">*</span><span class="n">nBandCount</span><span class="p">,</span><span class="mf">255.0</span><span class="p">);</span>
 <span class="n">CPLErr</span> <span class="n">err</span> <span class="o">=</span> <span class="n">GDALRasterizeGeometries</span><span class="p">(</span><span class="n">hMemDset</span><span class="p">,</span> <span class="n">nBandCount</span><span class="p">,</span> <span class="n">bandList</span><span class="p">,</span>
                         <span class="n">nGeomCount</span><span class="p">,</span> <span class="n">pahGeoms</span><span class="p">,</span> <span class="n">pfnTransformer</span><span class="p">,</span> <span class="n">pTransformArg</span><span class="p">,</span>
                         <span class="n">geomBurnValue</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">papszOptions</span><span class="p">,</span>
                         <span class="n">pfnProgress</span><span class="p">,</span> <span class="n">pProgressArg</span><span class="p">);</span>
 <span class="k">if</span><span class="p">(</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">CE_None</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Do</span> <span class="n">something</span> <span class="o">...</span>
 <span class="p">}</span>
 <span class="n">GDALClose</span><span class="p">(</span><span class="n">hMemDset</span><span class="p">);</span>
 <span class="n">CPLFree</span><span class="p">(</span><span class="n">pData</span><span class="p">);</span>
</pre></div>
</div>
 <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure on error.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: output data, must be opened in update mode. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBandCount</span></code>: the number of bands to be updated. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panBandList</span></code>: the list of bands to be updated. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nGeomCount</span></code>: the number of geometries being passed in pahGeometries. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pahGeometries</span></code>: the array of geometries to burn in. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnTransformer</span></code>: transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: callback data for transformer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfGeomBurnValue</span></code>: the array of values to burn into the raster. There should be nBandCount values for each geometry. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: special options controlling rasterization <ul>
<li><p>“ALL_TOUCHED”: May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </p></li>
<li><p>“BURN_VALUE_FROM”: May be set to “Z” to use the Z values of the geometries. dfBurnValue is added to this before burning. Defaults to GDALBurnValueSrc.GBV_UserBurnValue in which case just the dfBurnValue is burned. This is implemented only for points and lines for now. The M value may be supported in the future. </p></li>
<li><p>“MERGE_ALG”: May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </p></li>
<li><p>“CHUNKYSIZE”: The height in lines of the chunk to operate on. The larger the chunk size the less times we need to make a pass through all the shapes. If it is not set or set to zero the default chunk size will be used. Default size will be estimated based on the GDAL cache buffer size using formula: cache_size_bytes/scanline_size_bytes, so the chunk will not exceed the cache. Not used in OPTIM=RASTER mode. </p></li>
</ul>
</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: the progress function to report completion. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback data for progress function.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419GDALRasterizeLayers12GDALDatasetHiPiiP9OGRLayerH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv">
<span id="_CPPv319GDALRasterizeLayers12GDALDatasetHiPiiP9OGRLayerH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv"></span><span id="_CPPv219GDALRasterizeLayers12GDALDatasetHiPiiP9OGRLayerH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv"></span><span id="GDALRasterizeLayers__GDALDatasetH.i.iP.i.OGRLayerHP.GDALTransformerFunc.voidP.doubleP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1adfe5e5d287d6c184aab03acbfa567cb1"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALRasterizeLayers</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hDS</em>, int <em>nBandCount</em>, int *<em>panBandList</em>, int <em>nLayerCount</em>, <a class="reference internal" href="vector_c_api.html#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> *<em>pahLayers</em>, <a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnTransformer</em>, void *<em>pTransformArg</em>, double *<em>padfLayerBurnValues</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GDALRasterizeLayers12GDALDatasetHiPiiP9OGRLayerH19GDALTransformerFuncPvPdPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Burn geometries from the specified list of layers into raster. </p>
<p>Rasterize all the geometric objects from a list of layers into a raster dataset. The layers are passed as an array of OGRLayerH handlers.</p>
<p>If the geometries are in the georeferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates on the raster dataset.</p>
<p>The output raster may be of any GDAL supported datatype, though currently internally the burning is done either as GDT_Byte or GDT_Float32. This may be improved in the future. An explicit list of burn values for each layer for each band must be passed in.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hDS</span></code>: output data, must be opened in update mode. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBandCount</span></code>: the number of bands to be updated. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panBandList</span></code>: the list of bands to be updated. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLayerCount</span></code>: the number of layers being passed in pahLayers array. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pahLayers</span></code>: the array of layers to burn in. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnTransformer</span></code>: transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: callback data for transformer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfLayerBurnValues</span></code>: the array of values to burn into the raster. There should be nBandCount values for each layer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: special options controlling rasterization: <ul>
<li><p>“ATTRIBUTE”: Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </p></li>
<li><p>“CHUNKYSIZE”: The height in lines of the chunk to operate on. The larger the chunk size the less times we need to make a pass through all the shapes. If it is not set or set to zero the default chunk size will be used. Default size will be estimated based on the GDAL cache buffer size using formula: cache_size_bytes/scanline_size_bytes, so the chunk will not exceed the cache. </p></li>
<li><p>“ALL_TOUCHED”: May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </p></li>
<li><p>“BURN_VALUE_FROM”: May be set to “Z” to use the Z values of the geometries. The value from padfLayerBurnValues or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </p></li>
<li><p>“MERGE_ALG”: May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </p></li>
</ul>
</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: the progress function to report completion. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback data for progress function.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422GDALRasterizeLayersBufPvii12GDALDataTypeiiiP9OGRLayerHPKcPd19GDALTransformerFuncPvdPPc16GDALProgressFuncPv">
<span id="_CPPv322GDALRasterizeLayersBufPvii12GDALDataTypeiiiP9OGRLayerHPKcPd19GDALTransformerFuncPvdPPc16GDALProgressFuncPv"></span><span id="_CPPv222GDALRasterizeLayersBufPvii12GDALDataTypeiiiP9OGRLayerHPKcPd19GDALTransformerFuncPvdPPc16GDALProgressFuncPv"></span><span id="GDALRasterizeLayersBuf__voidP.i.i.GDALDataType.i.i.i.OGRLayerHP.cCP.doubleP.GDALTransformerFunc.voidP.double.cPP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1ab791949af233e16c119e4f49ee573cae"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALRasterizeLayersBuf</code><span class="sig-paren">(</span>void *<em>pData</em>, int <em>nBufXSize</em>, int <em>nBufYSize</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDataType" title="GDALDataType">GDALDataType</a> <em>eBufType</em>, int <em>nPixelSpace</em>, int <em>nLineSpace</em>, int <em>nLayerCount</em>, <a class="reference internal" href="vector_c_api.html#_CPPv49OGRLayerH" title="OGRLayerH">OGRLayerH</a> *<em>pahLayers</em>, <em class="property">const</em> char *<em>pszDstProjection</em>, double *<em>padfDstGeoTransform</em>, <a class="reference internal" href="#_CPPv419GDALTransformerFunc" title="GDALTransformerFunc">GDALTransformerFunc</a> <em>pfnTransformer</em>, void *<em>pTransformArg</em>, double <em>dfBurnValue</em>, char **<em>papszOptions</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422GDALRasterizeLayersBufPvii12GDALDataTypeiiiP9OGRLayerHPKcPd19GDALTransformerFuncPvdPPc16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Burn geometries from the specified list of layer into raster. </p>
<p>Rasterize all the geometric objects from a list of layers into supplied raster buffer. The layers are passed as an array of OGRLayerH handlers.</p>
<p>If the geometries are in the georeferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates of the target raster.</p>
<p>The output raster may be of any GDAL supported datatype(non complex).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure on error. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pData</span></code>: pointer to the output data array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBufXSize</span></code>: width of the output data array in pixels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nBufYSize</span></code>: height of the output data array in pixels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eBufType</span></code>: data type of the output data array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPixelSpace</span></code>: The byte offset from the start of one pixel value in pData to the start of the next pixel value within a scanline. If defaulted (0) the size of the datatype eBufType is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLineSpace</span></code>: The byte offset from the start of one scanline in pData to the start of the next. If defaulted the size of the datatype eBufType * nBufXSize is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nLayerCount</span></code>: the number of layers being passed in pahLayers array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pahLayers</span></code>: the array of layers to burn in.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pszDstProjection</span></code>: WKT defining the coordinate system of the target raster.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfDstGeoTransform</span></code>: geotransformation matrix of the target raster.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnTransformer</span></code>: transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pTransformArg</span></code>: callback data for transformer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfBurnValue</span></code>: the value to burn into the raster.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: special options controlling rasterization: <ul>
<li><p>“ATTRIBUTE”: Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </p></li>
<li><p>“ALL_TOUCHED”: May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </p></li>
<li><p>“BURN_VALUE_FROM”: May be set to “Z” to use the Z values of the geometries. dfBurnValue or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </p></li>
<li><p>“MERGE_ALG”: May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </p></li>
</ul>
</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: the progress function to report completion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: callback data for progress function.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414GDALGridCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKddddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv">
<span id="_CPPv314GDALGridCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKddddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv"></span><span id="_CPPv214GDALGridCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKddddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv"></span><span id="GDALGridCreate__GDALGridAlgorithm.voidCP.GUInt32.doubleCP.doubleCP.doubleCP.double.double.double.double.GUInt32.GUInt32.GDALDataType.voidP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a1fdef40bcdbc98eff2328b0d093d3a22"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALGridCreate</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417GDALGridAlgorithm" title="GDALGridAlgorithm">GDALGridAlgorithm</a> <em>eAlgorithm</em>, <em class="property">const</em> void *<em>poOptions</em>, <a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <em>nPoints</em>, <em class="property">const</em> double *<em>padfX</em>, <em class="property">const</em> double *<em>padfY</em>, <em class="property">const</em> double *<em>padfZ</em>, double <em>dfXMin</em>, double <em>dfXMax</em>, double <em>dfYMin</em>, double <em>dfYMax</em>, <a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <em>nXSize</em>, <a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <em>nYSize</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDataType" title="GDALDataType">GDALDataType</a> <em>eType</em>, void *<em>pData</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414GDALGridCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKddddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create regular grid from the scattered data. </p>
<p>This function takes the arrays of X and Y coordinates and corresponding Z values as input and computes regular grid (or call it a raster) from these scattered data. You should supply geometry and extent of the output grid and allocate array sufficient to hold such a grid.</p>
<p>Starting with GDAL 1.10, it is possible to set the GDAL_NUM_THREADS configuration option to parallelize the processing. The value to set is the number of worker threads, or ALL_CPUS to use all the cores/CPUs of the computer (default value).</p>
<p>Starting with GDAL 1.10, on Intel/AMD i386/x86_64 architectures, some gridding methods will be optimized with SSE instructions (provided GDAL has been compiled with such support, and it is available at runtime). Currently, only ‘invdist’ algorithm with default parameters has an optimized implementation. This can provide substantial speed-up, but sometimes at the expense of reduced floating point precision. This can be disabled by setting the GDAL_USE_SSE configuration option to NO. Starting with GDAL 1.11, a further optimized version can use the AVX instruction set. This can be disabled by setting the GDAL_USE_AVX configuration option to NO.</p>
<p>Note: it will be more efficient to use <a class="reference internal" href="#gdal__alg_8h_1ab95ca80bfa63d375c9242f8d10ba946f"><span class="std std-ref">GDALGridContextCreate()</span></a>, <a class="reference internal" href="#gdal__alg_8h_1a7da520568b6aaa37d76396d668f96390"><span class="std std-ref">GDALGridContextProcess()</span></a> and <a class="reference internal" href="#gdal__alg_8h_1a1d2d6dce1e7b14d8a26e03fb52e37286"><span class="std std-ref">GDALGridContextFree()</span></a> when doing repeated gridding operations with the same algorithm, parameters and points, and moving the window in the output grid.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if something goes wrong. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eAlgorithm</span></code>: Gridding method. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poOptions</span></code>: Options to control chosen gridding method. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPoints</span></code>: Number of elements in input arrays. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfX</span></code>: Input array of X coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfY</span></code>: Input array of Y coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfZ</span></code>: Input array of Z values. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfXMin</span></code>: Lowest X border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfXMax</span></code>: Highest X border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfYMin</span></code>: Lowest Y border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfYMax</span></code>: Highest Y border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXSize</span></code>: Number of columns in output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYSize</span></code>: Number of rows in output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Data type of output array. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pData</span></code>: Pointer to array where the computed grid will be stored. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421GDALGridContextCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKdi">
<span id="_CPPv321GDALGridContextCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKdi"></span><span id="_CPPv221GDALGridContextCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKdi"></span><span id="GDALGridContextCreate__GDALGridAlgorithm.voidCP.GUInt32.doubleCP.doubleCP.doubleCP.i"></span><span class="target" id="gdal__alg_8h_1ab95ca80bfa63d375c9242f8d10ba946f"></span><a class="reference internal" href="#_CPPv415GDALGridContext" title="GDALGridContext">GDALGridContext</a> *<code class="descname">GDALGridContextCreate</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417GDALGridAlgorithm" title="GDALGridAlgorithm">GDALGridAlgorithm</a> <em>eAlgorithm</em>, <em class="property">const</em> void *<em>poOptions</em>, <a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <em>nPoints</em>, <em class="property">const</em> double *<em>padfX</em>, <em class="property">const</em> double *<em>padfY</em>, <em class="property">const</em> double *<em>padfZ</em>, int <em>bCallerWillKeepPointArraysAlive</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421GDALGridContextCreate17GDALGridAlgorithmPKv7GUInt32PKdPKdPKdi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a context to do regular gridding from the scattered data. </p>
<p>This function takes the arrays of X and Y coordinates and corresponding Z values as input to prepare computation of regular grid (or call it a raster) from these scattered data.</p>
<p>On Intel/AMD i386/x86_64 architectures, some gridding methods will be optimized with SSE instructions (provided GDAL has been compiled with such support, and it is available at runtime). Currently, only ‘invdist’ algorithm with default parameters has an optimized implementation. This can provide substantial speed-up, but sometimes at the expense of reduced floating point precision. This can be disabled by setting the GDAL_USE_SSE configuration option to NO. A further optimized version can use the AVX instruction set. This can be disabled by setting the GDAL_USE_AVX configuration option to NO.</p>
<p>It is possible to set the GDAL_NUM_THREADS configuration option to parallelize the processing. The value to set is the number of worker threads, or ALL_CPUS to use all the cores/CPUs of the computer (default value).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the context (to be freed with <a class="reference internal" href="#gdal__alg_8h_1a1d2d6dce1e7b14d8a26e03fb52e37286"><span class="std std-ref">GDALGridContextFree()</span></a>) or NULL in case or error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eAlgorithm</span></code>: Gridding method. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poOptions</span></code>: Options to control chosen gridding method. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nPoints</span></code>: Number of elements in input arrays. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfX</span></code>: Input array of X coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfY</span></code>: Input array of Y coordinates. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfZ</span></code>: Input array of Z values. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bCallerWillKeepPointArraysAlive</span></code>: Whether the provided padfX, padfY, padfZ arrays will still be “alive” during the calls to <a class="reference internal" href="#gdal__alg_8h_1a7da520568b6aaa37d76396d668f96390"><span class="std std-ref">GDALGridContextProcess()</span></a>. Setting to TRUE prevent them from being duplicated in the context. If unsure, set to FALSE.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419GDALGridContextFreeP15GDALGridContext">
<span id="_CPPv319GDALGridContextFreeP15GDALGridContext"></span><span id="_CPPv219GDALGridContextFreeP15GDALGridContext"></span><span id="GDALGridContextFree__GDALGridContextP"></span><span class="target" id="gdal__alg_8h_1a1d2d6dce1e7b14d8a26e03fb52e37286"></span>void <code class="descname">GDALGridContextFree</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415GDALGridContext" title="GDALGridContext">GDALGridContext</a> *<em>psContext</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419GDALGridContextFreeP15GDALGridContext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a context used created by <a class="reference internal" href="#gdal__alg_8h_1ab95ca80bfa63d375c9242f8d10ba946f"><span class="std std-ref">GDALGridContextCreate()</span></a> </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psContext</span></code>: the context.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422GDALGridContextProcessP15GDALGridContextdddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv">
<span id="_CPPv322GDALGridContextProcessP15GDALGridContextdddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv"></span><span id="_CPPv222GDALGridContextProcessP15GDALGridContextdddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv"></span><span id="GDALGridContextProcess__GDALGridContextP.double.double.double.double.GUInt32.GUInt32.GDALDataType.voidP.GDALProgressFunc.voidP"></span><span class="target" id="gdal__alg_8h_1a7da520568b6aaa37d76396d668f96390"></span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr">CPLErr</a> <code class="descname">GDALGridContextProcess</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv415GDALGridContext" title="GDALGridContext">GDALGridContext</a> *<em>psContext</em>, double <em>dfXMin</em>, double <em>dfXMax</em>, double <em>dfYMin</em>, double <em>dfYMax</em>, <a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <em>nXSize</em>, <a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <em>nYSize</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDataType" title="GDALDataType">GDALDataType</a> <em>eType</em>, void *<em>pData</em>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc">GDALProgressFunc</a> <em>pfnProgress</em>, void *<em>pProgressArg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422GDALGridContextProcessP15GDALGridContextdddd7GUInt327GUInt3212GDALDataTypePv16GDALProgressFuncPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Do the gridding of a window of a raster. </p>
<p>This function takes the gridding context as input to preprare computation of regular grid (or call it a raster) from these scattered data. You should supply the extent of the output grid and allocate array sufficient to hold such a grid.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>CE_None on success or CE_Failure if something goes wrong.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psContext</span></code>: Gridding context. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfXMin</span></code>: Lowest X border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfXMax</span></code>: Highest X border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfYMin</span></code>: Lowest Y border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfYMax</span></code>: Highest Y border of output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nXSize</span></code>: Number of columns in output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nYSize</span></code>: Number of rows in output grid. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eType</span></code>: Data type of output array. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pData</span></code>: Pointer to array where the computed grid will be stored. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pfnProgress</span></code>: a GDALProgressFunc() compatible callback function for reporting progress or NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pProgressArg</span></code>: argument to be passed to pfnProgress. May be NULL.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALComputeMatchingPoints12GDALDatasetH12GDALDatasetHPPcPi">
<span id="_CPPv325GDALComputeMatchingPoints12GDALDatasetH12GDALDatasetHPPcPi"></span><span id="_CPPv225GDALComputeMatchingPoints12GDALDatasetH12GDALDatasetHPPcPi"></span><span id="GDALComputeMatchingPoints__GDALDatasetH.GDALDatasetH.cPP.iP"></span><span class="target" id="gdal__alg_8h_1aee648e2898ddca419ce0f682fcf99389"></span><a class="reference internal" href="raster_c_api.html#_CPPv48GDAL_GCP" title="GDAL_GCP">GDAL_GCP</a> *<code class="descname">GDALComputeMatchingPoints</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hFirstImage</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hSecondImage</em>, char **<em>papszOptions</em>, int *<em>pnGCPCount</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALComputeMatchingPoints12GDALDatasetH12GDALDatasetHPPcPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GDALComputeMatchingPoints. </p>
<p>TODO document </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420GDALHasTriangulationv">
<span id="_CPPv320GDALHasTriangulationv"></span><span id="_CPPv220GDALHasTriangulationv"></span><span id="GDALHasTriangulation__void"></span><span class="target" id="gdal__alg_8h_1aadb871f9f1bb30353e681c38a83c685a"></span>int <code class="descname">GDALHasTriangulation</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420GDALHasTriangulationv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns if GDAL is built with Delaunay triangulation support. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE if GDAL is built with Delaunay triangulation support.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv431GDALTriangulationCreateDelaunayiPKdPKd">
<span id="_CPPv331GDALTriangulationCreateDelaunayiPKdPKd"></span><span id="_CPPv231GDALTriangulationCreateDelaunayiPKdPKd"></span><span id="GDALTriangulationCreateDelaunay__i.doubleCP.doubleCP"></span><span class="target" id="gdal__alg_8h_1a498205ae5f4f0ec9f43e5c65bb392060"></span><a class="reference internal" href="#_CPPv417GDALTriangulation" title="GDALTriangulation">GDALTriangulation</a> *<code class="descname">GDALTriangulationCreateDelaunay</code><span class="sig-paren">(</span>int <em>nPoints</em>, <em class="property">const</em> double *<em>padfX</em>, <em class="property">const</em> double *<em>padfY</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431GDALTriangulationCreateDelaunayiPKdPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes a Delaunay triangulation of the passed points. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>triangulation that must be freed with <a class="reference internal" href="#gdal__alg_8h_1a1d9ddc2b9ee90b2f9984e020d8f099f6"><span class="std std-ref">GDALTriangulationFree()</span></a>, or NULL in case of error.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nPoints</span></code>: number of points </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfX</span></code>: x coordinates of the points. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfY</span></code>: y coordinates of the points. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv447GDALTriangulationComputeBarycentricCoefficientsP17GDALTriangulationPKdPKd">
<span id="_CPPv347GDALTriangulationComputeBarycentricCoefficientsP17GDALTriangulationPKdPKd"></span><span id="_CPPv247GDALTriangulationComputeBarycentricCoefficientsP17GDALTriangulationPKdPKd"></span><span id="GDALTriangulationComputeBarycentricCoefficients__GDALTriangulationP.doubleCP.doubleCP"></span><span class="target" id="gdal__alg_8h_1a99cb9c1fa87a9054fcfe9f5f45720fa9"></span>int <code class="descname">GDALTriangulationComputeBarycentricCoefficients</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417GDALTriangulation" title="GDALTriangulation">GDALTriangulation</a> *<em>psDT</em>, <em class="property">const</em> double *<em>padfX</em>, <em class="property">const</em> double *<em>padfY</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv447GDALTriangulationComputeBarycentricCoefficientsP17GDALTriangulationPKdPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes barycentric coefficients for each triangles of the triangulation. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE in case of success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psDT</span></code>: triangulation. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfX</span></code>: x coordinates of the points. Must be identical to the one passed to <a class="reference internal" href="#gdal__alg_8h_1a498205ae5f4f0ec9f43e5c65bb392060"><span class="std std-ref">GDALTriangulationCreateDelaunay()</span></a>. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padfY</span></code>: y coordinates of the points. Must be identical to the one passed to <a class="reference internal" href="#gdal__alg_8h_1a498205ae5f4f0ec9f43e5c65bb392060"><span class="std std-ref">GDALTriangulationCreateDelaunay()</span></a>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv446GDALTriangulationComputeBarycentricCoordinatesPK17GDALTriangulationiddPdPdPd">
<span id="_CPPv346GDALTriangulationComputeBarycentricCoordinatesPK17GDALTriangulationiddPdPdPd"></span><span id="_CPPv246GDALTriangulationComputeBarycentricCoordinatesPK17GDALTriangulationiddPdPdPd"></span><span id="GDALTriangulationComputeBarycentricCoordinates__GDALTriangulationCP.i.double.double.doubleP.doubleP.doubleP"></span><span class="target" id="gdal__alg_8h_1a2f846755f21f789d7a41ce2825713ee7"></span>int <code class="descname">GDALTriangulationComputeBarycentricCoordinates</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv417GDALTriangulation" title="GDALTriangulation">GDALTriangulation</a> *<em>psDT</em>, int <em>nFacetIdx</em>, double <em>dfX</em>, double <em>dfY</em>, double *<em>pdfL1</em>, double *<em>pdfL2</em>, double *<em>pdfL3</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv446GDALTriangulationComputeBarycentricCoordinatesPK17GDALTriangulationiddPdPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Computes the barycentric coordinates of a point. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE in case of success.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psDT</span></code>: triangulation. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFacetIdx</span></code>: index of the triangle in the triangulation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: x coordinate of the point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: y coordinate of the point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfL1</span></code>: (output) pointer to the 1st barycentric coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfL2</span></code>: (output) pointer to the 2nd barycentric coordinate. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pdfL3</span></code>: (output) pointer to the 2nd barycentric coordinate.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv436GDALTriangulationFindFacetBruteForcePK17GDALTriangulationddPi">
<span id="_CPPv336GDALTriangulationFindFacetBruteForcePK17GDALTriangulationddPi"></span><span id="_CPPv236GDALTriangulationFindFacetBruteForcePK17GDALTriangulationddPi"></span><span id="GDALTriangulationFindFacetBruteForce__GDALTriangulationCP.double.double.iP"></span><span class="target" id="gdal__alg_8h_1a63207eb23887a93ca97ee218848231f0"></span>int <code class="descname">GDALTriangulationFindFacetBruteForce</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv417GDALTriangulation" title="GDALTriangulation">GDALTriangulation</a> *<em>psDT</em>, double <em>dfX</em>, double <em>dfY</em>, int *<em>panOutputFacetIdx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436GDALTriangulationFindFacetBruteForcePK17GDALTriangulationddPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the index of the triangle that contains the point by iterating over all triangles. </p>
<p>If the function returns FALSE and *panOutputFacetIdx &gt;= 0, then it means the point is outside the hull of the triangulation, and *panOutputFacetIdx is the closest triangle to the point.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>index &gt;= 0 of the triangle in case of success, -1 otherwise.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psDT</span></code>: triangulation. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: x coordinate of the point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: y coordinate of the point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panOutputFacetIdx</span></code>: (output) pointer to the index of the triangle, or -1 in case of failure.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv434GDALTriangulationFindFacetDirectedPK17GDALTriangulationiddPi">
<span id="_CPPv334GDALTriangulationFindFacetDirectedPK17GDALTriangulationiddPi"></span><span id="_CPPv234GDALTriangulationFindFacetDirectedPK17GDALTriangulationiddPi"></span><span id="GDALTriangulationFindFacetDirected__GDALTriangulationCP.i.double.double.iP"></span><span class="target" id="gdal__alg_8h_1af4e3912995c59830c6bfcdf4ec1112fc"></span>int <code class="descname">GDALTriangulationFindFacetDirected</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv417GDALTriangulation" title="GDALTriangulation">GDALTriangulation</a> *<em>psDT</em>, int <em>nFacetIdx</em>, double <em>dfX</em>, double <em>dfY</em>, int *<em>panOutputFacetIdx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434GDALTriangulationFindFacetDirectedPK17GDALTriangulationiddPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the index of the triangle that contains the point by walking in the triangulation. </p>
<p>If the function returns FALSE and *panOutputFacetIdx &gt;= 0, then it means the point is outside the hull of the triangulation, and *panOutputFacetIdx is the closest triangle to the point.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TRUE in case of success, FALSE otherwise.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psDT</span></code>: triangulation. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nFacetIdx</span></code>: index of first triangle to start with. Must be &gt;= 0 &amp;&amp; &lt; psDT-&gt;nFacets </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfX</span></code>: x coordinate of the point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfY</span></code>: y coordinate of the point. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">panOutputFacetIdx</span></code>: (output) pointer to the index of the triangle, or -1 in case of failure.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421GDALTriangulationFreeP17GDALTriangulation">
<span id="_CPPv321GDALTriangulationFreeP17GDALTriangulation"></span><span id="_CPPv221GDALTriangulationFreeP17GDALTriangulation"></span><span id="GDALTriangulationFree__GDALTriangulationP"></span><span class="target" id="gdal__alg_8h_1a1d9ddc2b9ee90b2f9984e020d8f099f6"></span>void <code class="descname">GDALTriangulationFree</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417GDALTriangulation" title="GDALTriangulation">GDALTriangulation</a> *<em>psDT</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421GDALTriangulationFreeP17GDALTriangulation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a triangulation. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">psDT</span></code>: triangulation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425GDALOpenVerticalShiftGridPKcPi">
<span id="_CPPv325GDALOpenVerticalShiftGridPKcPi"></span><span id="_CPPv225GDALOpenVerticalShiftGridPKcPi"></span><span id="GDALOpenVerticalShiftGrid__cCP.iP"></span><span class="target" id="gdal__alg_8h_1a64e6a52db0d3bd8dd1aba937a0e8b052"></span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <code class="descname">GDALOpenVerticalShiftGrid</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>pszProj4Geoidgrids</em>, int *<em>pbError</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425GDALOpenVerticalShiftGridPKcPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Load proj.4 geoidgrids as GDAL dataset. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a dataset. If not NULL, it must be closed with <a class="reference internal" href="raster_c_api.html#gdal_8h_1a0984222d45a72028fcbbf1f44831ffbc"><span class="std std-ref">GDALClose()</span></a>.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pszProj4Geoidgrids</span></code>: Value of proj.4 geoidgrids parameter. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pbError</span></code>: If not NULL, the pointed value will be set to TRUE if an error occurred.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426GDALApplyVerticalShiftGrid12GDALDatasetH12GDALDatasetHiddPPCKc">
<span id="_CPPv326GDALApplyVerticalShiftGrid12GDALDatasetH12GDALDatasetHiddPPCKc"></span><span id="_CPPv226GDALApplyVerticalShiftGrid12GDALDatasetH12GDALDatasetHiddPPCKc"></span><span id="GDALApplyVerticalShiftGrid__GDALDatasetH.GDALDatasetH.i.double.double.cCPCP"></span><span class="target" id="gdal__alg_8h_1a365c29462f64484e80600559d493d6d5"></span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <code class="descname">GDALApplyVerticalShiftGrid</code><span class="sig-paren">(</span><a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hSrcDataset</em>, <a class="reference internal" href="raster_c_api.html#_CPPv412GDALDatasetH" title="GDALDatasetH">GDALDatasetH</a> <em>hGridDataset</em>, int <em>bInverse</em>, double <em>dfSrcUnitToMeter</em>, double <em>dfDstUnitToMeter</em>, <em class="property">const</em> char *<em class="property">const</em> *<em>papszOptions</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426GDALApplyVerticalShiftGrid12GDALDatasetH12GDALDatasetHiddPPCKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply a vertical shift grid to a source (DEM typically) dataset. </p>
<p>hGridDataset will typically use WGS84 as horizontal datum (but this is not a requirement) and its values are the values to add to go from geoid elevations to WGS84 ellipsoidal heights.</p>
<p>hGridDataset will be on-the-fly reprojected and resampled to the projection and resolution of hSrcDataset, using bilinear resampling by default.</p>
<p>Both hSrcDataset and hGridDataset must be single band datasets, and have a valid geotransform and projection.</p>
<p>On success, a reference will be taken on hSrcDataset and hGridDataset. Reference counting semantics on the source and grid datasets should be honoured. That is, don’t just <a class="reference internal" href="raster_c_api.html#gdal_8h_1a0984222d45a72028fcbbf1f44831ffbc"><span class="std std-ref">GDALClose()</span></a> it, unless it was opened with <a class="reference internal" href="raster_c_api.html#gdal_8h_1a46a02c21047d78f88f8abb1ff6b14ae2"><span class="std std-ref">GDALOpenShared()</span></a>, but rather use <a class="reference internal" href="raster_c_api.html#gdal_8h_1add1fc2ca3e674f68568816b932b398c6"><span class="std std-ref">GDALReleaseDataset()</span></a> if wanting to immediately release the reference(s) and make the returned dataset the owner of them.</p>
<p>Valid use cases:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hSrcDataset</span> <span class="o">=</span> <span class="n">GDALOpen</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">hGridDataset</span> <span class="o">=</span> <span class="n">GDALOpen</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">hDstDataset</span> <span class="o">=</span> <span class="n">GDALApplyVerticalShiftGrid</span><span class="p">(</span><span class="n">hSrcDataset</span><span class="p">,</span> <span class="n">hGridDataset</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">GDALReleaseDataset</span><span class="p">(</span><span class="n">hSrcDataset</span><span class="p">);</span>
<span class="n">GDALReleaseDataset</span><span class="p">(</span><span class="n">hGridDataset</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">hDstDataset</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Do</span> <span class="n">things</span> <span class="k">with</span> <span class="n">hDstDataset</span> 
    <span class="n">GDALClose</span><span class="p">(</span><span class="n">hDstDataset</span><span class="p">)</span> <span class="o">//</span> <span class="n">will</span> <span class="n">close</span> <span class="n">hSrcDataset</span> <span class="ow">and</span> <span class="n">hGridDataset</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new dataset corresponding to hSrcDataset adjusted with hGridDataset, or NULL. If not NULL, it must be closed with <a class="reference internal" href="raster_c_api.html#gdal_8h_1a0984222d45a72028fcbbf1f44831ffbc"><span class="std std-ref">GDALClose()</span></a>.</p>
</dd>
<dt><strong>Since</strong></dt><dd><p>GDAL 2.2 </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hSrcDataset</span></code>: source (DEM) dataset. Must not be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hGridDataset</span></code>: vertical grid shift dataset. Must not be NULL. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bInverse</span></code>: if set to FALSE, hGridDataset values will be added to hSrcDataset. If set to TRUE, they will be subtracted. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfSrcUnitToMeter</span></code>: the factor to convert values from hSrcDataset to meters (1.0 if source values are in meter). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfDstUnitToMeter</span></code>: the factor to convert shifted values from meter (1.0 if output values must be in meter). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">papszOptions</span></code>: list of options, or NULL. Supported options are: <ul>
<li><p>RESAMPLING=NEAREST/BILINEAR/CUBIC. Defaults to BILINEAR. </p></li>
<li><p>MAX_ERROR=val. Maximum error measured in input pixels that is allowed in approximating the transformation (0.0 for exact calculations). Defaults to 0.125 </p></li>
<li><p>DATATYPE=Byte/UInt16/Int16/Float32/Float64. Output data type. If not specified will be the same as the one of hSrcDataset. </p></li>
<li><p>ERROR_ON_MISSING_VERT_SHIFT=YES/NO. Whether a missing/nodata value in hGridDataset should cause I/O requests to fail. Default is NO (in which case 0 will be used) </p></li>
<li><p>SRC_SRS=srs_def. Override projection on hSrcDataset; </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="_CPPv438GDALGridInverseDistanceToAPowerOptions">
<span id="_CPPv338GDALGridInverseDistanceToAPowerOptions"></span><span id="_CPPv238GDALGridInverseDistanceToAPowerOptions"></span><span id="GDALGridInverseDistanceToAPowerOptions"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions"></span><em class="property">struct </em><code class="descname">GDALGridInverseDistanceToAPowerOptions</code><a class="headerlink" href="#_CPPv438GDALGridInverseDistanceToAPowerOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Inverse distance to a power method control options. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions7dfPowerE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions7dfPowerE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions7dfPowerE"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfPower__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a2b33badcbdaeb9464bd004cf11c442d4"></span>double <code class="descname">dfPower</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions7dfPowerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Weighting power. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions11dfSmoothingE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions11dfSmoothingE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions11dfSmoothingE"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfSmoothing__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a53c42a3be0970f4ce61613a998db17a5"></span>double <code class="descname">dfSmoothing</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions11dfSmoothingE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Smoothing parameter. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyRatioE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyRatioE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyRatioE"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfAnisotropyRatio__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1ade9e0033d4f955f4fbab621c523c28ea"></span>double <code class="descname">dfAnisotropyRatio</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyRatioE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserved for future use. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyAngleE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyAngleE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyAngleE"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfAnisotropyAngle__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1aff3a8a0a37baf153faf7940904bdc7e6"></span>double <code class="descname">dfAnisotropyAngle</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions17dfAnisotropyAngleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserved for future use. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions9dfRadius1E">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions9dfRadius1E"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions9dfRadius1E"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfRadius1__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a8526f2b55ea76906b502fcb7da7cb0aa"></span>double <code class="descname">dfRadius1</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions9dfRadius1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The first radius (X axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions9dfRadius2E">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions9dfRadius2E"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions9dfRadius2E"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfRadius2__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a39dc42caf1afa8fe6cdd63e50063a2f3"></span>double <code class="descname">dfRadius2</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions9dfRadius2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The second radius (Y axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions7dfAngleE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions7dfAngleE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions7dfAngleE"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfAngle__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a737bc8f26e3ad0cce94fb5d402af2ed5"></span>double <code class="descname">dfAngle</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions7dfAngleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angle of ellipse rotation in degrees.</p>
<p>Ellipse rotated counter clockwise. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions10nMaxPointsE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions10nMaxPointsE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions10nMaxPointsE"></span><span id="GDALGridInverseDistanceToAPowerOptions::nMaxPoints__GUInt32"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a85a096af2402b0b37a3520d2b7613352"></span><a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <code class="descname">nMaxPoints</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions10nMaxPointsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Maximum number of data points to use.</p>
<p>Do not search for more points than this number. If less amount of points found the grid node considered empty and will be filled with NODATA marker. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions10nMinPointsE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions10nMinPointsE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions10nMinPointsE"></span><span id="GDALGridInverseDistanceToAPowerOptions::nMinPoints__GUInt32"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a2575140ce033afcf4b6acebba1f6cc6c"></span><a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <code class="descname">nMinPoints</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions10nMinPointsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum number of data points to use.</p>
<p>If less amount of points found the grid node considered empty and will be filled with NODATA marker. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N38GDALGridInverseDistanceToAPowerOptions13dfNoDataValueE">
<span id="_CPPv3N38GDALGridInverseDistanceToAPowerOptions13dfNoDataValueE"></span><span id="_CPPv2N38GDALGridInverseDistanceToAPowerOptions13dfNoDataValueE"></span><span id="GDALGridInverseDistanceToAPowerOptions::dfNoDataValue__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerOptions_1a4bd2acae79c4526f6e9894c7fdbdf8bc"></span>double <code class="descname">dfNoDataValue</code><a class="headerlink" href="#_CPPv4N38GDALGridInverseDistanceToAPowerOptions13dfNoDataValueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No data marker to fill empty points. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv453GDALGridInverseDistanceToAPowerNearestNeighborOptions">
<span id="_CPPv353GDALGridInverseDistanceToAPowerNearestNeighborOptions"></span><span id="_CPPv253GDALGridInverseDistanceToAPowerNearestNeighborOptions"></span><span id="GDALGridInverseDistanceToAPowerNearestNeighborOptions"></span><span class="target" id="structGDALGridInverseDistanceToAPowerNearestNeighborOptions"></span><em class="property">struct </em><code class="descname">GDALGridInverseDistanceToAPowerNearestNeighborOptions</code><a class="headerlink" href="#_CPPv453GDALGridInverseDistanceToAPowerNearestNeighborOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Inverse distance to a power, with nearest neighbour search, control options. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions7dfPowerE">
<span id="_CPPv3N53GDALGridInverseDistanceToAPowerNearestNeighborOptions7dfPowerE"></span><span id="_CPPv2N53GDALGridInverseDistanceToAPowerNearestNeighborOptions7dfPowerE"></span><span id="GDALGridInverseDistanceToAPowerNearestNeighborOptions::dfPower__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerNearestNeighborOptions_1a1bfaddaca14ebd6f63e1aedcb44ecfe6"></span>double <code class="descname">dfPower</code><a class="headerlink" href="#_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions7dfPowerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Weighting power. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions8dfRadiusE">
<span id="_CPPv3N53GDALGridInverseDistanceToAPowerNearestNeighborOptions8dfRadiusE"></span><span id="_CPPv2N53GDALGridInverseDistanceToAPowerNearestNeighborOptions8dfRadiusE"></span><span id="GDALGridInverseDistanceToAPowerNearestNeighborOptions::dfRadius__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerNearestNeighborOptions_1a06c1b2838d646142cfa738e4acca2eb2"></span>double <code class="descname">dfRadius</code><a class="headerlink" href="#_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions8dfRadiusE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The radius of search circle. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions11dfSmoothingE">
<span id="_CPPv3N53GDALGridInverseDistanceToAPowerNearestNeighborOptions11dfSmoothingE"></span><span id="_CPPv2N53GDALGridInverseDistanceToAPowerNearestNeighborOptions11dfSmoothingE"></span><span id="GDALGridInverseDistanceToAPowerNearestNeighborOptions::dfSmoothing__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerNearestNeighborOptions_1a55b877f207571e87bd7be9e8f14dadf4"></span>double <code class="descname">dfSmoothing</code><a class="headerlink" href="#_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions11dfSmoothingE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Smoothing parameter. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMaxPointsE">
<span id="_CPPv3N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMaxPointsE"></span><span id="_CPPv2N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMaxPointsE"></span><span id="GDALGridInverseDistanceToAPowerNearestNeighborOptions::nMaxPoints__GUInt32"></span><span class="target" id="structGDALGridInverseDistanceToAPowerNearestNeighborOptions_1a4f4d26a47a5b5e061c3111f8171c49d3"></span><a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <code class="descname">nMaxPoints</code><a class="headerlink" href="#_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMaxPointsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Maximum number of data points to use.</p>
<p>Do not search for more points than this number. If less amount of points found the grid node considered empty and will be filled with NODATA marker. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMinPointsE">
<span id="_CPPv3N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMinPointsE"></span><span id="_CPPv2N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMinPointsE"></span><span id="GDALGridInverseDistanceToAPowerNearestNeighborOptions::nMinPoints__GUInt32"></span><span class="target" id="structGDALGridInverseDistanceToAPowerNearestNeighborOptions_1a02ddc8c36b487647735c935c2f5f6e52"></span><a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <code class="descname">nMinPoints</code><a class="headerlink" href="#_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions10nMinPointsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum number of data points to use.</p>
<p>If less amount of points found the grid node considered empty and will be filled with NODATA marker. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions13dfNoDataValueE">
<span id="_CPPv3N53GDALGridInverseDistanceToAPowerNearestNeighborOptions13dfNoDataValueE"></span><span id="_CPPv2N53GDALGridInverseDistanceToAPowerNearestNeighborOptions13dfNoDataValueE"></span><span id="GDALGridInverseDistanceToAPowerNearestNeighborOptions::dfNoDataValue__double"></span><span class="target" id="structGDALGridInverseDistanceToAPowerNearestNeighborOptions_1a38f719d6487ab45ee0e10cfa69334329"></span>double <code class="descname">dfNoDataValue</code><a class="headerlink" href="#_CPPv4N53GDALGridInverseDistanceToAPowerNearestNeighborOptions13dfNoDataValueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No data marker to fill empty points. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv428GDALGridMovingAverageOptions">
<span id="_CPPv328GDALGridMovingAverageOptions"></span><span id="_CPPv228GDALGridMovingAverageOptions"></span><span id="GDALGridMovingAverageOptions"></span><span class="target" id="structGDALGridMovingAverageOptions"></span><em class="property">struct </em><code class="descname">GDALGridMovingAverageOptions</code><a class="headerlink" href="#_CPPv428GDALGridMovingAverageOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Moving average method control options. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N28GDALGridMovingAverageOptions9dfRadius1E">
<span id="_CPPv3N28GDALGridMovingAverageOptions9dfRadius1E"></span><span id="_CPPv2N28GDALGridMovingAverageOptions9dfRadius1E"></span><span id="GDALGridMovingAverageOptions::dfRadius1__double"></span><span class="target" id="structGDALGridMovingAverageOptions_1a3d846750d226a5a025d7e743eba1b1a9"></span>double <code class="descname">dfRadius1</code><a class="headerlink" href="#_CPPv4N28GDALGridMovingAverageOptions9dfRadius1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The first radius (X axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N28GDALGridMovingAverageOptions9dfRadius2E">
<span id="_CPPv3N28GDALGridMovingAverageOptions9dfRadius2E"></span><span id="_CPPv2N28GDALGridMovingAverageOptions9dfRadius2E"></span><span id="GDALGridMovingAverageOptions::dfRadius2__double"></span><span class="target" id="structGDALGridMovingAverageOptions_1aadb10929f004851017ca529a8efb53e0"></span>double <code class="descname">dfRadius2</code><a class="headerlink" href="#_CPPv4N28GDALGridMovingAverageOptions9dfRadius2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The second radius (Y axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N28GDALGridMovingAverageOptions7dfAngleE">
<span id="_CPPv3N28GDALGridMovingAverageOptions7dfAngleE"></span><span id="_CPPv2N28GDALGridMovingAverageOptions7dfAngleE"></span><span id="GDALGridMovingAverageOptions::dfAngle__double"></span><span class="target" id="structGDALGridMovingAverageOptions_1a6f9a0110bb1df3187b5d51a21c662cc2"></span>double <code class="descname">dfAngle</code><a class="headerlink" href="#_CPPv4N28GDALGridMovingAverageOptions7dfAngleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angle of ellipse rotation in degrees.</p>
<p>Ellipse rotated counter clockwise. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N28GDALGridMovingAverageOptions10nMinPointsE">
<span id="_CPPv3N28GDALGridMovingAverageOptions10nMinPointsE"></span><span id="_CPPv2N28GDALGridMovingAverageOptions10nMinPointsE"></span><span id="GDALGridMovingAverageOptions::nMinPoints__GUInt32"></span><span class="target" id="structGDALGridMovingAverageOptions_1a79a8feba8337a75a64e3c349fa398562"></span><a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <code class="descname">nMinPoints</code><a class="headerlink" href="#_CPPv4N28GDALGridMovingAverageOptions10nMinPointsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum number of data points to average.</p>
<p>If less amount of points found the grid node considered empty and will be filled with NODATA marker. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N28GDALGridMovingAverageOptions13dfNoDataValueE">
<span id="_CPPv3N28GDALGridMovingAverageOptions13dfNoDataValueE"></span><span id="_CPPv2N28GDALGridMovingAverageOptions13dfNoDataValueE"></span><span id="GDALGridMovingAverageOptions::dfNoDataValue__double"></span><span class="target" id="structGDALGridMovingAverageOptions_1a644e2c5a9ab0b7f68b54eb8d4bd0a6a7"></span>double <code class="descname">dfNoDataValue</code><a class="headerlink" href="#_CPPv4N28GDALGridMovingAverageOptions13dfNoDataValueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No data marker to fill empty points. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv430GDALGridNearestNeighborOptions">
<span id="_CPPv330GDALGridNearestNeighborOptions"></span><span id="_CPPv230GDALGridNearestNeighborOptions"></span><span id="GDALGridNearestNeighborOptions"></span><span class="target" id="structGDALGridNearestNeighborOptions"></span><em class="property">struct </em><code class="descname">GDALGridNearestNeighborOptions</code><a class="headerlink" href="#_CPPv430GDALGridNearestNeighborOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Nearest neighbor method control options. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N30GDALGridNearestNeighborOptions9dfRadius1E">
<span id="_CPPv3N30GDALGridNearestNeighborOptions9dfRadius1E"></span><span id="_CPPv2N30GDALGridNearestNeighborOptions9dfRadius1E"></span><span id="GDALGridNearestNeighborOptions::dfRadius1__double"></span><span class="target" id="structGDALGridNearestNeighborOptions_1afe0c46e6483cb5ff7870f535b802e908"></span>double <code class="descname">dfRadius1</code><a class="headerlink" href="#_CPPv4N30GDALGridNearestNeighborOptions9dfRadius1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The first radius (X axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALGridNearestNeighborOptions9dfRadius2E">
<span id="_CPPv3N30GDALGridNearestNeighborOptions9dfRadius2E"></span><span id="_CPPv2N30GDALGridNearestNeighborOptions9dfRadius2E"></span><span id="GDALGridNearestNeighborOptions::dfRadius2__double"></span><span class="target" id="structGDALGridNearestNeighborOptions_1a7e7633a0c659c66d443681cb74491b5d"></span>double <code class="descname">dfRadius2</code><a class="headerlink" href="#_CPPv4N30GDALGridNearestNeighborOptions9dfRadius2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The second radius (Y axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALGridNearestNeighborOptions7dfAngleE">
<span id="_CPPv3N30GDALGridNearestNeighborOptions7dfAngleE"></span><span id="_CPPv2N30GDALGridNearestNeighborOptions7dfAngleE"></span><span id="GDALGridNearestNeighborOptions::dfAngle__double"></span><span class="target" id="structGDALGridNearestNeighborOptions_1abe934d82949c0f7afb19bc2f87062dc2"></span>double <code class="descname">dfAngle</code><a class="headerlink" href="#_CPPv4N30GDALGridNearestNeighborOptions7dfAngleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angle of ellipse rotation in degrees.</p>
<p>Ellipse rotated counter clockwise. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALGridNearestNeighborOptions13dfNoDataValueE">
<span id="_CPPv3N30GDALGridNearestNeighborOptions13dfNoDataValueE"></span><span id="_CPPv2N30GDALGridNearestNeighborOptions13dfNoDataValueE"></span><span id="GDALGridNearestNeighborOptions::dfNoDataValue__double"></span><span class="target" id="structGDALGridNearestNeighborOptions_1a1441ae5840b35067fca85c343e87c2a4"></span>double <code class="descname">dfNoDataValue</code><a class="headerlink" href="#_CPPv4N30GDALGridNearestNeighborOptions13dfNoDataValueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No data marker to fill empty points. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv426GDALGridDataMetricsOptions">
<span id="_CPPv326GDALGridDataMetricsOptions"></span><span id="_CPPv226GDALGridDataMetricsOptions"></span><span id="GDALGridDataMetricsOptions"></span><span class="target" id="structGDALGridDataMetricsOptions"></span><em class="property">struct </em><code class="descname">GDALGridDataMetricsOptions</code><a class="headerlink" href="#_CPPv426GDALGridDataMetricsOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Data metrics method control options. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N26GDALGridDataMetricsOptions9dfRadius1E">
<span id="_CPPv3N26GDALGridDataMetricsOptions9dfRadius1E"></span><span id="_CPPv2N26GDALGridDataMetricsOptions9dfRadius1E"></span><span id="GDALGridDataMetricsOptions::dfRadius1__double"></span><span class="target" id="structGDALGridDataMetricsOptions_1a703017fc9a2c0dd541450729e3a91278"></span>double <code class="descname">dfRadius1</code><a class="headerlink" href="#_CPPv4N26GDALGridDataMetricsOptions9dfRadius1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The first radius (X axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N26GDALGridDataMetricsOptions9dfRadius2E">
<span id="_CPPv3N26GDALGridDataMetricsOptions9dfRadius2E"></span><span id="_CPPv2N26GDALGridDataMetricsOptions9dfRadius2E"></span><span id="GDALGridDataMetricsOptions::dfRadius2__double"></span><span class="target" id="structGDALGridDataMetricsOptions_1a053a2affede2dea28010c21f90d611f9"></span>double <code class="descname">dfRadius2</code><a class="headerlink" href="#_CPPv4N26GDALGridDataMetricsOptions9dfRadius2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The second radius (Y axis if rotation angle is 0) of search ellipse. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N26GDALGridDataMetricsOptions7dfAngleE">
<span id="_CPPv3N26GDALGridDataMetricsOptions7dfAngleE"></span><span id="_CPPv2N26GDALGridDataMetricsOptions7dfAngleE"></span><span id="GDALGridDataMetricsOptions::dfAngle__double"></span><span class="target" id="structGDALGridDataMetricsOptions_1a08ef0db403f6751bc5e162d3d0fb3308"></span>double <code class="descname">dfAngle</code><a class="headerlink" href="#_CPPv4N26GDALGridDataMetricsOptions7dfAngleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Angle of ellipse rotation in degrees.</p>
<p>Ellipse rotated counter clockwise. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N26GDALGridDataMetricsOptions10nMinPointsE">
<span id="_CPPv3N26GDALGridDataMetricsOptions10nMinPointsE"></span><span id="_CPPv2N26GDALGridDataMetricsOptions10nMinPointsE"></span><span id="GDALGridDataMetricsOptions::nMinPoints__GUInt32"></span><span class="target" id="structGDALGridDataMetricsOptions_1a937e1cc325e9f6e1c3cf1c298ad19837"></span><a class="reference internal" href="cpl.html#_CPPv47GUInt32" title="GUInt32">GUInt32</a> <code class="descname">nMinPoints</code><a class="headerlink" href="#_CPPv4N26GDALGridDataMetricsOptions10nMinPointsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Minimum number of data points to average.</p>
<p>If less amount of points found the grid node considered empty and will be filled with NODATA marker. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N26GDALGridDataMetricsOptions13dfNoDataValueE">
<span id="_CPPv3N26GDALGridDataMetricsOptions13dfNoDataValueE"></span><span id="_CPPv2N26GDALGridDataMetricsOptions13dfNoDataValueE"></span><span id="GDALGridDataMetricsOptions::dfNoDataValue__double"></span><span class="target" id="structGDALGridDataMetricsOptions_1a48354b8319b72a4c8455c18da3eae2c8"></span>double <code class="descname">dfNoDataValue</code><a class="headerlink" href="#_CPPv4N26GDALGridDataMetricsOptions13dfNoDataValueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No data marker to fill empty points. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv421GDALGridLinearOptions">
<span id="_CPPv321GDALGridLinearOptions"></span><span id="_CPPv221GDALGridLinearOptions"></span><span id="GDALGridLinearOptions"></span><span class="target" id="structGDALGridLinearOptions"></span><em class="property">struct </em><code class="descname">GDALGridLinearOptions</code><a class="headerlink" href="#_CPPv421GDALGridLinearOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Linear method control options. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N21GDALGridLinearOptions8dfRadiusE">
<span id="_CPPv3N21GDALGridLinearOptions8dfRadiusE"></span><span id="_CPPv2N21GDALGridLinearOptions8dfRadiusE"></span><span id="GDALGridLinearOptions::dfRadius__double"></span><span class="target" id="structGDALGridLinearOptions_1ac9aabe3ceeff877aacd9a4458fb09ea6"></span>double <code class="descname">dfRadius</code><a class="headerlink" href="#_CPPv4N21GDALGridLinearOptions8dfRadiusE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In case the point to be interpolated does not fit into a triangle of the Delaunay triangulation, use that maximum distance to search a nearest neighbour, or use nodata otherwise. If set to -1, the search distance is infinite. If set to 0, nodata value will be always used. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N21GDALGridLinearOptions13dfNoDataValueE">
<span id="_CPPv3N21GDALGridLinearOptions13dfNoDataValueE"></span><span id="_CPPv2N21GDALGridLinearOptions13dfNoDataValueE"></span><span id="GDALGridLinearOptions::dfNoDataValue__double"></span><span class="target" id="structGDALGridLinearOptions_1ab62956293a7685afc7a5b75a15c66654"></span>double <code class="descname">dfNoDataValue</code><a class="headerlink" href="#_CPPv4N21GDALGridLinearOptions13dfNoDataValueE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No data marker to fill empty points. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv412GDALTriFacet">
<span id="_CPPv312GDALTriFacet"></span><span id="_CPPv212GDALTriFacet"></span><span id="GDALTriFacet"></span><span class="target" id="structGDALTriFacet"></span><em class="property">struct </em><code class="descname">GDALTriFacet</code><a class="headerlink" href="#_CPPv412GDALTriFacet" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Triangle fact. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N12GDALTriFacet11anVertexIdxE">
<span id="_CPPv3N12GDALTriFacet11anVertexIdxE"></span><span id="_CPPv2N12GDALTriFacet11anVertexIdxE"></span><span id="GDALTriFacet::anVertexIdx__iA"></span><span class="target" id="structGDALTriFacet_1aa3d3a438e54d59fef00ea554379722cc"></span>int <code class="descname">anVertexIdx</code>[3]<a class="headerlink" href="#_CPPv4N12GDALTriFacet11anVertexIdxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>index to the padfX/padfY arrays </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12GDALTriFacet13anNeighborIdxE">
<span id="_CPPv3N12GDALTriFacet13anNeighborIdxE"></span><span id="_CPPv2N12GDALTriFacet13anNeighborIdxE"></span><span id="GDALTriFacet::anNeighborIdx__iA"></span><span class="target" id="structGDALTriFacet_1ae89b733923f5cd7d5fd7046ae8f2516c"></span>int <code class="descname">anNeighborIdx</code>[3]<a class="headerlink" href="#_CPPv4N12GDALTriFacet13anNeighborIdxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>index to GDALDelaunayTriangulation.pasFacets, or -1 </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv430GDALTriBarycentricCoefficients">
<span id="_CPPv330GDALTriBarycentricCoefficients"></span><span id="_CPPv230GDALTriBarycentricCoefficients"></span><span id="GDALTriBarycentricCoefficients"></span><span class="target" id="structGDALTriBarycentricCoefficients"></span><em class="property">struct </em><code class="descname">GDALTriBarycentricCoefficients</code><a class="headerlink" href="#_CPPv430GDALTriBarycentricCoefficients" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Triangle barycentric coefficients. </p>
<p>Conversion from cartesian (x,y) to barycentric (l1,l2,l3) with : l1 = dfMul1X * (x - dfCxtX) + dfMul1Y * (y - dfCstY) l2 = dfMul2X * (x - dfCxtX) + dfMul2Y * (y - dfCstY) l3 = 1 - l1 - l2 </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N30GDALTriBarycentricCoefficients7dfMul1XE">
<span id="_CPPv3N30GDALTriBarycentricCoefficients7dfMul1XE"></span><span id="_CPPv2N30GDALTriBarycentricCoefficients7dfMul1XE"></span><span id="GDALTriBarycentricCoefficients::dfMul1X__double"></span><span class="target" id="structGDALTriBarycentricCoefficients_1af128bb3d90c4d5cac73780df653f6e44"></span>double <code class="descname">dfMul1X</code><a class="headerlink" href="#_CPPv4N30GDALTriBarycentricCoefficients7dfMul1XE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>dfMul1X </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALTriBarycentricCoefficients7dfMul1YE">
<span id="_CPPv3N30GDALTriBarycentricCoefficients7dfMul1YE"></span><span id="_CPPv2N30GDALTriBarycentricCoefficients7dfMul1YE"></span><span id="GDALTriBarycentricCoefficients::dfMul1Y__double"></span><span class="target" id="structGDALTriBarycentricCoefficients_1a5955d1e4f9ee5f6c0a1bb29eb11a2f37"></span>double <code class="descname">dfMul1Y</code><a class="headerlink" href="#_CPPv4N30GDALTriBarycentricCoefficients7dfMul1YE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>dfMul1Y </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALTriBarycentricCoefficients7dfMul2XE">
<span id="_CPPv3N30GDALTriBarycentricCoefficients7dfMul2XE"></span><span id="_CPPv2N30GDALTriBarycentricCoefficients7dfMul2XE"></span><span id="GDALTriBarycentricCoefficients::dfMul2X__double"></span><span class="target" id="structGDALTriBarycentricCoefficients_1ad64f28b4b20ad3304ff19bf927e1f16e"></span>double <code class="descname">dfMul2X</code><a class="headerlink" href="#_CPPv4N30GDALTriBarycentricCoefficients7dfMul2XE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>dfMul2X </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALTriBarycentricCoefficients7dfMul2YE">
<span id="_CPPv3N30GDALTriBarycentricCoefficients7dfMul2YE"></span><span id="_CPPv2N30GDALTriBarycentricCoefficients7dfMul2YE"></span><span id="GDALTriBarycentricCoefficients::dfMul2Y__double"></span><span class="target" id="structGDALTriBarycentricCoefficients_1a2cf9f36c296167b905a4c8a7926af97c"></span>double <code class="descname">dfMul2Y</code><a class="headerlink" href="#_CPPv4N30GDALTriBarycentricCoefficients7dfMul2YE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>dfMul2Y </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALTriBarycentricCoefficients6dfCstXE">
<span id="_CPPv3N30GDALTriBarycentricCoefficients6dfCstXE"></span><span id="_CPPv2N30GDALTriBarycentricCoefficients6dfCstXE"></span><span id="GDALTriBarycentricCoefficients::dfCstX__double"></span><span class="target" id="structGDALTriBarycentricCoefficients_1a270d8fe7ca11525645ab03bf17617355"></span>double <code class="descname">dfCstX</code><a class="headerlink" href="#_CPPv4N30GDALTriBarycentricCoefficients6dfCstXE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>dfCstX </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N30GDALTriBarycentricCoefficients6dfCstYE">
<span id="_CPPv3N30GDALTriBarycentricCoefficients6dfCstYE"></span><span id="_CPPv2N30GDALTriBarycentricCoefficients6dfCstYE"></span><span id="GDALTriBarycentricCoefficients::dfCstY__double"></span><span class="target" id="structGDALTriBarycentricCoefficients_1a0bc0d4e67db7a85905a13f354980c482"></span>double <code class="descname">dfCstY</code><a class="headerlink" href="#_CPPv4N30GDALTriBarycentricCoefficients6dfCstYE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>dfCstY </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv417GDALTriangulation">
<span id="_CPPv317GDALTriangulation"></span><span id="_CPPv217GDALTriangulation"></span><span id="GDALTriangulation"></span><span class="target" id="structGDALTriangulation"></span><em class="property">struct </em><code class="descname">GDALTriangulation</code><a class="headerlink" href="#_CPPv417GDALTriangulation" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;gdal_alg.h&gt;</em><p>Triangulation structure. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N17GDALTriangulation7nFacetsE">
<span id="_CPPv3N17GDALTriangulation7nFacetsE"></span><span id="_CPPv2N17GDALTriangulation7nFacetsE"></span><span id="GDALTriangulation::nFacets__i"></span><span class="target" id="structGDALTriangulation_1a5f49b449900c4703317ea4c1a8ba1b19"></span>int <code class="descname">nFacets</code><a class="headerlink" href="#_CPPv4N17GDALTriangulation7nFacetsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>number of facets </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17GDALTriangulation9pasFacetsE">
<span id="_CPPv3N17GDALTriangulation9pasFacetsE"></span><span id="_CPPv2N17GDALTriangulation9pasFacetsE"></span><span id="GDALTriangulation::pasFacets__GDALTriFacetP"></span><span class="target" id="structGDALTriangulation_1a872768a7b905c98baba27c8ee39c2cf5"></span><a class="reference internal" href="#_CPPv412GDALTriFacet" title="GDALTriFacet">GDALTriFacet</a> *<code class="descname">pasFacets</code><a class="headerlink" href="#_CPPv4N17GDALTriangulation9pasFacetsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>array of nFacets facets </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17GDALTriangulation20pasFacetCoefficientsE">
<span id="_CPPv3N17GDALTriangulation20pasFacetCoefficientsE"></span><span id="_CPPv2N17GDALTriangulation20pasFacetCoefficientsE"></span><span id="GDALTriangulation::pasFacetCoefficients__GDALTriBarycentricCoefficientsP"></span><span class="target" id="structGDALTriangulation_1a214a2c93a56b5205b0e34d7a186eb878"></span><a class="reference internal" href="#_CPPv430GDALTriBarycentricCoefficients" title="GDALTriBarycentricCoefficients">GDALTriBarycentricCoefficients</a> *<code class="descname">pasFacetCoefficients</code><a class="headerlink" href="#_CPPv4N17GDALTriangulation20pasFacetCoefficientsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>arra of nFacets barycentric coefficients </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ogr_srs_api.html" class="btn btn-neutral float-right" title="ogr_srs_api.h: Spatial Reference System C API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="vector_c_api.html" class="btn btn-neutral float-left" title="ogr_core.h and ogr_api.h: Vector C API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://osgeo.org">
        <div class="osgeo-logo"></div>
      </a>
      <div class="copyright">
      

      &copy; 1998-2020 <a href="https://github.com/warmerdam">Frank Warmerdam</a>,
      <a href="https://github.com/rouault">Even Rouault</a>, and
      <a href="https://github.com/OSGeo/gdal/graphs/contributors">others</a>


      
      </div>
    </div>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>