

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>RFC 45: GDAL datasets and raster bands as virtual memory mappings &mdash; GDAL  documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://gdal.orgdevelopment/rfc/rfc45_virtualmem.html"/>
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/gdal.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="RFC 46: GDAL/OGR unification" href="rfc46_gdal_ogr_unification.html" />
    <link rel="prev" title="RFC 44: Add Parseable Output Formats for ogrinfo and gdalinfo" href="rfc44_gdalinfoxml.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/gdalicon.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../programs/index.html">Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drivers/raster/index.html">Raster drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drivers/vector/index.html">Vector drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">User</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Development</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">RFC list</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="rfc1_pmc.html">RFC 1: Project Management Committee Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc2_svn.html">RFC 2: Migration to OSGeo Subversion Repository</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc3_commiters.html">RFC 3: GDAL Committer Guildlines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc4_geolocate.html">RFC 4: Geolocation Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc5_unicode.html">RFC 5: Unicode support in GDAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc6_sqlgeom.html">RFC 6: Geometry and Feature Style as OGR Special Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc7_vsilapi.html">RFC 7: Use VSILFILE for VSI*L Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc8_devguide.html">RFC 8: Developer Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc9_maintainer.html">RFC 9: GDAL Paid Maintainer Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc10_ogropen.html">RFC 10: OGR Open Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc11_fastidentify.html">RFC 11: Fast Format Identification</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc12_filemanagement.html">RFC 12: Improved File Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc13_createfeatures.html">RFC 13: Improved Feature Insertion/Update/Delete Performance in Batch Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc14_imagestructure.html">RFC 14: Image Structure Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc15_nodatabitmask.html">RFC 15: Band Masks</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc16_ogr_reentrancy.html">RFC 16: OGR Thread Safety</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc17_python_namespaces.html">RFC 17: Python Namespaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc18_ogr_styles_c_api.html">RFC 18: OGR Style Support in C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc19_safememalloc.html">RFC 19: Safer memory allocation in GDAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc20_srs_axes.html">RFC 20: OGRSpatialReference Axis Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc21_ogrsqlcast.html">RFC 21: OGR SQL type cast and field name alias</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc22_rpc.html">RFC 22: RPC Georeferencing</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc23_ogr_unicode.html">RFC 23.1: Unicode support in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc24_progressive_data_support.html">RFC 24: GDAL Progressive Data Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc25_fast_open.html">RFC 25: Fast Open</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc26_blockcache.html">RFC 26: GDAL Block Cache Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc27_supportdata.html">RFC 27: Improved Supporting Data File Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc28_sqlfunc.html">RFC 28: OGR SQL Generalized Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc29_desired_fields.html">RFC 29: OGR Set Ignored Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc30_utf8_filenames.html">RFC 30: Unicode Filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc31_ogr_64.html">RFC 31: OGR 64bit Integer Fields and FIDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc32_gdallocationinfo.html">RFC 32: gdallocationinfo utility</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc33_gtiff_pixelispoint.html">RFC 33: GTiff - Fixing PixelIsPoint Interpretation</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc34_license_policy.html">RFC 34: License Policy Enforcement</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc35_deletereorderalterfielddefn.html">RFC 35: Delete, reorder and alter field definitions of OGR layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc36_open_by_drivername.html">RFC 36: Allow specification of intended driver on GDALOpen</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc37_cplerror_userdata.html">RFC 37: User data callbacks in CPLError</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc38_ogr_faster_open.html">RFC 38: OGR Faster Open</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc39_ogr_layer_algebra.html">RFC 39: OGR Layer Algebra</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc40_enhanced_rat_support.html">RFC 40: Improving performance of Raster Attribute Table implementation for large tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc41_multiple_geometry_fields.html">RFC 41 : Support for multiple geometry fields in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc42_find_laundered_fields.html">RFC 42: OGR Layer laundered field lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc43_getmetadatadomainlist.html">RFC 43: GDALMajorObject::GetMetadataDomainList</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc44_gdalinfoxml.html">RFC 44: Add Parseable Output Formats for ogrinfo and gdalinfo</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">RFC 45: GDAL datasets and raster bands as virtual memory mappings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rationale">Rationale</a></li>
<li class="toctree-l4"><a class="reference internal" href="#details-of-new-api">Details of new API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#portability">Portability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performance">Performance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#related-thoughts">Related thoughts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#open-questions">Open questions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#backward-compatibility-issues">Backward compatibility issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#updated-drivers">Updated drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#swig-bindings">SWIG bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-suite">Test Suite</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#voting-history">Voting history</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rfc46_gdal_ogr_unification.html">RFC 46: GDAL/OGR unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc47_dataset_caching.html">RFC 47: Per Dataset Caching and GDALRasterBand Multithreading</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc48_geographical_networks_support.html">RFC 48: Geographical networks support</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc49_curve_geometries.html">RFC 49: Curve geometries</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc50_ogr_field_subtype.html">RFC 50: OGR field subtypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc51_rasterio_resampling_progress.html">RFC 51: RasterIO() improvements : resampling and progress callback</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc52_strict_sql_quoting.html">RFC 52: Strict OGR SQL quoting</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc53_ogr_notnull_default.html">RFC 53: OGR not-null constraints and default values</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc54_dataset_transactions.html">RFC 54: Dataset transactions</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc55_refined_setfeature_deletefeature_semantics.html">RFC 55: Refined SetFeature() and DeleteFeature() semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc56_millisecond_precision.html">RFC 56: OFTTime/OFTDateTime millisecond accuracy</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc57_histogram_64bit_count.html">RFC 57: 64-bit bucket counts for histograms</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc58_removing_dataset_nodata_value.html">RFC 58: Removing Dataset Nodata Value</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc59.1_utilities_as_a_library.html">RFC 59.1 : GDAL/OGR utilities as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc59_utilities_as_a_library.html">RFC 59 : GDAL/OGR utilities as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc60_improved_roundtripping_in_ogr.html">RFC 60 : Improved round-tripping in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc61_support_for_measured_geometries.html">RFC 61 : Support for measured geometries</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc62_raster_algebra.html">RFC 62 : Raster algebra</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc63_sparse_datasets_improvements.html">RFC 63 : Sparse datasets improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc64_triangle_polyhedralsurface_tin.html">RFC 64: Triangle, Polyhedral surface and TIN</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc65_rfc7946_geojson.html">RFC 65: RFC 7946 GeoJSON</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc66_randomlayerreadwrite.html">RFC 66 : OGR random layer read/write capabilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc67_nullfieldvalues.html">RFC 67 : Null values in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc68_cplusplus11.html">RFC 68: C++11 Compilation Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc69_cplusplus_formatting.html">RFC 69: C/C++ Code Formatting</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc70_output_format_guess.html">RFC 70: Guessing output format from output file name extension for utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc71_github_migration.html">RFC 71: Migration to GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc72_pytest.html">RFC 72: Update autotest suite to use pytest</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc73_proj6_wkt2_srsbarn.html">RFC 73: Integration of PROJ6 for WKT2, late binding capabilities, time-support and unified CRS database</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc74_sphinx.html">RFC 74: Migrate gdal.org to RTD-style Sphinx infrastructure</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc75_multidimensional_arrays.html">RFC 75: Multidimensional arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc76_ogrpythondrivers.html">RFC 76: OGR Python drivers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">How to contribute?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GDAL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html"> GDAL  documentation </a> &raquo;</li>
      
          <li><a href="../index.html">Development</a> &raquo;</li>
      
          <li><a href="index.html">RFC list</a> &raquo;</li>
      
      <li>RFC 45: GDAL datasets and raster bands as virtual memory mappings</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/OSGeo/gdal/edit//master/gdal/doc/source/development/rfc/rfc45_virtualmem.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="rfc46_gdal_ogr_unification.html" class="btn btn-neutral float-right" title="RFC 46: GDAL/OGR unification" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rfc44_gdalinfoxml.html" class="btn btn-neutral float-left" title="RFC 44: Add Parseable Output Formats for ogrinfo and gdalinfo" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="rfc-45-gdal-datasets-and-raster-bands-as-virtual-memory-mappings">
<span id="rfc-45"></span><h1>RFC 45: GDAL datasets and raster bands as virtual memory mappings<a class="headerlink" href="#rfc-45-gdal-datasets-and-raster-bands-as-virtual-memory-mappings" title="Permalink to this headline">¶</a></h1>
<p>Authors: Even Rouault</p>
<p>Contact: even dot rouault at spatialys.com</p>
<p>Status: Adopted, implemented</p>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>This document proposes additions to GDAL so that image data of GDAL
datasets and raster bands can be seen as virtual memory mappings, for
hopefully simpler usage.</p>
</div>
<div class="section" id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h2>
<p>When one wants to read or write image data from/into a GDAL dataset or
raster band, one must use the RasterIO() interface for the regions of
interest that are read or written. For small images, the most convenient
solution is usually to read/write the whole image in a single request
where the region of interest is the full raster extent. For larger
images, particularly when they do not fit entirely in RAM, this is not
possible, and if one wants to operate on the whole image, one must use a
windowing strategy to avoid memory issues : typically by proceeding
scanline (or group of scanlines) by scanline, or by blocks for tiled
images. This can make the writing of algorithms more complicated when
they need to access a neighbourhood of pixels around each pixel of
interest, since the size of this extra window must be taken into
account, leading to overlapping regions of interests. Nothing that
cannot be solved, but that requires some additional thinking that
distracts from the followed main purpose.</p>
<p>The proposed addition of this RFC is to make the image data appear as a
single array accessed with a pointer, without being limited by the size
of RAM with respect to the size of the dataset (excepted limitations
imposed by the CPU architecture and the operating system)</p>
<div class="section" id="technical-solution">
<h3>Technical solution<a class="headerlink" href="#technical-solution" title="Permalink to this headline">¶</a></h3>
<div class="section" id="low-level-machinery-cpl-virtualmem-h">
<h4>Low-level machinery : cpl_virtualmem.h<a class="headerlink" href="#low-level-machinery-cpl-virtualmem-h" title="Permalink to this headline">¶</a></h4>
<p>The low-level machinery to support this new capability is a
CPLVirtualMem object that represents an area of virtual memory ( on
Linux, an area of virtual memory allocated by the mmap() function ).
This virtual memory area is initially just reserved in terms of virtual
memory space, but has no actual allocation in physical memory. This
reserved virtual memory space is protected with an access permission
that cause any attempt to access it to result in an exception - a page
fault, that on POSIX systems triggers a SIGSEGV signal (segmentation
fault). Fortunately, segmentation faults can be caught by the software
with a signal handler. When such a segmentation fault occurs, our
specialized signal handler will check if it occurs in a virtual memory
region under its responsibility and, if so, it will proceed to fill the
part (a “page”) of the virtual memory area that has been accessed with
sensible values (thanks to a user provided callback). It will then set
appropriate permissions to the page (read-only or read-write), before
attempting again the instruction that triggered the segmentation fault.
From the point of view of the user code that accesses the memory
mapping, this is completely transparent, and this is equivalent as if
the whole virtual memory area had been filled from the start.</p>
<p>For very large mappings that are larger than RAM, this would still cause
disk swapping to occur at a certain point. To avoid that, the
segmentation fault handler will evict the least recently used pages,
once a threshold defined at the creation of the CPLVirtualMem object has
been reached.</p>
<p>For write support, another callback can be passed. It will be called
before a page is evicted so that user code has a chance to flush its
content to a more persistent storage.</p>
<p>We also offer an alternative way of creating a CPLVirtualMem object, by
using memory file mapping mechanisms. This may be used by “raw” datasets
(EHdr driver for example) where the organization of data on disk
directly matches the organization of a in-memory array.</p>
</div>
<div class="section" id="high-level-usage">
<h4>High-level usage<a class="headerlink" href="#high-level-usage" title="Permalink to this headline">¶</a></h4>
<p>Four new API are introduced (detailed in further section):</p>
<ul class="simple">
<li><p>GDALDatasetGetVirtualMem() : takes almost the same arguments as
GDALDatasetRasterIO(), with the notable exception of a pData buffer.
It returns a CPLVirtualMem* object, from which the base address of
the virtual memory mapping can be obtained with
CPLVirtualMemGetAddr().</p></li>
</ul>
<img alt="../../_images/rfc_2d_array.png" src="../../_images/rfc_2d_array.png" />
<ul class="simple">
<li><p>GDALRasterBandGetVirtualMem(): equivalent of
GDALDatasetGetVirtualMem() that operates on a raster band object
rather than a dataset object.</p></li>
<li><p>GDALDatasetGetTiledVirtualMem(): this is a rather original API.
Instead of presenting a 2D view of the image data (i.e. organized
rows by rows), the mapping exposes it as an array of tiles, which is
more suitable, performance wise, when the dataset is itself tiled.</p></li>
</ul>
<img alt="../../_images/rfc_tiled.png" src="../../_images/rfc_tiled.png" />
<p>When they are several bands, 3 different organizations of band
components are possible. To the best of our knowledge, there is no
standard way of calling those organizations, which consequently will be
best illustrated by the following schemas :</p>
<ul class="simple">
<li><p>TIP / Tile Interleaved by Pixel</p></li>
</ul>
<img alt="TIP / Tile Interleaved by Pixel" src="../../_images/rfc_TIP.png" />
<ul class="simple">
<li><p>BIT / Band Interleaved by Tile</p></li>
</ul>
<img alt="BIT / Band Interleaved by Tile" src="../../_images/rfc_BIT.png" />
<ul class="simple">
<li><p>BSQ / Band SeQuential organization</p></li>
</ul>
<img alt="BSQ / Band SeQuential organization" src="../../_images/rfc_BSQ.png" />
<ul class="simple">
<li><p>GDALRasterBandGetTiledVirtualMem(): equivalent of
GDALDatasetGetTiledVirtualMem() that operates on a raster band object
rather than a dataset object.</p></li>
<li><p>GDALGetVirtualMemAuto(): simplified version of
GDALRasterBandGetVirtualMem() where the user only specifies the
access mode. The pixel spacing and line spacing are returned by the
function. This is implemented as a virtual method at the
GDALRasterBand level, so that drivers have a chance of overriding the
base implementation. The base implementation justs uses
GDALRasterBandGetVirtualMem(). Overridden implementation may use the
memory file mapping mechanism instead. Such implementations will be
done in the RawRasterBand object and in the GeoTIFF driver.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="details-of-new-api">
<h2>Details of new API<a class="headerlink" href="#details-of-new-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="implemented-by-cpl-virtualmem-cpp">
<span id="implemented-by-cpl-virtualmemcpp"></span><h3>Implemented by cpl_virtualmem.cpp<a class="headerlink" href="#implemented-by-cpl-virtualmem-cpp" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/**
 * \file cpl_virtualmem.h
 *
 * Virtual memory management.
 *
 * This file provides mechanism to define virtual memory mappings, whose content
 * is allocated transparently and filled on-the-fly. Those virtual memory mappings
 * can be much larger than the available RAM, but only parts of the virtual
 * memory mapping, in the limit of the allowed the cache size, will actually be
 * physically allocated.
 *
 * This exploits low-level mechanisms of the operating system (virtual memory
 * allocation, page protection and handler of virtual memory exceptions).
 *
 * It is also possible to create a virtual memory mapping from a file or part
 * of a file.
 *
 * The current implementation is Linux only.
 */

/** Opaque type that represents a virtual memory mapping. */
typedef struct CPLVirtualMem CPLVirtualMem;

/** Callback triggered when a still unmapped page of virtual memory is accessed.
  * The callback has the responsibility of filling the page with relevant values
  *
  * @param ctxt virtual memory handle.
  * @param nOffset offset of the page in the memory mapping.
  * @param pPageToFill address of the page to fill. Note that the address might
  *                    be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.
  * @param nToFill number of bytes of the page.
  * @param pUserData user data that was passed to CPLVirtualMemNew().
  */
typedef void (*CPLVirtualMemCachePageCbk)(CPLVirtualMem* ctxt,
                                    size_t nOffset,
                                    void* pPageToFill,
                                    size_t nToFill,
                                    void* pUserData);

/** Callback triggered when a dirty mapped page is going to be freed.
  * (saturation of cache, or termination of the virtual memory mapping).
  *
  * @param ctxt virtual memory handle.
  * @param nOffset offset of the page in the memory mapping.
  * @param pPageToBeEvicted address of the page that will be flushed. Note that the address might
  *                    be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.
  * @param nToBeEvicted number of bytes of the page.
  * @param pUserData user data that was passed to CPLVirtualMemNew().
  */
typedef void (*CPLVirtualMemUnCachePageCbk)(CPLVirtualMem* ctxt,
                                      size_t nOffset,
                                      const void* pPageToBeEvicted,
                                      size_t nToBeEvicted,
                                      void* pUserData);

/** Callback triggered when a virtual memory mapping is destroyed.
  * @param pUserData user data that was passed to CPLVirtualMemNew().
 */
typedef void (*CPLVirtualMemFreeUserData)(void* pUserData);

/** Access mode of a virtual memory mapping. */
typedef enum
{
    /*! The mapping is meant at being read-only, but writes will not be prevented.
        Note that any content written will be lost. */
    VIRTUALMEM_READONLY,
    /*! The mapping is meant at being read-only, and this will be enforced
        through the operating system page protection mechanism. */
    VIRTUALMEM_READONLY_ENFORCED,
    /*! The mapping is meant at being read-write, and modified pages can be saved
        thanks to the pfnUnCachePage callback */
    VIRTUALMEM_READWRITE
} CPLVirtualMemAccessMode;


/** Return the size of a page of virtual memory.
 *
 * @return the page size.
 *
 * @since GDAL 1.11
 */
size_t CPL_DLL CPLGetPageSize(void);

/** Create a new virtual memory mapping.
 *
 * This will reserve an area of virtual memory of size nSize, whose size
 * might be potentially much larger than the physical memory available. Initially,
 * no physical memory will be allocated. As soon as memory pages will be accessed,
 * they will be allocated transparently and filled with the pfnCachePage callback.
 * When the allowed cache size is reached, the least recently used pages will
 * be unallocated.
 *
 * On Linux AMD64 platforms, the maximum value for nSize is 128 TB.
 * On Linux x86 platforms, the maximum value for nSize is 2 GB.
 *
 * Only supported on Linux for now.
 *
 * Note that on Linux, this function will install a SIGSEGV handler. The
 * original handler will be restored by CPLVirtualMemManagerTerminate().
 *
 * @param nSize size in bytes of the virtual memory mapping.
 * @param nCacheSize   size in bytes of the maximum memory that will be really
 *                     allocated (must ideally fit into RAM).
 * @param nPageSizeHint hint for the page size. Must be a multiple of the
 *                      system page size, returned by CPLGetPageSize().
 *                      Minimum value is generally 4096. Might be set to 0 to
 *                      let the function determine a default page size.
 * @param bSingleThreadUsage set to TRUE if there will be no concurrent threads
 *                           that will access the virtual memory mapping. This can
 *                           optimize performance a bit.
 * @param eAccessMode permission to use for the virtual memory mapping.
 * @param pfnCachePage callback triggered when a still unmapped page of virtual
 *                     memory is accessed. The callback has the responsibility
 *                     of filling the page with relevant values.
 * @param pfnUnCachePage callback triggered when a dirty mapped page is going to
 *                       be freed (saturation of cache, or termination of the
 *                       virtual memory mapping). Might be NULL.
 * @param pfnFreeUserData callback that can be used to free pCbkUserData. Might be
 *                        NULL
 * @param pCbkUserData user data passed to pfnCachePage and pfnUnCachePage.
 *
 * @return a virtual memory object that must be freed by CPLVirtualMemFree(),
 *         or NULL in case of failure.
 *
 * @since GDAL 1.11
 */

CPLVirtualMem CPL_DLL *CPLVirtualMemNew(size_t nSize,
                                        size_t nCacheSize,
                                        size_t nPageSizeHint,
                                        int bSingleThreadUsage,
                                        CPLVirtualMemAccessMode eAccessMode,
                                        CPLVirtualMemCachePageCbk pfnCachePage,
                                        CPLVirtualMemUnCachePageCbk pfnUnCachePage,
                                        CPLVirtualMemFreeUserData pfnFreeUserData,
                                        void *pCbkUserData);


/** Return if virtual memory mapping of a file is available.
 *
 * @return TRUE if virtual memory mapping of a file is available.
 * @since GDAL 1.11
 */
int CPL_DLL CPLIsVirtualMemFileMapAvailable(void);

/** Create a new virtual memory mapping from a file.
 *
 * The file must be a &quot;real&quot; file recognized by the operating system, and not
 * a VSI extended virtual file.
 *
 * In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written
 * in the file.
 *
 * On Linux AMD64 platforms, the maximum value for nLength is 128 TB.
 * On Linux x86 platforms, the maximum value for nLength is 2 GB.
 *
 * Only supported on Linux for now.
 *
 * @param  fp       Virtual file handle.
 * @param  nOffset  Offset in the file to start the mapping from.
 * @param  nLength  Length of the portion of the file to map into memory.
 * @param eAccessMode Permission to use for the virtual memory mapping. This must
 *                    be consistent with how the file has been opened.
 * @param pfnFreeUserData callback that is called when the object is destroyed.
 * @param pCbkUserData user data passed to pfnFreeUserData.
 * @return a virtual memory object that must be freed by CPLVirtualMemFree(),
 *         or NULL in case of failure.
 *
 * @since GDAL 1.11
 */
CPLVirtualMem CPL_DLL *CPLVirtualMemFileMapNew( VSILFILE* fp,
                                                vsi_l_offset nOffset,
                                                vsi_l_offset nLength,
                                                CPLVirtualMemAccessMode eAccessMode,
                                                CPLVirtualMemFreeUserData pfnFreeUserData,
                                                void *pCbkUserData );

/** Create a new virtual memory mapping derived from an other virtual memory
 *  mapping.
 *
 * This may be useful in case of creating mapping for pixel interleaved data.
 *
 * The new mapping takes a reference on the base mapping.
 *
 * @param pVMemBase Base virtual memory mapping
 * @param nOffset   Offset in the base virtual memory mapping from which to start
 *                  the new mapping.
 * @param nSize     Size of the base virtual memory mapping to expose in the
 *                  the new mapping.
 * @param pfnFreeUserData callback that is called when the object is destroyed.
 * @param pCbkUserData user data passed to pfnFreeUserData.
 * @return a virtual memory object that must be freed by CPLVirtualMemFree(),
 *         or NULL in case of failure.
 *
 * @since GDAL 1.11
 */
CPLVirtualMem CPL_DLL *CPLVirtualMemDerivedNew(CPLVirtualMem* pVMemBase,
                                               vsi_l_offset nOffset,
                                               vsi_l_offset nSize,
                                               CPLVirtualMemFreeUserData pfnFreeUserData,
                                               void *pCbkUserData);

/** Free a virtual memory mapping.
 *
 * The pointer returned by CPLVirtualMemGetAddr() will no longer be valid.
 * If the virtual memory mapping was created with read/write permissions and that
 * they are dirty (i.e. modified) pages, they will be flushed through the
 * pfnUnCachePage callback before being freed.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 *
 * @since GDAL 1.11
 */
void CPL_DLL CPLVirtualMemFree(CPLVirtualMem* ctxt);

/** Return the pointer to the start of a virtual memory mapping.
 *
 * The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer
 * returned by this function will be valid, until CPLVirtualMemFree() is called.
 *
 * Note that if a range of bytes used as an argument of a system call
 * (such as read() or write()) contains pages that have not been &quot;realized&quot;, the
 * system call will fail with EFAULT. CPLVirtualMemPin() can be used to work
 * around this issue.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 * @return the pointer to the start of a virtual memory mapping.
 *
 * @since GDAL 1.11
 */
void CPL_DLL *CPLVirtualMemGetAddr(CPLVirtualMem* ctxt);

/** Return the size of the virtual memory mapping.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 * @return the size of the virtual memory mapping.
 *
 * @since GDAL 1.11
 */
size_t CPL_DLL CPLVirtualMemGetSize(CPLVirtualMem* ctxt);

/** Return if the virtal memory mapping is a direct file mapping.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 * @return TRUE if the virtal memory mapping is a direct file mapping.
 *
 * @since GDAL 1.11
 */
int CPL_DLL CPLVirtualMemIsFileMapping(CPLVirtualMem* ctxt);

/** Return the access mode of the virtual memory mapping.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 * @return the access mode of the virtual memory mapping.
 *
 * @since GDAL 1.11
 */
CPLVirtualMemAccessMode CPL_DLL CPLVirtualMemGetAccessMode(CPLVirtualMem* ctxt);

/** Return the page size associated to a virtual memory mapping.
 *
 * The value returned will be at least CPLGetPageSize(), but potentially
 * larger.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 * @return the page size
 *
 * @since GDAL 1.11
 */
size_t CPL_DLL CPLVirtualMemGetPageSize(CPLVirtualMem* ctxt);

/** Return TRUE if this memory mapping can be accessed safely from concurrent
 *  threads.
 *
 * The situation that can cause problems is when several threads try to access
 * a page of the mapping that is not yet mapped.
 *
 * The return value of this function depends on whether bSingleThreadUsage has
 * been set of not in CPLVirtualMemNew() and/or the implementation.
 *
 * On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 * @return TRUE if this memory mapping can be accessed safely from concurrent
 *         threads.
 *
 * @since GDAL 1.11
 */
int CPL_DLL CPLVirtualMemIsAccessThreadSafe(CPLVirtualMem* ctxt);

/** Declare that a thread will access a virtual memory mapping.
 *
 * This function must be called by a thread that wants to access the
 * content of a virtual memory mapping, except if the virtual memory mapping has
 * been created with bSingleThreadUsage = TRUE.
 *
 * This function must be paired with CPLVirtualMemUnDeclareThread().
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 *
 * @since GDAL 1.11
 */
void CPL_DLL CPLVirtualMemDeclareThread(CPLVirtualMem* ctxt);

/** Declare that a thread will stop accessing a virtual memory mapping.
 *
 * This function must be called by a thread that will no longer access the
 * content of a virtual memory mapping, except if the virtual memory mapping has
 * been created with bSingleThreadUsage = TRUE.
 *
 * This function must be paired with CPLVirtualMemDeclareThread().
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 *
 * @since GDAL 1.11
 */
void CPL_DLL CPLVirtualMemUnDeclareThread(CPLVirtualMem* ctxt);

/** Make sure that a region of virtual memory will be realized.
 *
 * Calling this function is not required, but might be useful when debugging
 * a process with tools like gdb or valgrind that do not naturally like
 * segmentation fault signals.
 *
 * It is also needed when wanting to provide part of virtual memory mapping
 * to a system call such as read() or write(). If read() or write() is called
 * on a memory region not yet realized, the call will fail with EFAULT.
 *
 * @param ctxt context returned by CPLVirtualMemNew().
 * @param pAddr the memory region to pin.
 * @param nSize the size of the memory region.
 * @param bWriteOp set to TRUE if the memory are will be accessed in write mode.
 *
 * @since GDAL 1.11
 */
void CPL_DLL CPLVirtualMemPin(CPLVirtualMem* ctxt,
                              void* pAddr, size_t nSize, int bWriteOp);

/** Cleanup any resource and handlers related to virtual memory.
 *
 * This function must be called after the last CPLVirtualMem object has
 * been freed.
 *
 * @since GDAL 1.11
 */
void CPL_DLL CPLVirtualMemManagerTerminate(void);
</pre></div>
</div>
</div>
<div class="section" id="implemented-by-gdalvirtualmem-cpp">
<span id="implemented-by-gdalvirtualmemcpp"></span><h3>Implemented by gdalvirtualmem.cpp<a class="headerlink" href="#implemented-by-gdalvirtualmem-cpp" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/** Create a CPLVirtualMem object from a GDAL dataset object.
 *
 * Only supported on Linux for now.
 *
 * This method allows creating a virtual memory object for a region of one
 * or more GDALRasterBands from  this dataset. The content of the virtual
 * memory object is automatically filled from dataset content when a virtual
 * memory page is first accessed, and it is released (or flushed in case of a
 * &quot;dirty&quot; page) when the cache size limit has been reached.
 *
 * The pointer to access the virtual memory object is obtained with
 * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is called.
 * CPLVirtualMemFree() must be called before the dataset object is destroyed.
 *
 * If p is such a pointer and base_type the C type matching eBufType, for default
 * values of spacing parameters, the element of image coordinates (x, y)
 * (relative to xOff, yOff) for band b can be accessed with
 * ((base_type*)p)[x + y * nBufXSize + (b-1)*nBufXSize*nBufYSize].
 *
 * Note that the mechanism used to transparently fill memory pages when they are
 * accessed is the same (but in a controlled way) than what occurs when a memory
 * error occurs in a program. Debugging software will generally interrupt program
 * execution when that happens. If needed, CPLVirtualMemPin() can be used to avoid
 * that by ensuring memory pages are allocated before being accessed.
 *
 * The size of the region that can be mapped as a virtual memory object depends
 * on hardware and operating system limitations.
 * On Linux AMD64 platforms, the maximum value is 128 TB.
 * On Linux x86 platforms, the maximum value is 2 GB.
 *
 * Data type translation is automatically done if the data type
 * (eBufType) of the buffer is different than
 * that of the GDALRasterBand.
 *
 * Image decimation / replication is currently not supported, i.e. if the
 * size of the region being accessed (nXSize x nYSize) is different from the
 * buffer size (nBufXSize x nBufYSize).
 *
 * The nPixelSpace, nLineSpace and nBandSpace parameters allow reading into or
 * writing from various organization of buffers. Arbitrary values for the spacing
 * parameters are not supported. Those values must be multiple of the size of the
 * buffer data type, and must be either band sequential organization (typically
 * nPixelSpace = GDALGetDataTypeSize(eBufType) / 8, nLineSpace = nPixelSpace * nBufXSize,
 * nBandSpace = nLineSpace * nBufYSize), or pixel-interleaved organization
 * (typically nPixelSpace = nBandSpace * nBandCount, nLineSpace = nPixelSpace * nBufXSize,
 * nBandSpace = GDALGetDataTypeSize(eBufType) / 8)
 *
 * @param hDS Dataset object
 *
 * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to
 * write a region of data.
 *
 * @param nXOff The pixel offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the left side.
 *
 * @param nYOff The line offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the top.
 *
 * @param nXSize The width of the region of the band to be accessed in pixels.
 *
 * @param nYSize The height of the region of the band to be accessed in lines.
 *
 * @param nBufXSize the width of the buffer image into which the desired region
 * is to be read, or from which it is to be written.
 *
 * @param nBufYSize the height of the buffer image into which the desired
 * region is to be read, or from which it is to be written.
 *
 * @param eBufType the type of the pixel values in the data buffer. The
 * pixel values will automatically be translated to/from the GDALRasterBand
 * data type as needed.
 *
 * @param nBandCount the number of bands being read or written.
 *
 * @param panBandMap the list of nBandCount band numbers being read/written.
 * Note band numbers are 1 based. This may be NULL to select the first
 * nBandCount bands.
 *
 * @param nPixelSpace The byte offset from the start of one pixel value in
 * the buffer to the start of the next pixel value within a scanline. If defaulted
 * (0) the size of the datatype eBufType is used.
 *
 * @param nLineSpace The byte offset from the start of one scanline in
 * the buffer to the start of the next. If defaulted (0) the size of the datatype
 * eBufType * nBufXSize is used.
 *
 * @param nBandSpace the byte offset from the start of one bands data to the
 * start of the next. If defaulted (0) the value will be
 * nLineSpace * nBufYSize implying band sequential organization
 * of the data buffer.
 *
 * @param nCacheSize   size in bytes of the maximum memory that will be really
 *                     allocated (must ideally fit into RAM)
 *
 * @param nPageSizeHint hint for the page size. Must be a multiple of the
 *                      system page size, returned by CPLGetPageSize().
 *                      Minimum value is generally 4096. Might be set to 0 to
 *                      let the function determine a default page size.
 *
 * @param bSingleThreadUsage set to TRUE if there will be no concurrent threads
 *                           that will access the virtual memory mapping. This can
 *                           optimize performance a bit. If set to FALSE,
 *                           CPLVirtualMemDeclareThread() must be called.
 *
 * @param papszOptions NULL terminated list of options. Unused for now.
 *
 * @return a virtual memory object that must be freed by CPLVirtualMemFree(),
 *         or NULL in case of failure.
 *
 * @since GDAL 1.11
 */

CPLVirtualMem CPL_DLL* GDALDatasetGetVirtualMem( GDALDatasetH hDS,
                                         GDALRWFlag eRWFlag,
                                         int nXOff, int nYOff,
                                         int nXSize, int nYSize,
                                         int nBufXSize, int nBufYSize,
                                         GDALDataType eBufType,
                                         int nBandCount, int* panBandMap,
                                         int nPixelSpace,
                                         GIntBig nLineSpace,
                                         GIntBig nBandSpace,
                                         size_t nCacheSize,
                                         size_t nPageSizeHint,
                                         int bSingleThreadUsage,
                                         char **papszOptions );

** Create a CPLVirtualMem object from a GDAL raster band object.
 *
 * Only supported on Linux for now.
 *
 * This method allows creating a virtual memory object for a region of a
 * GDALRasterBand. The content of the virtual
 * memory object is automatically filled from dataset content when a virtual
 * memory page is first accessed, and it is released (or flushed in case of a
 * &quot;dirty&quot; page) when the cache size limit has been reached.
 *
 * The pointer to access the virtual memory object is obtained with
 * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is called.
 * CPLVirtualMemFree() must be called before the raster band object is destroyed.
 *
 * If p is such a pointer and base_type the C type matching eBufType, for default
 * values of spacing parameters, the element of image coordinates (x, y)
 * (relative to xOff, yOff) can be accessed with
 * ((base_type*)p)[x + y * nBufXSize].
 *
 * Note that the mechanism used to transparently fill memory pages when they are
 * accessed is the same (but in a controlled way) than what occurs when a memory
 * error occurs in a program. Debugging software will generally interrupt program
 * execution when that happens. If needed, CPLVirtualMemPin() can be used to avoid
 * that by ensuring memory pages are allocated before being accessed.
 *
 * The size of the region that can be mapped as a virtual memory object depends
 * on hardware and operating system limitations.
 * On Linux AMD64 platforms, the maximum value is 128 TB.
 * On Linux x86 platforms, the maximum value is 2 GB.
 *
 * Data type translation is automatically done if the data type
 * (eBufType) of the buffer is different than
 * that of the GDALRasterBand.
 *
 * Image decimation / replication is currently not supported, i.e. if the
 * size of the region being accessed (nXSize x nYSize) is different from the
 * buffer size (nBufXSize x nBufYSize).
 *
 * The nPixelSpace and nLineSpace parameters allow reading into or
 * writing from various organization of buffers. Arbitrary values for the spacing
 * parameters are not supported. Those values must be multiple of the size of the
 * buffer data type and must be such that nLineSpace &gt;= nPixelSpace * nBufXSize.
 *
 * @param hBand Rasterband object
 *
 * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to
 * write a region of data.
 *
 * @param nXOff The pixel offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the left side.
 *
 * @param nYOff The line offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the top.
 *
 * @param nXSize The width of the region of the band to be accessed in pixels.
 *
 * @param nYSize The height of the region of the band to be accessed in lines.
 *
 * @param nBufXSize the width of the buffer image into which the desired region
 * is to be read, or from which it is to be written.
 *
 * @param nBufYSize the height of the buffer image into which the desired
 * region is to be read, or from which it is to be written.
 *
 * @param eBufType the type of the pixel values in the data buffer. The
 * pixel values will automatically be translated to/from the GDALRasterBand
 * data type as needed.
 *
 * @param nPixelSpace The byte offset from the start of one pixel value in
 * the buffer to the start of the next pixel value within a scanline. If defaulted
 * (0) the size of the datatype eBufType is used.
 *
 * @param nLineSpace The byte offset from the start of one scanline in
 * the buffer to the start of the next. If defaulted (0) the size of the datatype
 * eBufType * nBufXSize is used.
 *
 * @param nCacheSize   size in bytes of the maximum memory that will be really
 *                     allocated (must ideally fit into RAM)
 *
 * @param nPageSizeHint hint for the page size. Must be a multiple of the
 *                      system page size, returned by CPLGetPageSize().
 *                      Minimum value is generally 4096. Might be set to 0 to
 *                      let the function determine a default page size.
 *
 * @param bSingleThreadUsage set to TRUE if there will be no concurrent threads
 *                           that will access the virtual memory mapping. This can
 *                           optimize performance a bit. If set to FALSE,
 *                           CPLVirtualMemDeclareThread() must be called.
 *
 * @param papszOptions NULL terminated list of options. Unused for now.
 *
 * @return a virtual memory object that must be freed by CPLVirtualMemFree(),
 *         or NULL in case of failure.
 *
 * @since GDAL 1.11
 */

CPLVirtualMem CPL_DLL* GDALRasterBandGetVirtualMem( GDALRasterBandH hBand,
                                         GDALRWFlag eRWFlag,
                                         int nXOff, int nYOff,
                                         int nXSize, int nYSize,
                                         int nBufXSize, int nBufYSize,
                                         GDALDataType eBufType,
                                         int nPixelSpace,
                                         GIntBig nLineSpace,
                                         size_t nCacheSize,
                                         size_t nPageSizeHint,
                                         int bSingleThreadUsage,
                                         char **papszOptions );

typedef enum
{
    /*! Tile Interleaved by Pixel: tile (0,0) with internal band interleaved
        by pixel organization, tile (1, 0), ...  */
    GTO_TIP,
    /*! Band Interleaved by Tile : tile (0,0) of first band, tile (0,0) of second
        band, ... tile (1,0) of first band, tile (1,0) of second band, ... */
    GTO_BIT,
    /*! Band SeQuential : all the tiles of first band, all the tiles of following band... */
    GTO_BSQ
} GDALTileOrganization;

/** Create a CPLVirtualMem object from a GDAL dataset object, with tiling
 * organization
 *
 * Only supported on Linux for now.
 *
 * This method allows creating a virtual memory object for a region of one
 * or more GDALRasterBands from  this dataset. The content of the virtual
 * memory object is automatically filled from dataset content when a virtual
 * memory page is first accessed, and it is released (or flushed in case of a
 * &quot;dirty&quot; page) when the cache size limit has been reached.
 *
 * Contrary to GDALDatasetGetVirtualMem(), pixels will be organized by tiles
 * instead of scanlines. Different ways of organizing pixel within/across tiles
 * can be selected with the eTileOrganization parameter.
 *
 * If nXSize is not a multiple of nTileXSize or nYSize is not a multiple of
 * nTileYSize, partial tiles will exists at the right and/or bottom of the region
 * of interest. Those partial tiles will also have nTileXSize * nTileYSize dimension,
 * with padding pixels.
 *
 * The pointer to access the virtual memory object is obtained with
 * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is called.
 * CPLVirtualMemFree() must be called before the dataset object is destroyed.
 *
 * If p is such a pointer and base_type the C type matching eBufType, for default
 * values of spacing parameters, the element of image coordinates (x, y)
 * (relative to xOff, yOff) for band b can be accessed with :
 *  - for eTileOrganization = GTO_TIP, ((base_type*)p)[tile_number(x,y)*nBandCount*tile_size + offset_in_tile(x,y)*nBandCount + (b-1)].
 *  - for eTileOrganization = GTO_BIT, ((base_type*)p)[(tile_number(x,y)*nBandCount + (b-1)) * tile_size + offset_in_tile(x,y)].
 *  - for eTileOrganization = GTO_BSQ, ((base_type*)p)[(tile_number(x,y) + (b-1)*nTilesCount) * tile_size + offset_in_tile(x,y)].
 *
 * where nTilesPerRow = ceil(nXSize / nTileXSize)
 *       nTilesPerCol = ceil(nYSize / nTileYSize)
 *       nTilesCount = nTilesPerRow * nTilesPerCol
 *       tile_number(x,y) = (y / nTileYSize) * nTilesPerRow + (x / nTileXSize)
 *       offset_in_tile(x,y) = (y % nTileYSize) * nTileXSize  + (x % nTileXSize)
 *       tile_size = nTileXSize * nTileYSize
 *
 * Note that for a single band request, all tile organizations are equivalent.
 *
 * Note that the mechanism used to transparently fill memory pages when they are
 * accessed is the same (but in a controlled way) than what occurs when a memory
 * error occurs in a program. Debugging software will generally interrupt program
 * execution when that happens. If needed, CPLVirtualMemPin() can be used to avoid
 * that by ensuring memory pages are allocated before being accessed.
 *
 * The size of the region that can be mapped as a virtual memory object depends
 * on hardware and operating system limitations.
 * On Linux AMD64 platforms, the maximum value is 128 TB.
 * On Linux x86 platforms, the maximum value is 2 GB.
 *
 * Data type translation is automatically done if the data type
 * (eBufType) of the buffer is different than
 * that of the GDALRasterBand.
 *
 * @param hDS Dataset object
 *
 * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to
 * write a region of data.
 *
 * @param nXOff The pixel offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the left side.
 *
 * @param nYOff The line offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the top.
 *
 * @param nXSize The width of the region of the band to be accessed in pixels.
 *
 * @param nYSize The height of the region of the band to be accessed in lines.
 *
 * @param nTileXSize the width of the tiles.
 *
 * @param nTileYSize the height of the tiles.
 *
 * @param eBufType the type of the pixel values in the data buffer. The
 * pixel values will automatically be translated to/from the GDALRasterBand
 * data type as needed.
 *
 * @param nBandCount the number of bands being read or written.
 *
 * @param panBandMap the list of nBandCount band numbers being read/written.
 * Note band numbers are 1 based. This may be NULL to select the first
 * nBandCount bands.
 *
 * @param eTileOrganization tile organization.
 *
 * @param nCacheSize   size in bytes of the maximum memory that will be really
 *                     allocated (must ideally fit into RAM)
 *
 * @param bSingleThreadUsage set to TRUE if there will be no concurrent threads
 *                           that will access the virtual memory mapping. This can
 *                           optimize performance a bit. If set to FALSE,
 *                           CPLVirtualMemDeclareThread() must be called.
 *
 * @param papszOptions NULL terminated list of options. Unused for now.
 *
 * @return a virtual memory object that must be freed by CPLVirtualMemFree(),
 *         or NULL in case of failure.
 *
 * @since GDAL 1.11
 */

CPLVirtualMem CPL_DLL* GDALDatasetGetTiledVirtualMem( GDALDatasetH hDS,
                                              GDALRWFlag eRWFlag,
                                              int nXOff, int nYOff,
                                              int nXSize, int nYSize,
                                              int nTileXSize, int nTileYSize,
                                              GDALDataType eBufType,
                                              int nBandCount, int* panBandMap,
                                              GDALTileOrganization eTileOrganization,
                                              size_t nCacheSize,
                                              int bSingleThreadUsage,
                                              char **papszOptions );

/** Create a CPLVirtualMem object from a GDAL rasterband object, with tiling
 * organization
 *
 * Only supported on Linux for now.
 *
 * This method allows creating a virtual memory object for a region of one
 * GDALRasterBand. The content of the virtual
 * memory object is automatically filled from dataset content when a virtual
 * memory page is first accessed, and it is released (or flushed in case of a
 * &quot;dirty&quot; page) when the cache size limit has been reached.
 *
 * Contrary to GDALDatasetGetVirtualMem(), pixels will be organized by tiles
 * instead of scanlines.
 *
 * If nXSize is not a multiple of nTileXSize or nYSize is not a multiple of
 * nTileYSize, partial tiles will exists at the right and/or bottom of the region
 * of interest. Those partial tiles will also have nTileXSize * nTileYSize dimension,
 * with padding pixels.
 *
 * The pointer to access the virtual memory object is obtained with
 * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is called.
 * CPLVirtualMemFree() must be called before the raster band object is destroyed.
 *
 * If p is such a pointer and base_type the C type matching eBufType, for default
 * values of spacing parameters, the element of image coordinates (x, y)
 * (relative to xOff, yOff) can be accessed with :
 *  ((base_type*)p)[tile_number(x,y)*tile_size + offset_in_tile(x,y)].
 *
 * where nTilesPerRow = ceil(nXSize / nTileXSize)
 *       nTilesCount = nTilesPerRow * nTilesPerCol
 *       tile_number(x,y) = (y / nTileYSize) * nTilesPerRow + (x / nTileXSize)
 *       offset_in_tile(x,y) = (y % nTileYSize) * nTileXSize  + (x % nTileXSize)
 *       tile_size = nTileXSize * nTileYSize
 *
 * Note that the mechanism used to transparently fill memory pages when they are
 * accessed is the same (but in a controlled way) than what occurs when a memory
 * error occurs in a program. Debugging software will generally interrupt program
 * execution when that happens. If needed, CPLVirtualMemPin() can be used to avoid
 * that by ensuring memory pages are allocated before being accessed.
 *
 * The size of the region that can be mapped as a virtual memory object depends
 * on hardware and operating system limitations.
 * On Linux AMD64 platforms, the maximum value is 128 TB.
 * On Linux x86 platforms, the maximum value is 2 GB.
 *
 * Data type translation is automatically done if the data type
 * (eBufType) of the buffer is different than
 * that of the GDALRasterBand.
 *
 * @param hBand Rasterband object
 *
 * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to
 * write a region of data.
 *
 * @param nXOff The pixel offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the left side.
 *
 * @param nYOff The line offset to the top left corner of the region
 * of the band to be accessed.  This would be zero to start from the top.
 *
 * @param nXSize The width of the region of the band to be accessed in pixels.
 *
 * @param nYSize The height of the region of the band to be accessed in lines.
 *
 * @param nTileXSize the width of the tiles.
 *
 * @param nTileYSize the height of the tiles.
 *
 * @param eBufType the type of the pixel values in the data buffer. The
 * pixel values will automatically be translated to/from the GDALRasterBand
 * data type as needed.
 *
 * @param nCacheSize   size in bytes of the maximum memory that will be really
 *                     allocated (must ideally fit into RAM)
 *
 * @param bSingleThreadUsage set to TRUE if there will be no concurrent threads
 *                           that will access the virtual memory mapping. This can
 *                           optimize performance a bit. If set to FALSE,
 *                           CPLVirtualMemDeclareThread() must be called.
 *
 * @param papszOptions NULL terminated list of options. Unused for now.
 *
 * @return a virtual memory object that must be freed by CPLVirtualMemFree(),
 *         or NULL in case of failure.
 *
 * @since GDAL 1.11
 */

CPLVirtualMem CPL_DLL* GDALRasterBandGetTiledVirtualMem( GDALRasterBandH hBand,
                                              GDALRWFlag eRWFlag,
                                              int nXOff, int nYOff,
                                              int nXSize, int nYSize,
                                              int nTileXSize, int nTileYSize,
                                              GDALDataType eBufType,
                                              size_t nCacheSize,
                                              int bSingleThreadUsage,
                                              char **papszOptions );
</pre></div>
</div>
</div>
<div class="section" id="implemented-by-gdalrasterband-cpp">
<span id="implemented-by-gdalrasterbandcpp"></span><h3>Implemented by gdalrasterband.cpp<a class="headerlink" href="#implemented-by-gdalrasterband-cpp" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> \<span class="n">brief</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">CPLVirtualMem</span> <span class="nb">object</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">GDAL</span> <span class="n">raster</span> <span class="n">band</span> <span class="nb">object</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">Only</span> <span class="n">supported</span> <span class="n">on</span> <span class="n">Linux</span> <span class="k">for</span> <span class="n">now</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">This</span> <span class="n">method</span> <span class="n">allows</span> <span class="n">creating</span> <span class="n">a</span> <span class="n">virtual</span> <span class="n">memory</span> <span class="nb">object</span> <span class="k">for</span> <span class="n">a</span> <span class="n">GDALRasterBand</span><span class="p">,</span>
 <span class="o">*</span> <span class="n">that</span> <span class="n">exposes</span> <span class="n">the</span> <span class="n">whole</span> <span class="n">image</span> <span class="n">data</span> <span class="k">as</span> <span class="n">a</span> <span class="n">virtual</span> <span class="n">array</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">The</span> <span class="n">default</span> <span class="n">implementation</span> <span class="n">relies</span> <span class="n">on</span> <span class="n">GDALRasterBandGetVirtualMem</span><span class="p">(),</span> <span class="n">but</span> <span class="n">specialized</span>
 <span class="o">*</span> <span class="n">implementation</span><span class="p">,</span> <span class="n">such</span> <span class="k">as</span> <span class="k">for</span> <span class="n">raw</span> <span class="n">files</span><span class="p">,</span> <span class="n">may</span> <span class="n">also</span> <span class="n">directly</span> <span class="n">use</span> <span class="n">mechanisms</span> <span class="n">of</span> <span class="n">the</span>
 <span class="o">*</span> <span class="n">operating</span> <span class="n">system</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">view</span> <span class="n">of</span> <span class="n">the</span> <span class="n">underlying</span> <span class="n">file</span> <span class="n">into</span> <span class="n">virtual</span> <span class="n">memory</span>
 <span class="o">*</span> <span class="p">(</span> <span class="n">CPLVirtualMemFileMapNew</span><span class="p">()</span> <span class="p">)</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">At</span> <span class="n">the</span> <span class="n">time</span> <span class="n">of</span> <span class="n">writing</span><span class="p">,</span> <span class="n">the</span> <span class="n">GeoTIFF</span> <span class="n">driver</span> <span class="ow">and</span> <span class="s2">&quot;raw&quot;</span> <span class="n">drivers</span> <span class="p">(</span><span class="n">EHdr</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="n">offer</span>
 <span class="o">*</span> <span class="n">a</span> <span class="n">specialized</span> <span class="n">implementation</span> <span class="k">with</span> <span class="n">direct</span> <span class="n">file</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">provided</span> <span class="n">that</span> <span class="n">some</span>
 <span class="o">*</span> <span class="n">requirements</span> <span class="n">are</span> <span class="n">met</span> <span class="p">:</span>
 <span class="o">*</span>   <span class="o">-</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">drivers</span><span class="p">,</span> <span class="n">the</span> <span class="n">dataset</span> <span class="n">must</span> <span class="n">be</span> <span class="n">backed</span> <span class="n">by</span> <span class="n">a</span> <span class="s2">&quot;real&quot;</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">file</span>
 <span class="o">*</span>     <span class="n">system</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">byte</span> <span class="n">ordering</span> <span class="n">of</span> <span class="n">multi</span><span class="o">-</span><span class="n">byte</span> <span class="n">datatypes</span> <span class="p">(</span><span class="n">Int16</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span><span class="p">)</span>
 <span class="o">*</span>     <span class="n">must</span> <span class="n">match</span> <span class="n">the</span> <span class="n">native</span> <span class="n">ordering</span> <span class="n">of</span> <span class="n">the</span> <span class="n">CPU</span><span class="o">.</span>
 <span class="o">*</span>   <span class="o">-</span> <span class="ow">in</span> <span class="n">addition</span><span class="p">,</span> <span class="k">for</span> <span class="n">the</span> <span class="n">GeoTIFF</span> <span class="n">driver</span><span class="p">,</span> <span class="n">the</span> <span class="n">GeoTIFF</span> <span class="n">file</span> <span class="n">must</span> <span class="n">be</span> <span class="n">uncompressed</span><span class="p">,</span> <span class="n">scanline</span>
 <span class="o">*</span>     <span class="n">oriented</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span> <span class="ow">not</span> <span class="n">tiled</span><span class="p">)</span><span class="o">.</span> <span class="n">Strips</span> <span class="n">must</span> <span class="n">be</span> <span class="n">organized</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">sequential</span>
 <span class="o">*</span>     <span class="n">order</span><span class="p">,</span> <span class="ow">and</span> <span class="n">be</span> <span class="n">equally</span> <span class="n">spaced</span> <span class="p">(</span><span class="n">which</span> <span class="ow">is</span> <span class="n">generally</span> <span class="n">the</span> <span class="n">case</span><span class="p">)</span><span class="o">.</span> <span class="n">Only</span> <span class="n">power</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">two</span>
 <span class="o">*</span>     <span class="n">bit</span> <span class="n">depths</span> <span class="n">are</span> <span class="n">supported</span> <span class="p">(</span><span class="mi">8</span> <span class="k">for</span> <span class="n">GDT_Bye</span><span class="p">,</span> <span class="mi">16</span> <span class="k">for</span> <span class="n">GDT_Int16</span><span class="o">/</span><span class="n">GDT_UInt16</span><span class="p">,</span>
 <span class="o">*</span>     <span class="mi">32</span> <span class="k">for</span> <span class="n">GDT_Float32</span> <span class="ow">and</span> <span class="mi">64</span> <span class="k">for</span> <span class="n">GDT_Float64</span><span class="p">)</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">The</span> <span class="n">pointer</span> <span class="n">returned</span> <span class="n">remains</span> <span class="n">valid</span> <span class="n">until</span> <span class="n">CPLVirtualMemFree</span><span class="p">()</span> <span class="ow">is</span> <span class="n">called</span><span class="o">.</span>
 <span class="o">*</span> <span class="n">CPLVirtualMemFree</span><span class="p">()</span> <span class="n">must</span> <span class="n">be</span> <span class="n">called</span> <span class="n">before</span> <span class="n">the</span> <span class="n">raster</span> <span class="n">band</span> <span class="nb">object</span> <span class="ow">is</span> <span class="n">destroyed</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">If</span> <span class="n">p</span> <span class="ow">is</span> <span class="n">such</span> <span class="n">a</span> <span class="n">pointer</span> <span class="ow">and</span> <span class="n">base_type</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">matching</span> <span class="n">GDALGetRasterDataType</span><span class="p">(),</span>
 <span class="o">*</span> <span class="n">the</span> <span class="n">element</span> <span class="n">of</span> <span class="n">image</span> <span class="n">coordinates</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">can</span> <span class="n">be</span> <span class="n">accessed</span> <span class="k">with</span>
 <span class="o">*</span> <span class="o">*</span><span class="p">(</span><span class="n">base_type</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">GByte</span><span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="o">*</span><span class="n">pnPixelSpace</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="o">*</span><span class="n">pnLineSpace</span><span class="p">)</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">This</span> <span class="n">method</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">same</span> <span class="k">as</span> <span class="n">the</span> <span class="n">C</span> <span class="n">GDALGetVirtualMemAuto</span><span class="p">()</span> <span class="n">function</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nd">@param</span> <span class="n">eRWFlag</span> <span class="n">Either</span> <span class="n">GF_Read</span> <span class="n">to</span> <span class="n">read</span> <span class="n">the</span> <span class="n">band</span><span class="p">,</span> <span class="ow">or</span> <span class="n">GF_Write</span> <span class="n">to</span>
 <span class="o">*</span> <span class="n">read</span><span class="o">/</span><span class="n">write</span> <span class="n">the</span> <span class="n">band</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nd">@param</span> <span class="n">pnPixelSpace</span> <span class="n">Output</span> <span class="n">parameter</span> <span class="n">giving</span> <span class="n">the</span> <span class="n">byte</span> <span class="n">offset</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">one</span> <span class="n">pixel</span> <span class="n">value</span> <span class="ow">in</span>
 <span class="o">*</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">pixel</span> <span class="n">value</span> <span class="n">within</span> <span class="n">a</span> <span class="n">scanline</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nd">@param</span> <span class="n">pnLineSpace</span> <span class="n">Output</span> <span class="n">parameter</span> <span class="n">giving</span> <span class="n">the</span> <span class="n">byte</span> <span class="n">offset</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">one</span> <span class="n">scanline</span> <span class="ow">in</span>
 <span class="o">*</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">next</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nd">@param</span> <span class="n">papszOptions</span> <span class="n">NULL</span> <span class="n">terminated</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">options</span><span class="o">.</span>
 <span class="o">*</span>                     <span class="n">If</span> <span class="n">a</span> <span class="n">specialized</span> <span class="n">implementation</span> <span class="n">exists</span><span class="p">,</span> <span class="n">defining</span> <span class="n">USE_DEFAULT_IMPLEMENTATION</span><span class="o">=</span><span class="n">YES</span>
 <span class="o">*</span>                     <span class="n">will</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">default</span> <span class="n">implementation</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
 <span class="o">*</span>                     <span class="n">When</span> <span class="n">requiring</span> <span class="ow">or</span> <span class="n">falling</span> <span class="n">back</span> <span class="n">to</span> <span class="n">the</span> <span class="n">default</span> <span class="n">implementation</span><span class="p">,</span> <span class="n">the</span> <span class="n">following</span>
 <span class="o">*</span>                     <span class="n">options</span> <span class="n">are</span> <span class="n">available</span> <span class="p">:</span> <span class="n">CACHE_SIZE</span> <span class="p">(</span><span class="ow">in</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">defaults</span> <span class="n">to</span> <span class="mi">40</span> <span class="n">MB</span><span class="p">),</span>
 <span class="o">*</span>                     <span class="n">PAGE_SIZE_HINT</span> <span class="p">(</span><span class="ow">in</span> <span class="nb">bytes</span><span class="p">),</span>
 <span class="o">*</span>                     <span class="n">SINGLE_THREAD</span> <span class="p">(</span><span class="s2">&quot;FALSE&quot;</span> <span class="o">/</span> <span class="s2">&quot;TRUE&quot;</span><span class="p">,</span> <span class="n">defaults</span> <span class="n">to</span> <span class="n">FALSE</span><span class="p">)</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nd">@return</span> <span class="n">a</span> <span class="n">virtual</span> <span class="n">memory</span> <span class="nb">object</span> <span class="n">that</span> <span class="n">must</span> <span class="n">be</span> <span class="n">unreferenced</span> <span class="n">by</span> <span class="n">CPLVirtualMemFree</span><span class="p">(),</span>
 <span class="o">*</span>         <span class="ow">or</span> <span class="n">NULL</span> <span class="ow">in</span> <span class="n">case</span> <span class="n">of</span> <span class="n">failure</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nd">@since</span> <span class="n">GDAL</span> <span class="mf">1.11</span>
 <span class="o">*/</span>

<span class="n">CPLVirtualMem</span>  <span class="o">*</span><span class="n">GDALRasterBand</span><span class="p">::</span><span class="n">GetVirtualMemAuto</span><span class="p">(</span> <span class="n">GDALRWFlag</span> <span class="n">eRWFlag</span><span class="p">,</span>
                                                   <span class="nb">int</span> <span class="o">*</span><span class="n">pnPixelSpace</span><span class="p">,</span>
                                                   <span class="n">GIntBig</span> <span class="o">*</span><span class="n">pnLineSpace</span><span class="p">,</span>
                                                   <span class="n">char</span> <span class="o">**</span><span class="n">papszOptions</span> <span class="p">):</span>

<span class="n">CPLVirtualMem</span> <span class="n">CPL_DLL</span><span class="o">*</span> <span class="n">GDALGetVirtualMemAuto</span><span class="p">(</span> <span class="n">GDALRasterBandH</span> <span class="n">hBand</span><span class="p">,</span>
                                              <span class="n">GDALRWFlag</span> <span class="n">eRWFlag</span><span class="p">,</span>
                                              <span class="nb">int</span> <span class="o">*</span><span class="n">pnPixelSpace</span><span class="p">,</span>
                                              <span class="n">GIntBig</span> <span class="o">*</span><span class="n">pnLineSpace</span><span class="p">,</span>
                                              <span class="n">char</span> <span class="o">**</span><span class="n">papszOptions</span> <span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="portability">
<h2>Portability<a class="headerlink" href="#portability" title="Permalink to this headline">¶</a></h2>
<p>The CPLVirtualMem low-level machinery is only implemented for Linux now.
It assumes that returning from a SIGSEGV handler is possible, which is a
blatant violation of POSIX, but in practice it seems that most POSIX
(and non POSIX such as Windows) systems should be able to resume
execution after a segmentation fault.</p>
<p>Porting to other POSIX operating systems such as MacOSX should be doable
with moderate effort. Windows has API that offer similar capabilities as
POSIX API with VirtualAlloc(), VirtualProtect() and
SetUnhandledExceptionFilter(), although the porting would undoubtly
require more effort.</p>
<p>The existence of <a class="reference external" href="http://www.gnu.org/software/libsigsegv">libsigsegv</a>
that run on various OS is an evidence on its capacity of being ported to
other platforms.</p>
<p>The trickiest part is ensuring that things will work reliably when two
concurrent threads that try to access the same initially unmapped page.
Without special care, one thread could manage to access the page that is
being filled by the other thread, before it is completely filled. On
Linux this can be easily avoided with the mremap() call. When a page is
filled, we don’t actually pass the target page to the user callback, but
a temporary page. When the callback has finished its job, this temporary
page is mremap()’ed to its target location, which is an atomic
operation. An alternative implementation for POSIX systems that don’t
have this mremap() call has been tested : any declared threads that can
access the memory mapping are paused before the temporary page is
memcpy’ed to its target location, and are resumed afterwards. This
requires threads to priorly declare their “interest” for a memory
mapping with CPLVirtualMemDeclareThread(). Pausing a thread is
interestingly non-obvious : the solution found to do so is to send it a
SIGUSR1 signal and make it wait in a signal handler for this SIGUSR1
signal… It has not been investigated if/how this could be done on
Windows. CPLVirtualMemIsAccessThreadSafe() has been introduced for that
purpose.</p>
<p>As far as CPLVirtualMemFileMapNew() is concerned, memory file mapping on
POSIX systems with mmap() should be portable. Windows has
CreateFileMapping() and MapViewOfFile() API that have similar
capabilities as mmap().</p>
</div>
<div class="section" id="performance">
<h2>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h2>
<p>No miraculous performance gain should be expected from this new
capability, when compared to code that carefully uses GDALRasterIO().
Handling segmentation faults has a cost ( the operating system catches a
hardware exception, then calls the user program segmentation fault
handler, which does the normal GDAL I/O operations, and plays with page
mappings and permissions which invalidate some CPU caches, etc… ).
However, when a page has been realized, access to it should be really
fast, so with appropriate access patterns and cache size, good
performance should be expected.</p>
<p>It should also be noted that in the current implementation, the
realization of pages is done in a serialized way, that is to say if 2
threads which use 2 different memory mappings cause a segmentation fault
at the same time, they will not be dealt by 2 different threads, but one
after the other one.</p>
<p>The overhead of virtual memory objects returned by GetVirtualMemAuto(),
when using the memory file mapping, should be lesser than the manual
management of page faults. However, GDAL has no control of the strategy
used by the operating system to cache pages.</p>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>The maximum size of the virtual memory space (and thus a virtual memory
mapping) depends on the CPU architecture and OS limitations :</p>
<ul class="simple">
<li><p>on Linux AMD64, 128 TB.</p></li>
<li><p>on Linux x86, 2 GB.</p></li>
<li><p>On Windows AMD64 (unsupported by the current implementation), 8 TB.</p></li>
<li><p>On Windows x86 (unsupported by the current implementation), 2 GB.</p></li>
</ul>
<p>Clearly, the main interest of this new functionality is for AMD64
platforms.</p>
<p>On a Linux AMD64 machine with 4 GB RAM, the Python binding of
GDALDatasetGetTiledVirtualMem() has been successfully used to access
random points on the new <a class="reference external" href="http://www.eea.europa.eu/data-and-maps/data/eu-dem/#tab-original-data">Europe 3’’ DEM
dataset</a>,
which is a 20 GB compressed GeoTIFF ( and 288000 * 180000 * 4 = 193 GB
uncompressed )</p>
</div>
<div class="section" id="related-thoughts">
<h2>Related thoughts<a class="headerlink" href="#related-thoughts" title="Permalink to this headline">¶</a></h2>
<p>Some issues with system calls such as read() or write(), or easier
multi-threading could potentially be solved by making a FUSE (File
system in USEr space) driver that would expose a GDAL dataset as a file,
and the mmap()’ing the file itself. However FUSE drivers are only
available on POSIX OS, and need root privilege to be mounted (a FUSE
filesystem does not need root privilege to run, but the mounting
operation does).</p>
</div>
<div class="section" id="open-questions">
<h2>Open questions<a class="headerlink" href="#open-questions" title="Permalink to this headline">¶</a></h2>
<p>Due to the fact that it currently only works on Linux, should we mark
the API as experimental for now ?</p>
</div>
<div class="section" id="backward-compatibility-issues">
<h2>Backward compatibility issues<a class="headerlink" href="#backward-compatibility-issues" title="Permalink to this headline">¶</a></h2>
<p>C/C++ API –&gt; compatible (new API). C ABI –&gt; compatible (new API). C++
ABI –&gt; incompatibility because GDALRasterBand has a new virtual method.</p>
</div>
<div class="section" id="updated-drivers">
<h2>Updated drivers<a class="headerlink" href="#updated-drivers" title="Permalink to this headline">¶</a></h2>
<p>The RawRasterBand object and GeoTIFF drivers will be updated to
implement GetVirtualMemAuto() and offer memory file mapping when
possible (see above documented restrictions on when this is possible).</p>
<p>In future steps, other drivers such as the VRT driver (for
VRTRawRasterBand) could also offer a specialized implementation of
GetVirtualMemAuto().</p>
</div>
<div class="section" id="swig-bindings">
<h2>SWIG bindings<a class="headerlink" href="#swig-bindings" title="Permalink to this headline">¶</a></h2>
<p>The high level API (dataset and raster band) API is available in Python
bindings.</p>
<p>GDALDatasetGetVirtualMem() is mapped as Dataset.GetVirtualArray(), which
returns a NumPy array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GetVirtualMemArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eAccess</span> <span class="o">=</span> <span class="n">gdalconst</span><span class="o">.</span><span class="n">GF_Read</span><span class="p">,</span> <span class="n">xoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">yoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">xsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ysize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bufxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bufysize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">datatype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">band_list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">band_sequential</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="n">cache_size</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">page_size_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a NumPy array for the dataset, seen as a virtual memory mapping.</span>
<span class="sd">       If there are several bands and band_sequential = True, an element is</span>
<span class="sd">       accessed with array[band][y][x].</span>
<span class="sd">       If there are several bands and band_sequential = False, an element is</span>
<span class="sd">       accessed with array[y][x][band].</span>
<span class="sd">       If there is only one band, an element is accessed with array[y][x].</span>
<span class="sd">       Any reference to the array must be dropped before the last reference to the</span>
<span class="sd">       related dataset is also dropped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Similarly for GDALDatasetGetTiledVirtualMem() :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GetTiledVirtualMemArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eAccess</span> <span class="o">=</span> <span class="n">gdalconst</span><span class="o">.</span><span class="n">GF_Read</span><span class="p">,</span> <span class="n">xoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">yoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">xsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ysize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tilexsize</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">tileysize</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
                       <span class="n">datatype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">band_list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tile_organization</span> <span class="o">=</span> <span class="n">gdalconst</span><span class="o">.</span><span class="n">GTO_BSQ</span><span class="p">,</span>
                       <span class="n">cache_size</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a NumPy array for the dataset, seen as a virtual memory mapping with</span>
<span class="sd">       a tile organization.</span>
<span class="sd">       If there are several bands and tile_organization = gdal.GTO_BIP, an element is</span>
<span class="sd">       accessed with array[tiley][tilex][y][x][band].</span>
<span class="sd">       If there are several bands and tile_organization = gdal.GTO_BTI, an element is</span>
<span class="sd">       accessed with array[tiley][tilex][band][y][x].</span>
<span class="sd">       If there are several bands and tile_organization = gdal.GTO_BSQ, an element is</span>
<span class="sd">       accessed with array[band][tiley][tilex][y][x].</span>
<span class="sd">       If there is only one band, an element is accessed with array[tiley][tilex][y][x].</span>
<span class="sd">       Any reference to the array must be dropped before the last reference to the</span>
<span class="sd">       related dataset is also dropped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>And the Band object has the following 3 methods :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">GetVirtualMemArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eAccess</span> <span class="o">=</span> <span class="n">gdalconst</span><span class="o">.</span><span class="n">GF_Read</span><span class="p">,</span> <span class="n">xoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">yoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">xsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ysize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bufxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bufysize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">datatype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">cache_size</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">page_size_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;Return a NumPy array for the band, seen as a virtual memory mapping.</span>
<span class="sd">         An element is accessed with array[y][x].</span>
<span class="sd">         Any reference to the array must be dropped before the last reference to the</span>
<span class="sd">         related dataset is also dropped.</span>
<span class="sd">      &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">GetVirtualMemAutoArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eAccess</span> <span class="o">=</span> <span class="n">gdalconst</span><span class="o">.</span><span class="n">GF_Read</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;Return a NumPy array for the band, seen as a virtual memory mapping.</span>
<span class="sd">         An element is accessed with array[y][x].</span>

<span class="sd">def GetTiledVirtualMemArray(self, eAccess = gdalconst.GF_Read, xoff=0, yoff=0,</span>
<span class="sd">                         xsize=None, ysize=None, tilexsize=256, tileysize=256,</span>
<span class="sd">                         datatype = None,</span>
<span class="sd">                         cache_size = 10 * 1024 * 1024, options = None):</span>
<span class="sd">      &quot;&quot;&quot;</span><span class="n">Return</span> <span class="n">a</span> <span class="n">NumPy</span> <span class="n">array</span> <span class="k">for</span> <span class="n">the</span> <span class="n">band</span><span class="p">,</span> <span class="n">seen</span> <span class="k">as</span> <span class="n">a</span> <span class="n">virtual</span> <span class="n">memory</span> <span class="n">mapping</span> <span class="k">with</span>
         <span class="n">a</span> <span class="n">tile</span> <span class="n">organization</span><span class="o">.</span>
         <span class="n">An</span> <span class="n">element</span> <span class="ow">is</span> <span class="n">accessed</span> <span class="k">with</span> <span class="n">array</span><span class="p">[</span><span class="n">tiley</span><span class="p">][</span><span class="n">tilex</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">.</span>
         <span class="n">Any</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">the</span> <span class="n">array</span> <span class="n">must</span> <span class="n">be</span> <span class="n">dropped</span> <span class="n">before</span> <span class="n">the</span> <span class="n">last</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">the</span>
         <span class="n">related</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="n">also</span> <span class="n">dropped</span><span class="o">.</span>
      <span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Note: dataset/Band.GetVirtualMem()/GetTiledVirtualMem() methods are also
available. They return a VirtualMem python object that has a GetAddr()
method that returns a Python memoryview object (Python 2.7 or later
required). However, using such object does not seem practical for
non-Byte data types.</p>
</div>
<div class="section" id="test-suite">
<h2>Test Suite<a class="headerlink" href="#test-suite" title="Permalink to this headline">¶</a></h2>
<p>The autotest suite will be extended to test the Python API of this RFC.
It will also test the specialized implementations of GetVirtualMemAuto()
in RawRasterBand and the GeoTIFF drivers. In autotest/cpp, a
test_virtualmem.cpp file tests concurrent access to the same pages by 2
threads.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Implementation will be done by Even Rouault in GDAL/OGR trunk. The
proposed implementation is attached as a
<a class="reference external" href="http://trac.osgeo.org/gdal/attachment/wiki/rfc45_virtualmem/virtualmem.patch">patch</a>.</p>
</div>
<div class="section" id="voting-history">
<h2>Voting history<a class="headerlink" href="#voting-history" title="Permalink to this headline">¶</a></h2>
<p>+1 from EvenR, FrankW, DanielM and JukkaR</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="rfc46_gdal_ogr_unification.html" class="btn btn-neutral float-right" title="RFC 46: GDAL/OGR unification" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rfc44_gdalinfoxml.html" class="btn btn-neutral float-left" title="RFC 44: Add Parseable Output Formats for ogrinfo and gdalinfo" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://osgeo.org">
        <div class="osgeo-logo"></div>
      </a>
      <div class="copyright">
      

      &copy; 1998-2020 <a href="https://github.com/warmerdam">Frank Warmerdam</a>,
      <a href="https://github.com/rouault">Even Rouault</a>, and
      <a href="https://github.com/OSGeo/gdal/graphs/contributors">others</a>


      
      </div>
    </div>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>