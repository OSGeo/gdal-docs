<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: cpl_vsi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_651562d8bf6cfd3e81eff5b570d7df50.html">port</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cpl_vsi.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Standard C Covers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br />
<code>#include &quot;cpl_progress.h&quot;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
</div>
<p><a href="cpl__vsi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVSIDIREntry.html">VSIDIREntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directory entry.  <a href="structVSIDIREntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct containing callbacks to used by the handler.  <a href="structVSIFilesystemPluginCallbacksStruct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7e5cdfef2e52acfa6c2d723934e0d796"><td class="memItemLeft" align="right" valign="top"><a id="a7e5cdfef2e52acfa6c2d723934e0d796"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7e5cdfef2e52acfa6c2d723934e0d796">VSI_ISLNK</a>(x)&#160;&#160;&#160;S_ISLNK(x)</td></tr>
<tr class="memdesc:a7e5cdfef2e52acfa6c2d723934e0d796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the file is a symbolic link. <br /></td></tr>
<tr class="separator:a7e5cdfef2e52acfa6c2d723934e0d796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c4561cb89d1e6d0273c5be2a374777"><td class="memItemLeft" align="right" valign="top"><a id="a57c4561cb89d1e6d0273c5be2a374777"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a57c4561cb89d1e6d0273c5be2a374777">VSI_ISREG</a>(x)&#160;&#160;&#160;S_ISREG(x)</td></tr>
<tr class="memdesc:a57c4561cb89d1e6d0273c5be2a374777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the file is a regular file. <br /></td></tr>
<tr class="separator:a57c4561cb89d1e6d0273c5be2a374777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9ada3d2bb3df2eae358b1037f9a1b"><td class="memItemLeft" align="right" valign="top"><a id="a13e9ada3d2bb3df2eae358b1037f9a1b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a13e9ada3d2bb3df2eae358b1037f9a1b">VSI_ISDIR</a>(x)&#160;&#160;&#160;S_ISDIR(x)</td></tr>
<tr class="memdesc:a13e9ada3d2bb3df2eae358b1037f9a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the file is a directory. <br /></td></tr>
<tr class="separator:a13e9ada3d2bb3df2eae358b1037f9a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bb0e8c2fc561600efe533babb577aa"><td class="memItemLeft" align="right" valign="top"><a id="a20bb0e8c2fc561600efe533babb577aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a20bb0e8c2fc561600efe533babb577aa">VSI_L_OFFSET_MAX</a>&#160;&#160;&#160;<a class="el" href="cpl__port_8h.html#a82bd4992c0362d8addec634ec7d213b8">GUINTBIG_MAX</a></td></tr>
<tr class="memdesc:a20bb0e8c2fc561600efe533babb577aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for a file offset. <br /></td></tr>
<tr class="separator:a20bb0e8c2fc561600efe533babb577aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a9e6a14285f31ad3d34390a3d7ac23"><td class="memItemLeft" align="right" valign="top"><a id="a05a9e6a14285f31ad3d34390a3d7ac23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a>&#160;&#160;&#160;VSIStatBuf</td></tr>
<tr class="memdesc:a05a9e6a14285f31ad3d34390a3d7ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for <a class="el" href="cpl__vsi_8h.html#a2fc1cc4f2893dc422eb57e430798991a" title="Get filesystem object info. ">VSIStatL()</a> <br /></td></tr>
<tr class="separator:a05a9e6a14285f31ad3d34390a3d7ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3fb3d4a5abff8b360d7b7941397503"><td class="memItemLeft" align="right" valign="top"><a id="a3e3fb3d4a5abff8b360d7b7941397503"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3e3fb3d4a5abff8b360d7b7941397503">VSI_STAT_EXISTS_FLAG</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a3e3fb3d4a5abff8b360d7b7941397503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#a9bd744516c08f11f8129261a38a5fd29" title="Get filesystem object info. ">VSIStatExL()</a> to test if the file exists. <br /></td></tr>
<tr class="separator:a3e3fb3d4a5abff8b360d7b7941397503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c44d6a3cae38b33d4b4b6bfb02131"><td class="memItemLeft" align="right" valign="top"><a id="ae67c44d6a3cae38b33d4b4b6bfb02131"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ae67c44d6a3cae38b33d4b4b6bfb02131">VSI_STAT_NATURE_FLAG</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:ae67c44d6a3cae38b33d4b4b6bfb02131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#a9bd744516c08f11f8129261a38a5fd29" title="Get filesystem object info. ">VSIStatExL()</a> to query the nature (file/dir) of the file. <br /></td></tr>
<tr class="separator:ae67c44d6a3cae38b33d4b4b6bfb02131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4465858df54d216dbade556b08a5d4d"><td class="memItemLeft" align="right" valign="top"><a id="ac4465858df54d216dbade556b08a5d4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac4465858df54d216dbade556b08a5d4d">VSI_STAT_SIZE_FLAG</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:ac4465858df54d216dbade556b08a5d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#a9bd744516c08f11f8129261a38a5fd29" title="Get filesystem object info. ">VSIStatExL()</a> to query the file size. <br /></td></tr>
<tr class="separator:ac4465858df54d216dbade556b08a5d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c624636d6673f91667e8460417495e0"><td class="memItemLeft" align="right" valign="top"><a id="a0c624636d6673f91667e8460417495e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0c624636d6673f91667e8460417495e0">VSI_STAT_SET_ERROR_FLAG</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="memdesc:a0c624636d6673f91667e8460417495e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#a9bd744516c08f11f8129261a38a5fd29" title="Get filesystem object info. ">VSIStatExL()</a> to issue a VSIError in case of failure. <br /></td></tr>
<tr class="separator:a0c624636d6673f91667e8460417495e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab86f661220e57cd07d7bc6818183e1"><td class="memItemLeft" align="right" valign="top"><a id="a7ab86f661220e57cd07d7bc6818183e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7ab86f661220e57cd07d7bc6818183e1">VSI_MALLOC_ALIGNED_AUTO_VERBOSE</a>(size)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#a2d4eef330cb2ff336bad8d43b1e5cd9d">VSIMallocAlignedAutoVerbose</a>(size,__FILE__,__LINE__)</td></tr>
<tr class="memdesc:a7ab86f661220e57cd07d7bc6818183e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="cpl__vsi_8h.html#a2d4eef330cb2ff336bad8d43b1e5cd9d" title="See VSIMallocAlignedAuto() ">VSIMallocAlignedAutoVerbose()</a> with FILE and LINE reporting. <br /></td></tr>
<tr class="separator:a7ab86f661220e57cd07d7bc6818183e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade5a8741eb3362f68b2c3ee2d1b3676"><td class="memItemLeft" align="right" valign="top"><a id="aade5a8741eb3362f68b2c3ee2d1b3676"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aade5a8741eb3362f68b2c3ee2d1b3676">VSI_MALLOC_VERBOSE</a>(size)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#a8ea742cee644dd5b84648f4bd32889ed">VSIMallocVerbose</a>(size,__FILE__,__LINE__)</td></tr>
<tr class="memdesc:aade5a8741eb3362f68b2c3ee2d1b3676"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_MALLOC_VERBOSE. <br /></td></tr>
<tr class="separator:aade5a8741eb3362f68b2c3ee2d1b3676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b87a2d19d51f10ecce10d4ba53570"><td class="memItemLeft" align="right" valign="top"><a id="ac85b87a2d19d51f10ecce10d4ba53570"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac85b87a2d19d51f10ecce10d4ba53570">VSI_MALLOC2_VERBOSE</a>(nSize1,  nSize2)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#add34d6eae26372407fddf28da423fb59">VSIMalloc2Verbose</a>(nSize1,nSize2,__FILE__,__LINE__)</td></tr>
<tr class="memdesc:ac85b87a2d19d51f10ecce10d4ba53570"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_MALLOC2_VERBOSE. <br /></td></tr>
<tr class="separator:ac85b87a2d19d51f10ecce10d4ba53570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7325cdd9f33067256f91301e84b96fa1"><td class="memItemLeft" align="right" valign="top"><a id="a7325cdd9f33067256f91301e84b96fa1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7325cdd9f33067256f91301e84b96fa1">VSI_MALLOC3_VERBOSE</a>(nSize1,  nSize2,  nSize3)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#a864e6bc415881fccb6d3c1d7a7f069bc">VSIMalloc3Verbose</a>(nSize1,nSize2,nSize3,__FILE__,__LINE__)</td></tr>
<tr class="memdesc:a7325cdd9f33067256f91301e84b96fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_MALLOC3_VERBOSE. <br /></td></tr>
<tr class="separator:a7325cdd9f33067256f91301e84b96fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef6b56ece448880c45976dab915c89c"><td class="memItemLeft" align="right" valign="top"><a id="a0ef6b56ece448880c45976dab915c89c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0ef6b56ece448880c45976dab915c89c">VSI_CALLOC_VERBOSE</a>(nCount,  nSize)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#aad053ec87f032f23120fe04493e23b5b">VSICallocVerbose</a>(nCount,nSize,__FILE__,__LINE__)</td></tr>
<tr class="memdesc:a0ef6b56ece448880c45976dab915c89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_CALLOC_VERBOSE. <br /></td></tr>
<tr class="separator:a0ef6b56ece448880c45976dab915c89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f5ad7c5273fadcb66a4410f18fe0b4"><td class="memItemLeft" align="right" valign="top"><a id="a17f5ad7c5273fadcb66a4410f18fe0b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a17f5ad7c5273fadcb66a4410f18fe0b4">VSI_REALLOC_VERBOSE</a>(pOldPtr,  nNewSize)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#a5b5e4051ccf46b071475c0cefbac3cf7">VSIReallocVerbose</a>(pOldPtr,nNewSize,__FILE__,__LINE__)</td></tr>
<tr class="memdesc:a17f5ad7c5273fadcb66a4410f18fe0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_REALLOC_VERBOSE. <br /></td></tr>
<tr class="separator:a17f5ad7c5273fadcb66a4410f18fe0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5909c421c6d6bd385f6b702a9e7c693"><td class="memItemLeft" align="right" valign="top"><a id="ad5909c421c6d6bd385f6b702a9e7c693"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad5909c421c6d6bd385f6b702a9e7c693">VSI_STRDUP_VERBOSE</a>(pszStr)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#affabf0e9050f86e5ec57cadc40f56f6e">VSIStrdupVerbose</a>(pszStr,__FILE__,__LINE__)</td></tr>
<tr class="memdesc:ad5909c421c6d6bd385f6b702a9e7c693"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_STRDUP_VERBOSE. <br /></td></tr>
<tr class="separator:ad5909c421c6d6bd385f6b702a9e7c693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc1dc07ba4fe31933c9b522de783692"><td class="memItemLeft" align="right" valign="top"><a id="afdc1dc07ba4fe31933c9b522de783692"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#afdc1dc07ba4fe31933c9b522de783692">CPLReadDir</a>&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3">VSIReadDir</a></td></tr>
<tr class="memdesc:afdc1dc07ba4fe31933c9b522de783692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory. ">VSIReadDir()</a> <br /></td></tr>
<tr class="separator:afdc1dc07ba4fe31933c9b522de783692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af56f9ebab1994e4c2ed3f0a50af787b2"><td class="memItemLeft" align="right" valign="top"><a id="af56f9ebab1994e4c2ed3f0a50af787b2"></a>
typedef <a class="el" href="cpl__port_8h.html#a4f0794a0fb78d55ba284a414191dbc93">GUIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a></td></tr>
<tr class="memdesc:af56f9ebab1994e4c2ed3f0a50af787b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a file offset. <br /></td></tr>
<tr class="separator:af56f9ebab1994e4c2ed3f0a50af787b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b1400e402360b38304de2b13d16c14"><td class="memItemLeft" align="right" valign="top"><a id="af1b1400e402360b38304de2b13d16c14"></a>
typedef FILE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a></td></tr>
<tr class="memdesc:af1b1400e402360b38304de2b13d16c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a FILE that implements the <a class="el" href="classVSIVirtualHandle.html" title="Virtual file handle. ">VSIVirtualHandle</a> API. <br /></td></tr>
<tr class="separator:af1b1400e402360b38304de2b13d16c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abfa965a6cceea416b192b38c90f9ad"><td class="memItemLeft" align="right" valign="top"><a id="a6abfa965a6cceea416b192b38c90f9ad"></a>
typedef struct <a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a></td></tr>
<tr class="memdesc:a6abfa965a6cceea416b192b38c90f9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a directory iterator. <br /></td></tr>
<tr class="separator:a6abfa965a6cceea416b192b38c90f9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ccf7fcbd054704350f72be08adec8"><td class="memItemLeft" align="right" valign="top"><a id="a121ccf7fcbd054704350f72be08adec8"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a121ccf7fcbd054704350f72be08adec8">VSIWriteFunction</a>) (const void *ptr, size_t size, size_t nmemb, FILE *stream)</td></tr>
<tr class="memdesc:a121ccf7fcbd054704350f72be08adec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used by <a class="el" href="cpl__vsi_8h.html#adc4a67cc303d7662c34f506d0bdddd79" title="Set an alternative write function and output file handle instead of fwrite() / stdout. ">VSIStdoutSetRedirection()</a> <br /></td></tr>
<tr class="separator:a121ccf7fcbd054704350f72be08adec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d3d7c93b141ad3947a696dd298781a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a94d3d7c93b141ad3947a696dd298781a">VSIFilesystemPluginStatCallback</a>) (void *pUserData, const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *pStatBuf, int nFlags)</td></tr>
<tr class="memdesc:a94d3d7c93b141ad3947a696dd298781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return information about a handle.  <a href="#a94d3d7c93b141ad3947a696dd298781a">More...</a><br /></td></tr>
<tr class="separator:a94d3d7c93b141ad3947a696dd298781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfad10f0726010c7b046b2a9153e496b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#abfad10f0726010c7b046b2a9153e496b">VSIFilesystemPluginUnlinkCallback</a>) (void *pUserData, const char *pszFilename)</td></tr>
<tr class="memdesc:abfad10f0726010c7b046b2a9153e496b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove handle by name.  <a href="#abfad10f0726010c7b046b2a9153e496b">More...</a><br /></td></tr>
<tr class="separator:abfad10f0726010c7b046b2a9153e496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d7066fe0aadaab4d2be154c100a1b2"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a46d7066fe0aadaab4d2be154c100a1b2">VSIFilesystemPluginRenameCallback</a>) (void *pUserData, const char *oldpath, const char *newpath)</td></tr>
<tr class="memdesc:a46d7066fe0aadaab4d2be154c100a1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename handle.  <a href="#a46d7066fe0aadaab4d2be154c100a1b2">More...</a><br /></td></tr>
<tr class="separator:a46d7066fe0aadaab4d2be154c100a1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f54d817dbcfce03ce9610f3bc76185b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6f54d817dbcfce03ce9610f3bc76185b">VSIFilesystemPluginMkdirCallback</a>) (void *pUserData, const char *pszDirname, long nMode)</td></tr>
<tr class="memdesc:a6f54d817dbcfce03ce9610f3bc76185b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Directory.  <a href="#a6f54d817dbcfce03ce9610f3bc76185b">More...</a><br /></td></tr>
<tr class="separator:a6f54d817dbcfce03ce9610f3bc76185b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdedd1069c545b7fe216a209fd6767a3"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#afdedd1069c545b7fe216a209fd6767a3">VSIFilesystemPluginRmdirCallback</a>) (void *pUserData, const char *pszDirname)</td></tr>
<tr class="memdesc:afdedd1069c545b7fe216a209fd6767a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete Directory.  <a href="#afdedd1069c545b7fe216a209fd6767a3">More...</a><br /></td></tr>
<tr class="separator:afdedd1069c545b7fe216a209fd6767a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5375b18a338bd51e92e3496d23e7c491"><td class="memItemLeft" align="right" valign="top">typedef char **(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5375b18a338bd51e92e3496d23e7c491">VSIFilesystemPluginReadDirCallback</a>) (void *pUserData, const char *pszDirname, int nMaxFiles)</td></tr>
<tr class="memdesc:a5375b18a338bd51e92e3496d23e7c491"><td class="mdescLeft">&#160;</td><td class="mdescRight">List directory content.  <a href="#a5375b18a338bd51e92e3496d23e7c491">More...</a><br /></td></tr>
<tr class="separator:a5375b18a338bd51e92e3496d23e7c491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb10302b47889ece6b19479a81f05bc"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5fb10302b47889ece6b19479a81f05bc">VSIFilesystemPluginOpenCallback</a>) (void *pUserData, const char *pszFilename, const char *pszAccess)</td></tr>
<tr class="memdesc:a5fb10302b47889ece6b19479a81f05bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a handle.  <a href="#a5fb10302b47889ece6b19479a81f05bc">More...</a><br /></td></tr>
<tr class="separator:a5fb10302b47889ece6b19479a81f05bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3522495c9dd6b480828847e06f573781"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3522495c9dd6b480828847e06f573781">VSIFilesystemPluginTellCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:a3522495c9dd6b480828847e06f573781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current position in handle.  <a href="#a3522495c9dd6b480828847e06f573781">More...</a><br /></td></tr>
<tr class="separator:a3522495c9dd6b480828847e06f573781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93db78968a0bc9d5b859a5f1ab9d579d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a93db78968a0bc9d5b859a5f1ab9d579d">VSIFilesystemPluginSeekCallback</a>) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, int nWhence)</td></tr>
<tr class="memdesc:a93db78968a0bc9d5b859a5f1ab9d579d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in handle.  <a href="#a93db78968a0bc9d5b859a5f1ab9d579d">More...</a><br /></td></tr>
<tr class="separator:a93db78968a0bc9d5b859a5f1ab9d579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb9bc1c9e4faa76fe1395c5a2ecfc13"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2bb9bc1c9e4faa76fe1395c5a2ecfc13">VSIFilesystemPluginReadCallback</a>) (void *pFile, void *pBuffer, size_t nSize, size_t nCount)</td></tr>
<tr class="memdesc:a2bb9bc1c9e4faa76fe1395c5a2ecfc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from current position, returns the number of blocks correctly read.  <a href="#a2bb9bc1c9e4faa76fe1395c5a2ecfc13">More...</a><br /></td></tr>
<tr class="separator:a2bb9bc1c9e4faa76fe1395c5a2ecfc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2253223aadc64bea6904fd485eede527"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2253223aadc64bea6904fd485eede527">VSIFilesystemPluginReadMultiRangeCallback</a>) (void *pFile, int nRanges, void **ppData, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes)</td></tr>
<tr class="memdesc:a2253223aadc64bea6904fd485eede527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from multiple offsets.  <a href="#a2253223aadc64bea6904fd485eede527">More...</a><br /></td></tr>
<tr class="separator:a2253223aadc64bea6904fd485eede527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adeb34e38b0bd646643e18d016fe47d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a8adeb34e38b0bd646643e18d016fe47d">VSIFilesystemPluginGetRangeStatusCallback</a>) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength)</td></tr>
<tr class="memdesc:a8adeb34e38b0bd646643e18d016fe47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get empty ranges.  <a href="#a8adeb34e38b0bd646643e18d016fe47d">More...</a><br /></td></tr>
<tr class="separator:a8adeb34e38b0bd646643e18d016fe47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff9cabb436bd411346471369bee545d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#acff9cabb436bd411346471369bee545d">VSIFilesystemPluginEofCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:acff9cabb436bd411346471369bee545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has end of file been reached.  <a href="#acff9cabb436bd411346471369bee545d">More...</a><br /></td></tr>
<tr class="separator:acff9cabb436bd411346471369bee545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb9cabc545c740a05dfe0dc2c237834"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7bb9cabc545c740a05dfe0dc2c237834">VSIFilesystemPluginWriteCallback</a>) (void *pFile, const void *pBuffer, size_t nSize, size_t nCount)</td></tr>
<tr class="memdesc:a7bb9cabc545c740a05dfe0dc2c237834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes at current offset.  <a href="#a7bb9cabc545c740a05dfe0dc2c237834">More...</a><br /></td></tr>
<tr class="separator:a7bb9cabc545c740a05dfe0dc2c237834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed880694c27b9f94fd619c6ba81bf3fe"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aed880694c27b9f94fd619c6ba81bf3fe">VSIFilesystemPluginFlushCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:aed880694c27b9f94fd619c6ba81bf3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync written bytes.  <a href="#aed880694c27b9f94fd619c6ba81bf3fe">More...</a><br /></td></tr>
<tr class="separator:aed880694c27b9f94fd619c6ba81bf3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700c550a3f060ef72be35a639fa67775"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a700c550a3f060ef72be35a639fa67775">VSIFilesystemPluginTruncateCallback</a>) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nNewSize)</td></tr>
<tr class="memdesc:a700c550a3f060ef72be35a639fa67775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate handle.  <a href="#a700c550a3f060ef72be35a639fa67775">More...</a><br /></td></tr>
<tr class="separator:a700c550a3f060ef72be35a639fa67775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9c46d54ad75e6914322a84ced153f5"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6a9c46d54ad75e6914322a84ced153f5">VSIFilesystemPluginCloseCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:a6a9c46d54ad75e6914322a84ced153f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close file handle.  <a href="#a6a9c46d54ad75e6914322a84ced153f5">More...</a><br /></td></tr>
<tr class="separator:a6a9c46d54ad75e6914322a84ced153f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2aa5b80209e71d81a118d647c6a9be66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a> { <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66a68ea00493f4c073e19da9613d1d3d630">VSI_RANGE_STATUS_UNKNOWN</a>, 
<a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66a20f1d70259ba20c9c8767fed7b0a7119">VSI_RANGE_STATUS_DATA</a>, 
<a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66a4518228a517000ca00f132bc67ac6dc7">VSI_RANGE_STATUS_HOLE</a>
 }<tr class="memdesc:a2aa5b80209e71d81a118d647c6a9be66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range status.  <a href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2aa5b80209e71d81a118d647c6a9be66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae3cfa1605ce32e78fddb534bba7742f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5">VSIFOpenL</a> (const char *, const char *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ae3cfa1605ce32e78fddb534bba7742f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open file.  <a href="#ae3cfa1605ce32e78fddb534bba7742f5">More...</a><br /></td></tr>
<tr class="separator:ae3cfa1605ce32e78fddb534bba7742f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0a2c35f1214c39546192e192d9322f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ace0a2c35f1214c39546192e192d9322f">VSIFOpenExL</a> (const char *, const char *, int) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ace0a2c35f1214c39546192e192d9322f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open file.  <a href="#ace0a2c35f1214c39546192e192d9322f">More...</a><br /></td></tr>
<tr class="separator:ace0a2c35f1214c39546192e192d9322f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fe3eb9b2988c5a3c74889697f87e45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ae7fe3eb9b2988c5a3c74889697f87e45">VSIFCloseL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:ae7fe3eb9b2988c5a3c74889697f87e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close file.  <a href="#ae7fe3eb9b2988c5a3c74889697f87e45">More...</a><br /></td></tr>
<tr class="separator:ae7fe3eb9b2988c5a3c74889697f87e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d81e8bf69e8e6e87f0aadf0a490c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab32d81e8bf69e8e6e87f0aadf0a490c3">VSIFSeekL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>, int) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:ab32d81e8bf69e8e6e87f0aadf0a490c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to requested offset.  <a href="#ab32d81e8bf69e8e6e87f0aadf0a490c3">More...</a><br /></td></tr>
<tr class="separator:ab32d81e8bf69e8e6e87f0aadf0a490c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bacb4bbdbd8474a1ec2236199549e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad8bacb4bbdbd8474a1ec2236199549e3">VSIFTellL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ad8bacb4bbdbd8474a1ec2236199549e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell current file offset.  <a href="#ad8bacb4bbdbd8474a1ec2236199549e3">More...</a><br /></td></tr>
<tr class="separator:ad8bacb4bbdbd8474a1ec2236199549e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc227f7c966e95ece4691c3cc1c562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#abbbc227f7c966e95ece4691c3cc1c562">VSIRewindL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *)</td></tr>
<tr class="memdesc:abbbc227f7c966e95ece4691c3cc1c562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the file pointer to the beginning of the file.  <a href="#abbbc227f7c966e95ece4691c3cc1c562">More...</a><br /></td></tr>
<tr class="separator:abbbc227f7c966e95ece4691c3cc1c562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e64279a239eef70703efc09f43585e9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3e64279a239eef70703efc09f43585e9">VSIFReadL</a> (void *, size_t, size_t, <a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:a3e64279a239eef70703efc09f43585e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from file.  <a href="#a3e64279a239eef70703efc09f43585e9">More...</a><br /></td></tr>
<tr class="separator:a3e64279a239eef70703efc09f43585e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7637441ad8a51cdc200e926579f48986"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7637441ad8a51cdc200e926579f48986">VSIFReadMultiRangeL</a> (int nRanges, void **ppData, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes, <a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:a7637441ad8a51cdc200e926579f48986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several ranges of bytes from file.  <a href="#a7637441ad8a51cdc200e926579f48986">More...</a><br /></td></tr>
<tr class="separator:a7637441ad8a51cdc200e926579f48986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e59f50d000a7c6ca7dce76ba5946f9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a05e59f50d000a7c6ca7dce76ba5946f9">VSIFWriteL</a> (const void *, size_t, size_t, <a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:a05e59f50d000a7c6ca7dce76ba5946f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to file.  <a href="#a05e59f50d000a7c6ca7dce76ba5946f9">More...</a><br /></td></tr>
<tr class="separator:a05e59f50d000a7c6ca7dce76ba5946f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f16dba458b87271269c8c4cb39ade6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a41f16dba458b87271269c8c4cb39ade6">VSIFEofL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:a41f16dba458b87271269c8c4cb39ade6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for end of file.  <a href="#a41f16dba458b87271269c8c4cb39ade6">More...</a><br /></td></tr>
<tr class="separator:a41f16dba458b87271269c8c4cb39ade6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce7a020522db02f0324734e2b86d84c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2ce7a020522db02f0324734e2b86d84c">VSIFTruncateL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:a2ce7a020522db02f0324734e2b86d84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate/expand the file to the specified size.  <a href="#a2ce7a020522db02f0324734e2b86d84c">More...</a><br /></td></tr>
<tr class="separator:a2ce7a020522db02f0324734e2b86d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ca4651926531e79e047709c9ea346"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac52ca4651926531e79e047709c9ea346">VSIFFlushL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:ac52ca4651926531e79e047709c9ea346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending writes to disk.  <a href="#ac52ca4651926531e79e047709c9ea346">More...</a><br /></td></tr>
<tr class="separator:ac52ca4651926531e79e047709c9ea346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb02b3133f6e66a44c1cd6c7a251722"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6bb02b3133f6e66a44c1cd6c7a251722">VSIFPrintfL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *, const char *,...) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:a6bb02b3133f6e66a44c1cd6c7a251722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatted write to file.  <a href="#a6bb02b3133f6e66a44c1cd6c7a251722">More...</a><br /></td></tr>
<tr class="separator:a6bb02b3133f6e66a44c1cd6c7a251722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42c63c8266a2adc9ecbe5c8a15efa9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac42c63c8266a2adc9ecbe5c8a15efa9f">VSIFPutcL</a> (int, <a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *) EXPERIMENTAL_CPL_WARN_UNUSED_RESULT</td></tr>
<tr class="memdesc:ac42c63c8266a2adc9ecbe5c8a15efa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte to the file.  <a href="#ac42c63c8266a2adc9ecbe5c8a15efa9f">More...</a><br /></td></tr>
<tr class="separator:ac42c63c8266a2adc9ecbe5c8a15efa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e748fc4b8a074da08095bd91fff8fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0e748fc4b8a074da08095bd91fff8fed">VSIFGetRangeStatusL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *fp, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nStart, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength)</td></tr>
<tr class="memdesc:a0e748fc4b8a074da08095bd91fff8fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if a given file range contains data or holes filled with zeroes.  <a href="#a0e748fc4b8a074da08095bd91fff8fed">More...</a><br /></td></tr>
<tr class="separator:a0e748fc4b8a074da08095bd91fff8fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1d497584c01f156cda57b30de447dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9d1d497584c01f156cda57b30de447dc">VSIIngestFile</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *fp, const char *pszFilename, <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> **ppabyRet, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *pnSize, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nMaxSize) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a9d1d497584c01f156cda57b30de447dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ingest a file into memory.  <a href="#a9d1d497584c01f156cda57b30de447dc">More...</a><br /></td></tr>
<tr class="separator:a9d1d497584c01f156cda57b30de447dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0f456d7e6579d15a0cdc5f2d42104d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aee0f456d7e6579d15a0cdc5f2d42104d">VSIOverwriteFile</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *fpTarget, const char *pszSourceFilename) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aee0f456d7e6579d15a0cdc5f2d42104d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite an existing file with content from another one.  <a href="#aee0f456d7e6579d15a0cdc5f2d42104d">More...</a><br /></td></tr>
<tr class="separator:aee0f456d7e6579d15a0cdc5f2d42104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc1cc4f2893dc422eb57e430798991a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2fc1cc4f2893dc422eb57e430798991a">VSIStatL</a> (const char *, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2fc1cc4f2893dc422eb57e430798991a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get filesystem object info.  <a href="#a2fc1cc4f2893dc422eb57e430798991a">More...</a><br /></td></tr>
<tr class="separator:a2fc1cc4f2893dc422eb57e430798991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd744516c08f11f8129261a38a5fd29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9bd744516c08f11f8129261a38a5fd29">VSIStatExL</a> (const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *psStatBuf, int nFlags) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a9bd744516c08f11f8129261a38a5fd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get filesystem object info.  <a href="#a9bd744516c08f11f8129261a38a5fd29">More...</a><br /></td></tr>
<tr class="separator:a9bd744516c08f11f8129261a38a5fd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36737f0cb2949ba2f7bbf23cc6592a04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a36737f0cb2949ba2f7bbf23cc6592a04">VSIIsCaseSensitiveFS</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a36737f0cb2949ba2f7bbf23cc6592a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filenames of the filesystem are case sensitive.  <a href="#a36737f0cb2949ba2f7bbf23cc6592a04">More...</a><br /></td></tr>
<tr class="separator:a36737f0cb2949ba2f7bbf23cc6592a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1bc0831510b6d134fa4d865b2f1328"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6d1bc0831510b6d134fa4d865b2f1328">VSISupportsSparseFiles</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a6d1bc0831510b6d134fa4d865b2f1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filesystem supports sparse files.  <a href="#a6d1bc0831510b6d134fa4d865b2f1328">More...</a><br /></td></tr>
<tr class="separator:a6d1bc0831510b6d134fa4d865b2f1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f2fd6f6c0676f27eb1bfdec56753a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a40f2fd6f6c0676f27eb1bfdec56753a9">VSIHasOptimizedReadMultiRange</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a40f2fd6f6c0676f27eb1bfdec56753a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filesystem supports efficient multi-range reading.  <a href="#a40f2fd6f6c0676f27eb1bfdec56753a9">More...</a><br /></td></tr>
<tr class="separator:a40f2fd6f6c0676f27eb1bfdec56753a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc60b3e3bf1e892313f2abf0bcfaffd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0cc60b3e3bf1e892313f2abf0bcfaffd">VSIGetActualURL</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a0cc60b3e3bf1e892313f2abf0bcfaffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual URL of a supplied filename.  <a href="#a0cc60b3e3bf1e892313f2abf0bcfaffd">More...</a><br /></td></tr>
<tr class="separator:a0cc60b3e3bf1e892313f2abf0bcfaffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7d8fe76bc6c58fce962424574f0325"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9b7d8fe76bc6c58fce962424574f0325">VSIGetSignedURL</a> (const char *pszFilename, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a9b7d8fe76bc6c58fce962424574f0325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a signed URL of a supplied filename.  <a href="#a9b7d8fe76bc6c58fce962424574f0325">More...</a><br /></td></tr>
<tr class="separator:a9b7d8fe76bc6c58fce962424574f0325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ca54aa40490c9237e9dd2905d9daac"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a85ca54aa40490c9237e9dd2905d9daac">VSIGetFileSystemOptions</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a85ca54aa40490c9237e9dd2905d9daac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of options associated with a virtual file system handler as a serialized XML string.  <a href="#a85ca54aa40490c9237e9dd2905d9daac">More...</a><br /></td></tr>
<tr class="separator:a85ca54aa40490c9237e9dd2905d9daac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb3d5eb0effa7326ca6d3130b60bc94"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#adfb3d5eb0effa7326ca6d3130b60bc94">VSIGetFileSystemsPrefixes</a> (void)</td></tr>
<tr class="memdesc:adfb3d5eb0effa7326ca6d3130b60bc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of prefixes for virtual file system handlers currently registered.  <a href="#adfb3d5eb0effa7326ca6d3130b60bc94">More...</a><br /></td></tr>
<tr class="separator:adfb3d5eb0effa7326ca6d3130b60bc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fd7388a7491b3430d0abe961dada82"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a41fd7388a7491b3430d0abe961dada82">VSIFGetNativeFileDescriptorL</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a41fd7388a7491b3430d0abe961dada82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "native" file descriptor for the virtual handle.  <a href="#a41fd7388a7491b3430d0abe961dada82">More...</a><br /></td></tr>
<tr class="separator:a41fd7388a7491b3430d0abe961dada82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabd47a968dc175e77d0545187100b92"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aeabd47a968dc175e77d0545187100b92">VSIGetFileMetadata</a> (const char *pszFilename, const char *pszDomain, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aeabd47a968dc175e77d0545187100b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get metadata on files.  <a href="#aeabd47a968dc175e77d0545187100b92">More...</a><br /></td></tr>
<tr class="separator:aeabd47a968dc175e77d0545187100b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1c8d0014e7c76fbef98d24b9233a89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0a1c8d0014e7c76fbef98d24b9233a89">VSISetFileMetadata</a> (const char *pszFilename, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszMetadata, const char *pszDomain, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a0a1c8d0014e7c76fbef98d24b9233a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set metadata on files.  <a href="#a0a1c8d0014e7c76fbef98d24b9233a89">More...</a><br /></td></tr>
<tr class="separator:a0a1c8d0014e7c76fbef98d24b9233a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84892f1a5065294b3e3c400534e6a86c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a84892f1a5065294b3e3c400534e6a86c">VSICalloc</a> (size_t, size_t) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a84892f1a5065294b3e3c400534e6a86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of calloc().  <a href="#a84892f1a5065294b3e3c400534e6a86c">More...</a><br /></td></tr>
<tr class="separator:a84892f1a5065294b3e3c400534e6a86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e403f4f7e059d12da468d20d604e13c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3e403f4f7e059d12da468d20d604e13c">VSIMalloc</a> (size_t) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a3e403f4f7e059d12da468d20d604e13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of malloc().  <a href="#a3e403f4f7e059d12da468d20d604e13c">More...</a><br /></td></tr>
<tr class="separator:a3e403f4f7e059d12da468d20d604e13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26e15498e19c2a8169db924415ff7ab"><td class="memItemLeft" align="right" valign="top"><a id="af26e15498e19c2a8169db924415ff7ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab">VSIFree</a> (void *)</td></tr>
<tr class="memdesc:af26e15498e19c2a8169db924415ff7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of free() for data allocated with <a class="el" href="cpl__vsi_8h.html#a3e403f4f7e059d12da468d20d604e13c" title="Analog of malloc(). ">VSIMalloc()</a>, <a class="el" href="cpl__vsi_8h.html#a84892f1a5065294b3e3c400534e6a86c" title="Analog of calloc(). ">VSICalloc()</a>, <a class="el" href="cpl__vsi_8h.html#ac022eb90a80c108cc43c619ccd17792c" title="Analog of realloc(). ">VSIRealloc()</a> <br /></td></tr>
<tr class="separator:af26e15498e19c2a8169db924415ff7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac022eb90a80c108cc43c619ccd17792c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac022eb90a80c108cc43c619ccd17792c">VSIRealloc</a> (void *, size_t) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ac022eb90a80c108cc43c619ccd17792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of realloc().  <a href="#ac022eb90a80c108cc43c619ccd17792c">More...</a><br /></td></tr>
<tr class="separator:ac022eb90a80c108cc43c619ccd17792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0500f0dbd6c8c854931c6aa17d6566e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac0500f0dbd6c8c854931c6aa17d6566e">VSIStrdup</a> (const char *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ac0500f0dbd6c8c854931c6aa17d6566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of strdup().  <a href="#ac0500f0dbd6c8c854931c6aa17d6566e">More...</a><br /></td></tr>
<tr class="separator:ac0500f0dbd6c8c854931c6aa17d6566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244d29ecd0edf4cf4253ce840733e74e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a244d29ecd0edf4cf4253ce840733e74e">VSIMallocAligned</a> (size_t nAlignment, size_t nSize) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a244d29ecd0edf4cf4253ce840733e74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer with an alignment constraint.  <a href="#a244d29ecd0edf4cf4253ce840733e74e">More...</a><br /></td></tr>
<tr class="separator:a244d29ecd0edf4cf4253ce840733e74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7ffacaa79dbd0a8b7df8a43eab4a0c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6a7ffacaa79dbd0a8b7df8a43eab4a0c">VSIMallocAlignedAuto</a> (size_t nSize) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a6a7ffacaa79dbd0a8b7df8a43eab4a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer with an alignment constraint such that it can be used by the most demanding vector instruction set on that platform.  <a href="#a6a7ffacaa79dbd0a8b7df8a43eab4a0c">More...</a><br /></td></tr>
<tr class="separator:a6a7ffacaa79dbd0a8b7df8a43eab4a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fc84461d6ad10524a64ead6af56e33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad8fc84461d6ad10524a64ead6af56e33">VSIFreeAligned</a> (void *ptr)</td></tr>
<tr class="memdesc:ad8fc84461d6ad10524a64ead6af56e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a buffer allocated with <a class="el" href="cpl__vsi_8h.html#a244d29ecd0edf4cf4253ce840733e74e" title="Allocates a buffer with an alignment constraint. ">VSIMallocAligned()</a>.  <a href="#ad8fc84461d6ad10524a64ead6af56e33">More...</a><br /></td></tr>
<tr class="separator:ad8fc84461d6ad10524a64ead6af56e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4eef330cb2ff336bad8d43b1e5cd9d"><td class="memItemLeft" align="right" valign="top"><a id="a2d4eef330cb2ff336bad8d43b1e5cd9d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2d4eef330cb2ff336bad8d43b1e5cd9d">VSIMallocAlignedAutoVerbose</a> (size_t nSize, const char *pszFile, int nLine) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2d4eef330cb2ff336bad8d43b1e5cd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="cpl__vsi_8h.html#a6a7ffacaa79dbd0a8b7df8a43eab4a0c" title="Allocates a buffer with an alignment constraint such that it can be used by the most demanding vector...">VSIMallocAlignedAuto()</a> <br /></td></tr>
<tr class="separator:a2d4eef330cb2ff336bad8d43b1e5cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2286902bc6bf22d866e72df2e474d68c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2286902bc6bf22d866e72df2e474d68c">VSIMalloc2</a> (size_t nSize1, size_t nSize2) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2286902bc6bf22d866e72df2e474d68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc2 allocates (nSize1 * nSize2) bytes.  <a href="#a2286902bc6bf22d866e72df2e474d68c">More...</a><br /></td></tr>
<tr class="separator:a2286902bc6bf22d866e72df2e474d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114ce8d68c4f351309805314f3b5063"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5114ce8d68c4f351309805314f3b5063">VSIMalloc3</a> (size_t nSize1, size_t nSize2, size_t nSize3) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a5114ce8d68c4f351309805314f3b5063"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes.  <a href="#a5114ce8d68c4f351309805314f3b5063">More...</a><br /></td></tr>
<tr class="separator:a5114ce8d68c4f351309805314f3b5063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea742cee644dd5b84648f4bd32889ed"><td class="memItemLeft" align="right" valign="top"><a id="a8ea742cee644dd5b84648f4bd32889ed"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a8ea742cee644dd5b84648f4bd32889ed">VSIMallocVerbose</a> (size_t nSize, const char *pszFile, int nLine) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a8ea742cee644dd5b84648f4bd32889ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMallocVerbose. <br /></td></tr>
<tr class="separator:a8ea742cee644dd5b84648f4bd32889ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add34d6eae26372407fddf28da423fb59"><td class="memItemLeft" align="right" valign="top"><a id="add34d6eae26372407fddf28da423fb59"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#add34d6eae26372407fddf28da423fb59">VSIMalloc2Verbose</a> (size_t nSize1, size_t nSize2, const char *pszFile, int nLine) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:add34d6eae26372407fddf28da423fb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc2Verbose. <br /></td></tr>
<tr class="separator:add34d6eae26372407fddf28da423fb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864e6bc415881fccb6d3c1d7a7f069bc"><td class="memItemLeft" align="right" valign="top"><a id="a864e6bc415881fccb6d3c1d7a7f069bc"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a864e6bc415881fccb6d3c1d7a7f069bc">VSIMalloc3Verbose</a> (size_t nSize1, size_t nSize2, size_t nSize3, const char *pszFile, int nLine) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a864e6bc415881fccb6d3c1d7a7f069bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc3Verbose. <br /></td></tr>
<tr class="separator:a864e6bc415881fccb6d3c1d7a7f069bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad053ec87f032f23120fe04493e23b5b"><td class="memItemLeft" align="right" valign="top"><a id="aad053ec87f032f23120fe04493e23b5b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aad053ec87f032f23120fe04493e23b5b">VSICallocVerbose</a> (size_t nCount, size_t nSize, const char *pszFile, int nLine) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aad053ec87f032f23120fe04493e23b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSICallocVerbose. <br /></td></tr>
<tr class="separator:aad053ec87f032f23120fe04493e23b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5e4051ccf46b071475c0cefbac3cf7"><td class="memItemLeft" align="right" valign="top"><a id="a5b5e4051ccf46b071475c0cefbac3cf7"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5b5e4051ccf46b071475c0cefbac3cf7">VSIReallocVerbose</a> (void *pOldPtr, size_t nNewSize, const char *pszFile, int nLine) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a5b5e4051ccf46b071475c0cefbac3cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIReallocVerbose. <br /></td></tr>
<tr class="separator:a5b5e4051ccf46b071475c0cefbac3cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affabf0e9050f86e5ec57cadc40f56f6e"><td class="memItemLeft" align="right" valign="top"><a id="affabf0e9050f86e5ec57cadc40f56f6e"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#affabf0e9050f86e5ec57cadc40f56f6e">VSIStrdupVerbose</a> (const char *pszStr, const char *pszFile, int nLine) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:affabf0e9050f86e5ec57cadc40f56f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIStrdupVerbose. <br /></td></tr>
<tr class="separator:affabf0e9050f86e5ec57cadc40f56f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef39609553f41d5cb5078302c4b3de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2ef39609553f41d5cb5078302c4b3de2">CPLGetPhysicalRAM</a> (void)</td></tr>
<tr class="memdesc:a2ef39609553f41d5cb5078302c4b3de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total physical RAM in bytes.  <a href="#a2ef39609553f41d5cb5078302c4b3de2">More...</a><br /></td></tr>
<tr class="separator:a2ef39609553f41d5cb5078302c4b3de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eef6b11f21ea4d5c27a62ac265818a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac6eef6b11f21ea4d5c27a62ac265818a">CPLGetUsablePhysicalRAM</a> (void)</td></tr>
<tr class="memdesc:ac6eef6b11f21ea4d5c27a62ac265818a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total physical RAM, usable by a process, in bytes.  <a href="#ac6eef6b11f21ea4d5c27a62ac265818a">More...</a><br /></td></tr>
<tr class="separator:ac6eef6b11f21ea4d5c27a62ac265818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6158d73485d6cf92c75b38e7f26d00c3"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3">VSIReadDir</a> (const char *)</td></tr>
<tr class="memdesc:a6158d73485d6cf92c75b38e7f26d00c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read names in a directory.  <a href="#a6158d73485d6cf92c75b38e7f26d00c3">More...</a><br /></td></tr>
<tr class="separator:a6158d73485d6cf92c75b38e7f26d00c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c473cd78f2dffabf709245a928e6c7"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a03c473cd78f2dffabf709245a928e6c7">VSIReadDirRecursive</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a03c473cd78f2dffabf709245a928e6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read names in a directory recursively.  <a href="#a03c473cd78f2dffabf709245a928e6c7">More...</a><br /></td></tr>
<tr class="separator:a03c473cd78f2dffabf709245a928e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f5bbeaa3ad170682f130f427930bd"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aab9f5bbeaa3ad170682f130f427930bd">VSIReadDirEx</a> (const char *pszPath, int nMaxFiles)</td></tr>
<tr class="memdesc:aab9f5bbeaa3ad170682f130f427930bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read names in a directory.  <a href="#aab9f5bbeaa3ad170682f130f427930bd">More...</a><br /></td></tr>
<tr class="separator:aab9f5bbeaa3ad170682f130f427930bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186d32d750cca298ea625c00e8be3f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a186d32d750cca298ea625c00e8be3f90">VSIOpenDir</a> (const char *pszPath, int nRecurseDepth, const char *const *papszOptions)</td></tr>
<tr class="memdesc:a186d32d750cca298ea625c00e8be3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory to read its entries.  <a href="#a186d32d750cca298ea625c00e8be3f90">More...</a><br /></td></tr>
<tr class="separator:a186d32d750cca298ea625c00e8be3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce4131b005b1853a16d4f341d1ba031"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVSIDIREntry.html">VSIDIREntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0ce4131b005b1853a16d4f341d1ba031">VSIGetNextDirEntry</a> (<a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *dir)</td></tr>
<tr class="memdesc:a0ce4131b005b1853a16d4f341d1ba031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next entry of the directory.  <a href="#a0ce4131b005b1853a16d4f341d1ba031">More...</a><br /></td></tr>
<tr class="separator:a0ce4131b005b1853a16d4f341d1ba031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7448bda4230b3d8133a59027c5f02f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7e7448bda4230b3d8133a59027c5f02f">VSICloseDir</a> (<a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *dir)</td></tr>
<tr class="memdesc:a7e7448bda4230b3d8133a59027c5f02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a directory.  <a href="#a7e7448bda4230b3d8133a59027c5f02f">More...</a><br /></td></tr>
<tr class="separator:a7e7448bda4230b3d8133a59027c5f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3e0b14583ca553a29bf163b972c157"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aaa3e0b14583ca553a29bf163b972c157">VSIMkdir</a> (const char *pszPathname, long mode)</td></tr>
<tr class="memdesc:aaa3e0b14583ca553a29bf163b972c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory.  <a href="#aaa3e0b14583ca553a29bf163b972c157">More...</a><br /></td></tr>
<tr class="separator:aaa3e0b14583ca553a29bf163b972c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62018c639ec285ae04afa5799ee6a4d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a62018c639ec285ae04afa5799ee6a4d5">VSIMkdirRecursive</a> (const char *pszPathname, long mode)</td></tr>
<tr class="memdesc:a62018c639ec285ae04afa5799ee6a4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory and all its ancestors.  <a href="#a62018c639ec285ae04afa5799ee6a4d5">More...</a><br /></td></tr>
<tr class="separator:a62018c639ec285ae04afa5799ee6a4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c8873a6ff54d9c1e7f752cada9822"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af12c8873a6ff54d9c1e7f752cada9822">VSIRmdir</a> (const char *pszDirname)</td></tr>
<tr class="memdesc:af12c8873a6ff54d9c1e7f752cada9822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a directory.  <a href="#af12c8873a6ff54d9c1e7f752cada9822">More...</a><br /></td></tr>
<tr class="separator:af12c8873a6ff54d9c1e7f752cada9822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e05f10c591053fa876c9d3417421a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aa5e05f10c591053fa876c9d3417421a5">VSIRmdirRecursive</a> (const char *pszDirname)</td></tr>
<tr class="memdesc:aa5e05f10c591053fa876c9d3417421a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a directory recursively.  <a href="#aa5e05f10c591053fa876c9d3417421a5">More...</a><br /></td></tr>
<tr class="separator:aa5e05f10c591053fa876c9d3417421a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff49d132f70ec46a550c5a51103e394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7ff49d132f70ec46a550c5a51103e394">VSIUnlink</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a7ff49d132f70ec46a550c5a51103e394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file.  <a href="#a7ff49d132f70ec46a550c5a51103e394">More...</a><br /></td></tr>
<tr class="separator:a7ff49d132f70ec46a550c5a51103e394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82382a50ea3be8c5c192a27a45b2673"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad82382a50ea3be8c5c192a27a45b2673">VSIUnlinkBatch</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszFiles)</td></tr>
<tr class="memdesc:ad82382a50ea3be8c5c192a27a45b2673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete several files, possibly in a batch.  <a href="#ad82382a50ea3be8c5c192a27a45b2673">More...</a><br /></td></tr>
<tr class="separator:ad82382a50ea3be8c5c192a27a45b2673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cae93b5a32e11bef9ec7c118f8cca4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a26cae93b5a32e11bef9ec7c118f8cca4">VSIRename</a> (const char *oldpath, const char *newpath)</td></tr>
<tr class="memdesc:a26cae93b5a32e11bef9ec7c118f8cca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a file.  <a href="#a26cae93b5a32e11bef9ec7c118f8cca4">More...</a><br /></td></tr>
<tr class="separator:a26cae93b5a32e11bef9ec7c118f8cca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6845a21b2c0491c594dd9deef757db6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6845a21b2c0491c594dd9deef757db6b">VSISync</a> (const char *pszSource, const char *pszTarget, const char *const *papszOptions, GDALProgressFunc pProgressFunc, void *pProgressData, char ***ppapszOutputs)</td></tr>
<tr class="memdesc:a6845a21b2c0491c594dd9deef757db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize a source file/directory with a target file/directory.  <a href="#a6845a21b2c0491c594dd9deef757db6b">More...</a><br /></td></tr>
<tr class="separator:a6845a21b2c0491c594dd9deef757db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312ee85ec9884dc16feda2b81de1cc36"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a312ee85ec9884dc16feda2b81de1cc36">VSIStrerror</a> (int)</td></tr>
<tr class="memdesc:a312ee85ec9884dc16feda2b81de1cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error string corresponding to the error number.  <a href="#a312ee85ec9884dc16feda2b81de1cc36">More...</a><br /></td></tr>
<tr class="separator:a312ee85ec9884dc16feda2b81de1cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ae557aaaa4cc249cd97080101a8297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad4ae557aaaa4cc249cd97080101a8297">VSIGetDiskFreeSpace</a> (const char *pszDirname)</td></tr>
<tr class="memdesc:ad4ae557aaaa4cc249cd97080101a8297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return free disk space available on the filesystem.  <a href="#ad4ae557aaaa4cc249cd97080101a8297">More...</a><br /></td></tr>
<tr class="separator:ad4ae557aaaa4cc249cd97080101a8297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e2e6f093fd42f8a941b962d4c8a19e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a66e2e6f093fd42f8a941b962d4c8a19e">VSIInstallMemFileHandler</a> (void)</td></tr>
<tr class="memdesc:a66e2e6f093fd42f8a941b962d4c8a19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install "memory" file system handler.  <a href="#a66e2e6f093fd42f8a941b962d4c8a19e">More...</a><br /></td></tr>
<tr class="separator:a66e2e6f093fd42f8a941b962d4c8a19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee4232440e012b4b9920934fc571cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#abaee4232440e012b4b9920934fc571cc">VSIInstallSubFileHandler</a> (void)</td></tr>
<tr class="memdesc:abaee4232440e012b4b9920934fc571cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsisubfile/ virtual file handler.  <a href="#abaee4232440e012b4b9920934fc571cc">More...</a><br /></td></tr>
<tr class="separator:abaee4232440e012b4b9920934fc571cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f791960f2d86713d16e99e9c0c36258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a4f791960f2d86713d16e99e9c0c36258">VSIInstallCurlFileHandler</a> (void)</td></tr>
<tr class="memdesc:a4f791960f2d86713d16e99e9c0c36258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsicurl/ HTTP/FTP file system handler (requires libcurl)  <a href="#a4f791960f2d86713d16e99e9c0c36258">More...</a><br /></td></tr>
<tr class="separator:a4f791960f2d86713d16e99e9c0c36258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b22260317edc475793c4165957742b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6b22260317edc475793c4165957742b6">VSICurlClearCache</a> (void)</td></tr>
<tr class="memdesc:a6b22260317edc475793c4165957742b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean local cache associated with /vsicurl/ (and related file systems)  <a href="#a6b22260317edc475793c4165957742b6">More...</a><br /></td></tr>
<tr class="separator:a6b22260317edc475793c4165957742b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc83d16f0f279f601059a218ad2c55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6bc83d16f0f279f601059a218ad2c55c">VSICurlPartialClearCache</a> (const char *pszFilenamePrefix)</td></tr>
<tr class="memdesc:a6bc83d16f0f279f601059a218ad2c55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean local cache associated with /vsicurl/ (and related file systems) for a given filename (and its subfiles and subdirectories if it is a directory)  <a href="#a6bc83d16f0f279f601059a218ad2c55c">More...</a><br /></td></tr>
<tr class="separator:a6bc83d16f0f279f601059a218ad2c55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab187e6713f07be9756c22c58b782642d"><td class="memItemLeft" align="right" valign="top"><a id="ab187e6713f07be9756c22c58b782642d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VSIInstallCurlStreamingFileHandler</b> (void)</td></tr>
<tr class="separator:ab187e6713f07be9756c22c58b782642d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4754999acd06444bfda172ff2aaa16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5b4754999acd06444bfda172ff2aaa16">VSIInstallS3FileHandler</a> (void)</td></tr>
<tr class="memdesc:a5b4754999acd06444bfda172ff2aaa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsis3/ Amazon S3 file system handler (requires libcurl)  <a href="#a5b4754999acd06444bfda172ff2aaa16">More...</a><br /></td></tr>
<tr class="separator:a5b4754999acd06444bfda172ff2aaa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c1e0314bbd7e4661bc526f45032c5"><td class="memItemLeft" align="right" valign="top"><a id="a126c1e0314bbd7e4661bc526f45032c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VSIInstallS3StreamingFileHandler</b> (void)</td></tr>
<tr class="separator:a126c1e0314bbd7e4661bc526f45032c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80a70fd45cd7a2119f1a2f7da071870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af80a70fd45cd7a2119f1a2f7da071870">VSIInstallGSFileHandler</a> (void)</td></tr>
<tr class="memdesc:af80a70fd45cd7a2119f1a2f7da071870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsigs/ Google Cloud Storage file system handler (requires libcurl)  <a href="#af80a70fd45cd7a2119f1a2f7da071870">More...</a><br /></td></tr>
<tr class="separator:af80a70fd45cd7a2119f1a2f7da071870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9158701b72f0c840996d8ad98bb2ff"><td class="memItemLeft" align="right" valign="top"><a id="aca9158701b72f0c840996d8ad98bb2ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VSIInstallGSStreamingFileHandler</b> (void)</td></tr>
<tr class="separator:aca9158701b72f0c840996d8ad98bb2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f1bf516788238d7138c879dedd62a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af1f1bf516788238d7138c879dedd62a4">VSIInstallAzureFileHandler</a> (void)</td></tr>
<tr class="memdesc:af1f1bf516788238d7138c879dedd62a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiaz/ Microsoft Azure Blob file system handler (requires libcurl)  <a href="#af1f1bf516788238d7138c879dedd62a4">More...</a><br /></td></tr>
<tr class="separator:af1f1bf516788238d7138c879dedd62a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af913ec753ebec2261f0420e8989dd6dd"><td class="memItemLeft" align="right" valign="top"><a id="af913ec753ebec2261f0420e8989dd6dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VSIInstallAzureStreamingFileHandler</b> (void)</td></tr>
<tr class="separator:af913ec753ebec2261f0420e8989dd6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad393a845ca054eab086fb933cee74be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad393a845ca054eab086fb933cee74be0">VSIInstallOSSFileHandler</a> (void)</td></tr>
<tr class="memdesc:ad393a845ca054eab086fb933cee74be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsioss/ Alibaba Cloud Object Storage Service (OSS) file system handler (requires libcurl)  <a href="#ad393a845ca054eab086fb933cee74be0">More...</a><br /></td></tr>
<tr class="separator:ad393a845ca054eab086fb933cee74be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966348bdbdd092035cd7925d56943d05"><td class="memItemLeft" align="right" valign="top"><a id="a966348bdbdd092035cd7925d56943d05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VSIInstallOSSStreamingFileHandler</b> (void)</td></tr>
<tr class="separator:a966348bdbdd092035cd7925d56943d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a177eab3fbc4241083f6749b9a75d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a87a177eab3fbc4241083f6749b9a75d5">VSIInstallSwiftFileHandler</a> (void)</td></tr>
<tr class="memdesc:a87a177eab3fbc4241083f6749b9a75d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiswift/ OpenStack Swif Object Storage (Swift) file system handler (requires libcurl)  <a href="#a87a177eab3fbc4241083f6749b9a75d5">More...</a><br /></td></tr>
<tr class="separator:a87a177eab3fbc4241083f6749b9a75d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6112f0851a51fe5ad1333f5cd1672ab6"><td class="memItemLeft" align="right" valign="top"><a id="a6112f0851a51fe5ad1333f5cd1672ab6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VSIInstallSwiftStreamingFileHandler</b> (void)</td></tr>
<tr class="separator:a6112f0851a51fe5ad1333f5cd1672ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cde09f204df6f417653b7af4761178e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3cde09f204df6f417653b7af4761178e">VSIInstallGZipFileHandler</a> (void)</td></tr>
<tr class="memdesc:a3cde09f204df6f417653b7af4761178e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install GZip file system handler.  <a href="#a3cde09f204df6f417653b7af4761178e">More...</a><br /></td></tr>
<tr class="separator:a3cde09f204df6f417653b7af4761178e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884fac3cd6be2c09deb807e959d78b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a884fac3cd6be2c09deb807e959d78b3a">VSIInstallZipFileHandler</a> (void)</td></tr>
<tr class="memdesc:a884fac3cd6be2c09deb807e959d78b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install ZIP file system handler.  <a href="#a884fac3cd6be2c09deb807e959d78b3a">More...</a><br /></td></tr>
<tr class="separator:a884fac3cd6be2c09deb807e959d78b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6b408477f59b40f0aec51d5980eb8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2c6b408477f59b40f0aec51d5980eb8e">VSIInstallStdinHandler</a> (void)</td></tr>
<tr class="memdesc:a2c6b408477f59b40f0aec51d5980eb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsistdin/ file system handler.  <a href="#a2c6b408477f59b40f0aec51d5980eb8e">More...</a><br /></td></tr>
<tr class="separator:a2c6b408477f59b40f0aec51d5980eb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c296255c2263248d0e6ad7c4481d746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5c296255c2263248d0e6ad7c4481d746">VSIInstallHdfsHandler</a> (void)</td></tr>
<tr class="memdesc:a5c296255c2263248d0e6ad7c4481d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsihdfs/ file system handler (requires JVM and HDFS support)  <a href="#a5c296255c2263248d0e6ad7c4481d746">More...</a><br /></td></tr>
<tr class="separator:a5c296255c2263248d0e6ad7c4481d746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b1d08d5f6dcd37d2ed89583765ee9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a51b1d08d5f6dcd37d2ed89583765ee9b">VSIInstallWebHdfsHandler</a> (void)</td></tr>
<tr class="memdesc:a51b1d08d5f6dcd37d2ed89583765ee9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiwebhdfs/ WebHDFS (Hadoop File System) REST API file system handler (requires libcurl)  <a href="#a51b1d08d5f6dcd37d2ed89583765ee9b">More...</a><br /></td></tr>
<tr class="separator:a51b1d08d5f6dcd37d2ed89583765ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d2250ab2b22ca79b051a8479ee5383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a61d2250ab2b22ca79b051a8479ee5383">VSIInstallStdoutHandler</a> (void)</td></tr>
<tr class="memdesc:a61d2250ab2b22ca79b051a8479ee5383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsistdout/ file system handler.  <a href="#a61d2250ab2b22ca79b051a8479ee5383">More...</a><br /></td></tr>
<tr class="separator:a61d2250ab2b22ca79b051a8479ee5383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79aed725b28eb22471a8b6733405843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab79aed725b28eb22471a8b6733405843">VSIInstallSparseFileHandler</a> (void)</td></tr>
<tr class="memdesc:ab79aed725b28eb22471a8b6733405843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsisparse/ virtual file handler.  <a href="#ab79aed725b28eb22471a8b6733405843">More...</a><br /></td></tr>
<tr class="separator:ab79aed725b28eb22471a8b6733405843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dd983338849e7da4eaa88f6458ab64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad6dd983338849e7da4eaa88f6458ab64">VSIInstallTarFileHandler</a> (void)</td></tr>
<tr class="memdesc:ad6dd983338849e7da4eaa88f6458ab64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsitar/ file system handler.  <a href="#ad6dd983338849e7da4eaa88f6458ab64">More...</a><br /></td></tr>
<tr class="separator:ad6dd983338849e7da4eaa88f6458ab64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e20b79947f58970f5514b3eb9a524a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5e20b79947f58970f5514b3eb9a524a9">VSIInstallCryptFileHandler</a> (void)</td></tr>
<tr class="memdesc:a5e20b79947f58970f5514b3eb9a524a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsicrypt/ encrypted file system handler (requires <a href="http://www.cryptopp.com/">libcrypto++</a>)  <a href="#a5e20b79947f58970f5514b3eb9a524a9">More...</a><br /></td></tr>
<tr class="separator:a5e20b79947f58970f5514b3eb9a524a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619a6f6758371a39e0c1a4168462452c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a619a6f6758371a39e0c1a4168462452c">VSISetCryptKey</a> (const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyKey, int nKeySize)</td></tr>
<tr class="memdesc:a619a6f6758371a39e0c1a4168462452c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the encryption/decryption key.  <a href="#a619a6f6758371a39e0c1a4168462452c">More...</a><br /></td></tr>
<tr class="separator:a619a6f6758371a39e0c1a4168462452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b6b1c37bb19d954ee3c4a7e910120c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a86b6b1c37bb19d954ee3c4a7e910120c">VSIFileFromMemBuffer</a> (const char *pszFilename, <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyData, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nDataLength, int bTakeOwnership) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a86b6b1c37bb19d954ee3c4a7e910120c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create memory "file" from a buffer.  <a href="#a86b6b1c37bb19d954ee3c4a7e910120c">More...</a><br /></td></tr>
<tr class="separator:a86b6b1c37bb19d954ee3c4a7e910120c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf26bcc4a5314371f426bb2a5e6ce7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a">VSIGetMemFileBuffer</a> (const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *pnDataLength, int bUnlinkAndSeize)</td></tr>
<tr class="memdesc:aeaf26bcc4a5314371f426bb2a5e6ce7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch buffer underlying memory file.  <a href="#aeaf26bcc4a5314371f426bb2a5e6ce7a">More...</a><br /></td></tr>
<tr class="separator:aeaf26bcc4a5314371f426bb2a5e6ce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4a67cc303d7662c34f506d0bdddd79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#adc4a67cc303d7662c34f506d0bdddd79">VSIStdoutSetRedirection</a> (<a class="el" href="cpl__vsi_8h.html#a121ccf7fcbd054704350f72be08adec8">VSIWriteFunction</a> pFct, FILE *stream)</td></tr>
<tr class="memdesc:adc4a67cc303d7662c34f506d0bdddd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an alternative write function and output file handle instead of fwrite() / stdout.  <a href="#adc4a67cc303d7662c34f506d0bdddd79">More...</a><br /></td></tr>
<tr class="separator:adc4a67cc303d7662c34f506d0bdddd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060262f8e9dbe8509bbe535341021750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a060262f8e9dbe8509bbe535341021750">VSIAllocFilesystemPluginCallbacksStruct</a> (void)</td></tr>
<tr class="memdesc:a060262f8e9dbe8509bbe535341021750"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html" title="struct containing callbacks to used by the handler. ">VSIFilesystemPluginCallbacksStruct</a> to be populated at runtime with handler callbacks  <a href="#a060262f8e9dbe8509bbe535341021750">More...</a><br /></td></tr>
<tr class="separator:a060262f8e9dbe8509bbe535341021750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463cc08892a277549cff8b1e4fe460a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a463cc08892a277549cff8b1e4fe460a2">VSIFreeFilesystemPluginCallbacksStruct</a> (<a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *poCb)</td></tr>
<tr class="memdesc:a463cc08892a277549cff8b1e4fe460a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">free resources allocated by VSIAllocFilesystemPluginCallbacksStruct  <a href="#a463cc08892a277549cff8b1e4fe460a2">More...</a><br /></td></tr>
<tr class="separator:a463cc08892a277549cff8b1e4fe460a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd74a1b0cad563fe1518660967a673f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9fd74a1b0cad563fe1518660967a673f">VSIInstallPluginHandler</a> (const char *pszPrefix, const <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *poCb)</td></tr>
<tr class="memdesc:a9fd74a1b0cad563fe1518660967a673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a handler on the given prefix.  <a href="#a9fd74a1b0cad563fe1518660967a673f">More...</a><br /></td></tr>
<tr class="separator:a9fd74a1b0cad563fe1518660967a673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Standard C Covers. </p>
<p>The VSI functions are intended to be hookable aliases for Standard C I/O, memory allocation and other system functions. They are intended to allow virtualization of disk I/O so that non file data sources can be made to appear as files, and so that additional error trapping and reporting can be interested. The memory access API is aliased so that special application memory management services can be used.</p>
<p>It is intended that each of these functions retains exactly the same calling pattern as the original Standard C functions they relate to. This means we don't have to provide custom documentation, and also means that the default implementation is very simple. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a6a9c46d54ad75e6914322a84ced153f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9c46d54ad75e6914322a84ced153f5">&#9670;&nbsp;</a></span>VSIFilesystemPluginCloseCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginCloseCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close file handle. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="acff9cabb436bd411346471369bee545d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff9cabb436bd411346471369bee545d">&#9670;&nbsp;</a></span>VSIFilesystemPluginEofCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginEofCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has end of file been reached. </p>
<p>Mandatory? for read handles. </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="aed880694c27b9f94fd619c6ba81bf3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed880694c27b9f94fd619c6ba81bf3fe">&#9670;&nbsp;</a></span>VSIFilesystemPluginFlushCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginFlushCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync written bytes. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a8adeb34e38b0bd646643e18d016fe47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adeb34e38b0bd646643e18d016fe47d">&#9670;&nbsp;</a></span>VSIFilesystemPluginGetRangeStatusCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a>(* VSIFilesystemPluginGetRangeStatusCallback) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get empty ranges. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a6f54d817dbcfce03ce9610f3bc76185b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f54d817dbcfce03ce9610f3bc76185b">&#9670;&nbsp;</a></span>VSIFilesystemPluginMkdirCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginMkdirCallback) (void *pUserData, const char *pszDirname, long nMode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Directory. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a5fb10302b47889ece6b19479a81f05bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb10302b47889ece6b19479a81f05bc">&#9670;&nbsp;</a></span>VSIFilesystemPluginOpenCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* VSIFilesystemPluginOpenCallback) (void *pUserData, const char *pszFilename, const char *pszAccess)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a handle. </p>
<p>Mandatory. Returns an opaque pointer that will be used in subsequent file I/O calls. Should return null and/or set errno if the handle does not exist or the access mode is incorrect. </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a2bb9bc1c9e4faa76fe1395c5a2ecfc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb9bc1c9e4faa76fe1395c5a2ecfc13">&#9670;&nbsp;</a></span>VSIFilesystemPluginReadCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* VSIFilesystemPluginReadCallback) (void *pFile, void *pBuffer, size_t nSize, size_t nCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from current position, returns the number of blocks correctly read. </p>
<p>Mandatory except for write only handles </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a5375b18a338bd51e92e3496d23e7c491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5375b18a338bd51e92e3496d23e7c491">&#9670;&nbsp;</a></span>VSIFilesystemPluginReadDirCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char**(* VSIFilesystemPluginReadDirCallback) (void *pUserData, const char *pszDirname, int nMaxFiles)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List directory content. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a2253223aadc64bea6904fd485eede527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2253223aadc64bea6904fd485eede527">&#9670;&nbsp;</a></span>VSIFilesystemPluginReadMultiRangeCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginReadMultiRangeCallback) (void *pFile, int nRanges, void **ppData, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from multiple offsets. </p>
<p>Optional, will be replaced by multiple calls to Read() if not provided </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a46d7066fe0aadaab4d2be154c100a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d7066fe0aadaab4d2be154c100a1b2">&#9670;&nbsp;</a></span>VSIFilesystemPluginRenameCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginRenameCallback) (void *pUserData, const char *oldpath, const char *newpath)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename handle. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="afdedd1069c545b7fe216a209fd6767a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdedd1069c545b7fe216a209fd6767a3">&#9670;&nbsp;</a></span>VSIFilesystemPluginRmdirCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginRmdirCallback) (void *pUserData, const char *pszDirname)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete Directory. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a93db78968a0bc9d5b859a5f1ab9d579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93db78968a0bc9d5b859a5f1ab9d579d">&#9670;&nbsp;</a></span>VSIFilesystemPluginSeekCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginSeekCallback) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, int nWhence)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to position in handle. </p>
<p>Mandatory except for write only handles </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a94d3d7c93b141ad3947a696dd298781a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d3d7c93b141ad3947a696dd298781a">&#9670;&nbsp;</a></span>VSIFilesystemPluginStatCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginStatCallback) (void *pUserData, const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *pStatBuf, int nFlags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return information about a handle. </p>
<p>Optional (driver dependent) </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a3522495c9dd6b480828847e06f573781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3522495c9dd6b480828847e06f573781">&#9670;&nbsp;</a></span>VSIFilesystemPluginTellCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>(* VSIFilesystemPluginTellCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current position in handle. </p>
<p>Mandatory </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a700c550a3f060ef72be35a639fa67775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700c550a3f060ef72be35a639fa67775">&#9670;&nbsp;</a></span>VSIFilesystemPluginTruncateCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginTruncateCallback) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nNewSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate handle. </p>
<p>Mandatory (driver dependent?) for write handles </p>

</div>
</div>
<a id="abfad10f0726010c7b046b2a9153e496b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfad10f0726010c7b046b2a9153e496b">&#9670;&nbsp;</a></span>VSIFilesystemPluginUnlinkCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginUnlinkCallback) (void *pUserData, const char *pszFilename)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove handle by name. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a7bb9cabc545c740a05dfe0dc2c237834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb9cabc545c740a05dfe0dc2c237834">&#9670;&nbsp;</a></span>VSIFilesystemPluginWriteCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* VSIFilesystemPluginWriteCallback) (void *pFile, const void *pBuffer, size_t nSize, size_t nCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes at current offset. </p>
<p>Mandatory for writable handles </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2aa5b80209e71d81a118d647c6a9be66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa5b80209e71d81a118d647c6a9be66">&#9670;&nbsp;</a></span>VSIRangeStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2aa5b80209e71d81a118d647c6a9be66a68ea00493f4c073e19da9613d1d3d630"></a>VSI_RANGE_STATUS_UNKNOWN&#160;</td><td class="fielddoc"><p>Unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aa5b80209e71d81a118d647c6a9be66a20f1d70259ba20c9c8767fed7b0a7119"></a>VSI_RANGE_STATUS_DATA&#160;</td><td class="fielddoc"><p>Data present. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aa5b80209e71d81a118d647c6a9be66a4518228a517000ca00f132bc67ac6dc7"></a>VSI_RANGE_STATUS_HOLE&#160;</td><td class="fielddoc"><p>Hole. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2ef39609553f41d5cb5078302c4b3de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef39609553f41d5cb5078302c4b3de2">&#9670;&nbsp;</a></span>CPLGetPhysicalRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> CPLGetPhysicalRAM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total physical RAM in bytes. </p>
<p>In the context of a container using cgroups (typically Docker), this will take into account that limitation (starting with GDAL 2.4.0)</p>
<p>You should generally use <a class="el" href="cpl__vsi_8h.html#ac6eef6b11f21ea4d5c27a62ac265818a" title="Return the total physical RAM, usable by a process, in bytes. ">CPLGetUsablePhysicalRAM()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the total physical RAM in bytes (or 0 in case of failure). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ac6eef6b11f21ea4d5c27a62ac265818a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eef6b11f21ea4d5c27a62ac265818a">&#9670;&nbsp;</a></span>CPLGetUsablePhysicalRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> CPLGetUsablePhysicalRAM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total physical RAM, usable by a process, in bytes. </p>
<p>This is the same as <a class="el" href="cpl__vsi_8h.html#a2ef39609553f41d5cb5078302c4b3de2" title="Return the total physical RAM in bytes. ">CPLGetPhysicalRAM()</a> except it will limit to 2 GB for 32 bit processes.</p>
<p>Starting with GDAL 2.4.0, it will also take account resource limits on Posix systems.</p>
<p>Note: This memory may already be partly used by other processes.</p>
<dl class="section return"><dt>Returns</dt><dd>the total physical RAM, usable by a process, in bytes (or 0 in case of failure). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a060262f8e9dbe8509bbe535341021750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060262f8e9dbe8509bbe535341021750">&#9670;&nbsp;</a></span>VSIAllocFilesystemPluginCallbacksStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a>* VSIAllocFilesystemPluginCallbacksStruct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html" title="struct containing callbacks to used by the handler. ">VSIFilesystemPluginCallbacksStruct</a> to be populated at runtime with handler callbacks </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a84892f1a5065294b3e3c400534e6a86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84892f1a5065294b3e3c400534e6a86c">&#9670;&nbsp;</a></span>VSICalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSICalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of calloc(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a> to free </p>

</div>
</div>
<a id="a7e7448bda4230b3d8133a59027c5f02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7448bda4230b3d8133a59027c5f02f">&#9670;&nbsp;</a></span>VSICloseDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSICloseDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a directory. </p>
<p>This function is close to the POSIX closedir() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Directory handled returned by <a class="el" href="cpl__vsi_8h.html#a186d32d750cca298ea625c00e8be3f90" title="Open a directory to read its entries. ">VSIOpenDir()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a6b22260317edc475793c4165957742b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b22260317edc475793c4165957742b6">&#9670;&nbsp;</a></span>VSICurlClearCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSICurlClearCache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean local cache associated with /vsicurl/ (and related file systems) </p>
<p>/vsicurl (and related file systems like /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiswift/) cache a number of metadata and data for faster execution in read-only scenarios. But when the content on the server-side may change during the same process, those mechanisms can prevent opening new files, or give an outdated version of them.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2.1 </dd></dl>

</div>
</div>
<a id="a6bc83d16f0f279f601059a218ad2c55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc83d16f0f279f601059a218ad2c55c">&#9670;&nbsp;</a></span>VSICurlPartialClearCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSICurlPartialClearCache </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilenamePrefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean local cache associated with /vsicurl/ (and related file systems) for a given filename (and its subfiles and subdirectories if it is a directory) </p>
<p>/vsicurl (and related file systems like /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiswift/) cache a number of metadata and data for faster execution in read-only scenarios. But when the content on the server-side may change during the same process, those mechanisms can prevent opening new files, or give an outdated version of them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilenamePrefix</td><td>Filename prefix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4.0 </dd></dl>

</div>
</div>
<a id="ae7fe3eb9b2988c5a3c74889697f87e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fe3eb9b2988c5a3c74889697f87e45">&#9670;&nbsp;</a></span>VSIFCloseL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFCloseL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close file. </p>
<p>This function closes the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fclose() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>. Passing a nullptr produces undefined behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="a41f16dba458b87271269c8c4cb39ade6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f16dba458b87271269c8c4cb39ade6">&#9670;&nbsp;</a></span>VSIFEofL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFEofL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for end of file. </p>
<p>Returns TRUE (non-zero) if an end-of-file condition occurred during the previous read operation. The end-of-file flag is cleared by a successful <a class="el" href="cpl__vsi_8h.html#ab32d81e8bf69e8e6e87f0aadf0a490c3" title="Seek to requested offset. ">VSIFSeekL()</a> call.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX feof() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if at EOF else FALSE. </dd></dl>

</div>
</div>
<a id="ac52ca4651926531e79e047709c9ea346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52ca4651926531e79e047709c9ea346">&#9670;&nbsp;</a></span>VSIFFlushL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFFlushL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending writes to disk. </p>
<p>For files in write or update mode and on filesystem types where it is applicable, all pending output on the file is flushed to the physical disk.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fflush() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error. </dd></dl>

</div>
</div>
<a id="a41fd7388a7491b3430d0abe961dada82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fd7388a7491b3430d0abe961dada82">&#9670;&nbsp;</a></span>VSIFGetNativeFileDescriptorL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIFGetNativeFileDescriptorL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the "native" file descriptor for the virtual handle. </p>
<p>This will only return a non-NULL value for "real" files handled by the operating system (to be opposed to GDAL virtual file systems).</p>
<p>On POSIX systems, this will be a integer value ("fd") cast as a void*. On Windows systems, this will be the HANDLE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the native file descriptor, or NULL. </dd></dl>

</div>
</div>
<a id="a0e748fc4b8a074da08095bd91fff8fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e748fc4b8a074da08095bd91fff8fed">&#9670;&nbsp;</a></span>VSIFGetRangeStatusL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a> VSIFGetRangeStatusL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if a given file range contains data or holes filled with zeroes. </p>
<p>This uses the filesystem capabilities of querying which regions of a sparse file are allocated or not. This is currently only implemented for Linux (and no other Unix derivatives) and Windows.</p>
<p>Note: A return of VSI_RANGE_STATUS_DATA doesn't exclude that the extent is filled with zeroes! It must be interpreted as "may
contain non-zero data".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset of the start of the extent. </td></tr>
    <tr><td class="paramname">nLength</td><td>extent length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>extent status: VSI_RANGE_STATUS_UNKNOWN, VSI_RANGE_STATUS_DATA or VSI_RANGE_STATUS_HOLE </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a86b6b1c37bb19d954ee3c4a7e910120c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b6b1c37bb19d954ee3c4a7e910120c">&#9670;&nbsp;</a></span>VSIFileFromMemBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a>* VSIFileFromMemBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bTakeOwnership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create memory "file" from a buffer. </p>
<p>A virtual memory file is created from the passed buffer with the indicated filename. Under normal conditions the filename would need to be absolute and within the /vsimem/ portion of the filesystem.</p>
<p>If bTakeOwnership is TRUE, then the memory file system handler will take ownership of the buffer, freeing it when the file is deleted. Otherwise it remains the responsibility of the caller, but should not be freed as long as it might be accessed as a file. In no circumstances does this function take a copy of the pabyData contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the filename to be created. </td></tr>
    <tr><td class="paramname">pabyData</td><td>the data buffer for the file. </td></tr>
    <tr><td class="paramname">nDataLength</td><td>the length of buffer in bytes. </td></tr>
    <tr><td class="paramname">bTakeOwnership</td><td>TRUE to transfer "ownership" of buffer or FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>open file handle on created file (see <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>). </dd></dl>

</div>
</div>
<a id="ace0a2c35f1214c39546192e192d9322f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0a2c35f1214c39546192e192d9322f">&#9670;&nbsp;</a></span>VSIFOpenExL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a>* VSIFOpenExL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bSetError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open file. </p>
<p>This function opens a file with the desired access. Large files (larger than 2GB) should be supported. Binary access is always implied and the "b" does not need to be included in the pszAccess string.</p>
<p>Note that the "VSILFILE *" returned by this function is <em>NOT</em> a standard C library FILE *, and cannot be used with any functions other than the "VSI*L" family of functions. They aren't "real" FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, restoring the pre-1.8.0 behavior of <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fopen() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the file to open. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszAccess</td><td>access requested (i.e. "r", "r+", "w") </td></tr>
    <tr><td class="paramname">bSetError</td><td>flag determining whether or not this open call should set VSIErrors on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, or the file handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ae3cfa1605ce32e78fddb534bba7742f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cfa1605ce32e78fddb534bba7742f5">&#9670;&nbsp;</a></span>VSIFOpenL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a>* VSIFOpenL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open file. </p>
<p>This function opens a file with the desired access. Large files (larger than 2GB) should be supported. Binary access is always implied and the "b" does not need to be included in the pszAccess string.</p>
<p>Note that the "VSILFILE *" returned since GDAL 1.8.0 by this function is <em>NOT</em> a standard C library FILE *, and cannot be used with any functions other than the "VSI*L" family of functions. They aren't "real" FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, restoring the pre-1.8.0 behavior of <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fopen() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the file to open. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszAccess</td><td>access requested (i.e. "r", "r+", "w")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, or the file handle. </dd></dl>

</div>
</div>
<a id="a6bb02b3133f6e66a44c1cd6c7a251722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb02b3133f6e66a44c1cd6c7a251722">&#9670;&nbsp;</a></span>VSIFPrintfL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFPrintfL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatted write to file. </p>
<p>Provides fprintf() style formatted output to a VSI*L file. This formats an internal buffer which is written using <a class="el" href="cpl__vsi_8h.html#a05e59f50d000a7c6ca7dce76ba5946f9" title="Write bytes to file. ">VSIFWriteL()</a>.</p>
<p>Analog of the POSIX fprintf() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">pszFormat</td><td>the printf() style format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -1 on an error. </dd></dl>

</div>
</div>
<a id="ac42c63c8266a2adc9ecbe5c8a15efa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42c63c8266a2adc9ecbe5c8a15efa9f">&#9670;&nbsp;</a></span>VSIFPutcL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFPutcL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single byte to the file. </p>
<p>Writes the character nChar, cast to an unsigned char, to file.</p>
<p>Almost an analog of the POSIX fputc() call, except that it returns the number of character written (1 or 0), and not the (cast) character itself or EOF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nChar</td><td>character to write. </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success, 0 on error. </dd></dl>

</div>
</div>
<a id="a3e64279a239eef70703efc09f43585e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e64279a239eef70703efc09f43585e9">&#9670;&nbsp;</a></span>VSIFReadL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VSIFReadL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from file. </p>
<p>Reads nCount objects of nSize bytes from the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fread() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>the buffer into which the data should be read (at least nCount * nSize bytes in size. </td></tr>
    <tr><td class="paramname">nSize</td><td>size of objects to read in bytes. </td></tr>
    <tr><td class="paramname">nCount</td><td>number of objects to read. </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects successfully read. </dd></dl>

</div>
</div>
<a id="a7637441ad8a51cdc200e926579f48986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7637441ad8a51cdc200e926579f48986">&#9670;&nbsp;</a></span>VSIFReadMultiRangeL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFReadMultiRangeL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ppData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *&#160;</td>
          <td class="paramname"><em>panOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>panSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read several ranges of bytes from file. </p>
<p>Reads nRanges objects of panSizes[i] bytes from the indicated file at the offset panOffsets[i] into the buffer ppData[i].</p>
<p>Ranges must be sorted in ascending start offset, and must not overlap each other.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory or /vsicurl/.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nRanges</td><td>number of ranges to read. </td></tr>
    <tr><td class="paramname">ppData</td><td>array of nRanges buffer into which the data should be read (ppData[i] must be at list panSizes[i] bytes). </td></tr>
    <tr><td class="paramname">panOffsets</td><td>array of nRanges offsets at which the data should be read. </td></tr>
    <tr><td class="paramname">panSizes</td><td>array of nRanges sizes of objects to read (in bytes). </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a id="ad8fc84461d6ad10524a64ead6af56e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fc84461d6ad10524a64ead6af56e33">&#9670;&nbsp;</a></span>VSIFreeAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIFreeAligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a buffer allocated with <a class="el" href="cpl__vsi_8h.html#a244d29ecd0edf4cf4253ce840733e74e" title="Allocates a buffer with an alignment constraint. ">VSIMallocAligned()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a463cc08892a277549cff8b1e4fe460a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463cc08892a277549cff8b1e4fe460a2">&#9670;&nbsp;</a></span>VSIFreeFilesystemPluginCallbacksStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIFreeFilesystemPluginCallbacksStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *&#160;</td>
          <td class="paramname"><em>poCb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free resources allocated by VSIAllocFilesystemPluginCallbacksStruct </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="ab32d81e8bf69e8e6e87f0aadf0a490c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32d81e8bf69e8e6e87f0aadf0a490c3">&#9670;&nbsp;</a></span>VSIFSeekL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFSeekL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nWhence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to requested offset. </p>
<p>Seek to the desired offset (nOffset) in the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fseek() call.</p>
<p>Caution: vsi_l_offset is a unsigned type, so SEEK_CUR can only be used for positive seek. If negative seek is needed, use VSIFSeekL( fp, VSIFTellL(fp) + negative_offset, SEEK_SET ).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset in bytes. </td></tr>
    <tr><td class="paramname">nWhence</td><td>one of SEEK_SET, SEEK_CUR or SEEK_END.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 one failure. </dd></dl>

</div>
</div>
<a id="ad8bacb4bbdbd8474a1ec2236199549e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bacb4bbdbd8474a1ec2236199549e3">&#9670;&nbsp;</a></span>VSIFTellL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> VSIFTellL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell current file offset. </p>
<p>Returns the current file read/write offset in bytes from the beginning of the file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftell() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>file offset in bytes. </dd></dl>

</div>
</div>
<a id="a2ce7a020522db02f0324734e2b86d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce7a020522db02f0324734e2b86d84c">&#9670;&nbsp;</a></span>VSIFTruncateL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFTruncateL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nNewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate/expand the file to the specified size. </p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftruncate() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">nNewSize</td><td>new size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a id="a05e59f50d000a7c6ca7dce76ba5946f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e59f50d000a7c6ca7dce76ba5946f9">&#9670;&nbsp;</a></span>VSIFWriteL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VSIFWriteL </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes to file. </p>
<p>Writess nCount objects of nSize bytes to the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fwrite() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>the buffer from which the data should be written (at least nCount * nSize bytes in size. </td></tr>
    <tr><td class="paramname">nSize</td><td>size of objects to read in bytes. </td></tr>
    <tr><td class="paramname">nCount</td><td>number of objects to read. </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects successfully written. </dd></dl>

</div>
</div>
<a id="a0cc60b3e3bf1e892313f2abf0bcfaffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc60b3e3bf1e892313f2abf0bcfaffd">&#9670;&nbsp;</a></span>VSIGetActualURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VSIGetActualURL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual URL of a supplied filename. </p>
<p>Currently only returns a non-NULL value for network-based virtual file systems. For example "/vsis3/bucket/filename" will be expanded as "https://bucket.s3.amazon.com/filename"</p>
<p>Note that the lifetime of the returned string, is short, and may be invalidated by any following GDAL functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual URL corresponding to the supplied filename, or NULL. Should not be freed.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad4ae557aaaa4cc249cd97080101a8297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ae557aaaa4cc249cd97080101a8297">&#9670;&nbsp;</a></span>VSIGetDiskFreeSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> VSIGetDiskFreeSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return free disk space available on the filesystem. </p>
<p>This function returns the free disk space available on the filesystem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDirname</td><td>a directory of the filesystem to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The free space in bytes. Or -1 in case of error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="aeabd47a968dc175e77d0545187100b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabd47a968dc175e77d0545187100b92">&#9670;&nbsp;</a></span>VSIGetFileMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIGetFileMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get metadata on files. </p>
<p>Implemented currently only for network-like filesystems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszDomain</td><td>Metadata domain to query. Depends on the file system. The following are supported: <ul>
<li>
HEADERS: to get HTTP headers for network-like filesystems (/vsicurl/, /vsis3/, etc) </li>
<li>
TAGS: specific to /vsis3/: to get S3 Object tagging information </li>
</ul>
</td></tr>
    <tr><td class="paramname">papszOptions</td><td>Unused. Should be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a NULL-terminated list of key=value strings, to be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list. ">CSLDestroy()</a> or NULL in case of error / empty list.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="a85ca54aa40490c9237e9dd2905d9daac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ca54aa40490c9237e9dd2905d9daac">&#9670;&nbsp;</a></span>VSIGetFileSystemOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VSIGetFileSystemOptions </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of options associated with a virtual file system handler as a serialized XML string. </p>
<p>Those options may be set as configuration options with <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use. ">CPLSetConfigOption()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>a filename, or prefix of a virtual file system handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string, which must not be freed, or NULL if no options is declared. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="adfb3d5eb0effa7326ca6d3130b60bc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb3d5eb0effa7326ca6d3130b60bc94">&#9670;&nbsp;</a></span>VSIGetFileSystemsPrefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIGetFileSystemsPrefixes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of prefixes for virtual file system handlers currently registered. </p>
<p>Typically: "", "/vsimem/", "/vsicurl/", etc</p>
<dl class="section return"><dt>Returns</dt><dd>a NULL terminated list of prefixes. Must be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list. ">CSLDestroy()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aeaf26bcc4a5314371f426bb2a5e6ce7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf26bcc4a5314371f426bb2a5e6ce7a">&#9670;&nbsp;</a></span>VSIGetMemFileBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a>* VSIGetMemFileBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *&#160;</td>
          <td class="paramname"><em>pnDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUnlinkAndSeize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch buffer underlying memory file. </p>
<p>This function returns a pointer to the memory buffer underlying a virtual "in memory" file. If bUnlinkAndSeize is TRUE the filesystem object will be deleted, and ownership of the buffer will pass to the caller otherwise the underlying file will remain in existence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the name of the file to grab the buffer of. </td></tr>
    <tr><td class="paramname">pnDataLength</td><td>(file) length returned in this variable. </td></tr>
    <tr><td class="paramname">bUnlinkAndSeize</td><td>TRUE to remove the file, or FALSE to leave unaltered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory buffer or NULL on failure. </dd></dl>

</div>
</div>
<a id="a0ce4131b005b1853a16d4f341d1ba031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce4131b005b1853a16d4f341d1ba031">&#9670;&nbsp;</a></span>VSIGetNextDirEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVSIDIREntry.html">VSIDIREntry</a>* VSIGetNextDirEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next entry of the directory. </p>
<p>This function is close to the POSIX readdir() function. It actually returns more information (file size, last modification time), which on 'real' file systems involve one 'stat' call per file.</p>
<p>For filesystems that can have both a regular file and a directory name of the same name (typically /vsis3/), when this situation of duplicate happens, the directory name will be suffixed by a slash character. Otherwise directory names are not suffixed by slash.</p>
<p>The returned entry remains valid until the next call to VSINextDirEntry() or <a class="el" href="cpl__vsi_8h.html#a7e7448bda4230b3d8133a59027c5f02f" title="Close a directory. ">VSICloseDir()</a> with the same handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Directory handled returned by <a class="el" href="cpl__vsi_8h.html#a186d32d750cca298ea625c00e8be3f90" title="Open a directory to read its entries. ">VSIOpenDir()</a>. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a entry, or NULL if there is no more entry in the directory. This return value must not be freed. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a9b7d8fe76bc6c58fce962424574f0325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7d8fe76bc6c58fce962424574f0325">&#9670;&nbsp;</a></span>VSIGetSignedURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIGetSignedURL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a signed URL of a supplied filename. </p>
<p>Currently only returns a non-NULL value for /vsis3/, /vsigs/, /vsiaz/ and /vsioss/ For example "/vsis3/bucket/filename" will be expanded as "https://bucket.s3.amazon.com/filename?X-Amz-Algorithm=AWS4-HMAC-SHA256..." Configuration options that apply for file opening (typically to provide credentials), and are returned by <a class="el" href="cpl__vsi_8h.html#a85ca54aa40490c9237e9dd2905d9daac" title="Return the list of options associated with a virtual file system handler as a serialized XML string...">VSIGetFileSystemOptions()</a>, are also valid in that context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>list of options, or NULL. Depend on file system handler. For /vsis3/, /vsigs/, /vsiaz/ and /vsioss/, the following options are supported: <ul>
<li>
START_DATE=YYMMDDTHHMMSSZ: date and time in UTC following ISO 8601 standard, corresponding to the start of validity of the URL. If not specified, current date time. </li>
<li>
EXPIRATION_DELAY=number_of_seconds: number between 1 and 604800 (seven days) for the validity of the signed URL. Defaults to 3600 (one hour) </li>
<li>
VERB=GET/HEAD/DELETE/PUT/POST: HTTP VERB for which the request will be used. Default to GET. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>/vsiaz/ supports additional options: </p><ul>
<li>
SIGNEDIDENTIFIER=value: to relate the given shared access signature to a corresponding stored access policy. </li>
<li>
SIGNEDPERMISSIONS=r|w: permissions associated with the shared access signature. Normally deduced from VERB. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a signed URL, or NULL. Should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a40f2fd6f6c0676f27eb1bfdec56753a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f2fd6f6c0676f27eb1bfdec56753a9">&#9670;&nbsp;</a></span>VSIHasOptimizedReadMultiRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIHasOptimizedReadMultiRange </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filesystem supports efficient multi-range reading. </p>
<p>Currently only returns TRUE for /vsicurl/ and derived file systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the file system is known to have an efficient multi-range reading.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a9d1d497584c01f156cda57b30de447dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1d497584c01f156cda57b30de447dc">&#9670;&nbsp;</a></span>VSIIngestFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIIngestFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> **&#160;</td>
          <td class="paramname"><em>ppabyRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *&#160;</td>
          <td class="paramname"><em>pnSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nMaxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ingest a file into memory. </p>
<p>Read the whole content of a file into a memory buffer.</p>
<p>Either fp or pszFilename can be NULL, but not both at the same time.</p>
<p>If fp is passed non-NULL, it is the responsibility of the caller to close it.</p>
<p>If non-NULL, the returned buffer is guaranteed to be NUL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">pszFilename</td><td>filename. </td></tr>
    <tr><td class="paramname">ppabyRet</td><td>pointer to the target buffer. *ppabyRet must be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a> </td></tr>
    <tr><td class="paramname">pnSize</td><td>pointer to variable to store the file size. May be NULL. </td></tr>
    <tr><td class="paramname">nMaxSize</td><td>maximum size of file allowed. If no limit, set to a negative value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="af1f1bf516788238d7138c879dedd62a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f1bf516788238d7138c879dedd62a4">&#9670;&nbsp;</a></span>VSIInstallAzureFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallAzureFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiaz/ Microsoft Azure Blob file system handler (requires libcurl) </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsiaz">/vsiaz/ documentation</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a5e20b79947f58970f5514b3eb9a524a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e20b79947f58970f5514b3eb9a524a9">&#9670;&nbsp;</a></span>VSIInstallCryptFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCryptFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsicrypt/ encrypted file system handler (requires <a href="http://www.cryptopp.com/">libcrypto++</a>) </p>
<p>A special file handler is installed that allows reading/creating/update encrypted files on the fly, with random access capabilities.</p>
<p>The cryptographic algorithms used are <a href="https://en.wikipedia.org/wiki/Block_cipher">block ciphers</a>, with symmetric key.</p>
<p>In their simplest form, recognized filenames are of the form /vsicrypt//absolute_path/to/file, /vsicrypt/c:/absolute_path/to/file or /vsicrypt/relative/path/to/file.</p>
<p>Options can also be used with the following format : /vsicrypt/option1=val1,option2=val2,...,file=/path/to/file</p>
<p>They can also be passed as configuration option/environment variable, because in some use cases, the syntax with option in the filename might not properly work with some drivers.</p>
<p>In all modes, the encryption key must be provided. There are several ways of doing so : </p><ul>
<li>
By adding a key= parameter to the filename, like /vsicrypt/key=my_secret_key,file=/path/to/file. Note that this restricts the key to be in text format, whereas at its full power, it can be binary content. </li>
<li>
By adding a key_b64= parameter to the filename, to specify a binary key expressed in Base64 encoding, like /vsicrypt/key_b64=th1sl00kslikebase64=,file=/path/to/file. </li>
<li>
By setting the VSICRYPT_KEY configuration option. The key should be in text format. </li>
<li>
By setting the VSICRYPT_KEY_B64 configuration option. The key should be encoded in Base64. </li>
<li>
By using the <a class="el" href="cpl__vsi_8h.html#a619a6f6758371a39e0c1a4168462452c" title="Installs the encryption/decryption key. ">VSISetCryptKey()</a> C function. </li>
</ul>
<p>When creating a file, if key=GENERATE_IT or VSICRYPT_KEY=GENERATE_IT is passed, the encryption key will be generated from the pseudo-random number generator of the operating system. The key will be displayed on the standard error stream in a Base64 form (unless the VSICRYPT_DISPLAY_GENERATED_KEY configuration option is set to OFF), and the VSICRYPT_KEY_B64 configuration option will also be set with the Base64 form of the key (so that CPLGetConfigOption("VSICRYPT_KEY_B64", NULL) can be used to get it back).</p>
<p>The available options are : </p><ul>
<li>
alg=AES/Blowfish/Camellia/CAST256/DES_EDE2/DES_EDE3/MARS/IDEA/RC5/RC6/Serpent/SHACAL2/SKIPJACK/Twofish/XTEA: to specify the <a href="https://en.wikipedia.org/wiki/Block_cipher">block cipher</a> algorithm. The default is AES. Only used on creation. Ignored otherwise. Note: depending on how GDAL is build, if linked against the DLL version of libcrypto++, only a subset of those algorithms will be available, namely AES, DES_EDE2, DES_EDE3 and SKIPJACK. Also available as VSICRYPT_ALG configuration option. </li>
<li>
mode=CBC/CFB/OFB/CTR/CBC_CTS: to specify the <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">block cipher mode of operation</a>. The default is CBC. Only used on creation. Ignored otherwise. Also available as VSICRYPT_MODE configuration option. </li>
<li>
key=text_key: see above. </li>
<li>
key_b64=base64_encoded_key: see above. </li>
<li>
freetext=some_text: to specify a text content that will be written <em>unencrypted</em> in the file header, for informational purposes. Default to empty. Only used on creation. Ignored otherwise. Also available as VSICRYPT_FREETEXT configuration option. </li>
<li>
sector_size=int_value: to specify the size of the "sector", which is the unit chunk of information that is encrypted/decrypted. Default to 512 bytes. The valid values depend on the algorithm and block cipher mode of operation. Only used on creation. Ignored otherwise. Also available as VSICRYPT_SECTOR_SIZE configuration option. </li>
<li>
<p class="startli">iv=initial_vector_as_text: to specify the Initial Vector. This is an advanced option that should generally <em>NOT</em> be used. It is only useful to get completely deterministic output given the plaintext, key and other parameters, which in general <em>NOT</em> what you want to do. By default, a random initial vector of the appropriate size will be generated for each new file created. Only used on creation. Ignored otherwise. Also available as VSICRYPT_IV configuration option.</p>
<p class="endli"></p>
</li>
<li>
add_key_check=YES/NO: whether a special value should be encrypted in the header, so as to be quickly able to determine if the decryption key is correct. Defaults to NO. Only used on creation. Ignored otherwise. Also available as VSICRYPT_ADD_KEY_CHECK configuration option. </li>
<li>
file=filename. To specify the filename. This must be the last option put in the option list (so as to make it possible to use filenames with comma in them. ) </li>
</ul>
<p>This special file handler can be combined with other virtual filesystems handlers, such as /vsizip. For example, /vsicrypt//vsicurl/path/to/remote/encrypted/file.tif</p>
<p>Implementation details:</p>
<p>The structure of encrypted files is the following: a header, immediately followed by the encrypted payload (by sectors, i.e. chunks of sector_size bytes).</p>
<p>The header structure is the following : </p><ol>
<li>
8 bytes. Signature. Fixed value: VSICRYPT. </li>
<li>
UINT16_LE. Header size (including previous signature bytes). </li>
<li>
UINT8. Format major version. Current value: 1. </li>
<li>
UINT8. Format minor version. Current value: 0. </li>
<li>
UINT16. Sector size. </li>
<li>
UINT8. Cipher algorithm. Valid values are: 0 = AES (Rijndael), 1 = Blowfish, 2 = Camellia, 3 = CAST256, 4 = DES_EDE2, 5 = DES_EDE3, 6 = MARS, 7 = IDEA, 8 = RC5, 9 = RC6, 10 = Serpent, 11 = SHACAL2, 12 = SKIPJACK, 13 = Twofish, 14 = XTEA. </li>
<li>
UINT8. Block cipher mode of operation. Valid values are: 0 = CBC, 1 = CFB, 2 = OFB, 3 = CTR, 4 = CBC_CTS. </li>
<li>
UINT8. Size in bytes of the Initial Vector. </li>
<li>
N bytes with the content of the Initial Vector, where N is the value of the previous field. </li>
<li>
UINT16_LE. Size in bytes of the free text. </li>
<li>
N bytes with the content of the free text, where N is the value of the previous field. </li>
<li>
UINT8. Size in bytes of encrypted content (key check), or 0 if key check is absent. </li>
<li>
N bytes with encrypted content (key check), where N is the value of the previous field. </li>
<li>
UINT64_LE. Size of the unencrypted file, in bytes. </li>
<li>
UINT16_LE. Size in bytes of extra content (of unspecified semantics). For v1.0, fixed value of 0 </li>
<li>
N bytes with extra content (of unspecified semantics), where N is the value of the previous field. </li>
</ol>
<p>This design does not provide any means of authentication or integrity check.</p>
<p>Each sector is encrypted/decrypted independently of other sectors. For that, the Initial Vector contained in the header is XOR'ed with the file offset (relative to plain text file) of the start of the sector being processed, as a 8-byte integer. More precisely, the first byte of the main IV is XOR'ed with the 8 least-significant bits of the sector offset, the second byte of the main IV is XOR'ed with the following 8 bits of the sector offset, etc... until the 8th byte.</p>
<p>This design could potentially be prone to chosen-plaintext attack, for example if the attacker managed to get (part of) an existing encrypted file to be encrypted from plaintext he might have selected.</p>
<p>Note: if "hostile" code can explore process content, or attach to it with a debugger, it might be relatively easy to retrieve the encryption key. A GDAL plugin could for example get the content of configuration options, or list opened datasets and see the key/key_b64 values, so disabling plugin loading might be a first step, as well as linking statically GDAL to application code. If plugin loading is enabled or GDAL dynamically linked, using <a class="el" href="cpl__vsi_8h.html#a619a6f6758371a39e0c1a4168462452c" title="Installs the encryption/decryption key. ">VSISetCryptKey()</a> to set the key might make it a bit more complicated to spy the key. But, as said initially, this is in no way a perfect protection.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1.0 </dd></dl>

</div>
</div>
<a id="a4f791960f2d86713d16e99e9c0c36258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f791960f2d86713d16e99e9c0c36258">&#9670;&nbsp;</a></span>VSIInstallCurlFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCurlFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsicurl/ HTTP/FTP file system handler (requires libcurl) </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsicurl">/vsicurl/ documentation</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="af80a70fd45cd7a2119f1a2f7da071870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80a70fd45cd7a2119f1a2f7da071870">&#9670;&nbsp;</a></span>VSIInstallGSFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallGSFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsigs/ Google Cloud Storage file system handler (requires libcurl) </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsigs">/vsigs/ documentation</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a3cde09f204df6f417653b7af4761178e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cde09f204df6f417653b7af4761178e">&#9670;&nbsp;</a></span>VSIInstallGZipFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallGZipFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install GZip file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly and writing in GZip (.gz) files.</p>
<p>All portions of the file system underneath the base path "/vsigzip/" will be handled by this driver.</p>
<p>Additional documentation is to be found at: <a href="http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip">http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip</a></p>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a id="a5c296255c2263248d0e6ad7c4481d746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c296255c2263248d0e6ad7c4481d746">&#9670;&nbsp;</a></span>VSIInstallHdfsHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallHdfsHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsihdfs/ file system handler (requires JVM and HDFS support) </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4.0 </dd></dl>

</div>
</div>
<a id="a66e2e6f093fd42f8a941b962d4c8a19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e2e6f093fd42f8a941b962d4c8a19e">&#9670;&nbsp;</a></span>VSIInstallMemFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallMemFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install "memory" file system handler. </p>
<p>A special file handler is installed that allows block of memory to be treated as files. All portions of the file system underneath the base path "/vsimem/" will be handled by this driver.</p>
<p>Normal VSI*L functions can be used freely to create and destroy memory arrays treating them as if they were real file system objects. Some additional methods exist to efficient create memory file system objects without duplicating original copies of the data or to "steal" the block of memory associated with a memory file.</p>
<p>Directory related functions are supported.</p>
<p>This code example demonstrates using GDAL to translate from one memory buffer to another.</p>
<div class="fragment"><div class="line"><a class="code" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *ConvertBufferFormat( <a class="code" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyInData, <a class="code" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nInDataLength,</div><div class="line">                            <a class="code" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *pnOutDataLength )</div><div class="line">{</div><div class="line">    <span class="comment">// create memory file system object from buffer.</span></div><div class="line">    <a class="code" href="cpl__vsi_8h.html#ae7fe3eb9b2988c5a3c74889697f87e45">VSIFCloseL</a>( <a class="code" href="cpl__vsi_8h.html#a86b6b1c37bb19d954ee3c4a7e910120c">VSIFileFromMemBuffer</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span>, pabyInData,</div><div class="line">                                      nInDataLength, FALSE ) );</div><div class="line"></div><div class="line">    <span class="comment">// Open memory buffer for read.</span></div><div class="line">    <a class="code" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDS = <a class="code" href="gdal_8h.html#a6836f0f810396c5e45622c8ef94624d4">GDALOpen</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span>, <a class="code" href="gdal_8h.html#a045e3967c208993f70257bfd40c9f1d7a5a021a550b9d5640307d3c0e7e35b732">GA_ReadOnly</a> );</div><div class="line"></div><div class="line">    <span class="comment">// Get output format driver.</span></div><div class="line">    <a class="code" href="gdal_8h.html#adfd09c07260442427a225e2a536ead72">GDALDriverH</a> hDriver = <a class="code" href="gdal_8h.html#ae8ae868eef1e4773283d137b0a1adfc4">GDALGetDriverByName</a>( <span class="stringliteral">&quot;GTiff&quot;</span> );</div><div class="line">    <a class="code" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hOutDS;</div><div class="line"></div><div class="line">    hOutDS = <a class="code" href="gdal_8h.html#a7e30145de0c454cb6c0661cfff12ee69">GDALCreateCopy</a>( hDriver, <span class="stringliteral">&quot;/vsimem/out.tif&quot;</span>, hDS, TRUE, NULL,</div><div class="line">                             NULL, NULL );</div><div class="line"></div><div class="line">    <span class="comment">// close source file, and &quot;unlink&quot; it.</span></div><div class="line">    <a class="code" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc">GDALClose</a>( hDS );</div><div class="line">    <a class="code" href="cpl__vsi_8h.html#a7ff49d132f70ec46a550c5a51103e394">VSIUnlink</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span> );</div><div class="line"></div><div class="line">    <span class="comment">// seize the buffer associated with the output file.</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a">VSIGetMemFileBuffer</a>( <span class="stringliteral">&quot;/vsimem/out.tif&quot;</span>, pnOutDataLength, TRUE );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ad393a845ca054eab086fb933cee74be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad393a845ca054eab086fb933cee74be0">&#9670;&nbsp;</a></span>VSIInstallOSSFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallOSSFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsioss/ Alibaba Cloud Object Storage Service (OSS) file system handler (requires libcurl) </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsioss">/vsioss/ documentation</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a9fd74a1b0cad563fe1518660967a673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd74a1b0cad563fe1518660967a673f">&#9670;&nbsp;</a></span>VSIInstallPluginHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIInstallPluginHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *&#160;</td>
          <td class="paramname"><em>poCb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register a handler on the given prefix. </p>
<p>All IO on datasets opened with the filename /prefix/xxxxxx will go through these callbacks. pszPrefix must begin and end with a '/' </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a5b4754999acd06444bfda172ff2aaa16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4754999acd06444bfda172ff2aaa16">&#9670;&nbsp;</a></span>VSIInstallS3FileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallS3FileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsis3/ Amazon S3 file system handler (requires libcurl) </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsis3">/vsis3/ documentation</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ab79aed725b28eb22471a8b6733405843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79aed725b28eb22471a8b6733405843">&#9670;&nbsp;</a></span>VSIInstallSparseFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSparseFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsisparse/ virtual file handler. </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsisparse">/vsisparse/ documentation</a> </dd></dl>

</div>
</div>
<a id="a2c6b408477f59b40f0aec51d5980eb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6b408477f59b40f0aec51d5980eb8e">&#9670;&nbsp;</a></span>VSIInstallStdinHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallStdinHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsistdin/ file system handler. </p>
<p>A special file handler is installed that allows reading from the standard input stream.</p>
<p>The file operations available are of course limited to Read() and forward Seek() (full seek in the first MB of a file).</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="a61d2250ab2b22ca79b051a8479ee5383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d2250ab2b22ca79b051a8479ee5383">&#9670;&nbsp;</a></span>VSIInstallStdoutHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallStdoutHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsistdout/ file system handler. </p>
<p>A special file handler is installed that allows writing to the standard output stream.</p>
<p>The file operations available are of course limited to Write().</p>
<p>A variation of this file system exists as the /vsistdout_redirect/ file system handler, where the output function can be defined with <a class="el" href="cpl__vsi_8h.html#adc4a67cc303d7662c34f506d0bdddd79" title="Set an alternative write function and output file handle instead of fwrite() / stdout. ">VSIStdoutSetRedirection()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="abaee4232440e012b4b9920934fc571cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaee4232440e012b4b9920934fc571cc">&#9670;&nbsp;</a></span>VSIInstallSubFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSubFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsisubfile/ virtual file handler. </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_subfile">/vsisubfile/ documentation</a> </dd></dl>

</div>
</div>
<a id="a87a177eab3fbc4241083f6749b9a75d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a177eab3fbc4241083f6749b9a75d5">&#9670;&nbsp;</a></span>VSIInstallSwiftFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSwiftFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiswift/ OpenStack Swif Object Storage (Swift) file system handler (requires libcurl) </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsiswift">/vsiswift/ documentation</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad6dd983338849e7da4eaa88f6458ab64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dd983338849e7da4eaa88f6458ab64">&#9670;&nbsp;</a></span>VSIInstallTarFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallTarFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsitar/ file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in TAR (regular .tar, or compressed .tar.gz/.tgz) archives.</p>
<p>All portions of the file system underneath the base path "/vsitar/" will be handled by this driver.</p>
<p>The syntax to open a file inside a tar file is /vsitar/path/to/the/file.tar/path/inside/the/tar/file were path/to/the/file.tar is relative or absolute and path/inside/the/tar/file is the relative path to the file inside the archive.</p>
<p>Starting with GDAL 2.2, an alternate syntax is available so as to enable chaining and not being dependent on .tar extension : /vsitar/{/path/to/the/archive}/path/inside/the/tar/file. Note that /path/to/the/archive may also itself this alternate syntax.</p>
<p>If the path is absolute, it should begin with a / on a Unix-like OS (or C:\ on Windows), so the line looks like /vsitar//home/gdal/... For example gdalinfo /vsitar/myarchive.tar/subdir1/file1.tif</p>
<p>Syntactic sugar : if the tar archive contains only one file located at its root, just mentioning "/vsitar/path/to/the/file.tar" will work</p>
<p><a class="el" href="cpl__vsi_8h.html#a2fc1cc4f2893dc422eb57e430798991a" title="Get filesystem object info. ">VSIStatL()</a> will return the uncompressed size in st_size member and file nature- file or directory - in st_mode member.</p>
<p>Directory listing is available through <a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory. ">VSIReadDir()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="a51b1d08d5f6dcd37d2ed89583765ee9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b1d08d5f6dcd37d2ed89583765ee9b">&#9670;&nbsp;</a></span>VSIInstallWebHdfsHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallWebHdfsHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiwebhdfs/ WebHDFS (Hadoop File System) REST API file system handler (requires libcurl) </p>
<dl class="section see"><dt>See also</dt><dd><a href="gdal_virtual_file_systems.html#gdal_virtual_file_systems_vsiwebhdfs">/vsiwebhdfs/ documentation</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a884fac3cd6be2c09deb807e959d78b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884fac3cd6be2c09deb807e959d78b3a">&#9670;&nbsp;</a></span>VSIInstallZipFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallZipFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install ZIP file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in ZIP (.zip) archives.</p>
<p>All portions of the file system underneath the base path "/vsizip/" will be handled by this driver.</p>
<p>The syntax to open a file inside a zip file is /vsizip/path/to/the/file.zip/path/inside/the/zip/file where path/to/the/file.zip is relative or absolute and path/inside/the/zip/file is the relative path to the file inside the archive.</p>
<p>Starting with GDAL 2.2, an alternate syntax is available so as to enable chaining and not being dependent on .zip extension : /vsizip/{/path/to/the/archive}/path/inside/the/zip/file. Note that /path/to/the/archive may also itself use this alternate syntax.</p>
<p>If the path is absolute, it should begin with a / on a Unix-like OS (or C:\ on Windows), so the line looks like /vsizip//home/gdal/... For example gdalinfo /vsizip/myarchive.zip/subdir1/file1.tif</p>
<p>Syntactic sugar : if the .zip file contains only one file located at its root, just mentioning "/vsizip/path/to/the/file.zip" will work</p>
<p><a class="el" href="cpl__vsi_8h.html#a2fc1cc4f2893dc422eb57e430798991a" title="Get filesystem object info. ">VSIStatL()</a> will return the uncompressed size in st_size member and file nature- file or directory - in st_mode member.</p>
<p>Directory listing is available through <a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory. ">VSIReadDir()</a>.</p>
<p>Since GDAL 1.8.0, write capabilities are available. They allow creating a new zip file and adding new files to an already existing (or just created) zip file. Read and write operations cannot be interleaved : the new zip must be closed before being re-opened for read.</p>
<p>Additional documentation is to be found at <a href="http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip">http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip</a></p>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a id="a36737f0cb2949ba2f7bbf23cc6592a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36737f0cb2949ba2f7bbf23cc6592a04">&#9670;&nbsp;</a></span>VSIIsCaseSensitiveFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIIsCaseSensitiveFS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filenames of the filesystem are case sensitive. </p>
<p>This method retrieves to which filesystem belongs the passed filename and return TRUE if the filenames of that filesystem are case sensitive.</p>
<p>Currently, this will return FALSE only for Windows real filenames. Other VSI virtual filesystems are case sensitive.</p>
<p>This methods avoid ugly #ifndef WIN32 / #endif code, that is wrong when dealing with virtual filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the filenames of the filesystem are case sensitive.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="a3e403f4f7e059d12da468d20d604e13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e403f4f7e059d12da468d20d604e13c">&#9670;&nbsp;</a></span>VSIMalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of malloc(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a> to free </p>

</div>
</div>
<a id="a2286902bc6bf22d866e72df2e474d68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2286902bc6bf22d866e72df2e474d68c">&#9670;&nbsp;</a></span>VSIMalloc2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VSIMalloc2 allocates (nSize1 * nSize2) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a>. If nSize1 == 0 || nSize2 == 0, a NULL pointer will also be returned. <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a> can be used to free memory allocated by this function. </p>

</div>
</div>
<a id="a5114ce8d68c4f351309805314f3b5063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114ce8d68c4f351309805314f3b5063">&#9670;&nbsp;</a></span>VSIMalloc3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc3 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a>. If nSize1 == 0 || nSize2 == 0 || nSize3 == 0, a NULL pointer will also be returned. <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a> can be used to free memory allocated by this function. </p>

</div>
</div>
<a id="a244d29ecd0edf4cf4253ce840733e74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244d29ecd0edf4cf4253ce840733e74e">&#9670;&nbsp;</a></span>VSIMallocAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMallocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer with an alignment constraint. </p>
<p>The return value must be freed with <a class="el" href="cpl__vsi_8h.html#ad8fc84461d6ad10524a64ead6af56e33" title="Free a buffer allocated with VSIMallocAligned(). ">VSIFreeAligned()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nAlignment</td><td>Must be a power of 2, multiple of sizeof(void*), and lesser than 256. </td></tr>
    <tr><td class="paramname">nSize</td><td>Size of the buffer to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer aligned on nAlignment and of size nSize, or NULL </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a6a7ffacaa79dbd0a8b7df8a43eab4a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7ffacaa79dbd0a8b7df8a43eab4a0c">&#9670;&nbsp;</a></span>VSIMallocAlignedAuto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMallocAlignedAuto </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer with an alignment constraint such that it can be used by the most demanding vector instruction set on that platform. </p>
<p>The return value must be freed with <a class="el" href="cpl__vsi_8h.html#ad8fc84461d6ad10524a64ead6af56e33" title="Free a buffer allocated with VSIMallocAligned(). ">VSIFreeAligned()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>Size of the buffer to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an aligned buffer of size nSize, or NULL </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="aaa3e0b14583ca553a29bf163b972c157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3e0b14583ca553a29bf163b972c157">&#9670;&nbsp;</a></span>VSIMkdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory. </p>
<p>Create a new directory with the indicated mode. The mode is ignored on some platforms. A reasonable default mode value would be 0666. This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX mkdir() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathname</td><td>the path to the directory to create. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">mode</td><td>the permissions mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="a62018c639ec285ae04afa5799ee6a4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62018c639ec285ae04afa5799ee6a4d5">&#9670;&nbsp;</a></span>VSIMkdirRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMkdirRecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory and all its ancestors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathname</td><td>the path to the directory to create. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">mode</td><td>the permissions mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a186d32d750cca298ea625c00e8be3f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186d32d750cca298ea625c00e8be3f90">&#9670;&nbsp;</a></span>VSIOpenDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a>* VSIOpenDir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRecurseDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory to read its entries. </p>
<p>This function is close to the POSIX opendir() function.</p>
<p>For /vsis3/, /vsigs/, /vsioss/ and /vsiaz/, this function has an efficient implementation, minimizing the number of network requests, when invoked with nRecurseDepth &lt;= 0.</p>
<p>Entries are read by calling <a class="el" href="cpl__vsi_8h.html#a0ce4131b005b1853a16d4f341d1ba031" title="Return the next entry of the directory. ">VSIGetNextDirEntry()</a> on the handled returned by that function, until it returns NULL. <a class="el" href="cpl__vsi_8h.html#a7e7448bda4230b3d8133a59027c5f02f" title="Close a directory. ">VSICloseDir()</a> must be called once done with the returned directory handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">nRecurseDepth</td><td>0 means do not recurse in subdirectories, 1 means recurse only in the first level of subdirectories, etc. -1 means unlimited recursion level </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle, or NULL in case of error </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="aee0f456d7e6579d15a0cdc5f2d42104d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0f456d7e6579d15a0cdc5f2d42104d">&#9670;&nbsp;</a></span>VSIOverwriteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIOverwriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fpTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSourceFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite an existing file with content from another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpTarget</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a> with "rb+" flag. </td></tr>
    <tr><td class="paramname">pszSourceFilename</td><td>source filename</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="a6158d73485d6cf92c75b38e7f26d00c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6158d73485d6cf92c75b38e7f26d00c3">&#9670;&nbsp;</a></span>VSIReadDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read names in a directory. </p>
<p>This function abstracts access to directory contains. It returns a list of strings containing the names of files, and directories in this directory. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list. ">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<p>This function used to be known as <a class="el" href="cpl__vsi_8h.html#afdc1dc07ba4fe31933c9b522de783692" title="Alias of VSIReadDir() ">CPLReadDir()</a>, but the old name is now deprecated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of entries in the directory, or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>

</div>
</div>
<a id="aab9f5bbeaa3ad170682f130f427930bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9f5bbeaa3ad170682f130f427930bd">&#9670;&nbsp;</a></span>VSIReadDirEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDirEx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxFiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read names in a directory. </p>
<p>This function abstracts access to directory contains. It returns a list of strings containing the names of files, and directories in this directory. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list. ">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<p>If nMaxFiles is set to a positive number, directory listing will stop after that limit has been reached. Note that to indicate truncate, at least one element more than the nMaxFiles limit will be returned. If <a class="el" href="cpl__string_8h.html#a827f21b7a67d16059c131d0946482bb1" title="Return number of items in a string list. ">CSLCount()</a> on the result is lesser or equal to nMaxFiles, then no truncation occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">nMaxFiles</td><td>maximum number of files after which to stop, or 0 for no limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of entries in the directory, or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a03c473cd78f2dffabf709245a928e6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c473cd78f2dffabf709245a928e6c7">&#9670;&nbsp;</a></span>VSIReadDirRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDirRecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read names in a directory recursively. </p>
<p>This function abstracts access to directory contents and subdirectories. It returns a list of strings containing the names of files and directories in this directory and all subdirectories. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list. ">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathIn</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of entries in the directory and subdirectories or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
<a id="ac022eb90a80c108cc43c619ccd17792c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac022eb90a80c108cc43c619ccd17792c">&#9670;&nbsp;</a></span>VSIRealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nNewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of realloc(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a> to free </p>

</div>
</div>
<a id="a26cae93b5a32e11bef9ec7c118f8cca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cae93b5a32e11bef9ec7c118f8cca4">&#9670;&nbsp;</a></span>VSIRename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a file. </p>
<p>Renames a file object in the file system. It should be possible to rename a file onto a new filesystem, but it is safest if this function is only used to rename files that remain in the same directory.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rename() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldpath</td><td>the name of the file to be renamed. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">newpath</td><td>the name the file should be given. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="abbbc227f7c966e95ece4691c3cc1c562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbc227f7c966e95ece4691c3cc1c562">&#9670;&nbsp;</a></span>VSIRewindL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIRewindL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind the file pointer to the beginning of the file. </p>
<p>This is equivalent to VSIFSeekL( fp, 0, SEEK_SET )</p>
<p>Analog of the POSIX rewind() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file. ">VSIFOpenL()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12c8873a6ff54d9c1e7f752cada9822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c8873a6ff54d9c1e7f752cada9822">&#9670;&nbsp;</a></span>VSIRmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a directory. </p>
<p>Deletes a directory object from the file system. On some systems the directory must be empty before it can be deleted.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rmdir() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDirname</td><td>the path of the directory to be deleted. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="aa5e05f10c591053fa876c9d3417421a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e05f10c591053fa876c9d3417421a5">&#9670;&nbsp;</a></span>VSIRmdirRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRmdirRecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a directory recursively. </p>
<p>Deletes a directory object and its content from the file system.</p>
<p>Starting with GDAL 3.1, /vsis3/ has an efficient implementation of this function.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a619a6f6758371a39e0c1a4168462452c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619a6f6758371a39e0c1a4168462452c">&#9670;&nbsp;</a></span>VSISetCryptKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSISetCryptKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nKeySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs the encryption/decryption key. </p>
<p>By passing a NULL key, the previously installed key will be cleared. Note, however, that it is not guaranteed that there won't be trace of it in other places in memory or in on-disk temporary file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyKey</td><td>key. Might be NULL to clear previously set key. </td></tr>
    <tr><td class="paramname">nKeySize</td><td>length of the key in bytes. Might be 0 to clear previously set key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__vsi_8h.html#a5e20b79947f58970f5514b3eb9a524a9" title="Install /vsicrypt/ encrypted file system handler (requires libcrypto++) ">VSIInstallCryptFileHandler()</a> for documentation on /vsicrypt/ </dd></dl>

</div>
</div>
<a id="a0a1c8d0014e7c76fbef98d24b9233a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1c8d0014e7c76fbef98d24b9233a89">&#9670;&nbsp;</a></span>VSISetFileMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSISetFileMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set metadata on files. </p>
<p>Implemented currently only for /vsis3/</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszMetadata</td><td>NULL-terminated list of key=value strings. </td></tr>
    <tr><td class="paramname">pszDomain</td><td>Metadata domain to set. Depends on the file system. The following are supported: <ul>
<li>
HEADERS: to set HTTP header </li>
<li>
TAGS: to set S3 Object tagging information </li>
</ul>
</td></tr>
    <tr><td class="paramname">papszOptions</td><td>Unused. Should be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="a9bd744516c08f11f8129261a38a5fd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd744516c08f11f8129261a38a5fd29">&#9670;&nbsp;</a></span>VSIStatExL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIStatExL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *&#160;</td>
          <td class="paramname"><em>psStatBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability, only use the st_size (size in bytes) and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function, with an extra parameter to specify which information is needed, which offers a potential for speed optimizations on specialized and potentially slow virtual filesystem objects (/vsigzip/, /vsicurl/)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">psStatBuf</td><td>the structure to load with information. </td></tr>
    <tr><td class="paramname">nFlags</td><td>0 to get all information, or VSI_STAT_EXISTS_FLAG, VSI_STAT_NATURE_FLAG or VSI_STAT_SIZE_FLAG, or a combination of those to get partial info.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="a2fc1cc4f2893dc422eb57e430798991a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc1cc4f2893dc422eb57e430798991a">&#9670;&nbsp;</a></span>VSIStatL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIStatL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *&#160;</td>
          <td class="paramname"><em>psStatBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability, only use the st_size (size in bytes) and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">psStatBuf</td><td>the structure to load with information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="adc4a67cc303d7662c34f506d0bdddd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4a67cc303d7662c34f506d0bdddd79">&#9670;&nbsp;</a></span>VSIStdoutSetRedirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIStdoutSetRedirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a121ccf7fcbd054704350f72be08adec8">VSIWriteFunction</a>&#160;</td>
          <td class="paramname"><em>pFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an alternative write function and output file handle instead of fwrite() / stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFct</td><td>Function with same signature as fwrite() </td></tr>
    <tr><td class="paramname">stream</td><td>File handle on which to output. Passed to pFct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ac0500f0dbd6c8c854931c6aa17d6566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0500f0dbd6c8c854931c6aa17d6566e">&#9670;&nbsp;</a></span>VSIStrdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIStrdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of strdup(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a> to free </p>

</div>
</div>
<a id="a312ee85ec9884dc16feda2b81de1cc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312ee85ec9884dc16feda2b81de1cc36">&#9670;&nbsp;</a></span>VSIStrerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIStrerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nErrno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the error string corresponding to the error number. </p>
<p>Do not free it </p>

</div>
</div>
<a id="a6d1bc0831510b6d134fa4d865b2f1328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1bc0831510b6d134fa4d865b2f1328">&#9670;&nbsp;</a></span>VSISupportsSparseFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSISupportsSparseFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filesystem supports sparse files. </p>
<p>Only supported on Linux (and no other Unix derivatives) and Windows. On Linux, the answer depends on a few hardcoded signatures for common filesystems. Other filesystems will be considered as not supporting sparse files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the file system is known to support sparse files. FALSE may be returned both in cases where it is known to not support them, or when it is unknown.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a6845a21b2c0491c594dd9deef757db6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6845a21b2c0491c594dd9deef757db6b">&#9670;&nbsp;</a></span>VSISync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSISync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pProgressFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>ppapszOutputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize a source file/directory with a target file/directory. </p>
<p>This is a analog of the 'rsync' utility. In the current implementation, rsync would be more efficient for local file copying, but <a class="el" href="cpl__vsi_8h.html#a6845a21b2c0491c594dd9deef757db6b" title="Synchronize a source file/directory with a target file/directory. ">VSISync()</a> main interest is when the source or target is a remote file system like /vsis3/ or /vsigs/, in which case it can take into account the timestamps of the files (or optionally the ETag/MD5Sum) to avoid unneeded copy operations.</p>
<p>This is only implemented efficiently for: </p><ul>
<li>
local filesystem &lt;&ndash;&gt; remote filesystem. </li>
<li>
remote filesystem &lt;&ndash;&gt; remote filesystem (starting with GDAL 3.1). Where the source and target remote filesystems are the same and one of /vsis3/, /vsigs/ or /vsiaz/ </li>
</ul>
<p>Similarly to rsync behavior, if the source filename ends with a slash, it means that the content of the directory must be copied, but not the directory name. For example, assuming "/home/even/foo" contains a file "bar", VSISync("/home/even/foo/", "/mnt/media", ...) will create a "/mnt/media/bar" file. Whereas VSISync("/home/even/foo", "/mnt/media", ...) will create a "/mnt/media/foo" directory which contains a bar file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSource</td><td>Source file or directory. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszTarget</td><td>Target file or directory. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Null terminated list of options, or NULL. Currently accepted options are: <ul>
<li>
RECURSIVE=NO (the default is YES) </li>
<li>
<p class="startli">SYNC_STRATEGY=TIMESTAMP/ETAG. Determines which criterion is used to determine if a target file must be replaced when it already exists and has the same file size as the source. Only applies for a source or target being a network filesystem.</p>
<p>The default is TIMESTAMP (similarly to how 'aws s3 sync' works), that is to say that for an upload operation, a remote file is replaced if it has a different size or if it is older than the source. For a download operation, a local file is replaced if it has a different size or if it is newer than the remote file.</p>
<p class="endli">The ETAG strategy assumes that the ETag metadata of the remote file is the MD5Sum of the file content, which is only true in the case of /vsis3/ for files not using KMS server side encryption and uploaded in a single PUT operation (so smaller than 50 MB given the default used by GDAL). Only to be used for /vsis3/, /vsigs/ or other filesystems using a MD5Sum as ETAG. </p>
</li>
<li>
NUM_THREADS=integer. Number of threads to use for parallel file copying. Only use for when /vsis3/, /vsigs/ or /vsiaz/ is in source or target. Since GDAL 3.1 </li>
<li>
CHUNK_SIZE=integer. Maximum size of chunk (in bytes) to use to split large objects when downloading them from /vsis3/, /vsigs/ or /vsiaz/ to local file system, or for upload to /vsis3/ from local file system. Only used if NUM_THREADS &gt; 1. For upload to /vsis3/, this chunk size will be set at least to 5 MB. Since GDAL 3.1 </li>
</ul>
</td></tr>
    <tr><td class="paramname">pProgressFunc</td><td>Progress callback, or NULL. </td></tr>
    <tr><td class="paramname">pProgressData</td><td>User data of progress callback, or NULL. </td></tr>
    <tr><td class="paramname">ppapszOutputs</td><td>Unused. Should be set to NULL for now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on an error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a7ff49d132f70ec46a550c5a51103e394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff49d132f70ec46a550c5a51103e394">&#9670;&nbsp;</a></span>VSIUnlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIUnlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file. </p>
<p>Deletes a file object from the file system.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX unlink() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the file to be deleted. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="ad82382a50ea3be8c5c192a27a45b2673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82382a50ea3be8c5c192a27a45b2673">&#9670;&nbsp;</a></span>VSIUnlinkBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* VSIUnlinkBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszFiles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete several files, possibly in a batch. </p>
<p>All files should belong to the same file system handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszFiles</td><td>NULL terminated list of files. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of size CSLCount(papszFiles), whose values are TRUE or FALSE depending on the success of deletion of the corresponding file. The array should be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc() ">VSIFree()</a>. NULL might be return in case of a more general error (for example, files belonging to different file system handlers)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
