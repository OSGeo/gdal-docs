<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: OGR_SRSNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classOGR__SRSNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OGR_SRSNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS format.  
 <a href="classOGR__SRSNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogr__spatialref_8h_source.html">ogr_spatialref.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOGR__SRSNode_1_1Listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structOGR__SRSNode_1_1Listener.html" title="Listener that is notified of modification to nodes. ">Listener</a> that is notified of modification to nodes.  <a href="structOGR__SRSNode_1_1Listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a656ce6dca85be20c222bb8b5b42cfa32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a656ce6dca85be20c222bb8b5b42cfa32">OGR_SRSNode</a> (const char *=nullptr)</td></tr>
<tr class="memdesc:a656ce6dca85be20c222bb8b5b42cfa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a656ce6dca85be20c222bb8b5b42cfa32">More...</a><br /></td></tr>
<tr class="separator:a656ce6dca85be20c222bb8b5b42cfa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd24698e7eca9fba8e15d70c051f82d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a2cd24698e7eca9fba8e15d70c051f82d">RegisterListener</a> (const std::shared_ptr&lt; <a class="el" href="structOGR__SRSNode_1_1Listener.html">Listener</a> &gt; &amp;listener)</td></tr>
<tr class="memdesc:a2cd24698e7eca9fba8e15d70c051f82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a (single) listener.  <a href="#a2cd24698e7eca9fba8e15d70c051f82d">More...</a><br /></td></tr>
<tr class="separator:a2cd24698e7eca9fba8e15d70c051f82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac547b305d96fe1fa285dda2ee6dd80f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#ac547b305d96fe1fa285dda2ee6dd80f2">IsLeafNode</a> () const</td></tr>
<tr class="memdesc:ac547b305d96fe1fa285dda2ee6dd80f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this is a leaf node.  <a href="#ac547b305d96fe1fa285dda2ee6dd80f2">More...</a><br /></td></tr>
<tr class="separator:ac547b305d96fe1fa285dda2ee6dd80f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abd1be9379bd21567b6cc0eadc819f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a1abd1be9379bd21567b6cc0eadc819f6">GetChildCount</a> () const</td></tr>
<tr class="memdesc:a1abd1be9379bd21567b6cc0eadc819f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of children nodes.  <a href="#a1abd1be9379bd21567b6cc0eadc819f6">More...</a><br /></td></tr>
<tr class="separator:a1abd1be9379bd21567b6cc0eadc819f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c07e21a228cdd2e58a9944aa86d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#aad8c07e21a228cdd2e58a9944aa86d76">GetChild</a> (int)</td></tr>
<tr class="memdesc:aad8c07e21a228cdd2e58a9944aa86d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch requested child.  <a href="#aad8c07e21a228cdd2e58a9944aa86d76">More...</a><br /></td></tr>
<tr class="separator:aad8c07e21a228cdd2e58a9944aa86d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1722f596c4f0cd70daf64f74b242af"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a6c1722f596c4f0cd70daf64f74b242af">GetChild</a> (int) const</td></tr>
<tr class="memdesc:a6c1722f596c4f0cd70daf64f74b242af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch requested child.  <a href="#a6c1722f596c4f0cd70daf64f74b242af">More...</a><br /></td></tr>
<tr class="separator:a6c1722f596c4f0cd70daf64f74b242af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6760a6ffee3941f9b55d184304a70b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a6760a6ffee3941f9b55d184304a70b06">GetNode</a> (const char *)</td></tr>
<tr class="memdesc:a6760a6ffee3941f9b55d184304a70b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find named node in tree.  <a href="#a6760a6ffee3941f9b55d184304a70b06">More...</a><br /></td></tr>
<tr class="separator:a6760a6ffee3941f9b55d184304a70b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b8ee9d044d9375b3848644e7deedea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a87b8ee9d044d9375b3848644e7deedea">GetNode</a> (const char *) const</td></tr>
<tr class="memdesc:a87b8ee9d044d9375b3848644e7deedea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find named node in tree.  <a href="#a87b8ee9d044d9375b3848644e7deedea">More...</a><br /></td></tr>
<tr class="separator:a87b8ee9d044d9375b3848644e7deedea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c84c7cfcadf8ee273eb5f265b5dcd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a56c84c7cfcadf8ee273eb5f265b5dcd9">InsertChild</a> (<a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *, int)</td></tr>
<tr class="memdesc:a56c84c7cfcadf8ee273eb5f265b5dcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the passed node as a child of target node, at the indicated position.  <a href="#a56c84c7cfcadf8ee273eb5f265b5dcd9">More...</a><br /></td></tr>
<tr class="separator:a56c84c7cfcadf8ee273eb5f265b5dcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161233efeab69c02691bfdfb8acda20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a161233efeab69c02691bfdfb8acda20d">AddChild</a> (<a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *)</td></tr>
<tr class="memdesc:a161233efeab69c02691bfdfb8acda20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add passed node as a child of target node.  <a href="#a161233efeab69c02691bfdfb8acda20d">More...</a><br /></td></tr>
<tr class="separator:a161233efeab69c02691bfdfb8acda20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666ea75a56bde64a752d146589f01089"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a666ea75a56bde64a752d146589f01089">FindChild</a> (const char *) const</td></tr>
<tr class="memdesc:a666ea75a56bde64a752d146589f01089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the child matching the given string.  <a href="#a666ea75a56bde64a752d146589f01089">More...</a><br /></td></tr>
<tr class="separator:a666ea75a56bde64a752d146589f01089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad292fa90c3d86e79a7dcc0d1ed7bfa72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#ad292fa90c3d86e79a7dcc0d1ed7bfa72">DestroyChild</a> (int)</td></tr>
<tr class="memdesc:ad292fa90c3d86e79a7dcc0d1ed7bfa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child node, and it's subtree.  <a href="#ad292fa90c3d86e79a7dcc0d1ed7bfa72">More...</a><br /></td></tr>
<tr class="separator:ad292fa90c3d86e79a7dcc0d1ed7bfa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af599fd462c258828a6c1c1987bc96ff2"><td class="memItemLeft" align="right" valign="top"><a id="af599fd462c258828a6c1c1987bc96ff2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#af599fd462c258828a6c1c1987bc96ff2">ClearChildren</a> ()</td></tr>
<tr class="memdesc:af599fd462c258828a6c1c1987bc96ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear children nodes. <br /></td></tr>
<tr class="separator:af599fd462c258828a6c1c1987bc96ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181ab5c7787769906e42ad54101e326a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a181ab5c7787769906e42ad54101e326a">StripNodes</a> (const char *)</td></tr>
<tr class="memdesc:a181ab5c7787769906e42ad54101e326a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip child nodes matching name.  <a href="#a181ab5c7787769906e42ad54101e326a">More...</a><br /></td></tr>
<tr class="separator:a181ab5c7787769906e42ad54101e326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a32e6047922b70c704bf3e11559b750"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a3a32e6047922b70c704bf3e11559b750">GetValue</a> () const</td></tr>
<tr class="memdesc:a3a32e6047922b70c704bf3e11559b750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch value string for this node.  <a href="#a3a32e6047922b70c704bf3e11559b750">More...</a><br /></td></tr>
<tr class="separator:a3a32e6047922b70c704bf3e11559b750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07094ad4ae48e6760d0816ff14d2a8ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a07094ad4ae48e6760d0816ff14d2a8ad">SetValue</a> (const char *)</td></tr>
<tr class="memdesc:a07094ad4ae48e6760d0816ff14d2a8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node value.  <a href="#a07094ad4ae48e6760d0816ff14d2a8ad">More...</a><br /></td></tr>
<tr class="separator:a07094ad4ae48e6760d0816ff14d2a8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8176e81a89fb8e8cd8522c0785492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a1cb8176e81a89fb8e8cd8522c0785492">MakeValueSafe</a> ()</td></tr>
<tr class="memdesc:a1cb8176e81a89fb8e8cd8522c0785492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Massage value string, stripping special characters so it will be a database safe string.  <a href="#a1cb8176e81a89fb8e8cd8522c0785492">More...</a><br /></td></tr>
<tr class="separator:a1cb8176e81a89fb8e8cd8522c0785492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1400b9c8cbe19ec67e7082f383a9f0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a1400b9c8cbe19ec67e7082f383a9f0d3">Clone</a> () const</td></tr>
<tr class="memdesc:a1400b9c8cbe19ec67e7082f383a9f0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate of this node, and it's children.  <a href="#a1400b9c8cbe19ec67e7082f383a9f0d3">More...</a><br /></td></tr>
<tr class="separator:a1400b9c8cbe19ec67e7082f383a9f0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8db59ea569b214a0ae163f505dc2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a6b8db59ea569b214a0ae163f505dc2e0">importFromWkt</a> (char **)</td></tr>
<tr class="memdesc:a6b8db59ea569b214a0ae163f505dc2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from WKT string.  <a href="#a6b8db59ea569b214a0ae163f505dc2e0">More...</a><br /></td></tr>
<tr class="separator:a6b8db59ea569b214a0ae163f505dc2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfb2b84c7887ba524a84bf54bea94c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a6bfb2b84c7887ba524a84bf54bea94c5">importFromWkt</a> (const char **)</td></tr>
<tr class="memdesc:a6bfb2b84c7887ba524a84bf54bea94c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from WKT string.  <a href="#a6bfb2b84c7887ba524a84bf54bea94c5">More...</a><br /></td></tr>
<tr class="separator:a6bfb2b84c7887ba524a84bf54bea94c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00f402cb334eb22d4b5c3829f321d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#ab00f402cb334eb22d4b5c3829f321d5e">exportToWkt</a> (char **) const</td></tr>
<tr class="memdesc:ab00f402cb334eb22d4b5c3829f321d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this tree of nodes into WKT format.  <a href="#ab00f402cb334eb22d4b5c3829f321d5e">More...</a><br /></td></tr>
<tr class="separator:ab00f402cb334eb22d4b5c3829f321d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6ed4d62d22f1f00cfa37aa75a1b9c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a8e6ed4d62d22f1f00cfa37aa75a1b9c2">exportToPrettyWkt</a> (char **, int=1) const</td></tr>
<tr class="memdesc:a8e6ed4d62d22f1f00cfa37aa75a1b9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this tree of nodes into pretty WKT format.  <a href="#a8e6ed4d62d22f1f00cfa37aa75a1b9c2">More...</a><br /></td></tr>
<tr class="separator:a8e6ed4d62d22f1f00cfa37aa75a1b9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS format. </p>
<p>For instance UNIT["METER",1] would be rendered into three OGR_SRSNodes. The root node would have a value of UNIT, and two children, the first with a value of METER, and the second with a value of 1.</p>
<p>Normally application code just interacts with the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> object, which uses the <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a> to implement its data structure; however, this class is user accessible for detailed access to components of an SRS definition. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a656ce6dca85be20c222bb8b5b42cfa32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656ce6dca85be20c222bb8b5b42cfa32">&#9670;&nbsp;</a></span>OGR_SRSNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OGR_SRSNode::OGR_SRSNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValueIn</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValueIn</td><td>this optional parameter can be used to initialize the value of the node upon creation. If omitted the node will be created with a value of "". Newly created OGR_SRSNodes have no children. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a161233efeab69c02691bfdfb8acda20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161233efeab69c02691bfdfb8acda20d">&#9670;&nbsp;</a></span>AddChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::AddChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td>
          <td class="paramname"><em>poNew</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add passed node as a child of target node. </p>
<p>Note that ownership of the passed node is assumed by the node on which the method is invoked ... use the <a class="el" href="classOGR__SRSNode.html#a1400b9c8cbe19ec67e7082f383a9f0d3" title="Make a duplicate of this node, and it&#39;s children. ">Clone()</a> method if the original is to be preserved. New children are always added at the end of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNew</td><td>the node to add as a child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1400b9c8cbe19ec67e7082f383a9f0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1400b9c8cbe19ec67e7082f383a9f0d3">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a duplicate of this node, and it's children. </p>
<dl class="section return"><dt>Returns</dt><dd>a new node tree, which becomes the responsibility of the caller. </dd></dl>

</div>
</div>
<a id="ad292fa90c3d86e79a7dcc0d1ed7bfa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad292fa90c3d86e79a7dcc0d1ed7bfa72">&#9670;&nbsp;</a></span>DestroyChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::DestroyChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a child node, and it's subtree. </p>
<p>Note that removing a child node will result in children after it being renumbered down one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChild</td><td>the index of the child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e6ed4d62d22f1f00cfa37aa75a1b9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6ed4d62d22f1f00cfa37aa75a1b9c2">&#9670;&nbsp;</a></span>exportToPrettyWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::exportToPrettyWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDepth</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this tree of nodes into pretty WKT format. </p>
<p>Note that the returned WKT string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed. It is the responsibility of the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszResult</td><td>the resulting string is returned in this pointer.</td></tr>
    <tr><td class="paramname">nDepth</td><td>depth of the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>currently OGRERR_NONE is always returned, but the future it is possible error conditions will develop. </dd></dl>

</div>
</div>
<a id="ab00f402cb334eb22d4b5c3829f321d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00f402cb334eb22d4b5c3829f321d5e">&#9670;&nbsp;</a></span>exportToWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszResult</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this tree of nodes into WKT format. </p>
<p>Note that the returned WKT string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed. It is the responsibility of the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszResult</td><td>the resulting string is returned in this pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>currently OGRERR_NONE is always returned, but the future it is possible error conditions will develop. </dd></dl>

</div>
</div>
<a id="a666ea75a56bde64a752d146589f01089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666ea75a56bde64a752d146589f01089">&#9670;&nbsp;</a></span>FindChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SRSNode::FindChild </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValueIn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the child matching the given string. </p>
<p>Note that the node value must match pszValue with the exception of case. The comparison is case insensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValueIn</td><td>the node value being searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child index, or -1 on failure. </dd></dl>

</div>
</div>
<a id="aad8c07e21a228cdd2e58a9944aa86d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8c07e21a228cdd2e58a9944aa86d76">&#9670;&nbsp;</a></span>GetChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch requested child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChild</td><td>the index of the child to fetch, from 0 to <a class="el" href="classOGR__SRSNode.html#a1abd1be9379bd21567b6cc0eadc819f6" title="Get number of children nodes. ">GetChildCount()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the child <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a>, or NULL if there is no such child. </dd></dl>

</div>
</div>
<a id="a6c1722f596c4f0cd70daf64f74b242af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1722f596c4f0cd70daf64f74b242af">&#9670;&nbsp;</a></span>GetChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch requested child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChild</td><td>the index of the child to fetch, from 0 to <a class="el" href="classOGR__SRSNode.html#a1abd1be9379bd21567b6cc0eadc819f6" title="Get number of children nodes. ">GetChildCount()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the child <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a>, or NULL if there is no such child. </dd></dl>

</div>
</div>
<a id="a1abd1be9379bd21567b6cc0eadc819f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abd1be9379bd21567b6cc0eadc819f6">&#9670;&nbsp;</a></span>GetChildCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SRSNode::GetChildCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of children nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>0 for leaf nodes, or the number of children nodes. </dd></dl>

</div>
</div>
<a id="a6760a6ffee3941f9b55d184304a70b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6760a6ffee3941f9b55d184304a70b06">&#9670;&nbsp;</a></span>GetNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find named node in tree. </p>
<p>This method does a pre-order traversal of the node tree searching for a node with this exact value (case insensitive), and returns it. Leaf nodes are not considered, under the assumption that they are just attribute value nodes.</p>
<p>If a node appears more than once in the tree (such as UNIT for instance), the first encountered will be returned. Use <a class="el" href="classOGR__SRSNode.html#a6760a6ffee3941f9b55d184304a70b06" title="Find named node in tree. ">GetNode()</a> on a subtree to be more specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the node to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node found, or NULL if none. </dd></dl>

</div>
</div>
<a id="a87b8ee9d044d9375b3848644e7deedea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b8ee9d044d9375b3848644e7deedea">&#9670;&nbsp;</a></span>GetNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find named node in tree. </p>
<p>This method does a pre-order traversal of the node tree searching for a node with this exact value (case insensitive), and returns it. Leaf nodes are not considered, under the assumption that they are just attribute value nodes.</p>
<p>If a node appears more than once in the tree (such as UNIT for instance), the first encountered will be returned. Use <a class="el" href="classOGR__SRSNode.html#a6760a6ffee3941f9b55d184304a70b06" title="Find named node in tree. ">GetNode()</a> on a subtree to be more specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the node to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node found, or NULL if none. </dd></dl>

</div>
</div>
<a id="a3a32e6047922b70c704bf3e11559b750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a32e6047922b70c704bf3e11559b750">&#9670;&nbsp;</a></span>GetValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_SRSNode::GetValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch value string for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A non-NULL string is always returned. The returned pointer is to the internal value of this node, and should not be modified, or freed. </dd></dl>

</div>
</div>
<a id="a6b8db59ea569b214a0ae163f505dc2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8db59ea569b214a0ae163f505dc2e0">&#9670;&nbsp;</a></span>importFromWkt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from WKT string. </p>
<p>This method will wipe the existing children and value of this node, and reassign them based on the contents of the passed WKT string. Only as much of the input string as needed to construct this node, and its children is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>Pointer to pointer to input. The pointer is updated to point to remaining unused input text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if import succeeds, or OGRERR_CORRUPT_DATA if it fails for any reason. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>GDAL 2.3. Use <a class="el" href="classOGR__SRSNode.html#a6bfb2b84c7887ba524a84bf54bea94c5" title="Import from WKT string. ">importFromWkt(const char**)</a> instead. </dd></dl>

</div>
</div>
<a id="a6bfb2b84c7887ba524a84bf54bea94c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfb2b84c7887ba524a84bf54bea94c5">&#9670;&nbsp;</a></span>importFromWkt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from WKT string. </p>
<p>This method will wipe the existing children and value of this node, and reassign them based on the contents of the passed WKT string. Only as much of the input string as needed to construct this node, and its children is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>Pointer to pointer to input. The pointer is updated to point to remaining unused input text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if import succeeds, or OGRERR_CORRUPT_DATA if it fails for any reason.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a56c84c7cfcadf8ee273eb5f265b5dcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c84c7cfcadf8ee273eb5f265b5dcd9">&#9670;&nbsp;</a></span>InsertChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::InsertChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td>
          <td class="paramname"><em>poNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the passed node as a child of target node, at the indicated position. </p>
<p>Note that ownership of the passed node is assumed by the node on which the method is invoked ... use the <a class="el" href="classOGR__SRSNode.html#a1400b9c8cbe19ec67e7082f383a9f0d3" title="Make a duplicate of this node, and it&#39;s children. ">Clone()</a> method if the original is to be preserved. All existing children at location iChild and beyond are push down one space to make space for the new child.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNew</td><td>the node to add as a child. </td></tr>
    <tr><td class="paramname">iChild</td><td>position to insert, use 0 to insert at the beginning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac547b305d96fe1fa285dda2ee6dd80f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac547b305d96fe1fa285dda2ee6dd80f2">&#9670;&nbsp;</a></span>IsLeafNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SRSNode::IsLeafNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether this is a leaf node. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE </dd></dl>

</div>
</div>
<a id="a1cb8176e81a89fb8e8cd8522c0785492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb8176e81a89fb8e8cd8522c0785492">&#9670;&nbsp;</a></span>MakeValueSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::MakeValueSafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Massage value string, stripping special characters so it will be a database safe string. </p>
<p>The operation is also applies to all subnodes of the current node. </p>

</div>
</div>
<a id="a2cd24698e7eca9fba8e15d70c051f82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd24698e7eca9fba8e15d70c051f82d">&#9670;&nbsp;</a></span>RegisterListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::RegisterListener </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structOGR__SRSNode_1_1Listener.html">Listener</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a (single) listener. </p>

</div>
</div>
<a id="a07094ad4ae48e6760d0816ff14d2a8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07094ad4ae48e6760d0816ff14d2a8ad">&#9670;&nbsp;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::SetValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the node value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNewValue</td><td>the new value to assign to this node. The passed string is duplicated and remains the responsibility of the caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a181ab5c7787769906e42ad54101e326a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181ab5c7787769906e42ad54101e326a">&#9670;&nbsp;</a></span>StripNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::StripNodes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip child nodes matching name. </p>
<p>Removes any descendant nodes of this node that match the given name. Of course children of removed nodes are also discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name for nodes that should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__spatialref_8h_source.html">ogr_spatialref.h</a></li>
<li>ogr_srsnode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
