<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: OGRGeometryFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classOGRGeometryFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OGRGeometryFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Create geometry objects from well known text/binary.  
 <a href="classOGRGeometryFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory_1_1TransformWithOptionsCache.html">TransformWithOptionsCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque class used as argument to <a class="el" href="classOGRGeometryFactory.html#a47b03de00271a9ca9902d2c8920414ad" title="Transform a geometry. ">transformWithOptions()</a>  <a href="classOGRGeometryFactory_1_1TransformWithOptionsCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a66de314779c192b94e2e8cf2836c13c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a66de314779c192b94e2e8cf2836c13c8">createFromWkb</a> (const void *, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **, int=-1, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>)</td></tr>
<tr class="memdesc:a66de314779c192b94e2e8cf2836c13c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known binary representation.  <a href="#a66de314779c192b94e2e8cf2836c13c8">More...</a><br /></td></tr>
<tr class="separator:a66de314779c192b94e2e8cf2836c13c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3911fd286dee7d4227a805d389a524"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#acb3911fd286dee7d4227a805d389a524">createFromWkb</a> (const void *pabyData, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **, int nSize, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a> eVariant, int &amp;nBytesConsumedOut)</td></tr>
<tr class="memdesc:acb3911fd286dee7d4227a805d389a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known binary representation.  <a href="#acb3911fd286dee7d4227a805d389a524">More...</a><br /></td></tr>
<tr class="separator:acb3911fd286dee7d4227a805d389a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f997c743af4220655285eda8724a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a955f997c743af4220655285eda8724a9">createFromWkt</a> (const char *, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **)</td></tr>
<tr class="memdesc:a955f997c743af4220655285eda8724a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known text representation.  <a href="#a955f997c743af4220655285eda8724a9">More...</a><br /></td></tr>
<tr class="separator:a955f997c743af4220655285eda8724a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7774e8a46ff248ecd26b2d05af8d9d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#ad7774e8a46ff248ecd26b2d05af8d9d4">createFromWkt</a> (const char **, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **)</td></tr>
<tr class="memdesc:ad7774e8a46ff248ecd26b2d05af8d9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known text representation.  <a href="#ad7774e8a46ff248ecd26b2d05af8d9d4">More...</a><br /></td></tr>
<tr class="separator:ad7774e8a46ff248ecd26b2d05af8d9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d156df1983ac35735e48f382b8df0a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a4d156df1983ac35735e48f382b8df0a1">createFromWkt</a> (char **ppszInput, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSRS, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **ppoGeom)</td></tr>
<tr class="memdesc:a4d156df1983ac35735e48f382b8df0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="#a4d156df1983ac35735e48f382b8df0a1">More...</a><br /></td></tr>
<tr class="separator:a4d156df1983ac35735e48f382b8df0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99be8486694e4b99384c38aab094ebdc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a99be8486694e4b99384c38aab094ebdc">createFromFgf</a> (const void *, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **, int=-1, int *=nullptr)</td></tr>
<tr class="memdesc:a99be8486694e4b99384c38aab094ebdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representation.  <a href="#a99be8486694e4b99384c38aab094ebdc">More...</a><br /></td></tr>
<tr class="separator:a99be8486694e4b99384c38aab094ebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8714df4e6b6c5d5b2cdbdeec78af08c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#af8714df4e6b6c5d5b2cdbdeec78af08c">createFromGML</a> (const char *)</td></tr>
<tr class="memdesc:af8714df4e6b6c5d5b2cdbdeec78af08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry from GML.  <a href="#af8714df4e6b6c5d5b2cdbdeec78af08c">More...</a><br /></td></tr>
<tr class="separator:af8714df4e6b6c5d5b2cdbdeec78af08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6329797203eb527ee093aec9ddc46d7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a6329797203eb527ee093aec9ddc46d7d">createFromGEOS</a> (<a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> hGEOSCtxt, <a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a>)</td></tr>
<tr class="memdesc:a6329797203eb527ee093aec9ddc46d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a OGRGeometry* from a GEOSGeom.  <a href="#a6329797203eb527ee093aec9ddc46d7d">More...</a><br /></td></tr>
<tr class="separator:a6329797203eb527ee093aec9ddc46d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25daa0c05f98b607e5dbdb706b1336f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a25daa0c05f98b607e5dbdb706b1336f8">createFromGeoJson</a> (const char *)</td></tr>
<tr class="memdesc:a25daa0c05f98b607e5dbdb706b1336f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry from GeoJson fragment.  <a href="#a25daa0c05f98b607e5dbdb706b1336f8">More...</a><br /></td></tr>
<tr class="separator:a25daa0c05f98b607e5dbdb706b1336f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bd16194ebd9b77b9d83544c72fdf72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a30bd16194ebd9b77b9d83544c72fdf72">createFromGeoJson</a> (const <a class="el" href="classCPLJSONObject.html">CPLJSONObject</a> &amp;oJSONObject)</td></tr>
<tr class="memdesc:a30bd16194ebd9b77b9d83544c72fdf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry from GeoJson fragment.  <a href="#a30bd16194ebd9b77b9d83544c72fdf72">More...</a><br /></td></tr>
<tr class="separator:a30bd16194ebd9b77b9d83544c72fdf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae001086e26985d95c36ccd255a8c6d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5">destroyGeometry</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr class="memdesc:aae001086e26985d95c36ccd255a8c6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy geometry object.  <a href="#aae001086e26985d95c36ccd255a8c6d5">More...</a><br /></td></tr>
<tr class="separator:aae001086e26985d95c36ccd255a8c6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4887e270d5099357f9a19b1eda6027a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#ae4887e270d5099357f9a19b1eda6027a">createGeometry</a> (<a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr class="memdesc:ae4887e270d5099357f9a19b1eda6027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty geometry of desired type.  <a href="#ae4887e270d5099357f9a19b1eda6027a">More...</a><br /></td></tr>
<tr class="separator:ae4887e270d5099357f9a19b1eda6027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd61936e41ea69831b3196e817658d08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">forceToPolygon</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr class="memdesc:afd61936e41ea69831b3196e817658d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to polygon.  <a href="#afd61936e41ea69831b3196e817658d08">More...</a><br /></td></tr>
<tr class="separator:afd61936e41ea69831b3196e817658d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae79ea28620e332a3d1df87f1180f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">forceToLineString</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *, bool bOnlyInOrder=true)</td></tr>
<tr class="memdesc:adcae79ea28620e332a3d1df87f1180f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to line string.  <a href="#adcae79ea28620e332a3d1df87f1180f3">More...</a><br /></td></tr>
<tr class="separator:adcae79ea28620e332a3d1df87f1180f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a40032fa65cc71c028516bf8fc0df3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e">forceToMultiPolygon</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr class="memdesc:a2a40032fa65cc71c028516bf8fc0df3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multipolygon.  <a href="#a2a40032fa65cc71c028516bf8fc0df3e">More...</a><br /></td></tr>
<tr class="separator:a2a40032fa65cc71c028516bf8fc0df3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97b7837101f6c56e476520d10a9f3c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3">forceToMultiPoint</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr class="memdesc:aa97b7837101f6c56e476520d10a9f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multipoint.  <a href="#aa97b7837101f6c56e476520d10a9f3c3">More...</a><br /></td></tr>
<tr class="separator:aa97b7837101f6c56e476520d10a9f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c00a78cec110d71175726d6f26b1b39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">forceToMultiLineString</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr class="memdesc:a1c00a78cec110d71175726d6f26b1b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multilinestring.  <a href="#a1c00a78cec110d71175726d6f26b1b39">More...</a><br /></td></tr>
<tr class="separator:a1c00a78cec110d71175726d6f26b1b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26120382ccfec8ac4b5f932dd3a67c5f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a26120382ccfec8ac4b5f932dd3a67c5f">forceTo</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poGeom, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> eTargetType, const char *const *papszOptions=nullptr)</td></tr>
<tr class="memdesc:a26120382ccfec8ac4b5f932dd3a67c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to another geometry type.  <a href="#a26120382ccfec8ac4b5f932dd3a67c5f">More...</a><br /></td></tr>
<tr class="separator:a26120382ccfec8ac4b5f932dd3a67c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dda76280700944f813f6b4c8e7be7a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a9dda76280700944f813f6b4c8e7be7a0">removeLowerDimensionSubGeoms</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poGeom)</td></tr>
<tr class="memdesc:a9dda76280700944f813f6b4c8e7be7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove sub-geometries from a geometry collection that do not have the maximum topological dimensionality of the collection.  <a href="#a9dda76280700944f813f6b4c8e7be7a0">More...</a><br /></td></tr>
<tr class="separator:a9dda76280700944f813f6b4c8e7be7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce97d39ca2e0dd88f415227e71b7fd5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a9ce97d39ca2e0dd88f415227e71b7fd5">organizePolygons</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> **papoPolygons, int nPolygonCount, int *pbResultValidGeometry, const char **papszOptions=nullptr)</td></tr>
<tr class="memdesc:a9ce97d39ca2e0dd88f415227e71b7fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organize polygons based on geometries.  <a href="#a9ce97d39ca2e0dd88f415227e71b7fd5">More...</a><br /></td></tr>
<tr class="separator:a9ce97d39ca2e0dd88f415227e71b7fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5549a7effe79efd7fcef838787b224"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a2b5549a7effe79efd7fcef838787b224">haveGEOS</a> ()</td></tr>
<tr class="memdesc:a2b5549a7effe79efd7fcef838787b224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if GEOS enabled.  <a href="#a2b5549a7effe79efd7fcef838787b224">More...</a><br /></td></tr>
<tr class="separator:a2b5549a7effe79efd7fcef838787b224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b03de00271a9ca9902d2c8920414ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a47b03de00271a9ca9902d2c8920414ad">transformWithOptions</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poSrcGeom, <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *poCT, char **papszOptions, const <a class="el" href="classOGRGeometryFactory_1_1TransformWithOptionsCache.html">TransformWithOptionsCache</a> &amp;cache=<a class="el" href="classOGRGeometryFactory_1_1TransformWithOptionsCache.html">TransformWithOptionsCache</a>())</td></tr>
<tr class="memdesc:a47b03de00271a9ca9902d2c8920414ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a geometry.  <a href="#a47b03de00271a9ca9902d2c8920414ad">More...</a><br /></td></tr>
<tr class="separator:a47b03de00271a9ca9902d2c8920414ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3ab8a97c131389fd92cf4a92727806"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a7c3ab8a97c131389fd92cf4a92727806">approximateArcAngles</a> (double dfX, double dfY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees, const bool bUseMaxGap=false)</td></tr>
<tr class="memdesc:a7c3ab8a97c131389fd92cf4a92727806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke arc to linestring.  <a href="#a7c3ab8a97c131389fd92cf4a92727806">More...</a><br /></td></tr>
<tr class="separator:a7c3ab8a97c131389fd92cf4a92727806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01e72263a6d75bb8a891235df4a75f5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#ad01e72263a6d75bb8a891235df4a75f5">GetCurveParmeters</a> (double x0, double y0, double x1, double y1, double x2, double y2, double &amp;R, double &amp;cx, double &amp;cy, double &amp;alpha0, double &amp;alpha1, double &amp;alpha2)</td></tr>
<tr class="memdesc:ad01e72263a6d75bb8a891235df4a75f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parameter of an arc circle.  <a href="#ad01e72263a6d75bb8a891235df4a75f5">More...</a><br /></td></tr>
<tr class="separator:ad01e72263a6d75bb8a891235df4a75f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f661d6691fcf745ca185ae4d586156c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a6f661d6691fcf745ca185ae4d586156c">curveToLineString</a> (double x0, double y0, double z0, double x1, double y1, double z1, double x2, double y2, double z2, int bHasZ, double dfMaxAngleStepSizeDegrees, const char *const *papszOptions=nullptr)</td></tr>
<tr class="memdesc:a6f661d6691fcf745ca185ae4d586156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arc circle into an approximate line string.  <a href="#a6f661d6691fcf745ca185ae4d586156c">More...</a><br /></td></tr>
<tr class="separator:a6f661d6691fcf745ca185ae4d586156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6642fde43ebaab7703ede629ca18a5d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a6642fde43ebaab7703ede629ca18a5d0">curveFromLineString</a> (const <a class="el" href="classOGRLineString.html">OGRLineString</a> *poLS, const char *const *papszOptions=nullptr)</td></tr>
<tr class="memdesc:a6642fde43ebaab7703ede629ca18a5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to convert a linestring approximating curves into a curve.  <a href="#a6642fde43ebaab7703ede629ca18a5d0">More...</a><br /></td></tr>
<tr class="separator:a6642fde43ebaab7703ede629ca18a5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Create geometry objects from well known text/binary. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c3ab8a97c131389fd92cf4a92727806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3ab8a97c131389fd92cf4a92727806">&#9670;&nbsp;</a></span>approximateArcAngles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::approximateArcAngles </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfPrimaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfSecondaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfStartAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfEndAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bUseMaxGap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke arc to linestring. </p>
<p>Stroke an arc of a circle to a linestring based on a center point, radius, start angle and end angle, all angles in degrees.</p>
<p>If the dfMaxAngleStepSizeDegrees is zero, then a default value will be used. This is currently 4 degrees unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>If the OGR_ARC_MAX_GAP configuration variable is set, the straight-line distance between adjacent pairs of interpolated points will be limited to the specified distance. If the distance between a pair of points exceeds this maximum, additional points are interpolated between the two points.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use. ">CPLSetConfigOption()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfCenterX</td><td>center X </td></tr>
    <tr><td class="paramname">dfCenterY</td><td>center Y </td></tr>
    <tr><td class="paramname">dfZ</td><td>center Z </td></tr>
    <tr><td class="paramname">dfPrimaryRadius</td><td>X radius of ellipse. </td></tr>
    <tr><td class="paramname">dfSecondaryRadius</td><td>Y radius of ellipse. </td></tr>
    <tr><td class="paramname">dfRotation</td><td>rotation of the ellipse clockwise. </td></tr>
    <tr><td class="paramname">dfStartAngle</td><td>angle to first point on arc (clockwise of X-positive) </td></tr>
    <tr><td class="paramname">dfEndAngle</td><td>angle to last point on arc (clockwise of X-positive) </td></tr>
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">bUseMaxGap</td><td>Optional: whether to honor OGR_ARC_MAX_GAP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classOGRLineString.html" title="Concrete representation of a multi-vertex line. ">OGRLineString</a> geometry representing an approximation of the arc.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a99be8486694e4b99384c38aab094ebdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99be8486694e4b99384c38aab094ebdc">&#9670;&nbsp;</a></span>createFromFgf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometryFactory::createFromFgf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&#160;</td>
          <td class="paramname"><em>ppoReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBytesConsumed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representation. </p>
<p>Also note that this is a static method, and that there is no need to instantiate an <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary. ">OGRGeometryFactory</a> object.</p>
<p>The C function <a class="el" href="ogr__api_8h.html#a3ab486f7ab98a4b592d25e4b8a0ac698" title="Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representa...">OGR_G_CreateFromFgf()</a> is the same as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td class="paramname">poSR</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">ppoReturn</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL in case of failure, but NULL might be a valid return for a NULL shape. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes available in pabyData. </td></tr>
    <tr><td class="paramname">pnBytesConsumed</td><td>if not NULL, it will be set to the number of bytes consumed (at most nBytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a25daa0c05f98b607e5dbdb706b1336f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25daa0c05f98b607e5dbdb706b1336f8">&#9670;&nbsp;</a></span>createFromGeoJson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::createFromGeoJson </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszJsonString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create geometry from GeoJson fragment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszJsonString</td><td>The GeoJSON fragment for the geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a geometry on success, or NULL on error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a30bd16194ebd9b77b9d83544c72fdf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bd16194ebd9b77b9d83544c72fdf72">&#9670;&nbsp;</a></span>createFromGeoJson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::createFromGeoJson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCPLJSONObject.html">CPLJSONObject</a> &amp;&#160;</td>
          <td class="paramname"><em>oJsonObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create geometry from GeoJson fragment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oJsonObject</td><td>The JSONObject class describes the GeoJSON geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a geometry on success, or NULL on error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a6329797203eb527ee093aec9ddc46d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6329797203eb527ee093aec9ddc46d7d">&#9670;&nbsp;</a></span>createFromGEOS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::createFromGEOS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td>
          <td class="paramname"><em>hGEOSCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a>&#160;</td>
          <td class="paramname"><em>geosGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a OGRGeometry* from a GEOSGeom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGEOSCtxt</td><td>GEOS context </td></tr>
    <tr><td class="paramname">geosGeom</td><td>GEOS geometry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a OGRGeometry* </dd></dl>

</div>
</div>
<a id="af8714df4e6b6c5d5b2cdbdeec78af08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8714df4e6b6c5d5b2cdbdeec78af08c">&#9670;&nbsp;</a></span>createFromGML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::createFromGML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create geometry from GML. </p>
<p>This method translates a fragment of GML containing only the geometry portion into a corresponding <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes. ">OGRGeometry</a>. There are many limitations on the forms of GML geometries supported by this parser, but they are too numerous to list here.</p>
<p>The following GML2 elements are parsed : Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.</p>
<p>(OGR &gt;= 1.8.0) The following GML3 elements are parsed : Surface, MultiSurface, PolygonPatch, Triangle, Rectangle, Curve, MultiCurve, LineStringSegment, Arc, Circle, CompositeSurface, OrientableSurface, Solid, Tin, TriangulatedSurface.</p>
<p>Arc and Circle elements are stroked to linestring, by using a 4 degrees step, unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>The C function <a class="el" href="ogr__api_8h.html#a216201a5f821e553bd484d6953fa2ffb" title="Create geometry from GML. ">OGR_G_CreateFromGML()</a> is the same as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszData</td><td>The GML fragment for the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a geometry on success, or NULL on error. </dd></dl>

</div>
</div>
<a id="a66de314779c192b94e2e8cf2836c13c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66de314779c192b94e2e8cf2836c13c8">&#9670;&nbsp;</a></span>createFromWkb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometryFactory::createFromWkb </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&#160;</td>
          <td class="paramname"><em>ppoReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation. ">OGRGeometry::WkbSize()</a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>Also note that this is a static method, and that there is no need to instantiate an <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary. ">OGRGeometryFactory</a> object.</p>
<p>The C function <a class="el" href="ogr__api_8h.html#a65af51cbb3d62789dee6f96044f4dcb6" title="Create a geometry object of the appropriate type from its well known binary representation. ">OGR_G_CreateFromWkb()</a> is the same as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td class="paramname">poSR</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">ppoReturn</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL in case of failure. If not NULL, *ppoReturn should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object. ">OGRGeometryFactory::destroyGeometry()</a> after use. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes available in pabyData, or -1 if it isn't known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>WKB variant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="acb3911fd286dee7d4227a805d389a524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3911fd286dee7d4227a805d389a524">&#9670;&nbsp;</a></span>createFromWkb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometryFactory::createFromWkb </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&#160;</td>
          <td class="paramname"><em>ppoReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nBytesConsumedOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation. ">OGRGeometry::WkbSize()</a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>Also note that this is a static method, and that there is no need to instantiate an <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary. ">OGRGeometryFactory</a> object.</p>
<p>The C function <a class="el" href="ogr__api_8h.html#a65af51cbb3d62789dee6f96044f4dcb6" title="Create a geometry object of the appropriate type from its well known binary representation. ">OGR_G_CreateFromWkb()</a> is the same as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td class="paramname">poSR</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">ppoReturn</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL in case of failure. If not NULL, *ppoReturn should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object. ">OGRGeometryFactory::destroyGeometry()</a> after use. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes available in pabyData, or -1 if it isn't known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>WKB variant. </td></tr>
    <tr><td class="paramname">nBytesConsumedOut</td><td>output parameter. Number of bytes consumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a955f997c743af4220655285eda8724a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955f997c743af4220655285eda8724a9">&#9670;&nbsp;</a></span>createFromWkt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometryFactory::createFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&#160;</td>
          <td class="paramname"><em>ppoReturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known text representation. </p>
<p>The C function <a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a" title="Create a geometry object of the appropriate type from its well known text representation. ">OGR_G_CreateFromWkt()</a> is the same as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszData</td><td>input zero terminated string containing well known text representation of the geometry to be created. </td></tr>
    <tr><td class="paramname">poSR</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">ppoReturn</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL if the method fails. If not NULL, *ppoReturn should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object. ">OGRGeometryFactory::destroyGeometry()</a> after use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad7774e8a46ff248ecd26b2d05af8d9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7774e8a46ff248ecd26b2d05af8d9d4">&#9670;&nbsp;</a></span>createFromWkt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometryFactory::createFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&#160;</td>
          <td class="paramname"><em>ppoReturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known text representation. </p>
<p>The C function <a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a" title="Create a geometry object of the appropriate type from its well known text representation. ">OGR_G_CreateFromWkt()</a> is the same as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszData</td><td>input zero terminated string containing well known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed. </td></tr>
    <tr><td class="paramname">poSR</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">ppoReturn</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL if the method fails. If not NULL, *ppoReturn should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object. ">OGRGeometryFactory::destroyGeometry()</a> after use.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* wkt= <span class="stringliteral">&quot;POINT(0 0)&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// cast because OGR_G_CreateFromWkt will move the pointer</span></div><div class="line"><span class="keywordtype">char</span>* pszWkt = (<span class="keywordtype">char</span>*) wkt;</div><div class="line"><a class="code" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> ref = <a class="code" href="ogr__srs__api_8h.html#a80d2790f618a9800a126e736afb1198e">OSRNewSpatialReference</a>(NULL);</div><div class="line"><a class="code" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> new_geom;</div><div class="line"><a class="code" href="ogr__srs__api_8h.html#a96af9923a07918e66fa61e33f89aeddf">OSRSetAxisMappingStrategy</a>(poSR, <a class="code" href="ogr__srs__api_8h.html#ad72ddaac3b6182e47eb3f39f4a4058c6ab9d9e8e1296d00510690d46cdad4c55c">OAMS_TRADITIONAL_GIS_ORDER</a>);</div><div class="line"><a class="code" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> err = <a class="code" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">OGR_G_CreateFromWkt</a>(&amp;pszWkt, ref, &amp;new_geom);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a4d156df1983ac35735e48f382b8df0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d156df1983ac35735e48f382b8df0a1">&#9670;&nbsp;</a></span>createFromWkt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometryFactory::createFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&#160;</td>
          <td class="paramname"><em>ppoGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>in GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ae4887e270d5099357f9a19b1eda6027a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4887e270d5099357f9a19b1eda6027a">&#9670;&nbsp;</a></span>createGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::createGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eGeometryType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty geometry of desired type. </p>
<p>This is equivalent to allocating the desired geometry with new, but the allocation is guaranteed to take place in the context of the GDAL/OGR heap.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a60311342f2a329f433ea66e2d6fedadc" title="Create an empty geometry of desired type. ">OGR_G_CreateGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eGeometryType</td><td>the type code of the geometry class to be instantiated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly create geometry or NULL on failure. Should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object. ">OGRGeometryFactory::destroyGeometry()</a> after use. </dd></dl>

</div>
</div>
<a id="a6642fde43ebaab7703ede629ca18a5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6642fde43ebaab7703ede629ca18a5d0">&#9670;&nbsp;</a></span>curveFromLineString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurve.html">OGRCurve</a> * OGRGeometryFactory::curveFromLineString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td>
          <td class="paramname"><em>poLS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to convert a linestring approximating curves into a curve. </p>
<p>This method can return a COMPOUNDCURVE, a CIRCULARSTRING or a LINESTRING.</p>
<p>This method is the reverse of <a class="el" href="classOGRGeometryFactory.html#a6642fde43ebaab7703ede629ca18a5d0" title="Try to convert a linestring approximating curves into a curve. ">curveFromLineString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poLS</td><td>handle to the geometry to convert. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. Unused for now. Must be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a6f661d6691fcf745ca185ae4d586156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f661d6691fcf745ca185ae4d586156c">&#9670;&nbsp;</a></span>curveToLineString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLineString.html">OGRLineString</a> * OGRGeometryFactory::curveToLineString </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bHasZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an arc circle into an approximate line string. </p>
<p>The arc circle is defined by a first point, an intermediate point and a final point.</p>
<p>The provided dfMaxAngleStepSizeDegrees is a hint. The discretization algorithm may pick a slightly different value.</p>
<p>So as to avoid gaps when rendering curve polygons that share common arcs, this method is guaranteed to return a line with reversed vertex if called with inverted first and final point, and identical intermediate point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>x of first point </td></tr>
    <tr><td class="paramname">y0</td><td>y of first point </td></tr>
    <tr><td class="paramname">z0</td><td>z of first point </td></tr>
    <tr><td class="paramname">x1</td><td>x of intermediate point </td></tr>
    <tr><td class="paramname">y1</td><td>y of intermediate point </td></tr>
    <tr><td class="paramname">z1</td><td>z of intermediate point </td></tr>
    <tr><td class="paramname">x2</td><td>x of final point </td></tr>
    <tr><td class="paramname">y2</td><td>y of final point </td></tr>
    <tr><td class="paramname">z2</td><td>z of final point </td></tr>
    <tr><td class="paramname">bHasZ</td><td>TRUE if z must be taken into account </td></tr>
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings or NULL. Recognized options: <ul>
<li>
ADD_INTERMEDIATE_POINT=STEALTH/YES/NO (Default to STEALTH). Determine if and how the intermediate point must be output in the linestring. If set to STEALTH, no explicit intermediate point is added but its properties are encoded in low significant bits of intermediate points and <a class="el" href="classOGRGeometryFactory.html#a6642fde43ebaab7703ede629ca18a5d0" title="Try to convert a linestring approximating curves into a curve. ">OGRGeometryFactory::curveFromLineString()</a> can decode them. This is the best compromise for round-tripping in OGR and better results with PostGIS <a href="http://postgis.org/docs/ST_LineToCurve.html">ST_LineToCurve()</a> If set to YES, the intermediate point is explicitly added to the linestring. If set to NO, the intermediate point is not explicitly added.  </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="aae001086e26985d95c36ccd255a8c6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae001086e26985d95c36ccd255a8c6d5">&#9670;&nbsp;</a></span>destroyGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometryFactory::destroyGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy geometry object. </p>
<p>Equivalent to invoking delete on a geometry, but it guaranteed to take place within the context of the GDAL/OGR heap.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object. ">OGR_G_DestroyGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poGeom</td><td>the geometry to deallocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26120382ccfec8ac4b5f932dd3a67c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26120382ccfec8ac4b5f932dd3a67c5f">&#9670;&nbsp;</a></span>forceTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eTargetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to another geometry type. </p>
<p>Tries to force the provided geometry to the specified geometry type.</p>
<p>It can promote 'single' geometry type to their corresponding collection type (see <a class="el" href="ogr__core_8h.html#ad98b8626b3eb0d2b175532bc365bb9c5" title="Returns the collection type that can contain the passed geometry type. ">OGR_GT_GetCollection()</a>) or the reverse. non-linear geometry type to their corresponding linear geometry type (see <a class="el" href="ogr__core_8h.html#a510e29430cffef63b0b12a5d40db59e8" title="Returns the non-curve geometry type that can contain the passed geometry type. ">OGR_GT_GetLinear()</a>), by possibly approximating circular arcs they may contain. Regarding conversion from linear geometry types to curve geometry types, only "wrapping" will be done. No attempt to retrieve potential circular arcs by de-approximating stroking will be done. For that, <a class="el" href="classOGRGeometry.html#a49749581ed7c99f9923029333f7c834c" title="Return curve version of this geometry. ">OGRGeometry::getCurveGeometry()</a> can be used.</p>
<p>The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poGeom</td><td>the input geometry - ownership is passed to the method. </td></tr>
    <tr><td class="paramname">eTargetType</td><td>target output geometry type. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="adcae79ea28620e332a3d1df87f1180f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcae79ea28620e332a3d1df87f1180f3">&#9670;&nbsp;</a></span>forceToLineString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOnlyInOrder</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to line string. </p>
<p>Tries to force the provided geometry to be a line string. This nominally effects a change on multilinestrings. In GDAL 2.0, for polygons or curvepolygons that have a single exterior ring, it will return the ring. For circular strings or compound curves, it will return an approximated line string.</p>
<p>The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poGeom</td><td>the input geometry - ownership is passed to the method. </td></tr>
    <tr><td class="paramname">bOnlyInOrder</td><td>flag that, if set to FALSE, indicate that the order of points in a linestring might be reversed if it enables to match the extremity of another linestring. If set to TRUE, the start of a linestring must match the end of another linestring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry. </dd></dl>

</div>
</div>
<a id="a1c00a78cec110d71175726d6f26b1b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c00a78cec110d71175726d6f26b1b39">&#9670;&nbsp;</a></span>forceToMultiLineString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToMultiLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to multilinestring. </p>
<p>Tries to force the provided geometry to be a multilinestring.</p>
<ul>
<li>linestrings are placed in a multilinestring.</li>
<li>circularstrings and compoundcurves will be approximated and placed in a multilinestring.</li>
<li>geometry collections will be converted to multilinestring if they only contain linestrings.</li>
<li>polygons will be changed to a collection of linestrings (one per ring).</li>
<li>curvepolygons will be approximated and changed to a collection of ( linestrings (one per ring).</li>
</ul>
<p>The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="section return"><dt>Returns</dt><dd>new geometry. </dd></dl>

</div>
</div>
<a id="aa97b7837101f6c56e476520d10a9f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97b7837101f6c56e476520d10a9f3c3">&#9670;&nbsp;</a></span>forceToMultiPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToMultiPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to multipoint. </p>
<p>Tries to force the provided geometry to be a multipoint. Currently this just effects a change on points or collection of points. The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="section return"><dt>Returns</dt><dd>new geometry. </dd></dl>

</div>
</div>
<a id="a2a40032fa65cc71c028516bf8fc0df3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a40032fa65cc71c028516bf8fc0df3e">&#9670;&nbsp;</a></span>forceToMultiPolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToMultiPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to multipolygon. </p>
<p>Tries to force the provided geometry to be a multipolygon. Currently this just effects a change on polygons. The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="section return"><dt>Returns</dt><dd>new geometry. </dd></dl>

</div>
</div>
<a id="afd61936e41ea69831b3196e817658d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd61936e41ea69831b3196e817658d08">&#9670;&nbsp;</a></span>forceToPolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to polygon. </p>
<p>Tries to force the provided geometry to be a polygon. This effects a change on multipolygons. Starting with GDAL 2.0, curve polygons or closed curves will be changed to polygons. The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<p>Note: the resulting polygon may break the Simple Features rules for polygons, for example when converting from a multi-part multipolygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poGeom</td><td>the input geometry - ownership is passed to the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry. </dd></dl>

</div>
</div>
<a id="ad01e72263a6d75bb8a891235df4a75f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01e72263a6d75bb8a891235df4a75f5">&#9670;&nbsp;</a></span>GetCurveParmeters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometryFactory::GetCurveParmeters </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>alpha0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>alpha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>alpha2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parameter of an arc circle. </p>
<p>Angles are return in radians, with trigonometic convention (counter clock wise)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>x of first point </td></tr>
    <tr><td class="paramname">y0</td><td>y of first point </td></tr>
    <tr><td class="paramname">x1</td><td>x of intermediate point </td></tr>
    <tr><td class="paramname">y1</td><td>y of intermediate point </td></tr>
    <tr><td class="paramname">x2</td><td>x of final point </td></tr>
    <tr><td class="paramname">y2</td><td>y of final point </td></tr>
    <tr><td class="paramname">R</td><td>radius (output) </td></tr>
    <tr><td class="paramname">cx</td><td>x of arc center (output) </td></tr>
    <tr><td class="paramname">cy</td><td>y of arc center (output) </td></tr>
    <tr><td class="paramname">alpha0</td><td>angle between center and first point, in radians (output) </td></tr>
    <tr><td class="paramname">alpha1</td><td>angle between center and intermediate point, in radians (output) </td></tr>
    <tr><td class="paramname">alpha2</td><td>angle between center and final point, in radians (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the points are not aligned and define an arc circle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a2b5549a7effe79efd7fcef838787b224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5549a7effe79efd7fcef838787b224">&#9670;&nbsp;</a></span>haveGEOS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRGeometryFactory::haveGEOS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if GEOS enabled. </p>
<p>This static method returns TRUE if GEOS support is built into OGR, otherwise it returns FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if available, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a9ce97d39ca2e0dd88f415227e71b7fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce97d39ca2e0dd88f415227e71b7fd5">&#9670;&nbsp;</a></span>organizePolygons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::organizePolygons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&#160;</td>
          <td class="paramname"><em>papoPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPolygonCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbIsValidGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Organize polygons based on geometries. </p>
<p>Analyse a set of rings (passed as simple polygons), and based on a geometric analysis convert them into a polygon with inner rings, (or a MultiPolygon if dealing with more than one polygon) that follow the OGC Simple Feature specification.</p>
<p>All the input geometries must be OGRPolygon/OGRCurvePolygon with only a valid exterior ring (at least 4 points) and no interior rings.</p>
<p>The passed in geometries become the responsibility of the method, but the papoPolygons "pointer array" remains owned by the caller.</p>
<p>For faster computation, a polygon is considered to be inside another one if a single point of its external ring is included into the other one. (unless 'OGR_DEBUG_ORGANIZE_POLYGONS' configuration option is set to TRUE. In that case, a slower algorithm that tests exact topological relationships is used if GEOS is available.)</p>
<p>In cases where a big number of polygons is passed to this function, the default processing may be really slow. You can skip the processing by adding METHOD=SKIP to the option list (the result of the function will be a multi-polygon with all polygons as toplevel polygons) or only make it analyze counterclockwise polygons by adding METHOD=ONLY_CCW to the option list if you can assume that the outline of holes is counterclockwise defined (this is the convention for example in shapefiles, Personal Geodatabases or File Geodatabases).</p>
<p>For FileGDB, in most cases, but not always, a faster method than ONLY_CCW can be used. It is CCW_INNER_JUST_AFTER_CW_OUTER. When using it, inner rings are assumed to be counterclockwise oriented, and following immediately the outer ring (clockwise oriented) that they belong to. If that assumption is not met, an inner ring could be attached to the wrong outer ring, so this method must be used with care.</p>
<p>If the OGR_ORGANIZE_POLYGONS configuration option is defined, its value will override the value of the METHOD option of papszOptions (useful to modify the behavior of the shapefile driver)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papoPolygons</td><td>array of geometry pointers - should all be OGRPolygons. Ownership of the geometries is passed, but not of the array itself. </td></tr>
    <tr><td class="paramname">nPolygonCount</td><td>number of items in papoPolygons </td></tr>
    <tr><td class="paramname">pbIsValidGeometry</td><td>value will be set TRUE if result is valid or FALSE otherwise. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a list of strings for passing options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a single resulting geometry (either <a class="el" href="classOGRPolygon.html" title="Concrete class representing polygons. ">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons. ">OGRCurvePolygon</a>, <a class="el" href="classOGRMultiPolygon.html" title="A collection of non-overlapping OGRPolygon. ">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html" title="A collection of non-overlapping OGRSurface. ">OGRMultiSurface</a> or <a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects. ">OGRGeometryCollection</a>). Returns a POLYGON EMPTY in the case of nPolygonCount being 0. </dd></dl>

</div>
</div>
<a id="a9dda76280700944f813f6b4c8e7be7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dda76280700944f813f6b4c8e7be7a0">&#9670;&nbsp;</a></span>removeLowerDimensionSubGeoms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::removeLowerDimensionSubGeoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove sub-geometries from a geometry collection that do not have the maximum topological dimensionality of the collection. </p>
<p>This is typically to be used as a cleanup phase after running <a class="el" href="classOGRGeometry.html#a26664b35c9a65737ccb26a38dc161214" title="Attempts to make an invalid geometry valid without losing vertices. ">OGRGeometry::MakeValid()</a></p>
<p>For example, MakeValid() on a polygon can return a geometry collection of polygons and linestrings. Calling this method will return either a polygon or multipolygon by dropping those linestrings.</p>
<p>On a non-geometry collection, this will return a clone of the passed geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poGeom</td><td>input geometry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="a47b03de00271a9ca9902d2c8920414ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b03de00271a9ca9902d2c8920414ad">&#9670;&nbsp;</a></span>transformWithOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::transformWithOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poSrcGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *&#160;</td>
          <td class="paramname"><em>poCT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOGRGeometryFactory_1_1TransformWithOptionsCache.html">TransformWithOptionsCache</a> &amp;&#160;</td>
          <td class="paramname"><em>cache</em> = <code><a class="el" href="classOGRGeometryFactory_1_1TransformWithOptionsCache.html">TransformWithOptionsCache</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSrcGeom</td><td>source geometry </td></tr>
    <tr><td class="paramname">poCT</td><td>coordinate transformation object, or NULL. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options. Including WRAPDATELINE=YES and DATELINEOFFSET=. </td></tr>
    <tr><td class="paramname">cache</td><td>Cache. May increase performance if persisted between invocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(new) transformed geometry. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li>ogrgeometryfactory.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
