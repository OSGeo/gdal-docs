<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: GDALWarpKernel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classGDALWarpKernel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GDALWarpKernel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the lowest level of abstraction of warping.  
 <a href="classGDALWarpKernel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gdalwarper_8h_source.html">gdalwarper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4e1dae4933b3aa3fe1b4c8528d320fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a4e1dae4933b3aa3fe1b4c8528d320fcc">Validate</a> ()</td></tr>
<tr class="memdesc:a4e1dae4933b3aa3fe1b4c8528d320fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the settings in the <a class="el" href="classGDALWarpKernel.html" title="This class represents the lowest level of abstraction of warping. ">GDALWarpKernel</a>, and issue a <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a> (and return CE_Failure) if the configuration is considered to be invalid for some reason.  <a href="#a4e1dae4933b3aa3fe1b4c8528d320fcc">More...</a><br /></td></tr>
<tr class="separator:a4e1dae4933b3aa3fe1b4c8528d320fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c70072beacf62993b38b0aa745e630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a43c70072beacf62993b38b0aa745e630">PerformWarp</a> ()</td></tr>
<tr class="memdesc:a43c70072beacf62993b38b0aa745e630"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method performs the warp described in the <a class="el" href="classGDALWarpKernel.html" title="This class represents the lowest level of abstraction of warping. ">GDALWarpKernel</a>.  <a href="#a43c70072beacf62993b38b0aa745e630">More...</a><br /></td></tr>
<tr class="separator:a43c70072beacf62993b38b0aa745e630"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a094c574206c0fb84d8856874eca320b3"><td class="memItemLeft" align="right" valign="top"><a id="a094c574206c0fb84d8856874eca320b3"></a>
char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a094c574206c0fb84d8856874eca320b3">papszWarpOptions</a></td></tr>
<tr class="memdesc:a094c574206c0fb84d8856874eca320b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warp options. <br /></td></tr>
<tr class="separator:a094c574206c0fb84d8856874eca320b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235bf2537bae77434bd2eb9803e451b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gdalwarper_8h.html#a4775b029869df1f9270ad554c0633843">GDALResampleAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a235bf2537bae77434bd2eb9803e451b1">eResample</a></td></tr>
<tr class="memdesc:a235bf2537bae77434bd2eb9803e451b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resample algorithm.  <a href="#a235bf2537bae77434bd2eb9803e451b1">More...</a><br /></td></tr>
<tr class="separator:a235bf2537bae77434bd2eb9803e451b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e9aa016494fcd80ef33d2e6881dee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a46e9aa016494fcd80ef33d2e6881dee0">eWorkingDataType</a></td></tr>
<tr class="memdesc:a46e9aa016494fcd80ef33d2e6881dee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Working data type.  <a href="#a46e9aa016494fcd80ef33d2e6881dee0">More...</a><br /></td></tr>
<tr class="separator:a46e9aa016494fcd80ef33d2e6881dee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c4ce6aff78d00bcc1ced37aaff53f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a36c4ce6aff78d00bcc1ced37aaff53f8">nBands</a></td></tr>
<tr class="memdesc:a36c4ce6aff78d00bcc1ced37aaff53f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of input and output bands (excluding alpha bands)  <a href="#a36c4ce6aff78d00bcc1ced37aaff53f8">More...</a><br /></td></tr>
<tr class="separator:a36c4ce6aff78d00bcc1ced37aaff53f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0879fc547b62266f0748387ac4064f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#af0879fc547b62266f0748387ac4064f5">nSrcXSize</a></td></tr>
<tr class="memdesc:af0879fc547b62266f0748387ac4064f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the source image.  <a href="#af0879fc547b62266f0748387ac4064f5">More...</a><br /></td></tr>
<tr class="separator:af0879fc547b62266f0748387ac4064f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0458bc023ec1a065df714422a33c805f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a0458bc023ec1a065df714422a33c805f">nSrcYSize</a></td></tr>
<tr class="memdesc:a0458bc023ec1a065df714422a33c805f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height of the source image.  <a href="#a0458bc023ec1a065df714422a33c805f">More...</a><br /></td></tr>
<tr class="separator:a0458bc023ec1a065df714422a33c805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c0d26a0e88a1379b29628b0339fda"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a144c0d26a0e88a1379b29628b0339fda">dfSrcXExtraSize</a></td></tr>
<tr class="memdesc:a144c0d26a0e88a1379b29628b0339fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra pixels (included in nSrcXSize) reserved for filter window.  <a href="#a144c0d26a0e88a1379b29628b0339fda">More...</a><br /></td></tr>
<tr class="separator:a144c0d26a0e88a1379b29628b0339fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e10b8809dce7c2ec7d0dc9097dd4a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a47e10b8809dce7c2ec7d0dc9097dd4a4">dfSrcYExtraSize</a></td></tr>
<tr class="memdesc:a47e10b8809dce7c2ec7d0dc9097dd4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra pixels (included in nSrcYSize) reserved for filter window.  <a href="#a47e10b8809dce7c2ec7d0dc9097dd4a4">More...</a><br /></td></tr>
<tr class="separator:a47e10b8809dce7c2ec7d0dc9097dd4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3cc13ac7b215567b98222136378b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#afa3cc13ac7b215567b98222136378b5e">papabySrcImage</a></td></tr>
<tr class="memdesc:afa3cc13ac7b215567b98222136378b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of nBands source images of size nSrcXSize * nSrcYSize.  <a href="#afa3cc13ac7b215567b98222136378b5e">More...</a><br /></td></tr>
<tr class="separator:afa3cc13ac7b215567b98222136378b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df0b81d44a6c5c1e231e2ff1b5c40c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a8df0b81d44a6c5c1e231e2ff1b5c40c6">papanBandSrcValid</a></td></tr>
<tr class="memdesc:a8df0b81d44a6c5c1e231e2ff1b5c40c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of nBands validity mask of size (nSrcXSize * nSrcYSize + WARP_EXTRA_ELTS) / 8.  <a href="#a8df0b81d44a6c5c1e231e2ff1b5c40c6">More...</a><br /></td></tr>
<tr class="separator:a8df0b81d44a6c5c1e231e2ff1b5c40c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159cc6bcf031b76a288f2c380936f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a3159cc6bcf031b76a288f2c380936f84">panUnifiedSrcValid</a></td></tr>
<tr class="memdesc:a3159cc6bcf031b76a288f2c380936f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified validity mask of size (nSrcXSize * nSrcYSize + WARP_EXTRA_ELTS) / 8.  <a href="#a3159cc6bcf031b76a288f2c380936f84">More...</a><br /></td></tr>
<tr class="separator:a3159cc6bcf031b76a288f2c380936f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa208b9321e1ba4fba7afd7f83f3d929e"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#aa208b9321e1ba4fba7afd7f83f3d929e">pafUnifiedSrcDensity</a></td></tr>
<tr class="memdesc:aa208b9321e1ba4fba7afd7f83f3d929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified source density of size nSrcXSize * nSrcYSize + WARP_EXTRA_ELTS.  <a href="#aa208b9321e1ba4fba7afd7f83f3d929e">More...</a><br /></td></tr>
<tr class="separator:aa208b9321e1ba4fba7afd7f83f3d929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12729bba83339095b7e42410d54b4017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a12729bba83339095b7e42410d54b4017">nDstXSize</a></td></tr>
<tr class="memdesc:a12729bba83339095b7e42410d54b4017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the destination image.  <a href="#a12729bba83339095b7e42410d54b4017">More...</a><br /></td></tr>
<tr class="separator:a12729bba83339095b7e42410d54b4017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323e61928f42c71fb3079c3fe49c2ba3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a323e61928f42c71fb3079c3fe49c2ba3">nDstYSize</a></td></tr>
<tr class="memdesc:a323e61928f42c71fb3079c3fe49c2ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height of the destination image.  <a href="#a323e61928f42c71fb3079c3fe49c2ba3">More...</a><br /></td></tr>
<tr class="separator:a323e61928f42c71fb3079c3fe49c2ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d4993befee8e0a631e08f9874fbafe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#ad8d4993befee8e0a631e08f9874fbafe">papabyDstImage</a></td></tr>
<tr class="memdesc:ad8d4993befee8e0a631e08f9874fbafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of nBands destination images of size nDstXSize * nDstYSize.  <a href="#ad8d4993befee8e0a631e08f9874fbafe">More...</a><br /></td></tr>
<tr class="separator:ad8d4993befee8e0a631e08f9874fbafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3d378ced7582208bcd2383a99c0963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#afa3d378ced7582208bcd2383a99c0963">panDstValid</a></td></tr>
<tr class="memdesc:afa3d378ced7582208bcd2383a99c0963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validify mask of size (nDstXSize * nDstYSize) / 8.  <a href="#afa3d378ced7582208bcd2383a99c0963">More...</a><br /></td></tr>
<tr class="separator:afa3d378ced7582208bcd2383a99c0963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83a64a7241f0214339334b4221a9767"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#ab83a64a7241f0214339334b4221a9767">pafDstDensity</a></td></tr>
<tr class="memdesc:ab83a64a7241f0214339334b4221a9767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination density of size nDstXSize * nDstYSize.  <a href="#ab83a64a7241f0214339334b4221a9767">More...</a><br /></td></tr>
<tr class="separator:ab83a64a7241f0214339334b4221a9767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9e90012a8aa212700fcddbbc4d0ea9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a0b9e90012a8aa212700fcddbbc4d0ea9">dfXScale</a></td></tr>
<tr class="memdesc:a0b9e90012a8aa212700fcddbbc4d0ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">X resampling scale, i.e.  <a href="#a0b9e90012a8aa212700fcddbbc4d0ea9">More...</a><br /></td></tr>
<tr class="separator:a0b9e90012a8aa212700fcddbbc4d0ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14e1bab454a8484fe5b46a6ff7eb2f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#ad14e1bab454a8484fe5b46a6ff7eb2f3">dfYScale</a></td></tr>
<tr class="memdesc:ad14e1bab454a8484fe5b46a6ff7eb2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y resampling scale, i.e.  <a href="#ad14e1bab454a8484fe5b46a6ff7eb2f3">More...</a><br /></td></tr>
<tr class="separator:ad14e1bab454a8484fe5b46a6ff7eb2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe138ee904ade55e528feaf531fddc6f"><td class="memItemLeft" align="right" valign="top"><a id="abe138ee904ade55e528feaf531fddc6f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#abe138ee904ade55e528feaf531fddc6f">dfXFilter</a></td></tr>
<tr class="memdesc:abe138ee904ade55e528feaf531fddc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">X size of filter kernel. <br /></td></tr>
<tr class="separator:abe138ee904ade55e528feaf531fddc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c511ce641ba37c5a62967df9d1c0ab0"><td class="memItemLeft" align="right" valign="top"><a id="a0c511ce641ba37c5a62967df9d1c0ab0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a0c511ce641ba37c5a62967df9d1c0ab0">dfYFilter</a></td></tr>
<tr class="memdesc:a0c511ce641ba37c5a62967df9d1c0ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y size of filter kernel. <br /></td></tr>
<tr class="separator:a0c511ce641ba37c5a62967df9d1c0ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024407198d5ef421fc76e6a9f624e738"><td class="memItemLeft" align="right" valign="top"><a id="a024407198d5ef421fc76e6a9f624e738"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a024407198d5ef421fc76e6a9f624e738">nXRadius</a></td></tr>
<tr class="memdesc:a024407198d5ef421fc76e6a9f624e738"><td class="mdescLeft">&#160;</td><td class="mdescRight">X size of window to filter. <br /></td></tr>
<tr class="separator:a024407198d5ef421fc76e6a9f624e738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacedc4caedb1f7bc300e34ea75fa0a67"><td class="memItemLeft" align="right" valign="top"><a id="aacedc4caedb1f7bc300e34ea75fa0a67"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#aacedc4caedb1f7bc300e34ea75fa0a67">nYRadius</a></td></tr>
<tr class="memdesc:aacedc4caedb1f7bc300e34ea75fa0a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y size of window to filter. <br /></td></tr>
<tr class="separator:aacedc4caedb1f7bc300e34ea75fa0a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad9a436cafa09806753612bdf656465"><td class="memItemLeft" align="right" valign="top"><a id="a0ad9a436cafa09806753612bdf656465"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a0ad9a436cafa09806753612bdf656465">nFiltInitX</a></td></tr>
<tr class="memdesc:a0ad9a436cafa09806753612bdf656465"><td class="mdescLeft">&#160;</td><td class="mdescRight">X filtering offset. <br /></td></tr>
<tr class="separator:a0ad9a436cafa09806753612bdf656465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89445991c74f15175c8b3c80b051fb30"><td class="memItemLeft" align="right" valign="top"><a id="a89445991c74f15175c8b3c80b051fb30"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a89445991c74f15175c8b3c80b051fb30">nFiltInitY</a></td></tr>
<tr class="memdesc:a89445991c74f15175c8b3c80b051fb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y filtering offset. <br /></td></tr>
<tr class="separator:a89445991c74f15175c8b3c80b051fb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be67aaba3185f65e83f857a01d3aa51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a4be67aaba3185f65e83f857a01d3aa51">nSrcXOff</a></td></tr>
<tr class="memdesc:a4be67aaba3185f65e83f857a01d3aa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">X offset of the source buffer regarding the top-left corner of the image.  <a href="#a4be67aaba3185f65e83f857a01d3aa51">More...</a><br /></td></tr>
<tr class="separator:a4be67aaba3185f65e83f857a01d3aa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e237558357f0bd4dc4af0ad2e51e12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a71e237558357f0bd4dc4af0ad2e51e12">nSrcYOff</a></td></tr>
<tr class="memdesc:a71e237558357f0bd4dc4af0ad2e51e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y offset of the source buffer regarding the top-left corner of the image.  <a href="#a71e237558357f0bd4dc4af0ad2e51e12">More...</a><br /></td></tr>
<tr class="separator:a71e237558357f0bd4dc4af0ad2e51e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e26f62aae281d23d13d02f10284d25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a22e26f62aae281d23d13d02f10284d25">nDstXOff</a></td></tr>
<tr class="memdesc:a22e26f62aae281d23d13d02f10284d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">X offset of the destination buffer regarding the top-left corner of the image.  <a href="#a22e26f62aae281d23d13d02f10284d25">More...</a><br /></td></tr>
<tr class="separator:a22e26f62aae281d23d13d02f10284d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8682f0ed0266db88cfb764d1fcf2a4a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a8682f0ed0266db88cfb764d1fcf2a4a9">nDstYOff</a></td></tr>
<tr class="memdesc:a8682f0ed0266db88cfb764d1fcf2a4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y offset of the destination buffer regarding the top-left corner of the image.  <a href="#a8682f0ed0266db88cfb764d1fcf2a4a9">More...</a><br /></td></tr>
<tr class="separator:a8682f0ed0266db88cfb764d1fcf2a4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f101096fda92d7d642d354aabd6d5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a2f101096fda92d7d642d354aabd6d5ba">pfnTransformer</a></td></tr>
<tr class="memdesc:a2f101096fda92d7d642d354aabd6d5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel transformation function.  <a href="#a2f101096fda92d7d642d354aabd6d5ba">More...</a><br /></td></tr>
<tr class="separator:a2f101096fda92d7d642d354aabd6d5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4352e0b3d97f9e44c7656dbb7a5ca3a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#af4352e0b3d97f9e44c7656dbb7a5ca3a">pTransformerArg</a></td></tr>
<tr class="memdesc:af4352e0b3d97f9e44c7656dbb7a5ca3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User data provided to pfnTransformer.  <a href="#af4352e0b3d97f9e44c7656dbb7a5ca3a">More...</a><br /></td></tr>
<tr class="separator:af4352e0b3d97f9e44c7656dbb7a5ca3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a87cffc6776d1d165c477740ad09520"><td class="memItemLeft" align="right" valign="top">GDALProgressFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a8a87cffc6776d1d165c477740ad09520">pfnProgress</a></td></tr>
<tr class="memdesc:a8a87cffc6776d1d165c477740ad09520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progress function.  <a href="#a8a87cffc6776d1d165c477740ad09520">More...</a><br /></td></tr>
<tr class="separator:a8a87cffc6776d1d165c477740ad09520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d33138d70373a265cec48292cbca1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a923d33138d70373a265cec48292cbca1">pProgress</a></td></tr>
<tr class="memdesc:a923d33138d70373a265cec48292cbca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">User data provided to pfnProgress.  <a href="#a923d33138d70373a265cec48292cbca1">More...</a><br /></td></tr>
<tr class="separator:a923d33138d70373a265cec48292cbca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c972b035201c33eb713e77682a5e8b0"><td class="memItemLeft" align="right" valign="top"><a id="a3c972b035201c33eb713e77682a5e8b0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a3c972b035201c33eb713e77682a5e8b0">dfProgressBase</a></td></tr>
<tr class="memdesc:a3c972b035201c33eb713e77682a5e8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base/offset value for progress computation. <br /></td></tr>
<tr class="separator:a3c972b035201c33eb713e77682a5e8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae178549cef9b117f594a16e5193a4882"><td class="memItemLeft" align="right" valign="top"><a id="ae178549cef9b117f594a16e5193a4882"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#ae178549cef9b117f594a16e5193a4882">dfProgressScale</a></td></tr>
<tr class="memdesc:ae178549cef9b117f594a16e5193a4882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale value for progress computation. <br /></td></tr>
<tr class="separator:ae178549cef9b117f594a16e5193a4882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1473f3de525e0848a8313dc0a586a8c0"><td class="memItemLeft" align="right" valign="top"><a id="a1473f3de525e0848a8313dc0a586a8c0"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALWarpKernel.html#a1473f3de525e0848a8313dc0a586a8c0">padfDstNoDataReal</a></td></tr>
<tr class="memdesc:a1473f3de525e0848a8313dc0a586a8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of nBands value for destination nodata. <br /></td></tr>
<tr class="separator:a1473f3de525e0848a8313dc0a586a8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents the lowest level of abstraction of warping. </p>
<p>Low level image warping class.</p>
<p>It holds the imagery for one "chunk" of a warp, and the pre-prepared masks. All IO is done before and after its operation. This class is not normally used by the application.</p>
<p>This class is responsible for low level image warping for one "chunk" of imagery. The class is essentially a structure with all data members public - primarily so that new special-case functions can be added without changing the class declaration.</p>
<p>Applications are normally intended to interactive with warping facilities through the <a class="el" href="classGDALWarpOperation.html" title="High level image warping class. ">GDALWarpOperation</a> class, though the <a class="el" href="classGDALWarpKernel.html" title="This class represents the lowest level of abstraction of warping. ">GDALWarpKernel</a> can in theory be used directly if great care is taken in setting up the control data.</p>
<h3>Design Issues</h3>
<p>The intention is that <a class="el" href="classGDALWarpKernel.html#a43c70072beacf62993b38b0aa745e630" title="This method performs the warp described in the GDALWarpKernel. ">PerformWarp()</a> would analyze the setup in terms of the datatype, resampling type, and validity/density mask usage and pick one of many specific implementations of the warping algorithm over a continuum of optimization vs. generality. At one end there will be a reference general purpose implementation of the algorithm that supports any data type (working internally in double precision complex), all three resampling types, and any or all of the validity/density masks. At the other end would be highly optimized algorithms for common cases like nearest neighbour resampling on GDT_Byte data with no masks.</p>
<p>The full set of optimized versions have not been decided but we should expect to have at least:</p><ul>
<li>One for each resampling algorithm for 8bit data with no masks.</li>
<li>One for each resampling algorithm for float data with no masks.</li>
<li>One for each resampling algorithm for float data with any/all masks (essentially the generic case for just float data).</li>
<li>One for each resampling algorithm for 8bit data with support for input validity masks (per band or per pixel). This handles the common case of nodata masking.</li>
<li>One for each resampling algorithm for float data with support for input validity masks (per band or per pixel). This handles the common case of nodata masking.</li>
</ul>
<p>Some of the specializations would operate on all bands in one pass (especially the ones without masking would do this), while others might process each band individually to reduce code complexity.</p>
<h3>Masking Semantics</h3>
<p>A detailed explanation of the semantics of the validity and density masks, and their effects on resampling kernels is needed here. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a43c70072beacf62993b38b0aa745e630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c70072beacf62993b38b0aa745e630">&#9670;&nbsp;</a></span>PerformWarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALWarpKernel::PerformWarp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method performs the warp described in the <a class="el" href="classGDALWarpKernel.html" title="This class represents the lowest level of abstraction of warping. ">GDALWarpKernel</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a id="a4e1dae4933b3aa3fe1b4c8528d320fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1dae4933b3aa3fe1b4c8528d320fcc">&#9670;&nbsp;</a></span>Validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALWarpKernel::Validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the settings in the <a class="el" href="classGDALWarpKernel.html" title="This class represents the lowest level of abstraction of warping. ">GDALWarpKernel</a>, and issue a <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a> (and return CE_Failure) if the configuration is considered to be invalid for some reason. </p>
<p>This method will also do some standard defaulting such as setting pfnProgress to GDALDummyProgress() if it is NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if an error is detected. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a144c0d26a0e88a1379b29628b0339fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c0d26a0e88a1379b29628b0339fda">&#9670;&nbsp;</a></span>dfSrcXExtraSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GDALWarpKernel::dfSrcXExtraSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extra pixels (included in nSrcXSize) reserved for filter window. </p>
<p>Number of pixels included in nSrcXSize that are present on the edges of the area of interest to take into account the width of the kernel.</p>
<p>Should be ignored in scale computation</p>
<p>This field is required. </p>

</div>
</div>
<a id="a47e10b8809dce7c2ec7d0dc9097dd4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e10b8809dce7c2ec7d0dc9097dd4a4">&#9670;&nbsp;</a></span>dfSrcYExtraSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GDALWarpKernel::dfSrcYExtraSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extra pixels (included in nSrcYSize) reserved for filter window. </p>
<p>Number of pixels included in nSrcYExtraSize that are present on the edges of the area of interest to take into account the height of the kernel.</p>
<p>Should be ignored in scale computation</p>
<p>This field is required. </p>

</div>
</div>
<a id="a0b9e90012a8aa212700fcddbbc4d0ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9e90012a8aa212700fcddbbc4d0ea9">&#9670;&nbsp;</a></span>dfXScale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GDALWarpKernel::dfXScale</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X resampling scale, i.e. </p>
<p>nDstXSize / nSrcXSize </p>

</div>
</div>
<a id="ad14e1bab454a8484fe5b46a6ff7eb2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14e1bab454a8484fe5b46a6ff7eb2f3">&#9670;&nbsp;</a></span>dfYScale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GDALWarpKernel::dfYScale</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Y resampling scale, i.e. </p>
<p>nDstYSize / nSrcYSize </p>

</div>
</div>
<a id="a235bf2537bae77434bd2eb9803e451b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235bf2537bae77434bd2eb9803e451b1">&#9670;&nbsp;</a></span>eResample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gdalwarper_8h.html#a4775b029869df1f9270ad554c0633843">GDALResampleAlg</a> GDALWarpKernel::eResample</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resample algorithm. </p>
<p>Resampling algorithm.</p>
<p>The resampling algorithm to use. One of GRA_NearestNeighbour, GRA_Bilinear, GRA_Cubic, GRA_CubicSpline, GRA_Lanczos, GRA_Average, GRA_Mode or GRA_Sum.</p>
<p>This field is required. GDT_NearestNeighbour may be used as a default value. </p>

</div>
</div>
<a id="a46e9aa016494fcd80ef33d2e6881dee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e9aa016494fcd80ef33d2e6881dee0">&#9670;&nbsp;</a></span>eWorkingDataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> GDALWarpKernel::eWorkingDataType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Working data type. </p>
<p>Working pixel data type.</p>
<p>The datatype of pixels in the source image (papabySrcimage) and destination image (papabyDstImage) buffers. Note that operations on some data types (such as GDT_Byte) may be much better optimized than other less common cases.</p>
<p>This field is required. It may not be GDT_Unknown. </p>

</div>
</div>
<a id="a36c4ce6aff78d00bcc1ced37aaff53f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c4ce6aff78d00bcc1ced37aaff53f8">&#9670;&nbsp;</a></span>nBands</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nBands</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of input and output bands (excluding alpha bands) </p>
<p>Number of bands.</p>
<p>The number of bands (layers) of imagery being warped. Determines the number of entries in the papabySrcImage, papanBandSrcValid, and papabyDstImage arrays.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a22e26f62aae281d23d13d02f10284d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e26f62aae281d23d13d02f10284d25">&#9670;&nbsp;</a></span>nDstXOff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nDstXOff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X offset of the destination buffer regarding the top-left corner of the image. </p>
<p>X offset to destination pixel coordinates for transformation.</p>
<p>See pfnTransformer.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a12729bba83339095b7e42410d54b4017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12729bba83339095b7e42410d54b4017">&#9670;&nbsp;</a></span>nDstXSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nDstXSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Width of the destination image. </p>
<p>Width of destination image in pixels.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a8682f0ed0266db88cfb764d1fcf2a4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8682f0ed0266db88cfb764d1fcf2a4a9">&#9670;&nbsp;</a></span>nDstYOff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nDstYOff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Y offset of the destination buffer regarding the top-left corner of the image. </p>
<p>Y offset to destination pixel coordinates for transformation.</p>
<p>See pfnTransformer.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a323e61928f42c71fb3079c3fe49c2ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323e61928f42c71fb3079c3fe49c2ba3">&#9670;&nbsp;</a></span>nDstYSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nDstYSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Height of the destination image. </p>
<p>Height of destination image in pixels.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a4be67aaba3185f65e83f857a01d3aa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be67aaba3185f65e83f857a01d3aa51">&#9670;&nbsp;</a></span>nSrcXOff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nSrcXOff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X offset of the source buffer regarding the top-left corner of the image. </p>
<p>X offset to source pixel coordinates for transformation.</p>
<p>See pfnTransformer.</p>
<p>This field is required. </p>

</div>
</div>
<a id="af0879fc547b62266f0748387ac4064f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0879fc547b62266f0748387ac4064f5">&#9670;&nbsp;</a></span>nSrcXSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nSrcXSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Width of the source image. </p>
<p>Source image width in pixels.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a71e237558357f0bd4dc4af0ad2e51e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e237558357f0bd4dc4af0ad2e51e12">&#9670;&nbsp;</a></span>nSrcYOff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nSrcYOff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Y offset of the source buffer regarding the top-left corner of the image. </p>
<p>Y offset to source pixel coordinates for transformation.</p>
<p>See pfnTransformer.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a0458bc023ec1a065df714422a33c805f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0458bc023ec1a065df714422a33c805f">&#9670;&nbsp;</a></span>nSrcYSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::nSrcYSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Height of the source image. </p>
<p>Source image height in pixels.</p>
<p>This field is required. </p>

</div>
</div>
<a id="ab83a64a7241f0214339334b4221a9767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83a64a7241f0214339334b4221a9767">&#9670;&nbsp;</a></span>pafDstDensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * GDALWarpKernel::pafDstDensity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destination density of size nDstXSize * nDstYSize. </p>
<p>Per pixel density mask for destination pixels.</p>
<p>A single density mask layer that applies to the pixels of all destination bands. It contains values between 0.0 and 1.0.</p>
<p>This pointer may be NULL indicating that all pixels have a density of 1.0.</p>
<p>The density for a pixel may be accessed like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> fDensity = 1.0;</div><div class="line"><span class="keywordtype">int</span>   nPixel = 3; <span class="comment">// Zero based.</span></div><div class="line"><span class="keywordtype">int</span>   nLine = 4;  <span class="comment">// Zero based.</span></div><div class="line"></div><div class="line">assert( nPixel &gt;= 0 &amp;&amp; nPixel &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a12729bba83339095b7e42410d54b4017">nDstXSize</a> );</div><div class="line">assert( nLine &gt;= 0 &amp;&amp; nLine &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a323e61928f42c71fb3079c3fe49c2ba3">nDstYSize</a> );</div><div class="line"><span class="keywordflow">if</span>( poKern-&gt;pafDstDensity != NULL )</div><div class="line">  fDensity = poKern-&gt;pafDstDensity[nPixel + nLine * poKern-&gt;nDstXSize];</div></div><!-- fragment --> 
</div>
</div>
<a id="aa208b9321e1ba4fba7afd7f83f3d929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa208b9321e1ba4fba7afd7f83f3d929e">&#9670;&nbsp;</a></span>pafUnifiedSrcDensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * GDALWarpKernel::pafUnifiedSrcDensity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unified source density of size nSrcXSize * nSrcYSize + WARP_EXTRA_ELTS. </p>
<p>Per pixel density mask for source pixels.</p>
<p>A single density mask layer that applies to the pixels of all source bands. It contains values between 0.0 and 1.0 indicating the degree to which this pixel should be allowed to contribute to the output result.</p>
<p>This pointer may be NULL indicating that all pixels have a density of 1.0.</p>
<p>The density for a pixel may be accessed like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> fDensity = 1.0;</div><div class="line"><span class="keywordtype">int</span> nPixel = 3;  <span class="comment">// Zero based.</span></div><div class="line"><span class="keywordtype">int</span> nLine = 4;   <span class="comment">// Zero based.</span></div><div class="line"></div><div class="line">assert( nPixel &gt;= 0 &amp;&amp; nPixel &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#af0879fc547b62266f0748387ac4064f5">nSrcXSize</a> );</div><div class="line">assert( nLine &gt;= 0 &amp;&amp; nLine &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a0458bc023ec1a065df714422a33c805f">nSrcYSize</a> );</div><div class="line"><span class="keywordflow">if</span>( poKern-&gt;pafUnifiedSrcDensity != NULL )</div><div class="line">  fDensity = poKern-&gt;pafUnifiedSrcDensity</div><div class="line">                               [nPixel + nLine * poKern-&gt;nSrcXSize];</div></div><!-- fragment --> 
</div>
</div>
<a id="afa3d378ced7582208bcd2383a99c0963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3d378ced7582208bcd2383a99c0963">&#9670;&nbsp;</a></span>panDstValid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> * GDALWarpKernel::panDstValid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validify mask of size (nDstXSize * nDstYSize) / 8. </p>
<p>Per pixel validity mask for destination pixels.</p>
<p>A single validity mask layer that applies to the pixels of all destination bands. It is accessed similarly to papanUnitifiedSrcValid, but based on the size of the destination image.</p>
<p>This pointer may be NULL indicating that all pixels are valid. </p>

</div>
</div>
<a id="a3159cc6bcf031b76a288f2c380936f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3159cc6bcf031b76a288f2c380936f84">&#9670;&nbsp;</a></span>panUnifiedSrcValid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> * GDALWarpKernel::panUnifiedSrcValid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unified validity mask of size (nSrcXSize * nSrcYSize + WARP_EXTRA_ELTS) / 8. </p>
<p>Per pixel validity mask for source pixels.</p>
<p>A single validity mask layer that applies to the pixels of all source bands. It is accessed similarly to papanBandSrcValid, but without the extra level of band indirection.</p>
<p>This pointer may be NULL indicating that all pixels are valid.</p>
<p>Note that if both panUnifiedSrcValid, and papanBandSrcValid are available, the pixel isn't considered to be valid unless both arrays indicate it is valid. </p>

</div>
</div>
<a id="ad8d4993befee8e0a631e08f9874fbafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d4993befee8e0a631e08f9874fbafe">&#9670;&nbsp;</a></span>papabyDstImage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> ** GDALWarpKernel::papabyDstImage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of nBands destination images of size nDstXSize * nDstYSize. </p>
<p>Array of destination image band data.</p>
<p>This is an array of pointers (of size <a class="el" href="classGDALWarpKernel.html#a36c4ce6aff78d00bcc1ced37aaff53f8" title="Number of input and output bands (excluding alpha bands) ">GDALWarpKernel::nBands</a>) pointers to image data. Each individual band of image data is organized as a single block of image data in left to right, then bottom to top order. The actual type of the image data is determined by <a class="el" href="classGDALWarpKernel.html#a46e9aa016494fcd80ef33d2e6881dee0" title="Working data type. ">GDALWarpKernel::eWorkingDataType</a>.</p>
<p>To access the pixel value for the (x=3, y=4) pixel (zero based) of the second band with eWorkingDataType set to GDT_Float32 use code like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> dfPixelValue;</div><div class="line"><span class="keywordtype">int</span>   nBand = 1;  <span class="comment">// Band indexes are zero based.</span></div><div class="line"><span class="keywordtype">int</span>   nPixel = 3; <span class="comment">// Zero based.</span></div><div class="line"><span class="keywordtype">int</span>   nLine = 4;  <span class="comment">// Zero based.</span></div><div class="line"></div><div class="line">assert( nPixel &gt;= 0 &amp;&amp; nPixel &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a12729bba83339095b7e42410d54b4017">nDstXSize</a> );</div><div class="line">assert( nLine &gt;= 0 &amp;&amp; nLine &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a323e61928f42c71fb3079c3fe49c2ba3">nDstYSize</a> );</div><div class="line">assert( nBand &gt;= 0 &amp;&amp; nBand &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a36c4ce6aff78d00bcc1ced37aaff53f8">nBands</a> );</div><div class="line">dfPixelValue = ((<span class="keywordtype">float</span> *) poKern-&gt;papabyDstImage[nBand-1])</div><div class="line">                               [nPixel + nLine * poKern-&gt;nSrcYSize];</div></div><!-- fragment --><p>This field is required. </p>

</div>
</div>
<a id="afa3cc13ac7b215567b98222136378b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3cc13ac7b215567b98222136378b5e">&#9670;&nbsp;</a></span>papabySrcImage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALWarpKernel::papabySrcImage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of nBands source images of size nSrcXSize * nSrcYSize. </p>
<p>Array of source image band data.</p>
<p>Each subarray must have WARP_EXTRA_ELTS at the end</p>
<p>This is an array of pointers (of size <a class="el" href="classGDALWarpKernel.html#a36c4ce6aff78d00bcc1ced37aaff53f8" title="Number of input and output bands (excluding alpha bands) ">GDALWarpKernel::nBands</a>) pointers to image data. Each individual band of image data is organized as a single block of image data in left to right, then bottom to top order. The actual type of the image data is determined by <a class="el" href="classGDALWarpKernel.html#a46e9aa016494fcd80ef33d2e6881dee0" title="Working data type. ">GDALWarpKernel::eWorkingDataType</a>.</p>
<p>To access the pixel value for the (x=3, y=4) pixel (zero based) of the second band with eWorkingDataType set to GDT_Float32 use code like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> dfPixelValue;</div><div class="line"><span class="keywordtype">int</span>   nBand = 1;  <span class="comment">// Band indexes are zero based.</span></div><div class="line"><span class="keywordtype">int</span>   nPixel = 3; <span class="comment">// Zero based.</span></div><div class="line"><span class="keywordtype">int</span>   nLine = 4;  <span class="comment">// Zero based.</span></div><div class="line"></div><div class="line">assert( nPixel &gt;= 0 &amp;&amp; nPixel &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#af0879fc547b62266f0748387ac4064f5">nSrcXSize</a> );</div><div class="line">assert( nLine &gt;= 0 &amp;&amp; nLine &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a0458bc023ec1a065df714422a33c805f">nSrcYSize</a> );</div><div class="line">assert( nBand &gt;= 0 &amp;&amp; nBand &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a36c4ce6aff78d00bcc1ced37aaff53f8">nBands</a> );</div><div class="line">dfPixelValue = ((<span class="keywordtype">float</span> *) poKern-&gt;papabySrcImage[nBand-1])</div><div class="line">                               [nPixel + nLine * poKern-&gt;nSrcXSize];</div></div><!-- fragment --><p>This field is required. </p>

</div>
</div>
<a id="a8df0b81d44a6c5c1e231e2ff1b5c40c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df0b81d44a6c5c1e231e2ff1b5c40c6">&#9670;&nbsp;</a></span>papanBandSrcValid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> ** GDALWarpKernel::papanBandSrcValid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of nBands validity mask of size (nSrcXSize * nSrcYSize + WARP_EXTRA_ELTS) / 8. </p>
<p>Per band validity mask for source pixels.</p>
<p>Array of pixel validity mask layers for each source band. Each of the mask layers is the same size (in pixels) as the source image with one bit per pixel. Note that it is legal (and common) for this to be NULL indicating that none of the pixels are invalidated, or for some band validity masks to be NULL in which case all pixels of the band are valid. The following code can be used to test the validity of a particular pixel.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>   bIsValid = TRUE;</div><div class="line"><span class="keywordtype">int</span>   nBand = 1;  <span class="comment">// Band indexes are zero based.</span></div><div class="line"><span class="keywordtype">int</span>   nPixel = 3; <span class="comment">// Zero based.</span></div><div class="line"><span class="keywordtype">int</span>   nLine = 4;  <span class="comment">// Zero based.</span></div><div class="line"></div><div class="line">assert( nPixel &gt;= 0 &amp;&amp; nPixel &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#af0879fc547b62266f0748387ac4064f5">nSrcXSize</a> );</div><div class="line">assert( nLine &gt;= 0 &amp;&amp; nLine &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a0458bc023ec1a065df714422a33c805f">nSrcYSize</a> );</div><div class="line">assert( nBand &gt;= 0 &amp;&amp; nBand &lt; poKern-&gt;<a class="code" href="classGDALWarpKernel.html#a36c4ce6aff78d00bcc1ced37aaff53f8">nBands</a> );</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>( poKern-&gt;papanBandSrcValid != NULL</div><div class="line">    &amp;&amp; poKern-&gt;papanBandSrcValid[nBand] != NULL )</div><div class="line">{</div><div class="line">    <a class="code" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> *panBandMask = poKern-&gt;papanBandSrcValid[nBand];</div><div class="line">    <span class="keywordtype">int</span>    iPixelOffset = nPixel + nLine * poKern-&gt;nSrcXSize;</div><div class="line"></div><div class="line">    bIsValid = panBandMask[iPixelOffset&gt;&gt;5]</div><div class="line">               &amp; (0x01 &lt;&lt; (iPixelOffset &amp; 0x1f));</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a8a87cffc6776d1d165c477740ad09520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a87cffc6776d1d165c477740ad09520">&#9670;&nbsp;</a></span>pfnProgress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GDALProgressFunc GDALWarpKernel::pfnProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Progress function. </p>
<p>The function to call to report progress of the algorithm, and to check for a requested termination of the operation.</p>
<p>It operates according to GDALProgressFunc() semantics.</p>
<p>Generally speaking the progress function will be invoked for each scanline of the destination buffer that has been processed.</p>
<p>This field may be NULL (internally set to GDALDummyProgress()). </p>

</div>
</div>
<a id="a2f101096fda92d7d642d354aabd6d5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f101096fda92d7d642d354aabd6d5ba">&#9670;&nbsp;</a></span>pfnTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> GDALWarpKernel::pfnTransformer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pixel transformation function. </p>
<p>Source/destination location transformer.</p>
<p>The function to call to transform coordinates between source image pixel/line coordinates and destination image pixel/line coordinates. See <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc()</a> for details of the semantics of this function.</p>
<p>The GDALWarpKern algorithm will only ever use this transformer in "destination to source" mode (bDstToSrc=TRUE), and will always pass partial or complete scanlines of points in the destination image as input. This means, among other things, that it is safe to the the approximating transform <a class="el" href="gdal__alg_8h.html#a766ccb23b021d30d86908c08ad8d1668" title="Perform approximate transformation. ">GDALApproxTransform()</a> as the transformation function.</p>
<p>Source and destination images may be subsets of a larger overall image. The transformation algorithms will expect and return pixel/line coordinates in terms of this larger image, so coordinates need to be offset by the offsets specified in nSrcXOff, nSrcYOff, nDstXOff, and nDstYOff before passing to pfnTransformer, and after return from it.</p>
<p>The GDALWarpKernel::pfnTransformerArg value will be passed as the callback data to this function when it is called.</p>
<p>This field is required. </p>

</div>
</div>
<a id="a923d33138d70373a265cec48292cbca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d33138d70373a265cec48292cbca1">&#9670;&nbsp;</a></span>pProgress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * GDALWarpKernel::pProgress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User data provided to pfnProgress. </p>
<p>Callback data for pfnProgress.</p>
<p>This field may be NULL if not required for the pfnProgress being used. </p>

</div>
</div>
<a id="af4352e0b3d97f9e44c7656dbb7a5ca3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4352e0b3d97f9e44c7656dbb7a5ca3a">&#9670;&nbsp;</a></span>pTransformerArg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * GDALWarpKernel::pTransformerArg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User data provided to pfnTransformer. </p>
<p>Callback data for pfnTransformer.</p>
<p>This field may be NULL if not required for the pfnTransformer being used. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="gdalwarper_8h_source.html">gdalwarper.h</a></li>
<li>gdalwarpkernel.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
