<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: cpl_minixml.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_651562d8bf6cfd3e81eff5b570d7df50.html">port</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cpl_minixml.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Definitions for CPL mini XML Parser/Serializer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br />
</div>
<p><a href="cpl__minixml_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Document node structure.  <a href="structCPLXMLNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLXMLTreeCloser.html">CPLXMLTreeCloser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage a tree of XML nodes so that all nodes are freed when the instance goes out of scope.  <a href="classCPLXMLTreeCloser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae2767267ad31c092d81a2380ee3474a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a> { <br />
&#160;&#160;<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e">CXT_Element</a> = 0, 
<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1">CXT_Text</a> = 1, 
<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad4a32b8961ea4b6caa7a471fd5c1412d">CXT_Attribute</a> = 2, 
<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ab3bea14871a8fa6136365aaef2d6ff15">CXT_Comment</a> = 3, 
<br />
&#160;&#160;<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1a0e4a04d69bb7e75b6955a282475867f4">CXT_Literal</a> = 4
<br />
 }<tr class="memdesc:ae2767267ad31c092d81a2380ee3474a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML node type.  <a href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae2767267ad31c092d81a2380ee3474a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2770716fe2b8dac4969df728e274c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#ad2770716fe2b8dac4969df728e274c9b">CPLParseXMLString</a> (const char *)</td></tr>
<tr class="memdesc:ad2770716fe2b8dac4969df728e274c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an XML string into tree form.  <a href="#ad2770716fe2b8dac4969df728e274c9b">More...</a><br /></td></tr>
<tr class="separator:ad2770716fe2b8dac4969df728e274c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e05eabc54728fb3266576404200da40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a9e05eabc54728fb3266576404200da40">CPLDestroyXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *)</td></tr>
<tr class="memdesc:a9e05eabc54728fb3266576404200da40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a tree.  <a href="#a9e05eabc54728fb3266576404200da40">More...</a><br /></td></tr>
<tr class="separator:a9e05eabc54728fb3266576404200da40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb137728b61e42765ea7e5188a24f90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#acb137728b61e42765ea7e5188a24f90e">CPLGetXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poRoot, const char *pszPath)</td></tr>
<tr class="memdesc:acb137728b61e42765ea7e5188a24f90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find node by path.  <a href="#acb137728b61e42765ea7e5188a24f90e">More...</a><br /></td></tr>
<tr class="separator:acb137728b61e42765ea7e5188a24f90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d07b7ebe279176dafa455a70043680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aa1d07b7ebe279176dafa455a70043680">CPLSearchXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poRoot, const char *pszTarget)</td></tr>
<tr class="memdesc:aa1d07b7ebe279176dafa455a70043680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a node in document.  <a href="#aa1d07b7ebe279176dafa455a70043680">More...</a><br /></td></tr>
<tr class="separator:aa1d07b7ebe279176dafa455a70043680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab837bc73eaa55ae1363ae30a5f2a2019"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#ab837bc73eaa55ae1363ae30a5f2a2019">CPLGetXMLValue</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poRoot, const char *pszPath, const char *pszDefault)</td></tr>
<tr class="memdesc:ab837bc73eaa55ae1363ae30a5f2a2019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch element/attribute value.  <a href="#ab837bc73eaa55ae1363ae30a5f2a2019">More...</a><br /></td></tr>
<tr class="separator:ab837bc73eaa55ae1363ae30a5f2a2019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8779ff560dde3b2cd076a16059e66771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a8779ff560dde3b2cd076a16059e66771">CPLCreateXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poParent, <a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a> eType, const char *pszText)</td></tr>
<tr class="memdesc:a8779ff560dde3b2cd076a16059e66771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an document tree item.  <a href="#a8779ff560dde3b2cd076a16059e66771">More...</a><br /></td></tr>
<tr class="separator:a8779ff560dde3b2cd076a16059e66771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17562c5f454d236e6749c73f4c93de6e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a17562c5f454d236e6749c73f4c93de6e">CPLSerializeXMLTree</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psNode)</td></tr>
<tr class="memdesc:a17562c5f454d236e6749c73f4c93de6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert tree into string document.  <a href="#a17562c5f454d236e6749c73f4c93de6e">More...</a><br /></td></tr>
<tr class="separator:a17562c5f454d236e6749c73f4c93de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4fd469090f44089221811f1c550742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#acf4fd469090f44089221811f1c550742">CPLAddXMLChild</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psParent, <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psChild)</td></tr>
<tr class="memdesc:acf4fd469090f44089221811f1c550742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child node to parent.  <a href="#acf4fd469090f44089221811f1c550742">More...</a><br /></td></tr>
<tr class="separator:acf4fd469090f44089221811f1c550742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe9f99875faf356b34d2b97a0668ffb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aabe9f99875faf356b34d2b97a0668ffb">CPLRemoveXMLChild</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psParent, <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psChild)</td></tr>
<tr class="memdesc:aabe9f99875faf356b34d2b97a0668ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child node from parent.  <a href="#aabe9f99875faf356b34d2b97a0668ffb">More...</a><br /></td></tr>
<tr class="separator:aabe9f99875faf356b34d2b97a0668ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae812ae18fd78d7f8feb387e8f0fc03c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aae812ae18fd78d7f8feb387e8f0fc03c">CPLAddXMLSibling</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psOlderSibling, <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psNewSibling)</td></tr>
<tr class="memdesc:aae812ae18fd78d7f8feb387e8f0fc03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new sibling.  <a href="#aae812ae18fd78d7f8feb387e8f0fc03c">More...</a><br /></td></tr>
<tr class="separator:aae812ae18fd78d7f8feb387e8f0fc03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd42dc2352a406a884d77591253e775e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#afd42dc2352a406a884d77591253e775e">CPLCreateXMLElementAndValue</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psParent, const char *pszName, const char *pszValue)</td></tr>
<tr class="memdesc:afd42dc2352a406a884d77591253e775e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an element and text value.  <a href="#afd42dc2352a406a884d77591253e775e">More...</a><br /></td></tr>
<tr class="separator:afd42dc2352a406a884d77591253e775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1192aadcc5f8ad6c7784e7468bada626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a1192aadcc5f8ad6c7784e7468bada626">CPLAddXMLAttributeAndValue</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psParent, const char *pszName, const char *pszValue)</td></tr>
<tr class="memdesc:a1192aadcc5f8ad6c7784e7468bada626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an attribute and text value.  <a href="#a1192aadcc5f8ad6c7784e7468bada626">More...</a><br /></td></tr>
<tr class="separator:a1192aadcc5f8ad6c7784e7468bada626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57871939966b74570294e0cd6a4011f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#ab57871939966b74570294e0cd6a4011f">CPLCloneXMLTree</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psTree)</td></tr>
<tr class="memdesc:ab57871939966b74570294e0cd6a4011f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy tree.  <a href="#ab57871939966b74570294e0cd6a4011f">More...</a><br /></td></tr>
<tr class="separator:ab57871939966b74570294e0cd6a4011f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abd72304d9ba159c965f5095c97b074"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a7abd72304d9ba159c965f5095c97b074">CPLSetXMLValue</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psRoot, const char *pszPath, const char *pszValue)</td></tr>
<tr class="memdesc:a7abd72304d9ba159c965f5095c97b074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element value by path.  <a href="#a7abd72304d9ba159c965f5095c97b074">More...</a><br /></td></tr>
<tr class="separator:a7abd72304d9ba159c965f5095c97b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c03d9f9d692128d6fa906c17c44bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a47c03d9f9d692128d6fa906c17c44bfc">CPLStripXMLNamespace</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psRoot, const char *pszNameSpace, int bRecurse)</td></tr>
<tr class="memdesc:a47c03d9f9d692128d6fa906c17c44bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip indicated namespaces.  <a href="#a47c03d9f9d692128d6fa906c17c44bfc">More...</a><br /></td></tr>
<tr class="separator:a47c03d9f9d692128d6fa906c17c44bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50df16661471484493d009bb57a18b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a50df16661471484493d009bb57a18b88">CPLCleanXMLElementName</a> (char *)</td></tr>
<tr class="memdesc:a50df16661471484493d009bb57a18b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make string into safe XML token.  <a href="#a50df16661471484493d009bb57a18b88">More...</a><br /></td></tr>
<tr class="separator:a50df16661471484493d009bb57a18b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe69e0041052c5bf04f5ba90ad77234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aebe69e0041052c5bf04f5ba90ad77234">CPLParseXMLFile</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:aebe69e0041052c5bf04f5ba90ad77234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse XML file into tree.  <a href="#aebe69e0041052c5bf04f5ba90ad77234">More...</a><br /></td></tr>
<tr class="separator:aebe69e0041052c5bf04f5ba90ad77234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44f5b9702a469037e7df18dda8d982c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#af44f5b9702a469037e7df18dda8d982c">CPLSerializeXMLTreeToFile</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psTree, const char *pszFilename)</td></tr>
<tr class="memdesc:af44f5b9702a469037e7df18dda8d982c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write document tree to a file.  <a href="#af44f5b9702a469037e7df18dda8d982c">More...</a><br /></td></tr>
<tr class="separator:af44f5b9702a469037e7df18dda8d982c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definitions for CPL mini XML Parser/Serializer. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae2767267ad31c092d81a2380ee3474a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2767267ad31c092d81a2380ee3474a1">&#9670;&nbsp;</a></span>CPLXMLNodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML node type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e"></a>CXT_Element&#160;</td><td class="fielddoc"><p>Node is an element </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1"></a>CXT_Text&#160;</td><td class="fielddoc"><p>Node is a raw text value </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2767267ad31c092d81a2380ee3474a1ad4a32b8961ea4b6caa7a471fd5c1412d"></a>CXT_Attribute&#160;</td><td class="fielddoc"><p>Node is attribute </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2767267ad31c092d81a2380ee3474a1ab3bea14871a8fa6136365aaef2d6ff15"></a>CXT_Comment&#160;</td><td class="fielddoc"><p>Node is an XML comment. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2767267ad31c092d81a2380ee3474a1a0e4a04d69bb7e75b6955a282475867f4"></a>CXT_Literal&#160;</td><td class="fielddoc"><p>Node is a special literal </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1192aadcc5f8ad6c7784e7468bada626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1192aadcc5f8ad6c7784e7468bada626">&#9670;&nbsp;</a></span>CPLAddXMLAttributeAndValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLAddXMLAttributeAndValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an attribute and text value. </p>
<p>This is function is a convenient short form for:</p>
<div class="fragment"><div class="line"><a class="code" href="structCPLXMLNode.html">CPLXMLNode</a> *psAttributeNode;</div><div class="line"></div><div class="line">psAttributeNode = <a class="code" href="cpl__minixml_8h.html#a8779ff560dde3b2cd076a16059e66771">CPLCreateXMLNode</a>( psParent, <a class="code" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad4a32b8961ea4b6caa7a471fd5c1412d">CXT_Attribute</a>, pszName );</div><div class="line"><a class="code" href="cpl__minixml_8h.html#a8779ff560dde3b2cd076a16059e66771">CPLCreateXMLNode</a>( psAttributeNode, <a class="code" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1">CXT_Text</a>, pszValue );</div></div><!-- fragment --><p>It creates a CXT_Attribute node, with a CXT_Text child, and attaches the element to the passed parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psParent</td><td>the parent node to which the resulting node should be attached. Must not be NULL. </td></tr>
    <tr><td class="paramname">pszName</td><td>the attribute name to create. </td></tr>
    <tr><td class="paramname">pszValue</td><td>the text to attach to the attribute. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="acf4fd469090f44089221811f1c550742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4fd469090f44089221811f1c550742">&#9670;&nbsp;</a></span>CPLAddXMLChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLAddXMLChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add child node to parent. </p>
<p>The passed child is added to the list of children of the indicated parent. Normally the child is added at the end of the parents child list, but attributes (CXT_Attribute) will be inserted after any other attributes but before any other element type. Ownership of the child node is effectively assumed by the parent node. If the child has siblings (its psNext is not NULL) they will be trimmed, but if the child has children they are carried with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psParent</td><td>the node to attach the child to. May not be NULL.</td></tr>
    <tr><td class="paramname">psChild</td><td>the child to add to the parent. May not be NULL. Should not be a child of any other parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae812ae18fd78d7f8feb387e8f0fc03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae812ae18fd78d7f8feb387e8f0fc03c">&#9670;&nbsp;</a></span>CPLAddXMLSibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLAddXMLSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psOlderSibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psNewSibling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add new sibling. </p>
<p>The passed psNewSibling is added to the end of siblings of the psOlderSibling node. That is, it is added to the end of the psNext chain. There is no special handling if psNewSibling is an attribute. If this is required, use <a class="el" href="cpl__minixml_8h.html#acf4fd469090f44089221811f1c550742" title="Add child node to parent. ">CPLAddXMLChild()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psOlderSibling</td><td>the node to attach the sibling after.</td></tr>
    <tr><td class="paramname">psNewSibling</td><td>the node to add at the end of psOlderSiblings psNext chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50df16661471484493d009bb57a18b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50df16661471484493d009bb57a18b88">&#9670;&nbsp;</a></span>CPLCleanXMLElementName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLCleanXMLElementName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make string into safe XML token. </p>
<p>Modifies a string in place to try and make it into a legal XML token that can be used as an element name. This is accomplished by changing any characters not legal in a token into an underscore.</p>
<p>NOTE: This function should implement the rules in section 2.3 of <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a> but it doesn't yet do that properly. We only do a rough approximation of that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTarget</td><td>the string to be adjusted. It is altered in place. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab57871939966b74570294e0cd6a4011f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57871939966b74570294e0cd6a4011f">&#9670;&nbsp;</a></span>CPLCloneXMLTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLCloneXMLTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy tree. </p>
<p>Creates a deep copy of a <a class="el" href="structCPLXMLNode.html" title="Document node structure. ">CPLXMLNode</a> tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psTree</td><td>the tree to duplicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the whole tree. </dd></dl>

</div>
</div>
<a id="afd42dc2352a406a884d77591253e775e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd42dc2352a406a884d77591253e775e">&#9670;&nbsp;</a></span>CPLCreateXMLElementAndValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLCreateXMLElementAndValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an element and text value. </p>
<p>This is function is a convenient short form for:</p>
<div class="fragment"><div class="line"><a class="code" href="structCPLXMLNode.html">CPLXMLNode</a> *psTextNode;</div><div class="line"><a class="code" href="structCPLXMLNode.html">CPLXMLNode</a> *psElementNode;</div><div class="line"></div><div class="line">psElementNode = <a class="code" href="cpl__minixml_8h.html#a8779ff560dde3b2cd076a16059e66771">CPLCreateXMLNode</a>( psParent, <a class="code" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e">CXT_Element</a>, pszName );</div><div class="line">psTextNode = <a class="code" href="cpl__minixml_8h.html#a8779ff560dde3b2cd076a16059e66771">CPLCreateXMLNode</a>( psElementNode, <a class="code" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1">CXT_Text</a>, pszValue );</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> psElementNode;</div></div><!-- fragment --><p>It creates a CXT_Element node, with a CXT_Text child, and attaches the element to the passed parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psParent</td><td>the parent node to which the resulting node should be attached. May be NULL to keep as freestanding.</td></tr>
    <tr><td class="paramname">pszName</td><td>the element name to create. </td></tr>
    <tr><td class="paramname">pszValue</td><td>the text to attach to the element. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the new element node. </dd></dl>

</div>
</div>
<a id="a8779ff560dde3b2cd076a16059e66771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8779ff560dde3b2cd076a16059e66771">&#9670;&nbsp;</a></span>CPLCreateXMLNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLCreateXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>poParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a>&#160;</td>
          <td class="paramname"><em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an document tree item. </p>
<p>Create a single <a class="el" href="structCPLXMLNode.html" title="Document node structure. ">CPLXMLNode</a> object with the desired value and type, and attach it as a child of the indicated parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poParent</td><td>the parent to which this node should be attached as a child. May be NULL to keep as free standing. </td></tr>
    <tr><td class="paramname">eType</td><td>the type of the newly created node </td></tr>
    <tr><td class="paramname">pszText</td><td>the value of the newly created node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created node, now owned by the caller (or parent node). </dd></dl>

</div>
</div>
<a id="a9e05eabc54728fb3266576404200da40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e05eabc54728fb3266576404200da40">&#9670;&nbsp;</a></span>CPLDestroyXMLNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLDestroyXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a tree. </p>
<p>This function frees resources associated with a <a class="el" href="structCPLXMLNode.html" title="Document node structure. ">CPLXMLNode</a> and all its children nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psNode</td><td>the tree to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb137728b61e42765ea7e5188a24f90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb137728b61e42765ea7e5188a24f90e">&#9670;&nbsp;</a></span>CPLGetXMLNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLGetXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find node by path. </p>
<p>Searches the document or subdocument indicated by psRoot for an element (or attribute) with the given path. The path should consist of a set of element names separated by dots, not including the name of the root element (psRoot). If the requested element is not found NULL is returned.</p>
<p>Attribute names may only appear as the last item in the path.</p>
<p>The search is done from the root nodes children, but all intermediate nodes in the path must be specified. Searching for "name" would only find a name element or attribute if it is a direct child of the root, not at any level in the subdocument.</p>
<p>If the pszPath is prefixed by "=" then the search will begin with the root node, and its siblings, instead of the root nodes children. This is particularly useful when searching within a whole document which is often prefixed by one or more "junk" nodes like the &lt;?xml&gt; declaration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psRoot</td><td>the subtree in which to search. This should be a node of type CXT_Element. NULL is safe.</td></tr>
    <tr><td class="paramname">pszPath</td><td>the list of element names in the path (dot separated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested element node, or NULL if not found. </dd></dl>

</div>
</div>
<a id="ab837bc73eaa55ae1363ae30a5f2a2019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab837bc73eaa55ae1363ae30a5f2a2019">&#9670;&nbsp;</a></span>CPLGetXMLValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetXMLValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch element/attribute value. </p>
<p>Searches the document for the element/attribute value associated with the path. The corresponding node is internally found with <a class="el" href="cpl__minixml_8h.html#acb137728b61e42765ea7e5188a24f90e" title="Find node by path. ">CPLGetXMLNode()</a> (see there for details on path handling). Once found, the value is considered to be the first CXT_Text child of the node.</p>
<p>If the attribute/element search fails, or if the found node has no value then the passed default value is returned.</p>
<p>The returned value points to memory within the document tree, and should not be altered or freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psRoot</td><td>the subtree in which to search. This should be a node of type CXT_Element. NULL is safe.</td></tr>
    <tr><td class="paramname">pszPath</td><td>the list of element names in the path (dot separated). An empty path means get the value of the psRoot node.</td></tr>
    <tr><td class="paramname">pszDefault</td><td>the value to return if a corresponding value is not found, may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested value or pszDefault if not found. </dd></dl>

</div>
</div>
<a id="aebe69e0041052c5bf04f5ba90ad77234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe69e0041052c5bf04f5ba90ad77234">&#9670;&nbsp;</a></span>CPLParseXMLFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLParseXMLFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse XML file into tree. </p>
<p>The named file is opened, loaded into memory as a big string, and parsed with <a class="el" href="cpl__minixml_8h.html#ad2770716fe2b8dac4969df728e274c9b" title="Parse an XML string into tree form. ">CPLParseXMLString()</a>. Errors in reading the file or parsing the XML will be reported by <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a>.</p>
<p>The "large file" API is used, so XML files can come from virtualized files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the file to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, or the document tree on success. </dd></dl>

</div>
</div>
<a id="ad2770716fe2b8dac4969df728e274c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2770716fe2b8dac4969df728e274c9b">&#9670;&nbsp;</a></span>CPLParseXMLString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLParseXMLString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an XML string into tree form. </p>
<p>The passed document is parsed into a <a class="el" href="structCPLXMLNode.html" title="Document node structure. ">CPLXMLNode</a> tree representation. If the document is not well formed XML then NULL is returned, and errors are reported via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a>. No validation beyond wellformedness is done. The <a class="el" href="cpl__minixml_8h.html#aebe69e0041052c5bf04f5ba90ad77234" title="Parse XML file into tree. ">CPLParseXMLFile()</a> convenience function can be used to parse from a file.</p>
<p>The returned document tree is owned by the caller and should be freed with <a class="el" href="cpl__minixml_8h.html#a9e05eabc54728fb3266576404200da40" title="Destroy a tree. ">CPLDestroyXMLNode()</a> when no longer needed.</p>
<p>If the document has more than one "root level" element then those after the first will be attached to the first as siblings (via the psNext pointers) even though there is no common parent. A document with no XML structure (no angle brackets for instance) would be considered well formed, and returned as a single CXT_Text node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszString</td><td>the document to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed tree or NULL on error. </dd></dl>

</div>
</div>
<a id="aabe9f99875faf356b34d2b97a0668ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe9f99875faf356b34d2b97a0668ffb">&#9670;&nbsp;</a></span>CPLRemoveXMLChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLRemoveXMLChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove child node from parent. </p>
<p>The passed child is removed from the child list of the passed parent, but the child is not destroyed. The child retains ownership of its own children, but is cleanly removed from the child list of the parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psParent</td><td>the node to the child is attached to.</td></tr>
    <tr><td class="paramname">psChild</td><td>the child to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE if the child was not found. </dd></dl>

</div>
</div>
<a id="aa1d07b7ebe279176dafa455a70043680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d07b7ebe279176dafa455a70043680">&#9670;&nbsp;</a></span>CPLSearchXMLNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLSearchXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a node in document. </p>
<p>Searches the children (and potentially siblings) of the documented passed in for the named element or attribute. To search following siblings as well as children, prefix the pszElement name with an equal sign. This function does an in-order traversal of the document tree. So it will first match against the current node, then its first child, that child's first child, and so on.</p>
<p>Use <a class="el" href="cpl__minixml_8h.html#acb137728b61e42765ea7e5188a24f90e" title="Find node by path. ">CPLGetXMLNode()</a> to find a specific child, or along a specific node path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psRoot</td><td>the subtree to search. This should be a node of type CXT_Element. NULL is safe.</td></tr>
    <tr><td class="paramname">pszElement</td><td>the name of the element or attribute to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matching node or NULL on failure. </dd></dl>

</div>
</div>
<a id="a17562c5f454d236e6749c73f4c93de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17562c5f454d236e6749c73f4c93de6e">&#9670;&nbsp;</a></span>CPLSerializeXMLTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLSerializeXMLTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert tree into string document. </p>
<p>This function converts a <a class="el" href="structCPLXMLNode.html" title="Document node structure. ">CPLXMLNode</a> tree representation of a document into a flat string representation. White space indentation is used visually preserve the tree structure of the document. The returned document becomes owned by the caller and should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psNode</td><td>the node to serialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the document on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="af44f5b9702a469037e7df18dda8d982c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44f5b9702a469037e7df18dda8d982c">&#9670;&nbsp;</a></span>CPLSerializeXMLTreeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLSerializeXMLTreeToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write document tree to a file. </p>
<p>The passed document tree is converted into one big string (with <a class="el" href="cpl__minixml_8h.html#a17562c5f454d236e6749c73f4c93de6e" title="Convert tree into string document. ">CPLSerializeXMLTree()</a>) and then written to the named file. Errors writing the file will be reported by <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a>. The source document tree is not altered. If the output file already exists it will be overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psTree</td><td>the document tree to write. </td></tr>
    <tr><td class="paramname">pszFilename</td><td>the name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a7abd72304d9ba159c965f5095c97b074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abd72304d9ba159c965f5095c97b074">&#9670;&nbsp;</a></span>CPLSetXMLValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLSetXMLValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set element value by path. </p>
<p>Find (or create) the target element or attribute specified in the path, and assign it the indicated value.</p>
<p>Any path elements that do not already exist will be created. The target nodes value (the first CXT_Text child) will be replaced with the provided value.</p>
<p>If the target node is an attribute instead of an element, the name should be prefixed with a #.</p>
<p>Example: CPLSetXMLValue( "Citation.Id.Description", "DOQ dataset" ); CPLSetXMLValue( "Citation.Id.Description.#name", "doq" );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psRoot</td><td>the subdocument to be updated.</td></tr>
    <tr><td class="paramname">pszPath</td><td>the dot separated path to the target element/attribute.</td></tr>
    <tr><td class="paramname">pszValue</td><td>the text value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a id="a47c03d9f9d692128d6fa906c17c44bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c03d9f9d692128d6fa906c17c44bfc">&#9670;&nbsp;</a></span>CPLStripXMLNamespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLStripXMLNamespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td>
          <td class="paramname"><em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNamespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bRecurse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip indicated namespaces. </p>
<p>The subdocument (psRoot) is recursively examined, and any elements with the indicated namespace prefix will have the namespace prefix stripped from the element names. If the passed namespace is NULL, then all namespace prefixes will be stripped.</p>
<p>Nodes other than elements should remain unaffected. The changes are made "in place", and should not alter any node locations, only the pszValue field of affected nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psRoot</td><td>the document to operate on. </td></tr>
    <tr><td class="paramname">pszNamespace</td><td>the name space prefix (not including colon), or NULL. </td></tr>
    <tr><td class="paramname">bRecurse</td><td>TRUE to recurse over whole document, or FALSE to only operate on the passed node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
