<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: ogr_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_95e959066acc6fd9509e74b3cd6c200f.html">ogr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ogr_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C API and defines for <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a>, <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes. ">OGRGeometry</a>, and <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a> related classes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;cpl_progress.h&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__minixml_8h_source.html">cpl_minixml.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ogr__core_8h_source.html">ogr_core.h</a>&quot;</code><br />
</div>
<p><a href="ogr__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a261ecc4eb3468bae5f5deaed761f4221"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a261ecc4eb3468bae5f5deaed761f4221">OGR_FOR_EACH_FEATURE_BEGIN</a>(hFeat,  hLayer)</td></tr>
<tr class="memdesc:a261ecc4eb3468bae5f5deaed761f4221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency macro to iterate over features of a layer.  <a href="#a261ecc4eb3468bae5f5deaed761f4221">More...</a><br /></td></tr>
<tr class="separator:a261ecc4eb3468bae5f5deaed761f4221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1c16c3af1f08084b3c261411beaf99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7c1c16c3af1f08084b3c261411beaf99">OGR_FOR_EACH_FEATURE_END</a>(hFeat)</td></tr>
<tr class="memdesc:a7c1c16c3af1f08084b3c261411beaf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of iterator.  <a href="#a7c1c16c3af1f08084b3c261411beaf99">More...</a><br /></td></tr>
<tr class="separator:a7c1c16c3af1f08084b3c261411beaf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a147386126eed05cc383cb3eb1b34104c"><td class="memItemLeft" align="right" valign="top"><a id="a147386126eed05cc383cb3eb1b34104c"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a></td></tr>
<tr class="memdesc:a147386126eed05cc383cb3eb1b34104c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a geometry. <br /></td></tr>
<tr class="separator:a147386126eed05cc383cb3eb1b34104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23361112dba57d043fa64632348c0870"><td class="memItemLeft" align="right" valign="top"><a id="a23361112dba57d043fa64632348c0870"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a></td></tr>
<tr class="memdesc:a23361112dba57d043fa64632348c0870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a spatial reference system. <br /></td></tr>
<tr class="separator:a23361112dba57d043fa64632348c0870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069f206f0e8e54328d648c14658cbf81"><td class="memItemLeft" align="right" valign="top"><a id="a069f206f0e8e54328d648c14658cbf81"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a></td></tr>
<tr class="memdesc:a069f206f0e8e54328d648c14658cbf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a coordinate transformation object. <br /></td></tr>
<tr class="separator:a069f206f0e8e54328d648c14658cbf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd327453a3ded09dad8dcfa88170dbb"><td class="memItemLeft" align="right" valign="top">typedef struct OGRGeomTransformer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a></td></tr>
<tr class="memdesc:abfd327453a3ded09dad8dcfa88170dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a geometry transformer.  <a href="#abfd327453a3ded09dad8dcfa88170dbb">More...</a><br /></td></tr>
<tr class="separator:abfd327453a3ded09dad8dcfa88170dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624dc73953f25ea4efd8686d5121249b"><td class="memItemLeft" align="right" valign="top"><a id="a624dc73953f25ea4efd8686d5121249b"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a></td></tr>
<tr class="memdesc:a624dc73953f25ea4efd8686d5121249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a field definition (<a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn. ">OGRFieldDefn</a>) <br /></td></tr>
<tr class="separator:a624dc73953f25ea4efd8686d5121249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827cc74dba4613e928843c4b5f781618"><td class="memItemLeft" align="right" valign="top"><a id="a827cc74dba4613e928843c4b5f781618"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a></td></tr>
<tr class="memdesc:a827cc74dba4613e928843c4b5f781618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a feature definition (<a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>) <br /></td></tr>
<tr class="separator:a827cc74dba4613e928843c4b5f781618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ebb4d695364da5635718ec664b95bf"><td class="memItemLeft" align="right" valign="top"><a id="aa4ebb4d695364da5635718ec664b95bf"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a></td></tr>
<tr class="memdesc:aa4ebb4d695364da5635718ec664b95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a feature (<a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a>) <br /></td></tr>
<tr class="separator:aa4ebb4d695364da5635718ec664b95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9fad6abd55f6760170e0e47a7455d8"><td class="memItemLeft" align="right" valign="top"><a id="ade9fad6abd55f6760170e0e47a7455d8"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a></td></tr>
<tr class="memdesc:ade9fad6abd55f6760170e0e47a7455d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a style table (<a class="el" href="classOGRStyleTable.html" title="This class represents a style table. ">OGRStyleTable</a>) <br /></td></tr>
<tr class="separator:ade9fad6abd55f6760170e0e47a7455d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02dff2945904f6c0664e17a80c5f6bf"><td class="memItemLeft" align="right" valign="top"><a id="ab02dff2945904f6c0664e17a80c5f6bf"></a>
typedef struct OGRGeomFieldDefnHS *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a></td></tr>
<tr class="memdesc:ab02dff2945904f6c0664e17a80c5f6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a geometry field definition (<a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn. ">OGRGeomFieldDefn</a>) <br /></td></tr>
<tr class="separator:ab02dff2945904f6c0664e17a80c5f6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635095fa23dfea934f4bb2df38fb9a67"><td class="memItemLeft" align="right" valign="top"><a id="a635095fa23dfea934f4bb2df38fb9a67"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a></td></tr>
<tr class="memdesc:a635095fa23dfea934f4bb2df38fb9a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a layer (<a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a>) <br /></td></tr>
<tr class="separator:a635095fa23dfea934f4bb2df38fb9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37d6a007fbf6453a11062443c9cc2a4"><td class="memItemLeft" align="right" valign="top"><a id="ae37d6a007fbf6453a11062443c9cc2a4"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a></td></tr>
<tr class="memdesc:ae37d6a007fbf6453a11062443c9cc2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a OGR datasource (<a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a>) <br /></td></tr>
<tr class="separator:ae37d6a007fbf6453a11062443c9cc2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb21d6f230ef8a5d2c1e65bf98473eca"><td class="memItemLeft" align="right" valign="top"><a id="acb21d6f230ef8a5d2c1e65bf98473eca"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a></td></tr>
<tr class="memdesc:acb21d6f230ef8a5d2c1e65bf98473eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a OGR driver (<a class="el" href="classOGRSFDriver.html" title="LEGACY class. ">OGRSFDriver</a>) <br /></td></tr>
<tr class="separator:acb21d6f230ef8a5d2c1e65bf98473eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e20dd0f2767e72fdf1cd84bfa58edd"><td class="memItemLeft" align="right" valign="top"><a id="a52e20dd0f2767e72fdf1cd84bfa58edd"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a></td></tr>
<tr class="memdesc:a52e20dd0f2767e72fdf1cd84bfa58edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style manager opaque type. <br /></td></tr>
<tr class="separator:a52e20dd0f2767e72fdf1cd84bfa58edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f1ce388fcfa9dfcedf873eb417e1c5"><td class="memItemLeft" align="right" valign="top"><a id="a92f1ce388fcfa9dfcedf873eb417e1c5"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a></td></tr>
<tr class="memdesc:a92f1ce388fcfa9dfcedf873eb417e1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style tool opaque type. <br /></td></tr>
<tr class="separator:a92f1ce388fcfa9dfcedf873eb417e1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65af51cbb3d62789dee6f96044f4dcb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a65af51cbb3d62789dee6f96044f4dcb6">OGR_G_CreateFromWkb</a> (const void *, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *, int)</td></tr>
<tr class="memdesc:a65af51cbb3d62789dee6f96044f4dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known binary representation.  <a href="#a65af51cbb3d62789dee6f96044f4dcb6">More...</a><br /></td></tr>
<tr class="separator:a65af51cbb3d62789dee6f96044f4dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02c3ed5f7ebd5039dc2ae70154fd94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">OGR_G_CreateFromWkt</a> (char **, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *)</td></tr>
<tr class="memdesc:ac02c3ed5f7ebd5039dc2ae70154fd94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known text representation.  <a href="#ac02c3ed5f7ebd5039dc2ae70154fd94a">More...</a><br /></td></tr>
<tr class="separator:ac02c3ed5f7ebd5039dc2ae70154fd94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab486f7ab98a4b592d25e4b8a0ac698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3ab486f7ab98a4b592d25e4b8a0ac698">OGR_G_CreateFromFgf</a> (const void *, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *, int, int *)</td></tr>
<tr class="memdesc:a3ab486f7ab98a4b592d25e4b8a0ac698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representation.  <a href="#a3ab486f7ab98a4b592d25e4b8a0ac698">More...</a><br /></td></tr>
<tr class="separator:a3ab486f7ab98a4b592d25e4b8a0ac698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e665f5f9690c4fa0c190b930fe9492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492">OGR_G_DestroyGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ac4e665f5f9690c4fa0c190b930fe9492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy geometry object.  <a href="#ac4e665f5f9690c4fa0c190b930fe9492">More...</a><br /></td></tr>
<tr class="separator:ac4e665f5f9690c4fa0c190b930fe9492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60311342f2a329f433ea66e2d6fedadc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a60311342f2a329f433ea66e2d6fedadc">OGR_G_CreateGeometry</a> (<a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a60311342f2a329f433ea66e2d6fedadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty geometry of desired type.  <a href="#a60311342f2a329f433ea66e2d6fedadc">More...</a><br /></td></tr>
<tr class="separator:a60311342f2a329f433ea66e2d6fedadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f8bce40c82b3513e36109ea051dff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a87f8bce40c82b3513e36109ea051dff2">OGR_G_ApproximateArcAngles</a> (double dfCenterX, double dfCenterY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a87f8bce40c82b3513e36109ea051dff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke arc to linestring.  <a href="#a87f8bce40c82b3513e36109ea051dff2">More...</a><br /></td></tr>
<tr class="separator:a87f8bce40c82b3513e36109ea051dff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc3d5b213a7891355329d205aaa0d2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0fc3d5b213a7891355329d205aaa0d2c">OGR_G_ForceToPolygon</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a0fc3d5b213a7891355329d205aaa0d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to polygon.  <a href="#a0fc3d5b213a7891355329d205aaa0d2c">More...</a><br /></td></tr>
<tr class="separator:a0fc3d5b213a7891355329d205aaa0d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cee9b0081977f61681a909231608146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5cee9b0081977f61681a909231608146">OGR_G_ForceToLineString</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a5cee9b0081977f61681a909231608146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to line string.  <a href="#a5cee9b0081977f61681a909231608146">More...</a><br /></td></tr>
<tr class="separator:a5cee9b0081977f61681a909231608146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0c5be9aa982ba776f4cfdab4d8b798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4c0c5be9aa982ba776f4cfdab4d8b798">OGR_G_ForceToMultiPolygon</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a4c0c5be9aa982ba776f4cfdab4d8b798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multipolygon.  <a href="#a4c0c5be9aa982ba776f4cfdab4d8b798">More...</a><br /></td></tr>
<tr class="separator:a4c0c5be9aa982ba776f4cfdab4d8b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb60e8b68ba76843577df5ebab22ab95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abb60e8b68ba76843577df5ebab22ab95">OGR_G_ForceToMultiPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:abb60e8b68ba76843577df5ebab22ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multipoint.  <a href="#abb60e8b68ba76843577df5ebab22ab95">More...</a><br /></td></tr>
<tr class="separator:abb60e8b68ba76843577df5ebab22ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0776505ab4794d50e425b5333415cf9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0776505ab4794d50e425b5333415cf9b">OGR_G_ForceToMultiLineString</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a0776505ab4794d50e425b5333415cf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multilinestring.  <a href="#a0776505ab4794d50e425b5333415cf9b">More...</a><br /></td></tr>
<tr class="separator:a0776505ab4794d50e425b5333415cf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a37c25a9b628982e86b1821446e3a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3a37c25a9b628982e86b1821446e3a0e">OGR_G_ForceTo</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> eTargetType, char **papszOptions) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a3a37c25a9b628982e86b1821446e3a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to another geometry type.  <a href="#a3a37c25a9b628982e86b1821446e3a0e">More...</a><br /></td></tr>
<tr class="separator:a3a37c25a9b628982e86b1821446e3a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af244bd6a0608d0b817efb7747c9a1ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af244bd6a0608d0b817efb7747c9a1ef6">OGR_G_RemoveLowerDimensionSubGeoms</a> (const <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:af244bd6a0608d0b817efb7747c9a1ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove sub-geometries from a geometry collection that do not have the maximum topological dimensionality of the collection.  <a href="#af244bd6a0608d0b817efb7747c9a1ef6">More...</a><br /></td></tr>
<tr class="separator:af244bd6a0608d0b817efb7747c9a1ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b633e1acd208c258ad49f8d4fd4104"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104">OGR_G_GetDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a94b633e1acd208c258ad49f8d4fd4104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of this geometry.  <a href="#a94b633e1acd208c258ad49f8d4fd4104">More...</a><br /></td></tr>
<tr class="separator:a94b633e1acd208c258ad49f8d4fd4104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e78b0753339d1cdd282b0e151d28f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f">OGR_G_GetCoordinateDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a8a5e78b0753339d1cdd282b0e151d28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this geometry.  <a href="#a8a5e78b0753339d1cdd282b0e151d28f">More...</a><br /></td></tr>
<tr class="separator:a8a5e78b0753339d1cdd282b0e151d28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4843a200c0c4e57bbdc99e509f68baf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf">OGR_G_CoordinateDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ac4843a200c0c4e57bbdc99e509f68baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this geometry.  <a href="#ac4843a200c0c4e57bbdc99e509f68baf">More...</a><br /></td></tr>
<tr class="separator:ac4843a200c0c4e57bbdc99e509f68baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bcad9553f488f7d8b6c8674cf7771c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac6bcad9553f488f7d8b6c8674cf7771c">OGR_G_SetCoordinateDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:ac6bcad9553f488f7d8b6c8674cf7771c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate dimension.  <a href="#ac6bcad9553f488f7d8b6c8674cf7771c">More...</a><br /></td></tr>
<tr class="separator:ac6bcad9553f488f7d8b6c8674cf7771c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d4c2fb8935e9ee9584f0243e4bd0ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af2d4c2fb8935e9ee9584f0243e4bd0ca">OGR_G_Is3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:af2d4c2fb8935e9ee9584f0243e4bd0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">See whether this geometry has Z coordinates.  <a href="#af2d4c2fb8935e9ee9584f0243e4bd0ca">More...</a><br /></td></tr>
<tr class="separator:af2d4c2fb8935e9ee9584f0243e4bd0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a8bf231d721ac04ed465d5208bac6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a84a8bf231d721ac04ed465d5208bac6e">OGR_G_IsMeasured</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a84a8bf231d721ac04ed465d5208bac6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See whether this geometry is measured.  <a href="#a84a8bf231d721ac04ed465d5208bac6e">More...</a><br /></td></tr>
<tr class="separator:a84a8bf231d721ac04ed465d5208bac6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c109c8afc2c614f206f8f610c7c4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a13c109c8afc2c614f206f8f610c7c4be">OGR_G_Set3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a13c109c8afc2c614f206f8f610c7c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the Z coordinate dimension.  <a href="#a13c109c8afc2c614f206f8f610c7c4be">More...</a><br /></td></tr>
<tr class="separator:a13c109c8afc2c614f206f8f610c7c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8840ed4e65bfbf50a6a52779305a78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8840ed4e65bfbf50a6a52779305a78f6">OGR_G_SetMeasured</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a8840ed4e65bfbf50a6a52779305a78f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the M coordinate dimension.  <a href="#a8840ed4e65bfbf50a6a52779305a78f6">More...</a><br /></td></tr>
<tr class="separator:a8840ed4e65bfbf50a6a52779305a78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1c08151c1873ebd4722cdf79a5ae2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aed1c08151c1873ebd4722cdf79a5ae2c">OGR_G_Clone</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aed1c08151c1873ebd4722cdf79a5ae2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of this object.  <a href="#aed1c08151c1873ebd4722cdf79a5ae2c">More...</a><br /></td></tr>
<tr class="separator:aed1c08151c1873ebd4722cdf79a5ae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617a9c9ea85157661619a1d8f0a69cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9">OGR_G_GetEnvelope</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *)</td></tr>
<tr class="memdesc:a617a9c9ea85157661619a1d8f0a69cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="#a617a9c9ea85157661619a1d8f0a69cf9">More...</a><br /></td></tr>
<tr class="separator:a617a9c9ea85157661619a1d8f0a69cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a950633ac824042b0afdb88c670c5ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce">OGR_G_GetEnvelope3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *)</td></tr>
<tr class="memdesc:a9a950633ac824042b0afdb88c670c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="#a9a950633ac824042b0afdb88c670c5ce">More...</a><br /></td></tr>
<tr class="separator:a9a950633ac824042b0afdb88c670c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae523fe14c8c87dffcee706438ec2e81f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f">OGR_G_ImportFromWkb</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, const void *, int)</td></tr>
<tr class="memdesc:ae523fe14c8c87dffcee706438ec2e81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="#ae523fe14c8c87dffcee706438ec2e81f">More...</a><br /></td></tr>
<tr class="separator:ae523fe14c8c87dffcee706438ec2e81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c94ae76c09774dba8725c24daeefd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6">OGR_G_ExportToWkb</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>, unsigned char *)</td></tr>
<tr class="memdesc:ad5c94ae76c09774dba8725c24daeefd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry well known binary format.  <a href="#ad5c94ae76c09774dba8725c24daeefd6">More...</a><br /></td></tr>
<tr class="separator:ad5c94ae76c09774dba8725c24daeefd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622a18776e6d51515d0f2ff0ee211d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91">OGR_G_ExportToIsoWkb</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>, unsigned char *)</td></tr>
<tr class="memdesc:a622a18776e6d51515d0f2ff0ee211d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format.  <a href="#a622a18776e6d51515d0f2ff0ee211d91">More...</a><br /></td></tr>
<tr class="separator:a622a18776e6d51515d0f2ff0ee211d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7035a933b957a9d453184c154c237c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c">OGR_G_WkbSize</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a5f7035a933b957a9d453184c154c237c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of related binary representation.  <a href="#a5f7035a933b957a9d453184c154c237c">More...</a><br /></td></tr>
<tr class="separator:a5f7035a933b957a9d453184c154c237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4286ba243fb05a831a49f52aabcbc6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8">OGR_G_ImportFromWkt</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **)</td></tr>
<tr class="memdesc:a4286ba243fb05a831a49f52aabcbc6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="#a4286ba243fb05a831a49f52aabcbc6f8">More...</a><br /></td></tr>
<tr class="separator:a4286ba243fb05a831a49f52aabcbc6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc9310302e2dbfaab1690de9e2fd2fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb">OGR_G_ExportToWkt</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **)</td></tr>
<tr class="memdesc:a3bc9310302e2dbfaab1690de9e2fd2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="#a3bc9310302e2dbfaab1690de9e2fd2fb">More...</a><br /></td></tr>
<tr class="separator:a3bc9310302e2dbfaab1690de9e2fd2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d988d220539479601e1a80a58864d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0d988d220539479601e1a80a58864d1e">OGR_G_ExportToIsoWkt</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **)</td></tr>
<tr class="memdesc:a0d988d220539479601e1a80a58864d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format.  <a href="#a0d988d220539479601e1a80a58864d1e">More...</a><br /></td></tr>
<tr class="separator:a0d988d220539479601e1a80a58864d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fae58102f5c4a4cf2526e5ca8369a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76">OGR_G_GetGeometryType</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a8fae58102f5c4a4cf2526e5ca8369a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry type.  <a href="#a8fae58102f5c4a4cf2526e5ca8369a76">More...</a><br /></td></tr>
<tr class="separator:a8fae58102f5c4a4cf2526e5ca8369a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18121f835b2fb724a0c1a87beb1a437a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a">OGR_G_GetGeometryName</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a18121f835b2fb724a0c1a87beb1a437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="#a18121f835b2fb724a0c1a87beb1a437a">More...</a><br /></td></tr>
<tr class="separator:a18121f835b2fb724a0c1a87beb1a437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a99330bd108940f8a33036c0f83119f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f">OGR_G_DumpReadable</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, FILE *, const char *)</td></tr>
<tr class="memdesc:a3a99330bd108940f8a33036c0f83119f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <a href="#a3a99330bd108940f8a33036c0f83119f">More...</a><br /></td></tr>
<tr class="separator:a3a99330bd108940f8a33036c0f83119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb7354b55c7448b60b44cd9e36073b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8">OGR_G_FlattenTo2D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:afdb7354b55c7448b60b44cd9e36073b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geometry to strictly 2D.  <a href="#afdb7354b55c7448b60b44cd9e36073b8">More...</a><br /></td></tr>
<tr class="separator:afdb7354b55c7448b60b44cd9e36073b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeb849dcfd4fdf4d6dab66e6ea697c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acfeb849dcfd4fdf4d6dab66e6ea697c0">OGR_G_CloseRings</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:acfeb849dcfd4fdf4d6dab66e6ea697c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force rings to be closed.  <a href="#acfeb849dcfd4fdf4d6dab66e6ea697c0">More...</a><br /></td></tr>
<tr class="separator:acfeb849dcfd4fdf4d6dab66e6ea697c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216201a5f821e553bd484d6953fa2ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a216201a5f821e553bd484d6953fa2ffb">OGR_G_CreateFromGML</a> (const char *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a216201a5f821e553bd484d6953fa2ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry from GML.  <a href="#a216201a5f821e553bd484d6953fa2ffb">More...</a><br /></td></tr>
<tr class="separator:a216201a5f821e553bd484d6953fa2ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cde7d88247415bf2d015b312ebb00d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac0cde7d88247415bf2d015b312ebb00d">OGR_G_ExportToGML</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ac0cde7d88247415bf2d015b312ebb00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="#ac0cde7d88247415bf2d015b312ebb00d">More...</a><br /></td></tr>
<tr class="separator:ac0cde7d88247415bf2d015b312ebb00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95226e12c2de1cdd2837c1ca15366fd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab95226e12c2de1cdd2837c1ca15366fd">OGR_G_ExportToGMLEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **papszOptions) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ab95226e12c2de1cdd2837c1ca15366fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="#ab95226e12c2de1cdd2837c1ca15366fd">More...</a><br /></td></tr>
<tr class="separator:ab95226e12c2de1cdd2837c1ca15366fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38986cd8e7e609cbce2fb0e7e5d75491"><td class="memItemLeft" align="right" valign="top"><a id="a38986cd8e7e609cbce2fb0e7e5d75491"></a>
<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a38986cd8e7e609cbce2fb0e7e5d75491">OGR_G_CreateFromGMLTree</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a38986cd8e7e609cbce2fb0e7e5d75491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry from GML. <br /></td></tr>
<tr class="separator:a38986cd8e7e609cbce2fb0e7e5d75491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556102dd03db654301035ad5ed1e14ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a556102dd03db654301035ad5ed1e14ac">OGR_G_ExportToGMLTree</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a556102dd03db654301035ad5ed1e14ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="#a556102dd03db654301035ad5ed1e14ac">More...</a><br /></td></tr>
<tr class="separator:a556102dd03db654301035ad5ed1e14ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad273f59c62bc1354fb5d1b3758622955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad273f59c62bc1354fb5d1b3758622955">OGR_G_ExportEnvelopeToGMLTree</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ad273f59c62bc1354fb5d1b3758622955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the envelope of a geometry as a gml:Box.  <a href="#ad273f59c62bc1354fb5d1b3758622955">More...</a><br /></td></tr>
<tr class="separator:ad273f59c62bc1354fb5d1b3758622955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2d35d3f6f10b4ca936a40a76d70d20"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5a2d35d3f6f10b4ca936a40a76d70d20">OGR_G_ExportToKML</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, const char *pszAltitudeMode) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a5a2d35d3f6f10b4ca936a40a76d70d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into KML format.  <a href="#a5a2d35d3f6f10b4ca936a40a76d70d20">More...</a><br /></td></tr>
<tr class="separator:a5a2d35d3f6f10b4ca936a40a76d70d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6d95725bd9fdb110b42d3c2749dd38"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aaf6d95725bd9fdb110b42d3c2749dd38">OGR_G_ExportToJson</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aaf6d95725bd9fdb110b42d3c2749dd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="#aaf6d95725bd9fdb110b42d3c2749dd38">More...</a><br /></td></tr>
<tr class="separator:aaf6d95725bd9fdb110b42d3c2749dd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e034548ba5f4c24d6fe72688e26f5ef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9e034548ba5f4c24d6fe72688e26f5ef">OGR_G_ExportToJsonEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **papszOptions) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a9e034548ba5f4c24d6fe72688e26f5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="#a9e034548ba5f4c24d6fe72688e26f5ef">More...</a><br /></td></tr>
<tr class="separator:a9e034548ba5f4c24d6fe72688e26f5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc681c6889a63a01baa301f1e3566c7c"><td class="memItemLeft" align="right" valign="top"><a id="adc681c6889a63a01baa301f1e3566c7c"></a>
<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adc681c6889a63a01baa301f1e3566c7c">OGR_G_CreateGeometryFromJson</a> (const char *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:adc681c6889a63a01baa301f1e3566c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a OGR geometry from a GeoJSON geometry object. <br /></td></tr>
<tr class="separator:adc681c6889a63a01baa301f1e3566c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d26550bbb5c23f6fff32b03a7c6bef"><td class="memItemLeft" align="right" valign="top"><a id="ae9d26550bbb5c23f6fff32b03a7c6bef"></a>
<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae9d26550bbb5c23f6fff32b03a7c6bef">OGR_G_CreateGeometryFromEsriJson</a> (const char *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ae9d26550bbb5c23f6fff32b03a7c6bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a OGR geometry from a ESRI JSON geometry object. <br /></td></tr>
<tr class="separator:ae9d26550bbb5c23f6fff32b03a7c6bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfbd5861e1cd20b372d090539fa4536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536">OGR_G_AssignSpatialReference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>)</td></tr>
<tr class="memdesc:a4dfbd5861e1cd20b372d090539fa4536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign spatial reference to this object.  <a href="#a4dfbd5861e1cd20b372d090539fa4536">More...</a><br /></td></tr>
<tr class="separator:a4dfbd5861e1cd20b372d090539fa4536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc393e40282eec3801fb4a4abc9e25bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf">OGR_G_GetSpatialReference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:abc393e40282eec3801fb4a4abc9e25bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spatial reference system for geometry.  <a href="#abc393e40282eec3801fb4a4abc9e25bf">More...</a><br /></td></tr>
<tr class="separator:abc393e40282eec3801fb4a4abc9e25bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a5b3f954b11cfbf6e78807c28d6090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090">OGR_G_Transform</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>)</td></tr>
<tr class="memdesc:a59a5b3f954b11cfbf6e78807c28d6090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="#a59a5b3f954b11cfbf6e78807c28d6090">More...</a><br /></td></tr>
<tr class="separator:a59a5b3f954b11cfbf6e78807c28d6090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43af4c2127cea0a5059692a62c0feb63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63">OGR_G_TransformTo</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>)</td></tr>
<tr class="memdesc:a43af4c2127cea0a5059692a62c0feb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform geometry to new spatial reference system.  <a href="#a43af4c2127cea0a5059692a62c0feb63">More...</a><br /></td></tr>
<tr class="separator:a43af4c2127cea0a5059692a62c0feb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc3ea8bd6aeffdbe26bbc519cc16882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adcc3ea8bd6aeffdbe26bbc519cc16882">OGR_GeomTransformer_Create</a> (<a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:adcc3ea8bd6aeffdbe26bbc519cc16882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry transformer.  <a href="#adcc3ea8bd6aeffdbe26bbc519cc16882">More...</a><br /></td></tr>
<tr class="separator:adcc3ea8bd6aeffdbe26bbc519cc16882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ac945d4635e074c7e09816ea13efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aed5ac945d4635e074c7e09816ea13efe">OGR_GeomTransformer_Transform</a> (<a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a> hTransformer, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aed5ac945d4635e074c7e09816ea13efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a geometry.  <a href="#aed5ac945d4635e074c7e09816ea13efe">More...</a><br /></td></tr>
<tr class="separator:aed5ac945d4635e074c7e09816ea13efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5729c801d758baee9dc23b95ac80f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae5729c801d758baee9dc23b95ac80f55">OGR_GeomTransformer_Destroy</a> (<a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a> hTransformer)</td></tr>
<tr class="memdesc:ae5729c801d758baee9dc23b95ac80f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a geometry transformer allocated with <a class="el" href="ogr__api_8h.html#adcc3ea8bd6aeffdbe26bbc519cc16882" title="Create a geometry transformer. ">OGR_GeomTransformer_Create()</a>  <a href="#ae5729c801d758baee9dc23b95ac80f55">More...</a><br /></td></tr>
<tr class="separator:ae5729c801d758baee9dc23b95ac80f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7727c1e3f1aea8740020a75d150b09c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae7727c1e3f1aea8740020a75d150b09c">OGR_G_Simplify</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hThis, double tolerance) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ae7727c1e3f1aea8740020a75d150b09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a simplified geometry.  <a href="#ae7727c1e3f1aea8740020a75d150b09c">More...</a><br /></td></tr>
<tr class="separator:ae7727c1e3f1aea8740020a75d150b09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2393494229046406871c38e58ffaf156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2393494229046406871c38e58ffaf156">OGR_G_SimplifyPreserveTopology</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hThis, double tolerance) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2393494229046406871c38e58ffaf156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry while preserving topology.  <a href="#a2393494229046406871c38e58ffaf156">More...</a><br /></td></tr>
<tr class="separator:a2393494229046406871c38e58ffaf156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fff3faa236d12e0374f5c65f61972ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8fff3faa236d12e0374f5c65f61972ae">OGR_G_DelaunayTriangulation</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hThis, double dfTolerance, int bOnlyEdges) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a8fff3faa236d12e0374f5c65f61972ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Delaunay triangulation of the vertices of the geometry.  <a href="#a8fff3faa236d12e0374f5c65f61972ae">More...</a><br /></td></tr>
<tr class="separator:a8fff3faa236d12e0374f5c65f61972ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9f08c8d63bc0e726cb20c201c86423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423">OGR_G_Segmentize</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, double dfMaxLength)</td></tr>
<tr class="memdesc:ade9f08c8d63bc0e726cb20c201c86423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="#ade9f08c8d63bc0e726cb20c201c86423">More...</a><br /></td></tr>
<tr class="separator:ade9f08c8d63bc0e726cb20c201c86423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaed6926b75cd33a42b284c10def6e87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87">OGR_G_Intersects</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:acaed6926b75cd33a42b284c10def6e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do these features intersect?  <a href="#acaed6926b75cd33a42b284c10def6e87">More...</a><br /></td></tr>
<tr class="separator:acaed6926b75cd33a42b284c10def6e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaed0c4fb6f08abc280f91619e2e47d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3">OGR_G_Equals</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:abaed0c4fb6f08abc280f91619e2e47d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="#abaed0c4fb6f08abc280f91619e2e47d3">More...</a><br /></td></tr>
<tr class="separator:abaed0c4fb6f08abc280f91619e2e47d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980d65f3d82d5a5442c5141efe3f503"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503">OGR_G_Disjoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7980d65f3d82d5a5442c5141efe3f503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for disjointness.  <a href="#a7980d65f3d82d5a5442c5141efe3f503">More...</a><br /></td></tr>
<tr class="separator:a7980d65f3d82d5a5442c5141efe3f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67616eb88f479eba50f9783c8494d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9">OGR_G_Touches</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a6f67616eb88f479eba50f9783c8494d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for touching.  <a href="#a6f67616eb88f479eba50f9783c8494d9">More...</a><br /></td></tr>
<tr class="separator:a6f67616eb88f479eba50f9783c8494d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af82e14406879c08841331b2a4cfe7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c">OGR_G_Crosses</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7af82e14406879c08841331b2a4cfe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for crossing.  <a href="#a7af82e14406879c08841331b2a4cfe7c">More...</a><br /></td></tr>
<tr class="separator:a7af82e14406879c08841331b2a4cfe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ba9e516ccae381ae7240cc9684eb72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72">OGR_G_Within</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a80ba9e516ccae381ae7240cc9684eb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="#a80ba9e516ccae381ae7240cc9684eb72">More...</a><br /></td></tr>
<tr class="separator:a80ba9e516ccae381ae7240cc9684eb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87e37380f0320faddbe5e67e23312f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8">OGR_G_Contains</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ad87e37380f0320faddbe5e67e23312f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="#ad87e37380f0320faddbe5e67e23312f8">More...</a><br /></td></tr>
<tr class="separator:ad87e37380f0320faddbe5e67e23312f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07acfe1bef39cd2cd1ad4a5ec26f2ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">OGR_G_Overlaps</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a07acfe1bef39cd2cd1ad4a5ec26f2ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for overlap.  <a href="#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">More...</a><br /></td></tr>
<tr class="separator:a07acfe1bef39cd2cd1ad4a5ec26f2ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e2ce6b8ad4347fa8bdbb1cdc0ad272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88e2ce6b8ad4347fa8bdbb1cdc0ad272">OGR_G_Boundary</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a88e2ce6b8ad4347fa8bdbb1cdc0ad272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute boundary.  <a href="#a88e2ce6b8ad4347fa8bdbb1cdc0ad272">More...</a><br /></td></tr>
<tr class="separator:a88e2ce6b8ad4347fa8bdbb1cdc0ad272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5408cae52870b2d162f166f42cd684b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad5408cae52870b2d162f166f42cd684b">OGR_G_ConvexHull</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ad5408cae52870b2d162f166f42cd684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull.  <a href="#ad5408cae52870b2d162f166f42cd684b">More...</a><br /></td></tr>
<tr class="separator:ad5408cae52870b2d162f166f42cd684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650366258bd4aa2a5a5e55966299cfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a650366258bd4aa2a5a5e55966299cfc1">OGR_G_Buffer</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, int) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a650366258bd4aa2a5a5e55966299cfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <a href="#a650366258bd4aa2a5a5e55966299cfc1">More...</a><br /></td></tr>
<tr class="separator:a650366258bd4aa2a5a5e55966299cfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d73915584c997f9bd79c8940379578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a96d73915584c997f9bd79c8940379578">OGR_G_Intersection</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a96d73915584c997f9bd79c8940379578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute intersection.  <a href="#a96d73915584c997f9bd79c8940379578">More...</a><br /></td></tr>
<tr class="separator:a96d73915584c997f9bd79c8940379578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a695a0e26f4992ba58d79eac92ed25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a59a695a0e26f4992ba58d79eac92ed25">OGR_G_Union</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a59a695a0e26f4992ba58d79eac92ed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union.  <a href="#a59a695a0e26f4992ba58d79eac92ed25">More...</a><br /></td></tr>
<tr class="separator:a59a695a0e26f4992ba58d79eac92ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a2be7e6f0e16a18df2d0d54f55554f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad6a2be7e6f0e16a18df2d0d54f55554f">OGR_G_UnionCascaded</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ad6a2be7e6f0e16a18df2d0d54f55554f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union using cascading.  <a href="#ad6a2be7e6f0e16a18df2d0d54f55554f">More...</a><br /></td></tr>
<tr class="separator:ad6a2be7e6f0e16a18df2d0d54f55554f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b43b2b0a38c1d63d785c37b392dc9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1b43b2b0a38c1d63d785c37b392dc9ec">OGR_G_PointOnSurface</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a1b43b2b0a38c1d63d785c37b392dc9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a point guaranteed to lie on the surface.  <a href="#a1b43b2b0a38c1d63d785c37b392dc9ec">More...</a><br /></td></tr>
<tr class="separator:a1b43b2b0a38c1d63d785c37b392dc9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4a22abdb38514237f13828dc1a987f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6e4a22abdb38514237f13828dc1a987f">OGR_G_Difference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a6e4a22abdb38514237f13828dc1a987f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute difference.  <a href="#a6e4a22abdb38514237f13828dc1a987f">More...</a><br /></td></tr>
<tr class="separator:a6e4a22abdb38514237f13828dc1a987f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59305c5838b6118e2d3f57f919ae666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af59305c5838b6118e2d3f57f919ae666">OGR_G_SymDifference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:af59305c5838b6118e2d3f57f919ae666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute symmetric difference.  <a href="#af59305c5838b6118e2d3f57f919ae666">More...</a><br /></td></tr>
<tr class="separator:af59305c5838b6118e2d3f57f919ae666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01002a9fd4175832af965930f069401"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401">OGR_G_Distance</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ab01002a9fd4175832af965930f069401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two geometries.  <a href="#ab01002a9fd4175832af965930f069401">More...</a><br /></td></tr>
<tr class="separator:ab01002a9fd4175832af965930f069401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7313a805a15bf78a26c52ff1bc6242e2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7313a805a15bf78a26c52ff1bc6242e2">OGR_G_Distance3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7313a805a15bf78a26c52ff1bc6242e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3D distance between two geometries.  <a href="#a7313a805a15bf78a26c52ff1bc6242e2">More...</a><br /></td></tr>
<tr class="separator:a7313a805a15bf78a26c52ff1bc6242e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb038c3271dbf41ac7ebc02fad3907f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5eb038c3271dbf41ac7ebc02fad3907f">OGR_G_Length</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a5eb038c3271dbf41ac7ebc02fad3907f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute length of a geometry.  <a href="#a5eb038c3271dbf41ac7ebc02fad3907f">More...</a><br /></td></tr>
<tr class="separator:a5eb038c3271dbf41ac7ebc02fad3907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a849c584cd22a199bcfb9b34b9a1a8f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a849c584cd22a199bcfb9b34b9a1a8f">OGR_G_Area</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a2a849c584cd22a199bcfb9b34b9a1a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geometry area.  <a href="#a2a849c584cd22a199bcfb9b34b9a1a8f">More...</a><br /></td></tr>
<tr class="separator:a2a849c584cd22a199bcfb9b34b9a1a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f5a19a81628af7f9cc59a37378cb2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b">OGR_G_Centroid</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a23f5a19a81628af7f9cc59a37378cb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometry centroid.  <a href="#a23f5a19a81628af7f9cc59a37378cb2b">More...</a><br /></td></tr>
<tr class="separator:a23f5a19a81628af7f9cc59a37378cb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fe6b95093ed248db61791cbf48b017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a40fe6b95093ed248db61791cbf48b017">OGR_G_Value</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double dfDistance) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a40fe6b95093ed248db61791cbf48b017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch point at given distance along curve.  <a href="#a40fe6b95093ed248db61791cbf48b017">More...</a><br /></td></tr>
<tr class="separator:a40fe6b95093ed248db61791cbf48b017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc83b0a3052b8fbe2ed77a86323bf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2">OGR_G_Empty</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a90cc83b0a3052b8fbe2ed77a86323bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear geometry information.  <a href="#a90cc83b0a3052b8fbe2ed77a86323bf2">More...</a><br /></td></tr>
<tr class="separator:a90cc83b0a3052b8fbe2ed77a86323bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737b0c4d73928e7406d69c658209dbbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a737b0c4d73928e7406d69c658209dbbf">OGR_G_IsEmpty</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a737b0c4d73928e7406d69c658209dbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is empty.  <a href="#a737b0c4d73928e7406d69c658209dbbf">More...</a><br /></td></tr>
<tr class="separator:a737b0c4d73928e7406d69c658209dbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df68924f3b41fd377c5b4aa6631a00b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b">OGR_G_IsValid</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a4df68924f3b41fd377c5b4aa6631a00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is valid.  <a href="#a4df68924f3b41fd377c5b4aa6631a00b">More...</a><br /></td></tr>
<tr class="separator:a4df68924f3b41fd377c5b4aa6631a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dbb0e05a715b16404a673d1ae2c9f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a60dbb0e05a715b16404a673d1ae2c9f5">OGR_G_MakeValid</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a60dbb0e05a715b16404a673d1ae2c9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to make an invalid geometry valid without losing vertices.  <a href="#a60dbb0e05a715b16404a673d1ae2c9f5">More...</a><br /></td></tr>
<tr class="separator:a60dbb0e05a715b16404a673d1ae2c9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb66472d7e302d16aacf0d66c01ac73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73">OGR_G_IsSimple</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a3cb66472d7e302d16aacf0d66c01ac73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the geometry is simple.  <a href="#a3cb66472d7e302d16aacf0d66c01ac73">More...</a><br /></td></tr>
<tr class="separator:a3cb66472d7e302d16aacf0d66c01ac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e99b4792042aca861866cb29bdf826"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826">OGR_G_IsRing</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ab9e99b4792042aca861866cb29bdf826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is a ring.  <a href="#ab9e99b4792042aca861866cb29bdf826">More...</a><br /></td></tr>
<tr class="separator:ab9e99b4792042aca861866cb29bdf826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c6a082065407712ff865471ad7136f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad7c6a082065407712ff865471ad7136f">OGR_G_Polygonize</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ad7c6a082065407712ff865471ad7136f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygonizes a set of sparse edges.  <a href="#ad7c6a082065407712ff865471ad7136f">More...</a><br /></td></tr>
<tr class="separator:ad7c6a082065407712ff865471ad7136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43cbe83609bc7b43739d67858846c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aec43cbe83609bc7b43739d67858846c1">OGR_G_GetPointCount</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:aec43cbe83609bc7b43739d67858846c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of points from a geometry.  <a href="#aec43cbe83609bc7b43739d67858846c1">More...</a><br /></td></tr>
<tr class="separator:aec43cbe83609bc7b43739d67858846c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c22d91b27d7a42c225a7dfde28f09c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c22d91b27d7a42c225a7dfde28f09c4">OGR_G_GetPoints</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride)</td></tr>
<tr class="memdesc:a6c22d91b27d7a42c225a7dfde28f09c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all points of line string.  <a href="#a6c22d91b27d7a42c225a7dfde28f09c4">More...</a><br /></td></tr>
<tr class="separator:a6c22d91b27d7a42c225a7dfde28f09c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce63762b79f4d882e1498981a4c26ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0ce63762b79f4d882e1498981a4c26ba">OGR_G_GetPointsZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride, void *pabyM, int nMStride)</td></tr>
<tr class="memdesc:a0ce63762b79f4d882e1498981a4c26ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all points of line string.  <a href="#a0ce63762b79f4d882e1498981a4c26ba">More...</a><br /></td></tr>
<tr class="separator:a0ce63762b79f4d882e1498981a4c26ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354146161d0a087b63ab6e350bae4d86"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a354146161d0a087b63ab6e350bae4d86">OGR_G_GetX</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a354146161d0a087b63ab6e350bae4d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the x coordinate of a point from a geometry.  <a href="#a354146161d0a087b63ab6e350bae4d86">More...</a><br /></td></tr>
<tr class="separator:a354146161d0a087b63ab6e350bae4d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8405350c9aea2ab7d0f759f0b09b926f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8405350c9aea2ab7d0f759f0b09b926f">OGR_G_GetY</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a8405350c9aea2ab7d0f759f0b09b926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the x coordinate of a point from a geometry.  <a href="#a8405350c9aea2ab7d0f759f0b09b926f">More...</a><br /></td></tr>
<tr class="separator:a8405350c9aea2ab7d0f759f0b09b926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8c6aeb013325f33b8e642003fc17ad"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1d8c6aeb013325f33b8e642003fc17ad">OGR_G_GetZ</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a1d8c6aeb013325f33b8e642003fc17ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the z coordinate of a point from a geometry.  <a href="#a1d8c6aeb013325f33b8e642003fc17ad">More...</a><br /></td></tr>
<tr class="separator:a1d8c6aeb013325f33b8e642003fc17ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fa1c4594aa103068870ef4b4ef094f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a49fa1c4594aa103068870ef4b4ef094f">OGR_G_GetM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a49fa1c4594aa103068870ef4b4ef094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the m coordinate of a point from a geometry.  <a href="#a49fa1c4594aa103068870ef4b4ef094f">More...</a><br /></td></tr>
<tr class="separator:a49fa1c4594aa103068870ef4b4ef094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b897ffcd88a83832964c3735fa1dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">OGR_G_GetPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double *, double *, double *)</td></tr>
<tr class="memdesc:a67b897ffcd88a83832964c3735fa1dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a point in line string or a point geometry.  <a href="#a67b897ffcd88a83832964c3735fa1dcb">More...</a><br /></td></tr>
<tr class="separator:a67b897ffcd88a83832964c3735fa1dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362999cdf708959829209e9d885d923d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a362999cdf708959829209e9d885d923d">OGR_G_GetPointZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double *, double *, double *, double *)</td></tr>
<tr class="memdesc:a362999cdf708959829209e9d885d923d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a point in line string or a point geometry.  <a href="#a362999cdf708959829209e9d885d923d">More...</a><br /></td></tr>
<tr class="separator:a362999cdf708959829209e9d885d923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4f7bff0d685b2713504bd89b14d0fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4f4f7bff0d685b2713504bd89b14d0fc">OGR_G_SetPointCount</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, int nNewPointCount)</td></tr>
<tr class="memdesc:a4f4f7bff0d685b2713504bd89b14d0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of points in a geometry.  <a href="#a4f4f7bff0d685b2713504bd89b14d0fc">More...</a><br /></td></tr>
<tr class="separator:a4f4f7bff0d685b2713504bd89b14d0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303fb1a2a94363c15f9e61dc46b710e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a303fb1a2a94363c15f9e61dc46b710e8">OGR_G_SetPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double, double)</td></tr>
<tr class="memdesc:a303fb1a2a94363c15f9e61dc46b710e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="#a303fb1a2a94363c15f9e61dc46b710e8">More...</a><br /></td></tr>
<tr class="separator:a303fb1a2a94363c15f9e61dc46b710e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14b9730d6f9fc829fe6be9bc2a5ec48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab14b9730d6f9fc829fe6be9bc2a5ec48">OGR_G_SetPoint_2D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double)</td></tr>
<tr class="memdesc:ab14b9730d6f9fc829fe6be9bc2a5ec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="#ab14b9730d6f9fc829fe6be9bc2a5ec48">More...</a><br /></td></tr>
<tr class="separator:ab14b9730d6f9fc829fe6be9bc2a5ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ce9b54d1e821bd020a7a6731d2f529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab4ce9b54d1e821bd020a7a6731d2f529">OGR_G_SetPointM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double, double)</td></tr>
<tr class="memdesc:ab4ce9b54d1e821bd020a7a6731d2f529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="#ab4ce9b54d1e821bd020a7a6731d2f529">More...</a><br /></td></tr>
<tr class="separator:ab4ce9b54d1e821bd020a7a6731d2f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034b6b1bae3843345cbfc78e07fa7075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a034b6b1bae3843345cbfc78e07fa7075">OGR_G_SetPointZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double, double, double)</td></tr>
<tr class="memdesc:a034b6b1bae3843345cbfc78e07fa7075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="#a034b6b1bae3843345cbfc78e07fa7075">More...</a><br /></td></tr>
<tr class="separator:a034b6b1bae3843345cbfc78e07fa7075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2702d812663bc767e3a8f8832fda089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa2702d812663bc767e3a8f8832fda089">OGR_G_AddPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double, double)</td></tr>
<tr class="memdesc:aa2702d812663bc767e3a8f8832fda089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="#aa2702d812663bc767e3a8f8832fda089">More...</a><br /></td></tr>
<tr class="separator:aa2702d812663bc767e3a8f8832fda089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280275c1492d6426cfe0a918d4725374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a280275c1492d6426cfe0a918d4725374">OGR_G_AddPoint_2D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double)</td></tr>
<tr class="memdesc:a280275c1492d6426cfe0a918d4725374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="#a280275c1492d6426cfe0a918d4725374">More...</a><br /></td></tr>
<tr class="separator:a280275c1492d6426cfe0a918d4725374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16370d0b3feb2505fa5f3a2acfffbf17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a16370d0b3feb2505fa5f3a2acfffbf17">OGR_G_AddPointM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double, double)</td></tr>
<tr class="memdesc:a16370d0b3feb2505fa5f3a2acfffbf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="#a16370d0b3feb2505fa5f3a2acfffbf17">More...</a><br /></td></tr>
<tr class="separator:a16370d0b3feb2505fa5f3a2acfffbf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01e19ca7b9951a5201b345ea130325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adf01e19ca7b9951a5201b345ea130325">OGR_G_AddPointZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double, double, double)</td></tr>
<tr class="memdesc:adf01e19ca7b9951a5201b345ea130325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="#adf01e19ca7b9951a5201b345ea130325">More...</a><br /></td></tr>
<tr class="separator:adf01e19ca7b9951a5201b345ea130325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51438701454d7e86988efc62b25d6aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a51438701454d7e86988efc62b25d6aeb">OGR_G_SetPoints</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, int nPointsIn, const void *pabyX, int nXStride, const void *pabyY, int nYStride, const void *pabyZ, int nZStride)</td></tr>
<tr class="memdesc:a51438701454d7e86988efc62b25d6aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all points in a point or a line string geometry.  <a href="#a51438701454d7e86988efc62b25d6aeb">More...</a><br /></td></tr>
<tr class="separator:a51438701454d7e86988efc62b25d6aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54402dc365f496b29ad1f01261e4576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac54402dc365f496b29ad1f01261e4576">OGR_G_SetPointsZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, int nPointsIn, const void *pabyX, int nXStride, const void *pabyY, int nYStride, const void *pabyZ, int nZStride, const void *pabyM, int nMStride)</td></tr>
<tr class="memdesc:ac54402dc365f496b29ad1f01261e4576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all points in a point or a line string geometry.  <a href="#ac54402dc365f496b29ad1f01261e4576">More...</a><br /></td></tr>
<tr class="separator:ac54402dc365f496b29ad1f01261e4576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cacbe8ef1bbacdcee7ad7c3d74ed593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4cacbe8ef1bbacdcee7ad7c3d74ed593">OGR_G_SwapXY</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a4cacbe8ef1bbacdcee7ad7c3d74ed593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap x and y coordinates.  <a href="#a4cacbe8ef1bbacdcee7ad7c3d74ed593">More...</a><br /></td></tr>
<tr class="separator:a4cacbe8ef1bbacdcee7ad7c3d74ed593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa07ddf969f97f6444de6ae5128d842"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1fa07ddf969f97f6444de6ae5128d842">OGR_G_GetGeometryCount</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a1fa07ddf969f97f6444de6ae5128d842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the number of elements in a geometry or number of geometries in container.  <a href="#a1fa07ddf969f97f6444de6ae5128d842">More...</a><br /></td></tr>
<tr class="separator:a1fa07ddf969f97f6444de6ae5128d842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bac93150529a5c98811db29e289dd66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6bac93150529a5c98811db29e289dd66">OGR_G_GetGeometryRef</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a6bac93150529a5c98811db29e289dd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry from a geometry container.  <a href="#a6bac93150529a5c98811db29e289dd66">More...</a><br /></td></tr>
<tr class="separator:a6bac93150529a5c98811db29e289dd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15e130614cb4c66fc99bb93dc6b3b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4a15e130614cb4c66fc99bb93dc6b3b5">OGR_G_AddGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a4a15e130614cb4c66fc99bb93dc6b3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a geometry to a geometry container.  <a href="#a4a15e130614cb4c66fc99bb93dc6b3b5">More...</a><br /></td></tr>
<tr class="separator:a4a15e130614cb4c66fc99bb93dc6b3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff56cae8305396a9c5b690d8356e39c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aff56cae8305396a9c5b690d8356e39c9">OGR_G_AddGeometryDirectly</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:aff56cae8305396a9c5b690d8356e39c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a geometry directly to an existing geometry container.  <a href="#aff56cae8305396a9c5b690d8356e39c9">More...</a><br /></td></tr>
<tr class="separator:aff56cae8305396a9c5b690d8356e39c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ea024bb659e48d3297404e53800237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a54ea024bb659e48d3297404e53800237">OGR_G_RemoveGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int, int)</td></tr>
<tr class="memdesc:a54ea024bb659e48d3297404e53800237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a geometry from an exiting geometry container.  <a href="#a54ea024bb659e48d3297404e53800237">More...</a><br /></td></tr>
<tr class="separator:a54ea024bb659e48d3297404e53800237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f8e7d05f06a1fe69ea9638085e5e26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af4f8e7d05f06a1fe69ea9638085e5e26">OGR_G_HasCurveGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int bLookForNonLinear)</td></tr>
<tr class="memdesc:af4f8e7d05f06a1fe69ea9638085e5e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this geometry is or has curve geometry.  <a href="#af4f8e7d05f06a1fe69ea9638085e5e26">More...</a><br /></td></tr>
<tr class="separator:af4f8e7d05f06a1fe69ea9638085e5e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd069f8338954fc8a6215594a37a8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6bd069f8338954fc8a6215594a37a8db">OGR_G_GetLinearGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, double dfMaxAngleStepSizeDegrees, char **papszOptions) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a6bd069f8338954fc8a6215594a37a8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, possibly approximate, linear version of this geometry.  <a href="#a6bd069f8338954fc8a6215594a37a8db">More...</a><br /></td></tr>
<tr class="separator:a6bd069f8338954fc8a6215594a37a8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4989d5287899041d70f4176d41ceeac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4989d5287899041d70f4176d41ceeac2">OGR_G_GetCurveGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, char **papszOptions) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a4989d5287899041d70f4176d41ceeac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return curve version of this geometry.  <a href="#a4989d5287899041d70f4176d41ceeac2">More...</a><br /></td></tr>
<tr class="separator:a4989d5287899041d70f4176d41ceeac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96ffb0c7265926d107dadde9a634763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac96ffb0c7265926d107dadde9a634763">OGRBuildPolygonFromEdges</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hLinesAsCollection, int bBestEffort, int bAutoClose, double dfTolerance, <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *peErr) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ac96ffb0c7265926d107dadde9a634763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a ring from a bunch of arcs.  <a href="#ac96ffb0c7265926d107dadde9a634763">More...</a><br /></td></tr>
<tr class="separator:ac96ffb0c7265926d107dadde9a634763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31febe0b845d7cc0052767e6257e7349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a31febe0b845d7cc0052767e6257e7349">OGRSetNonLinearGeometriesEnabledFlag</a> (int bFlag)</td></tr>
<tr class="memdesc:a31febe0b845d7cc0052767e6257e7349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag to enable/disable returning non-linear geometries in the C API.  <a href="#a31febe0b845d7cc0052767e6257e7349">More...</a><br /></td></tr>
<tr class="separator:a31febe0b845d7cc0052767e6257e7349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f6cfab316f5f22962bcd85216c4684"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af7f6cfab316f5f22962bcd85216c4684">OGRGetNonLinearGeometriesEnabledFlag</a> (void)</td></tr>
<tr class="memdesc:af7f6cfab316f5f22962bcd85216c4684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flag to enable/disable returning non-linear geometries in the C API.  <a href="#af7f6cfab316f5f22962bcd85216c4684">More...</a><br /></td></tr>
<tr class="separator:af7f6cfab316f5f22962bcd85216c4684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24af159359797a83c354fdf6cced3265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a24af159359797a83c354fdf6cced3265">OGR_Fld_Create</a> (const char *, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a24af159359797a83c354fdf6cced3265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field definition.  <a href="#a24af159359797a83c354fdf6cced3265">More...</a><br /></td></tr>
<tr class="separator:a24af159359797a83c354fdf6cced3265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455fa4a2c2451b1748facb6b7126a822"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a455fa4a2c2451b1748facb6b7126a822">OGR_Fld_Destroy</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a455fa4a2c2451b1748facb6b7126a822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a field definition.  <a href="#a455fa4a2c2451b1748facb6b7126a822">More...</a><br /></td></tr>
<tr class="separator:a455fa4a2c2451b1748facb6b7126a822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6599fa42bad3aba26574ae3260c6984d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6599fa42bad3aba26574ae3260c6984d">OGR_Fld_SetName</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, const char *)</td></tr>
<tr class="memdesc:a6599fa42bad3aba26574ae3260c6984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the name of this field.  <a href="#a6599fa42bad3aba26574ae3260c6984d">More...</a><br /></td></tr>
<tr class="separator:a6599fa42bad3aba26574ae3260c6984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7640a6b6a47a95d83415f9271ffe30"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8d7640a6b6a47a95d83415f9271ffe30">OGR_Fld_GetNameRef</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a8d7640a6b6a47a95d83415f9271ffe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch name of this field.  <a href="#a8d7640a6b6a47a95d83415f9271ffe30">More...</a><br /></td></tr>
<tr class="separator:a8d7640a6b6a47a95d83415f9271ffe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d150dfc678e0a2a7f5241ba38c5611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad8d150dfc678e0a2a7f5241ba38c5611">OGR_Fld_GetType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:ad8d150dfc678e0a2a7f5241ba38c5611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch type of this field.  <a href="#ad8d150dfc678e0a2a7f5241ba38c5611">More...</a><br /></td></tr>
<tr class="separator:ad8d150dfc678e0a2a7f5241ba38c5611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76195990f814eb93e821c01ce0599a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a76195990f814eb93e821c01ce0599a50">OGR_Fld_SetType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>)</td></tr>
<tr class="memdesc:a76195990f814eb93e821c01ce0599a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of this field.  <a href="#a76195990f814eb93e821c01ce0599a50">More...</a><br /></td></tr>
<tr class="separator:a76195990f814eb93e821c01ce0599a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef13952aa38f83b0dc1da047870511f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3ef13952aa38f83b0dc1da047870511f">OGR_Fld_GetSubType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a3ef13952aa38f83b0dc1da047870511f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch subtype of this field.  <a href="#a3ef13952aa38f83b0dc1da047870511f">More...</a><br /></td></tr>
<tr class="separator:a3ef13952aa38f83b0dc1da047870511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83497e3ce74c6abb615a234791850c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab83497e3ce74c6abb615a234791850c1">OGR_Fld_SetSubType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>)</td></tr>
<tr class="memdesc:ab83497e3ce74c6abb615a234791850c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subtype of this field.  <a href="#ab83497e3ce74c6abb615a234791850c1">More...</a><br /></td></tr>
<tr class="separator:ab83497e3ce74c6abb615a234791850c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf8a09826e47763e6bf667af0dae1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0cf8a09826e47763e6bf667af0dae1a7">OGR_Fld_GetJustify</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a0cf8a09826e47763e6bf667af0dae1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the justification for this field.  <a href="#a0cf8a09826e47763e6bf667af0dae1a7">More...</a><br /></td></tr>
<tr class="separator:a0cf8a09826e47763e6bf667af0dae1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4809f2fe957002b8e18aacc1bdca240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae4809f2fe957002b8e18aacc1bdca240">OGR_Fld_SetJustify</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>)</td></tr>
<tr class="memdesc:ae4809f2fe957002b8e18aacc1bdca240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the justification for this field.  <a href="#ae4809f2fe957002b8e18aacc1bdca240">More...</a><br /></td></tr>
<tr class="separator:ae4809f2fe957002b8e18aacc1bdca240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6500186e3f22761a615428c55bba0ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6500186e3f22761a615428c55bba0ce">OGR_Fld_GetWidth</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:aa6500186e3f22761a615428c55bba0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the formatting width for this field.  <a href="#aa6500186e3f22761a615428c55bba0ce">More...</a><br /></td></tr>
<tr class="separator:aa6500186e3f22761a615428c55bba0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7bf7c14a299448efac58f7bf364326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1d7bf7c14a299448efac58f7bf364326">OGR_Fld_SetWidth</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, int)</td></tr>
<tr class="memdesc:a1d7bf7c14a299448efac58f7bf364326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the formatting width for this field in characters.  <a href="#a1d7bf7c14a299448efac58f7bf364326">More...</a><br /></td></tr>
<tr class="separator:a1d7bf7c14a299448efac58f7bf364326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120dd56ee23070922e4d84ed06b06e27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a120dd56ee23070922e4d84ed06b06e27">OGR_Fld_GetPrecision</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a120dd56ee23070922e4d84ed06b06e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the formatting precision for this field.  <a href="#a120dd56ee23070922e4d84ed06b06e27">More...</a><br /></td></tr>
<tr class="separator:a120dd56ee23070922e4d84ed06b06e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13890f01f7d7e57bcd07e23f3e2947da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a13890f01f7d7e57bcd07e23f3e2947da">OGR_Fld_SetPrecision</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, int)</td></tr>
<tr class="memdesc:a13890f01f7d7e57bcd07e23f3e2947da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the formatting precision for this field in characters.  <a href="#a13890f01f7d7e57bcd07e23f3e2947da">More...</a><br /></td></tr>
<tr class="separator:a13890f01f7d7e57bcd07e23f3e2947da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5922e599fe8746b81adf251be6b5ecf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5922e599fe8746b81adf251be6b5ecf0">OGR_Fld_Set</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, const char *, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>, int, int, <a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>)</td></tr>
<tr class="memdesc:a5922e599fe8746b81adf251be6b5ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set defining parameters for a field in one call.  <a href="#a5922e599fe8746b81adf251be6b5ecf0">More...</a><br /></td></tr>
<tr class="separator:a5922e599fe8746b81adf251be6b5ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bec35ae5a4c232ad850315bdc2b675"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a29bec35ae5a4c232ad850315bdc2b675">OGR_Fld_IsIgnored</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a29bec35ae5a4c232ad850315bdc2b675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this field should be omitted when fetching features.  <a href="#a29bec35ae5a4c232ad850315bdc2b675">More...</a><br /></td></tr>
<tr class="separator:a29bec35ae5a4c232ad850315bdc2b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddf9aa9767cd28c90dc66ed2a7a7332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeddf9aa9767cd28c90dc66ed2a7a7332">OGR_Fld_SetIgnored</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:aeddf9aa9767cd28c90dc66ed2a7a7332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this field should be omitted when fetching features.  <a href="#aeddf9aa9767cd28c90dc66ed2a7a7332">More...</a><br /></td></tr>
<tr class="separator:aeddf9aa9767cd28c90dc66ed2a7a7332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bfc414977d37ee22edefd38c1f414b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a57bfc414977d37ee22edefd38c1f414b">OGR_Fld_IsNullable</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a57bfc414977d37ee22edefd38c1f414b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this field can receive null values.  <a href="#a57bfc414977d37ee22edefd38c1f414b">More...</a><br /></td></tr>
<tr class="separator:a57bfc414977d37ee22edefd38c1f414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a35def2d6766804a59f0b4c24e457d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a35def2d6766804a59f0b4c24e457d5">OGR_Fld_SetNullable</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:a9a35def2d6766804a59f0b4c24e457d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this field can receive null values.  <a href="#a9a35def2d6766804a59f0b4c24e457d5">More...</a><br /></td></tr>
<tr class="separator:a9a35def2d6766804a59f0b4c24e457d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc96ddb37f8b8076e711e48ee9ead62"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aacc96ddb37f8b8076e711e48ee9ead62">OGR_Fld_GetDefault</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:aacc96ddb37f8b8076e711e48ee9ead62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default field value.  <a href="#aacc96ddb37f8b8076e711e48ee9ead62">More...</a><br /></td></tr>
<tr class="separator:aacc96ddb37f8b8076e711e48ee9ead62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0268ee60f240e6fa668b7c612354f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa0268ee60f240e6fa668b7c612354f80">OGR_Fld_SetDefault</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, const char *)</td></tr>
<tr class="memdesc:aa0268ee60f240e6fa668b7c612354f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default field value.  <a href="#aa0268ee60f240e6fa668b7c612354f80">More...</a><br /></td></tr>
<tr class="separator:aa0268ee60f240e6fa668b7c612354f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf08ca1607bdc678f2ae166ad0f27e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4bf08ca1607bdc678f2ae166ad0f27e2">OGR_Fld_IsDefaultDriverSpecific</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a4bf08ca1607bdc678f2ae166ad0f27e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the default value is driver specific.  <a href="#a4bf08ca1607bdc678f2ae166ad0f27e2">More...</a><br /></td></tr>
<tr class="separator:a4bf08ca1607bdc678f2ae166ad0f27e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e61b89ae2d799cf5e217d01ef7b415"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af1e61b89ae2d799cf5e217d01ef7b415">OGR_GetFieldTypeName</a> (<a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>)</td></tr>
<tr class="memdesc:af1e61b89ae2d799cf5e217d01ef7b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch human readable name for a field type.  <a href="#af1e61b89ae2d799cf5e217d01ef7b415">More...</a><br /></td></tr>
<tr class="separator:af1e61b89ae2d799cf5e217d01ef7b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9611cba58f204544ecad73fd8defe3f3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9611cba58f204544ecad73fd8defe3f3">OGR_GetFieldSubTypeName</a> (<a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>)</td></tr>
<tr class="memdesc:a9611cba58f204544ecad73fd8defe3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch human readable name for a field subtype.  <a href="#a9611cba58f204544ecad73fd8defe3f3">More...</a><br /></td></tr>
<tr class="separator:a9611cba58f204544ecad73fd8defe3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3caffcd90d58c859cb51adef4c6c5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3f3caffcd90d58c859cb51adef4c6c5d">OGR_AreTypeSubTypeCompatible</a> (<a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> eType, <a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> eSubType)</td></tr>
<tr class="memdesc:a3f3caffcd90d58c859cb51adef4c6c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if type and subtype are compatible.  <a href="#a3f3caffcd90d58c859cb51adef4c6c5d">More...</a><br /></td></tr>
<tr class="separator:a3f3caffcd90d58c859cb51adef4c6c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4681750642cae49933ba4fc962744b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4681750642cae49933ba4fc962744b78">OGR_GFld_Create</a> (const char *, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a4681750642cae49933ba4fc962744b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field geometry definition.  <a href="#a4681750642cae49933ba4fc962744b78">More...</a><br /></td></tr>
<tr class="separator:a4681750642cae49933ba4fc962744b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e65993ea2b8b907e43ffa8b106871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0f3e65993ea2b8b907e43ffa8b106871">OGR_GFld_Destroy</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:a0f3e65993ea2b8b907e43ffa8b106871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a geometry field definition.  <a href="#a0f3e65993ea2b8b907e43ffa8b106871">More...</a><br /></td></tr>
<tr class="separator:a0f3e65993ea2b8b907e43ffa8b106871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9b9d56381cae346c5129943641f628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c9b9d56381cae346c5129943641f628">OGR_GFld_SetName</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>, const char *)</td></tr>
<tr class="memdesc:a6c9b9d56381cae346c5129943641f628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the name of this field.  <a href="#a6c9b9d56381cae346c5129943641f628">More...</a><br /></td></tr>
<tr class="separator:a6c9b9d56381cae346c5129943641f628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9914366a6cc3b4169a3359c2b1ef614"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad9914366a6cc3b4169a3359c2b1ef614">OGR_GFld_GetNameRef</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:ad9914366a6cc3b4169a3359c2b1ef614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch name of this field.  <a href="#ad9914366a6cc3b4169a3359c2b1ef614">More...</a><br /></td></tr>
<tr class="separator:ad9914366a6cc3b4169a3359c2b1ef614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f4350c2e90c6e67df37f68d244a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d">OGR_GFld_GetType</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:a323f4350c2e90c6e67df37f68d244a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry type of this field.  <a href="#a323f4350c2e90c6e67df37f68d244a0d">More...</a><br /></td></tr>
<tr class="separator:a323f4350c2e90c6e67df37f68d244a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3691474967ca5f0c9789e0626d55f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affb3691474967ca5f0c9789e0626d55f">OGR_GFld_SetType</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr class="memdesc:affb3691474967ca5f0c9789e0626d55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the geometry type of this field.  <a href="#affb3691474967ca5f0c9789e0626d55f">More...</a><br /></td></tr>
<tr class="separator:affb3691474967ca5f0c9789e0626d55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7927b11a85659d8ce6da8857f52b05c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7927b11a85659d8ce6da8857f52b05c4">OGR_GFld_GetSpatialRef</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:a7927b11a85659d8ce6da8857f52b05c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch spatial reference system of this field.  <a href="#a7927b11a85659d8ce6da8857f52b05c4">More...</a><br /></td></tr>
<tr class="separator:a7927b11a85659d8ce6da8857f52b05c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa717acc8f4f5f33825334fe72edc2be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa717acc8f4f5f33825334fe72edc2be9">OGR_GFld_SetSpatialRef</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hSRS)</td></tr>
<tr class="memdesc:aa717acc8f4f5f33825334fe72edc2be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the spatial reference of this field.  <a href="#aa717acc8f4f5f33825334fe72edc2be9">More...</a><br /></td></tr>
<tr class="separator:aa717acc8f4f5f33825334fe72edc2be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfbda2b68e11227611ff74ee0105d47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9bfbda2b68e11227611ff74ee0105d47">OGR_GFld_IsNullable</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a9bfbda2b68e11227611ff74ee0105d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this geometry field can receive null values.  <a href="#a9bfbda2b68e11227611ff74ee0105d47">More...</a><br /></td></tr>
<tr class="separator:a9bfbda2b68e11227611ff74ee0105d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1">OGR_GFld_SetNullable</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this geometry field can receive null values.  <a href="#aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1">More...</a><br /></td></tr>
<tr class="separator:aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab232798830d8dcae0742d83948e33d1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab232798830d8dcae0742d83948e33d1a">OGR_GFld_IsIgnored</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:ab232798830d8dcae0742d83948e33d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this field should be omitted when fetching features.  <a href="#ab232798830d8dcae0742d83948e33d1a">More...</a><br /></td></tr>
<tr class="separator:ab232798830d8dcae0742d83948e33d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a4e5e2af01140209e9d2814869eb41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af3a4e5e2af01140209e9d2814869eb41">OGR_GFld_SetIgnored</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:af3a4e5e2af01140209e9d2814869eb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this field should be omitted when fetching features.  <a href="#af3a4e5e2af01140209e9d2814869eb41">More...</a><br /></td></tr>
<tr class="separator:af3a4e5e2af01140209e9d2814869eb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbc5146fcab99667f021c40c714628c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8cbc5146fcab99667f021c40c714628c">OGR_FD_Create</a> (const char *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a8cbc5146fcab99667f021c40c714628c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new feature definition object to hold the field definitions.  <a href="#a8cbc5146fcab99667f021c40c714628c">More...</a><br /></td></tr>
<tr class="separator:a8cbc5146fcab99667f021c40c714628c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d5cbb660cce8467a210caa4d68a011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a59d5cbb660cce8467a210caa4d68a011">OGR_FD_Destroy</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a59d5cbb660cce8467a210caa4d68a011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a feature definition object and release all memory associated with it.  <a href="#a59d5cbb660cce8467a210caa4d68a011">More...</a><br /></td></tr>
<tr class="separator:a59d5cbb660cce8467a210caa4d68a011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0755b0360414095e15eaf2c1496f8c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0755b0360414095e15eaf2c1496f8c47">OGR_FD_Release</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a0755b0360414095e15eaf2c1496f8c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a reference, and destroy if unreferenced.  <a href="#a0755b0360414095e15eaf2c1496f8c47">More...</a><br /></td></tr>
<tr class="separator:a0755b0360414095e15eaf2c1496f8c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f309bf10e5b76cc083848b710babb8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a20f309bf10e5b76cc083848b710babb8">OGR_FD_GetName</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a20f309bf10e5b76cc083848b710babb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> passed as an argument.  <a href="#a20f309bf10e5b76cc083848b710babb8">More...</a><br /></td></tr>
<tr class="separator:a20f309bf10e5b76cc083848b710babb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586a14271a457387a2b5c0097a02c8da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a586a14271a457387a2b5c0097a02c8da">OGR_FD_GetFieldCount</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a586a14271a457387a2b5c0097a02c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of fields on the passed feature definition.  <a href="#a586a14271a457387a2b5c0097a02c8da">More...</a><br /></td></tr>
<tr class="separator:a586a14271a457387a2b5c0097a02c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484456df86a01284769d0afe3beaa4f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a484456df86a01284769d0afe3beaa4f6">OGR_FD_GetFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, int)</td></tr>
<tr class="memdesc:a484456df86a01284769d0afe3beaa4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field definition of the passed feature definition.  <a href="#a484456df86a01284769d0afe3beaa4f6">More...</a><br /></td></tr>
<tr class="separator:a484456df86a01284769d0afe3beaa4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54c3271dce0562209d78ae6eaae330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1e54c3271dce0562209d78ae6eaae330">OGR_FD_GetFieldIndex</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, const char *)</td></tr>
<tr class="memdesc:a1e54c3271dce0562209d78ae6eaae330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find field by name.  <a href="#a1e54c3271dce0562209d78ae6eaae330">More...</a><br /></td></tr>
<tr class="separator:a1e54c3271dce0562209d78ae6eaae330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a798e8d03299403418a7c87862f1acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a798e8d03299403418a7c87862f1acb">OGR_FD_AddFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, <a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a2a798e8d03299403418a7c87862f1acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new field definition to the passed feature definition.  <a href="#a2a798e8d03299403418a7c87862f1acb">More...</a><br /></td></tr>
<tr class="separator:a2a798e8d03299403418a7c87862f1acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6283475163d911204f5ff45098c8479e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6283475163d911204f5ff45098c8479e">OGR_FD_DeleteFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hDefn, int iField)</td></tr>
<tr class="memdesc:a6283475163d911204f5ff45098c8479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing field definition.  <a href="#a6283475163d911204f5ff45098c8479e">More...</a><br /></td></tr>
<tr class="separator:a6283475163d911204f5ff45098c8479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87da23094f3473a9a11bf2fdb6fd2dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a87da23094f3473a9a11bf2fdb6fd2dc4">OGR_FD_ReorderFieldDefns</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hDefn, int *panMap)</td></tr>
<tr class="memdesc:a87da23094f3473a9a11bf2fdb6fd2dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the field definitions in the array of the feature definition.  <a href="#a87da23094f3473a9a11bf2fdb6fd2dc4">More...</a><br /></td></tr>
<tr class="separator:a87da23094f3473a9a11bf2fdb6fd2dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0b3a6b6062122e4f4316d194d2a1cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf">OGR_FD_GetGeomType</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:add0b3a6b6062122e4f4316d194d2a1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the geometry base type of the passed feature definition.  <a href="#add0b3a6b6062122e4f4316d194d2a1cf">More...</a><br /></td></tr>
<tr class="separator:add0b3a6b6062122e4f4316d194d2a1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca3a84b54ac36c5f68a03821f1fa78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a11ca3a84b54ac36c5f68a03821f1fa78">OGR_FD_SetGeomType</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr class="memdesc:a11ca3a84b54ac36c5f68a03821f1fa78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the base geometry type for the passed layer (the same as the feature definition).  <a href="#a11ca3a84b54ac36c5f68a03821f1fa78">More...</a><br /></td></tr>
<tr class="separator:a11ca3a84b54ac36c5f68a03821f1fa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1208985f67db526136dbe74f490c8d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad1208985f67db526136dbe74f490c8d3">OGR_FD_IsGeometryIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:ad1208985f67db526136dbe74f490c8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the geometry can be omitted when fetching features.  <a href="#ad1208985f67db526136dbe74f490c8d3">More...</a><br /></td></tr>
<tr class="separator:ad1208985f67db526136dbe74f490c8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbc85e1ba2378679e4ce6bf3523bf8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1bbc85e1ba2378679e4ce6bf3523bf8e">OGR_FD_SetGeometryIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, int)</td></tr>
<tr class="memdesc:a1bbc85e1ba2378679e4ce6bf3523bf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the geometry can be omitted when fetching features.  <a href="#a1bbc85e1ba2378679e4ce6bf3523bf8e">More...</a><br /></td></tr>
<tr class="separator:a1bbc85e1ba2378679e4ce6bf3523bf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9490e3e5d25b780723ad3f0ab3302eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa9490e3e5d25b780723ad3f0ab3302eb">OGR_FD_IsStyleIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:aa9490e3e5d25b780723ad3f0ab3302eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the style can be omitted when fetching features.  <a href="#aa9490e3e5d25b780723ad3f0ab3302eb">More...</a><br /></td></tr>
<tr class="separator:aa9490e3e5d25b780723ad3f0ab3302eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c09218e9ef9e49abcdd0b76858a514b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c09218e9ef9e49abcdd0b76858a514b">OGR_FD_SetStyleIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, int)</td></tr>
<tr class="memdesc:a6c09218e9ef9e49abcdd0b76858a514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the style can be omitted when fetching features.  <a href="#a6c09218e9ef9e49abcdd0b76858a514b">More...</a><br /></td></tr>
<tr class="separator:a6c09218e9ef9e49abcdd0b76858a514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6763104e7fafcab1b52d9b0f275e19e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6763104e7fafcab1b52d9b0f275e19e8">OGR_FD_Reference</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a6763104e7fafcab1b52d9b0f275e19e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the reference count by one.  <a href="#a6763104e7fafcab1b52d9b0f275e19e8">More...</a><br /></td></tr>
<tr class="separator:a6763104e7fafcab1b52d9b0f275e19e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107635936c90c7f4347d7b3f9fb06e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a107635936c90c7f4347d7b3f9fb06e6d">OGR_FD_Dereference</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a107635936c90c7f4347d7b3f9fb06e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference count by one.  <a href="#a107635936c90c7f4347d7b3f9fb06e6d">More...</a><br /></td></tr>
<tr class="separator:a107635936c90c7f4347d7b3f9fb06e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e8867edeaf1a6f98e6ff284835811"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9e4e8867edeaf1a6f98e6ff284835811">OGR_FD_GetReferenceCount</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a9e4e8867edeaf1a6f98e6ff284835811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch current reference count.  <a href="#a9e4e8867edeaf1a6f98e6ff284835811">More...</a><br /></td></tr>
<tr class="separator:a9e4e8867edeaf1a6f98e6ff284835811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b34027b691ea40e20b911290f863303"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0b34027b691ea40e20b911290f863303">OGR_FD_GetGeomFieldCount</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn)</td></tr>
<tr class="memdesc:a0b34027b691ea40e20b911290f863303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of geometry fields on the passed feature definition.  <a href="#a0b34027b691ea40e20b911290f863303">More...</a><br /></td></tr>
<tr class="separator:a0b34027b691ea40e20b911290f863303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82275ef1d2655817f6fe582f885c92c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a82275ef1d2655817f6fe582f885c92c7">OGR_FD_GetGeomFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, int i)</td></tr>
<tr class="memdesc:a82275ef1d2655817f6fe582f885c92c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry field definition of the passed feature definition.  <a href="#a82275ef1d2655817f6fe582f885c92c7">More...</a><br /></td></tr>
<tr class="separator:a82275ef1d2655817f6fe582f885c92c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be97ea100c50bdaad8a1d3c30e7b14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a69be97ea100c50bdaad8a1d3c30e7b14">OGR_FD_GetGeomFieldIndex</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, const char *pszName)</td></tr>
<tr class="memdesc:a69be97ea100c50bdaad8a1d3c30e7b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find geometry field by name.  <a href="#a69be97ea100c50bdaad8a1d3c30e7b14">More...</a><br /></td></tr>
<tr class="separator:a69be97ea100c50bdaad8a1d3c30e7b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa080fdbe88c1829c1b7adcce208ec4b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa080fdbe88c1829c1b7adcce208ec4b8">OGR_FD_AddGeomFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, <a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hGFldDefn)</td></tr>
<tr class="memdesc:aa080fdbe88c1829c1b7adcce208ec4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new field definition to the passed feature definition.  <a href="#aa080fdbe88c1829c1b7adcce208ec4b8">More...</a><br /></td></tr>
<tr class="separator:aa080fdbe88c1829c1b7adcce208ec4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb650102be3837fc220b086b17f4462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1fb650102be3837fc220b086b17f4462">OGR_FD_DeleteGeomFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, int iGeomField)</td></tr>
<tr class="memdesc:a1fb650102be3837fc220b086b17f4462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing geometry field definition.  <a href="#a1fb650102be3837fc220b086b17f4462">More...</a><br /></td></tr>
<tr class="separator:a1fb650102be3837fc220b086b17f4462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07056d514160c26724f3a2d5319185f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab07056d514160c26724f3a2d5319185f">OGR_FD_IsSame</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, <a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hOtherFDefn)</td></tr>
<tr class="memdesc:ab07056d514160c26724f3a2d5319185f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the feature definition is identical to the other one.  <a href="#ab07056d514160c26724f3a2d5319185f">More...</a><br /></td></tr>
<tr class="separator:ab07056d514160c26724f3a2d5319185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335fbf2220d7f93437621cae723558ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a335fbf2220d7f93437621cae723558ac">OGR_F_Create</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a335fbf2220d7f93437621cae723558ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature factory.  <a href="#a335fbf2220d7f93437621cae723558ac">More...</a><br /></td></tr>
<tr class="separator:a335fbf2220d7f93437621cae723558ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fb8126aa932f4b4acdaca5ea99bbbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb">OGR_F_Destroy</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a16fb8126aa932f4b4acdaca5ea99bbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy feature.  <a href="#a16fb8126aa932f4b4acdaca5ea99bbbb">More...</a><br /></td></tr>
<tr class="separator:a16fb8126aa932f4b4acdaca5ea99bbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123dfa431bf655aafd2dbd42247dd7be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a123dfa431bf655aafd2dbd42247dd7be">OGR_F_GetDefnRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a123dfa431bf655aafd2dbd42247dd7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch feature definition.  <a href="#a123dfa431bf655aafd2dbd42247dd7be">More...</a><br /></td></tr>
<tr class="separator:a123dfa431bf655aafd2dbd42247dd7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad391d3197728bb6d12a6b0c2e2661aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad391d3197728bb6d12a6b0c2e2661aa4">OGR_F_SetGeometryDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ad391d3197728bb6d12a6b0c2e2661aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry.  <a href="#ad391d3197728bb6d12a6b0c2e2661aa4">More...</a><br /></td></tr>
<tr class="separator:ad391d3197728bb6d12a6b0c2e2661aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c524f5c01a6a4b4e50e351d03299f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7b9c524f5c01a6a4b4e50e351d03299f">OGR_F_SetGeometry</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7b9c524f5c01a6a4b4e50e351d03299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry.  <a href="#a7b9c524f5c01a6a4b4e50e351d03299f">More...</a><br /></td></tr>
<tr class="separator:a7b9c524f5c01a6a4b4e50e351d03299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf9596756aeacec4da502383c378f5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c">OGR_F_GetGeometryRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a1bf9596756aeacec4da502383c378f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an handle to feature geometry.  <a href="#a1bf9596756aeacec4da502383c378f5c">More...</a><br /></td></tr>
<tr class="separator:a1bf9596756aeacec4da502383c378f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2153b17a82c0026c20d710a79e6a779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae2153b17a82c0026c20d710a79e6a779">OGR_F_StealGeometry</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ae2153b17a82c0026c20d710a79e6a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take away ownership of geometry.  <a href="#ae2153b17a82c0026c20d710a79e6a779">More...</a><br /></td></tr>
<tr class="separator:ae2153b17a82c0026c20d710a79e6a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102988416ae11403cab68cbaea7386d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a102988416ae11403cab68cbaea7386d1">OGR_F_Clone</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a102988416ae11403cab68cbaea7386d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate feature.  <a href="#a102988416ae11403cab68cbaea7386d1">More...</a><br /></td></tr>
<tr class="separator:a102988416ae11403cab68cbaea7386d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6a502ec0b70f3de50e7184a087a264"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b6a502ec0b70f3de50e7184a087a264">OGR_F_Equal</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a8b6a502ec0b70f3de50e7184a087a264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if two features are the same.  <a href="#a8b6a502ec0b70f3de50e7184a087a264">More...</a><br /></td></tr>
<tr class="separator:a8b6a502ec0b70f3de50e7184a087a264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c1440956ee56c0c160394bccf96990"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af6c1440956ee56c0c160394bccf96990">OGR_F_GetFieldCount</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:af6c1440956ee56c0c160394bccf96990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of fields on this feature This will always be the same as the field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.  <a href="#af6c1440956ee56c0c160394bccf96990">More...</a><br /></td></tr>
<tr class="separator:af6c1440956ee56c0c160394bccf96990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8fc7fd6ecca789ad90db6d28391623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6f8fc7fd6ecca789ad90db6d28391623">OGR_F_GetFieldDefnRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a6f8fc7fd6ecca789ad90db6d28391623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch definition for this field.  <a href="#a6f8fc7fd6ecca789ad90db6d28391623">More...</a><br /></td></tr>
<tr class="separator:a6f8fc7fd6ecca789ad90db6d28391623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a6b93ab97204b94f5c2b358f8f98e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a8a6b93ab97204b94f5c2b358f8f98e">OGR_F_GetFieldIndex</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:a9a8a6b93ab97204b94f5c2b358f8f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the field index given field name.  <a href="#a9a8a6b93ab97204b94f5c2b358f8f98e">More...</a><br /></td></tr>
<tr class="separator:a9a8a6b93ab97204b94f5c2b358f8f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb018a9030ed76353ae26082deaaef11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11">OGR_F_IsFieldSet</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:abb018a9030ed76353ae26082deaaef11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a field has ever been assigned a value or not.  <a href="#abb018a9030ed76353ae26082deaaef11">More...</a><br /></td></tr>
<tr class="separator:abb018a9030ed76353ae26082deaaef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70b7675a003141e63f9603c752ee22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e">OGR_F_UnsetField</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:aa70b7675a003141e63f9603c752ee22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a field, marking it as unset.  <a href="#aa70b7675a003141e63f9603c752ee22e">More...</a><br /></td></tr>
<tr class="separator:aa70b7675a003141e63f9603c752ee22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d08c0ac3b9624955e682a9a2afe2b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa4d08c0ac3b9624955e682a9a2afe2b1">OGR_F_IsFieldNull</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:aa4d08c0ac3b9624955e682a9a2afe2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a field is null.  <a href="#aa4d08c0ac3b9624955e682a9a2afe2b1">More...</a><br /></td></tr>
<tr class="separator:aa4d08c0ac3b9624955e682a9a2afe2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf414eb3a145bcd7203fca727f7a2ead"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adf414eb3a145bcd7203fca727f7a2ead">OGR_F_IsFieldSetAndNotNull</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:adf414eb3a145bcd7203fca727f7a2ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a field is set and not null.  <a href="#adf414eb3a145bcd7203fca727f7a2ead">More...</a><br /></td></tr>
<tr class="separator:adf414eb3a145bcd7203fca727f7a2ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090a6a8d699d4eed977ce9fcf028137a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a090a6a8d699d4eed977ce9fcf028137a">OGR_F_SetFieldNull</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a090a6a8d699d4eed977ce9fcf028137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a field, marking it as null.  <a href="#a090a6a8d699d4eed977ce9fcf028137a">More...</a><br /></td></tr>
<tr class="separator:a090a6a8d699d4eed977ce9fcf028137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7043e9dfadbdeca8059ace336875d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af7043e9dfadbdeca8059ace336875d4c">OGR_F_GetRawFieldRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:af7043e9dfadbdeca8059ace336875d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an handle to the internal field value given the index.  <a href="#af7043e9dfadbdeca8059ace336875d4c">More...</a><br /></td></tr>
<tr class="separator:af7043e9dfadbdeca8059ace336875d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23095c63fc350d712940bdbf440bbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae23095c63fc350d712940bdbf440bbcb">OGR_RawField_IsUnset</a> (const <a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:ae23095c63fc350d712940bdbf440bbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a raw field is unset.  <a href="#ae23095c63fc350d712940bdbf440bbcb">More...</a><br /></td></tr>
<tr class="separator:ae23095c63fc350d712940bdbf440bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a401e6dbd5577396b567791cf85115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa9a401e6dbd5577396b567791cf85115">OGR_RawField_IsNull</a> (const <a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:aa9a401e6dbd5577396b567791cf85115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a raw field is null.  <a href="#aa9a401e6dbd5577396b567791cf85115">More...</a><br /></td></tr>
<tr class="separator:aa9a401e6dbd5577396b567791cf85115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaac3d8e8d01fa83a52dd2d95aac0cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acaac3d8e8d01fa83a52dd2d95aac0cc3">OGR_RawField_SetUnset</a> (<a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:acaac3d8e8d01fa83a52dd2d95aac0cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a raw field as unset.  <a href="#acaac3d8e8d01fa83a52dd2d95aac0cc3">More...</a><br /></td></tr>
<tr class="separator:acaac3d8e8d01fa83a52dd2d95aac0cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6c613c24de0e11fe259e86160157d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acf6c613c24de0e11fe259e86160157d3">OGR_RawField_SetNull</a> (<a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:acf6c613c24de0e11fe259e86160157d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a raw field as null.  <a href="#acf6c613c24de0e11fe259e86160157d3">More...</a><br /></td></tr>
<tr class="separator:acf6c613c24de0e11fe259e86160157d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb4d2c0001af379e396021ecbdaf275"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acfb4d2c0001af379e396021ecbdaf275">OGR_F_GetFieldAsInteger</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:acfb4d2c0001af379e396021ecbdaf275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as integer.  <a href="#acfb4d2c0001af379e396021ecbdaf275">More...</a><br /></td></tr>
<tr class="separator:acfb4d2c0001af379e396021ecbdaf275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e190099fd6ee40e206bf4bf74d3b784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0e190099fd6ee40e206bf4bf74d3b784">OGR_F_GetFieldAsInteger64</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a0e190099fd6ee40e206bf4bf74d3b784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as integer 64 bit.  <a href="#a0e190099fd6ee40e206bf4bf74d3b784">More...</a><br /></td></tr>
<tr class="separator:a0e190099fd6ee40e206bf4bf74d3b784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62252a0d4538c695d41956a96cdc6978"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a62252a0d4538c695d41956a96cdc6978">OGR_F_GetFieldAsDouble</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a62252a0d4538c695d41956a96cdc6978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a double.  <a href="#a62252a0d4538c695d41956a96cdc6978">More...</a><br /></td></tr>
<tr class="separator:a62252a0d4538c695d41956a96cdc6978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42acfd1f4b49dddc1c308462ae800c26"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a42acfd1f4b49dddc1c308462ae800c26">OGR_F_GetFieldAsString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a42acfd1f4b49dddc1c308462ae800c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a string.  <a href="#a42acfd1f4b49dddc1c308462ae800c26">More...</a><br /></td></tr>
<tr class="separator:a42acfd1f4b49dddc1c308462ae800c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac671852e05692c584b493b2acbd6b8ce"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac671852e05692c584b493b2acbd6b8ce">OGR_F_GetFieldAsIntegerList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:ac671852e05692c584b493b2acbd6b8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of integers.  <a href="#ac671852e05692c584b493b2acbd6b8ce">More...</a><br /></td></tr>
<tr class="separator:ac671852e05692c584b493b2acbd6b8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df79763bd50aeef2581454bcab51ce6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9df79763bd50aeef2581454bcab51ce6">OGR_F_GetFieldAsInteger64List</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:a9df79763bd50aeef2581454bcab51ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of 64 bit integers.  <a href="#a9df79763bd50aeef2581454bcab51ce6">More...</a><br /></td></tr>
<tr class="separator:a9df79763bd50aeef2581454bcab51ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a27f74a38506ac492ec8b6e00eb58c9"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4a27f74a38506ac492ec8b6e00eb58c9">OGR_F_GetFieldAsDoubleList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:a4a27f74a38506ac492ec8b6e00eb58c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of doubles.  <a href="#a4a27f74a38506ac492ec8b6e00eb58c9">More...</a><br /></td></tr>
<tr class="separator:a4a27f74a38506ac492ec8b6e00eb58c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e55ba4a06d4c4a392206518b390ac38"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3e55ba4a06d4c4a392206518b390ac38">OGR_F_GetFieldAsStringList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a3e55ba4a06d4c4a392206518b390ac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of strings.  <a href="#a3e55ba4a06d4c4a392206518b390ac38">More...</a><br /></td></tr>
<tr class="separator:a3e55ba4a06d4c4a392206518b390ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72727f2f59d1defa01cedfb884df1a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a72727f2f59d1defa01cedfb884df1a09">OGR_F_GetFieldAsBinary</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:a72727f2f59d1defa01cedfb884df1a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as binary.  <a href="#a72727f2f59d1defa01cedfb884df1a09">More...</a><br /></td></tr>
<tr class="separator:a72727f2f59d1defa01cedfb884df1a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ca681bb6099eb8c18004d1f7112d95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a47ca681bb6099eb8c18004d1f7112d95">OGR_F_GetFieldAsDateTime</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *, int *, int *, int *, int *, int *, int *)</td></tr>
<tr class="memdesc:a47ca681bb6099eb8c18004d1f7112d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as date and time.  <a href="#a47ca681bb6099eb8c18004d1f7112d95">More...</a><br /></td></tr>
<tr class="separator:a47ca681bb6099eb8c18004d1f7112d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748995fa28574b25f6b723013a405a8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a748995fa28574b25f6b723013a405a8f">OGR_F_GetFieldAsDateTimeEx</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField, int *pnYear, int *pnMonth, int *pnDay, int *pnHour, int *pnMinute, float *pfSecond, int *pnTZFlag)</td></tr>
<tr class="memdesc:a748995fa28574b25f6b723013a405a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as date and time.  <a href="#a748995fa28574b25f6b723013a405a8f">More...</a><br /></td></tr>
<tr class="separator:a748995fa28574b25f6b723013a405a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902fb7c7fe459aacf0b2c26b8e6d1ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad902fb7c7fe459aacf0b2c26b8e6d1ee">OGR_F_SetFieldInteger</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int)</td></tr>
<tr class="memdesc:ad902fb7c7fe459aacf0b2c26b8e6d1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to integer value.  <a href="#ad902fb7c7fe459aacf0b2c26b8e6d1ee">More...</a><br /></td></tr>
<tr class="separator:ad902fb7c7fe459aacf0b2c26b8e6d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c95abf476d0ad250eb7499627f0e3b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1c95abf476d0ad250eb7499627f0e3b1">OGR_F_SetFieldInteger64</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:a1c95abf476d0ad250eb7499627f0e3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to 64 bit integer value.  <a href="#a1c95abf476d0ad250eb7499627f0e3b1">More...</a><br /></td></tr>
<tr class="separator:a1c95abf476d0ad250eb7499627f0e3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28aa13b1b7c88f07066c36286d13b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d28aa13b1b7c88f07066c36286d13b9">OGR_F_SetFieldDouble</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, double)</td></tr>
<tr class="memdesc:a9d28aa13b1b7c88f07066c36286d13b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to double value.  <a href="#a9d28aa13b1b7c88f07066c36286d13b9">More...</a><br /></td></tr>
<tr class="separator:a9d28aa13b1b7c88f07066c36286d13b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a3e8b4a08f9558807389bcdde85bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad1a3e8b4a08f9558807389bcdde85bab">OGR_F_SetFieldString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, const char *)</td></tr>
<tr class="memdesc:ad1a3e8b4a08f9558807389bcdde85bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to string value.  <a href="#ad1a3e8b4a08f9558807389bcdde85bab">More...</a><br /></td></tr>
<tr class="separator:ad1a3e8b4a08f9558807389bcdde85bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c8595693b4e94f3be5f796e6f7c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a984c8595693b4e94f3be5f796e6f7c92">OGR_F_SetFieldIntegerList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const int *)</td></tr>
<tr class="memdesc:a984c8595693b4e94f3be5f796e6f7c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of integers value.  <a href="#a984c8595693b4e94f3be5f796e6f7c92">More...</a><br /></td></tr>
<tr class="separator:a984c8595693b4e94f3be5f796e6f7c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7538949a9e8b85920381809fadbe897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af7538949a9e8b85920381809fadbe897">OGR_F_SetFieldInteger64List</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> *)</td></tr>
<tr class="memdesc:af7538949a9e8b85920381809fadbe897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of 64 bit integers value.  <a href="#af7538949a9e8b85920381809fadbe897">More...</a><br /></td></tr>
<tr class="separator:af7538949a9e8b85920381809fadbe897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a56d01128bf247016c139faed157be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a83a56d01128bf247016c139faed157be">OGR_F_SetFieldDoubleList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const double *)</td></tr>
<tr class="memdesc:a83a56d01128bf247016c139faed157be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of doubles value.  <a href="#a83a56d01128bf247016c139faed157be">More...</a><br /></td></tr>
<tr class="separator:a83a56d01128bf247016c139faed157be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dd76723ae1acc91135054e64d7598e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a35dd76723ae1acc91135054e64d7598e">OGR_F_SetFieldStringList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:a35dd76723ae1acc91135054e64d7598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of strings value.  <a href="#a35dd76723ae1acc91135054e64d7598e">More...</a><br /></td></tr>
<tr class="separator:a35dd76723ae1acc91135054e64d7598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cfe4f766f5579f670bb651c53a99ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af3cfe4f766f5579f670bb651c53a99ca">OGR_F_SetFieldRaw</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, <a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:af3cfe4f766f5579f670bb651c53a99ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field.  <a href="#af3cfe4f766f5579f670bb651c53a99ca">More...</a><br /></td></tr>
<tr class="separator:af3cfe4f766f5579f670bb651c53a99ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348b1423e9ae34290f2e32f3bdf8154b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a348b1423e9ae34290f2e32f3bdf8154b">OGR_F_SetFieldBinary</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const void *)</td></tr>
<tr class="memdesc:a348b1423e9ae34290f2e32f3bdf8154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to binary data.  <a href="#a348b1423e9ae34290f2e32f3bdf8154b">More...</a><br /></td></tr>
<tr class="separator:a348b1423e9ae34290f2e32f3bdf8154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627970180a20e2a4b1c7ae694923fd73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a627970180a20e2a4b1c7ae694923fd73">OGR_F_SetFieldDateTime</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, int, int, int, int, int, int)</td></tr>
<tr class="memdesc:a627970180a20e2a4b1c7ae694923fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to datetime.  <a href="#a627970180a20e2a4b1c7ae694923fd73">More...</a><br /></td></tr>
<tr class="separator:a627970180a20e2a4b1c7ae694923fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e1bc23b8a31553550775a212075da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a71e1bc23b8a31553550775a212075da3">OGR_F_SetFieldDateTimeEx</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, int, int, int, int, float, int)</td></tr>
<tr class="memdesc:a71e1bc23b8a31553550775a212075da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to datetime.  <a href="#a71e1bc23b8a31553550775a212075da3">More...</a><br /></td></tr>
<tr class="separator:a71e1bc23b8a31553550775a212075da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7975076d4ab247189487c0fd50d8365c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7975076d4ab247189487c0fd50d8365c">OGR_F_GetGeomFieldCount</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat)</td></tr>
<tr class="memdesc:a7975076d4ab247189487c0fd50d8365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.  <a href="#a7975076d4ab247189487c0fd50d8365c">More...</a><br /></td></tr>
<tr class="separator:a7975076d4ab247189487c0fd50d8365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c3d59a3854dad80c4257e788c5d881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a11c3d59a3854dad80c4257e788c5d881">OGR_F_GetGeomFieldDefnRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField)</td></tr>
<tr class="memdesc:a11c3d59a3854dad80c4257e788c5d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch definition for this geometry field.  <a href="#a11c3d59a3854dad80c4257e788c5d881">More...</a><br /></td></tr>
<tr class="separator:a11c3d59a3854dad80c4257e788c5d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546acd0aad47128b1f178a8d01765e63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a546acd0aad47128b1f178a8d01765e63">OGR_F_GetGeomFieldIndex</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, const char *pszName)</td></tr>
<tr class="memdesc:a546acd0aad47128b1f178a8d01765e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the geometry field index given geometry field name.  <a href="#a546acd0aad47128b1f178a8d01765e63">More...</a><br /></td></tr>
<tr class="separator:a546acd0aad47128b1f178a8d01765e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37aa8b53b1fc8816c5b7bcbbcb6a46ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">OGR_F_GetGeomFieldRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField)</td></tr>
<tr class="memdesc:a37aa8b53b1fc8816c5b7bcbbcb6a46ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an handle to feature geometry.  <a href="#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">More...</a><br /></td></tr>
<tr class="separator:a37aa8b53b1fc8816c5b7bcbbcb6a46ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01530e163973979cfd8248e3ecbf2640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a01530e163973979cfd8248e3ecbf2640">OGR_F_SetGeomFieldDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a01530e163973979cfd8248e3ecbf2640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry of a specified geometry field.  <a href="#a01530e163973979cfd8248e3ecbf2640">More...</a><br /></td></tr>
<tr class="separator:a01530e163973979cfd8248e3ecbf2640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75b18930385432110aa8d3461854cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad75b18930385432110aa8d3461854cce">OGR_F_SetGeomField</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:ad75b18930385432110aa8d3461854cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry of a specified geometry field.  <a href="#ad75b18930385432110aa8d3461854cce">More...</a><br /></td></tr>
<tr class="separator:ad75b18930385432110aa8d3461854cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc99defd1fb1f8f71ff89c38982f2103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc99defd1fb1f8f71ff89c38982f2103">OGR_F_GetFID</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:afc99defd1fb1f8f71ff89c38982f2103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get feature identifier.  <a href="#afc99defd1fb1f8f71ff89c38982f2103">More...</a><br /></td></tr>
<tr class="separator:afc99defd1fb1f8f71ff89c38982f2103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf24e93da4c03360d1d2e01664596e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adf24e93da4c03360d1d2e01664596e29">OGR_F_SetFID</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:adf24e93da4c03360d1d2e01664596e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the feature identifier.  <a href="#adf24e93da4c03360d1d2e01664596e29">More...</a><br /></td></tr>
<tr class="separator:adf24e93da4c03360d1d2e01664596e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38d330f942798fcbaaf27e5807fb567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae38d330f942798fcbaaf27e5807fb567">OGR_F_DumpReadable</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, FILE *)</td></tr>
<tr class="memdesc:ae38d330f942798fcbaaf27e5807fb567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this feature in a human readable form.  <a href="#ae38d330f942798fcbaaf27e5807fb567">More...</a><br /></td></tr>
<tr class="separator:ae38d330f942798fcbaaf27e5807fb567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f7057a7a3764c526a4a59e2b587fba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba">OGR_F_SetFrom</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:ad7f7057a7a3764c526a4a59e2b587fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one feature from another.  <a href="#ad7f7057a7a3764c526a4a59e2b587fba">More...</a><br /></td></tr>
<tr class="separator:ad7f7057a7a3764c526a4a59e2b587fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1b7383891a47387a9b48cb02918fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9c1b7383891a47387a9b48cb02918fde">OGR_F_SetFromWithMap</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, const int *)</td></tr>
<tr class="memdesc:a9c1b7383891a47387a9b48cb02918fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one feature from another.  <a href="#a9c1b7383891a47387a9b48cb02918fde">More...</a><br /></td></tr>
<tr class="separator:a9c1b7383891a47387a9b48cb02918fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fb5f53d99ccf46280e4c38afe4a5a5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a10fb5f53d99ccf46280e4c38afe4a5a5">OGR_F_GetStyleString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a10fb5f53d99ccf46280e4c38afe4a5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch style string for this feature.  <a href="#a10fb5f53d99ccf46280e4c38afe4a5a5">More...</a><br /></td></tr>
<tr class="separator:a10fb5f53d99ccf46280e4c38afe4a5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe436a7a48ad5bbfb3aa34f44791a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68">OGR_F_SetStyleString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:afbe436a7a48ad5bbfb3aa34f44791a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature style string.  <a href="#afbe436a7a48ad5bbfb3aa34f44791a68">More...</a><br /></td></tr>
<tr class="separator:afbe436a7a48ad5bbfb3aa34f44791a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1ab2f6fb7937a8b927e4c1d3fd057c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c">OGR_F_SetStyleStringDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, char *)</td></tr>
<tr class="memdesc:abc1ab2f6fb7937a8b927e4c1d3fd057c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature style string.  <a href="#abc1ab2f6fb7937a8b927e4c1d3fd057c">More...</a><br /></td></tr>
<tr class="separator:abc1ab2f6fb7937a8b927e4c1d3fd057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f3bde7b0fe8c5db80d747c5e89d028"><td class="memItemLeft" align="right" valign="top"><a id="a82f3bde7b0fe8c5db80d747c5e89d028"></a>
<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a82f3bde7b0fe8c5db80d747c5e89d028">OGR_F_GetStyleTable</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a82f3bde7b0fe8c5db80d747c5e89d028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return style table. <br /></td></tr>
<tr class="separator:a82f3bde7b0fe8c5db80d747c5e89d028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a936b7f094f4d1047704417465a7279"><td class="memItemLeft" align="right" valign="top"><a id="a2a936b7f094f4d1047704417465a7279"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a936b7f094f4d1047704417465a7279">OGR_F_SetStyleTableDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:a2a936b7f094f4d1047704417465a7279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table and take ownership. <br /></td></tr>
<tr class="separator:a2a936b7f094f4d1047704417465a7279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10c6fd7cce64e03433af2e2ec52676c"><td class="memItemLeft" align="right" valign="top"><a id="aa10c6fd7cce64e03433af2e2ec52676c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa10c6fd7cce64e03433af2e2ec52676c">OGR_F_SetStyleTable</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:aa10c6fd7cce64e03433af2e2ec52676c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table. <br /></td></tr>
<tr class="separator:aa10c6fd7cce64e03433af2e2ec52676c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3737dec6492741cd11c1767e04edec1f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3737dec6492741cd11c1767e04edec1f">OGR_F_GetNativeData</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a3737dec6492741cd11c1767e04edec1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the native data for the feature.  <a href="#a3737dec6492741cd11c1767e04edec1f">More...</a><br /></td></tr>
<tr class="separator:a3737dec6492741cd11c1767e04edec1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0f1eb5d248e1d2131b877026cb2a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeb0f1eb5d248e1d2131b877026cb2a8a">OGR_F_SetNativeData</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:aeb0f1eb5d248e1d2131b877026cb2a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the native data for the feature.  <a href="#aeb0f1eb5d248e1d2131b877026cb2a8a">More...</a><br /></td></tr>
<tr class="separator:aeb0f1eb5d248e1d2131b877026cb2a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfe5e7897623a97a2bdc0ec32323fa6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6">OGR_F_GetNativeMediaType</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:abcfe5e7897623a97a2bdc0ec32323fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the native media type for the feature.  <a href="#abcfe5e7897623a97a2bdc0ec32323fa6">More...</a><br /></td></tr>
<tr class="separator:abcfe5e7897623a97a2bdc0ec32323fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5e7ec78caaa3d0c65acb662fa6161d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5e5e7ec78caaa3d0c65acb662fa6161d">OGR_F_SetNativeMediaType</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:a5e5e7ec78caaa3d0c65acb662fa6161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the native media type for the feature.  <a href="#a5e5e7ec78caaa3d0c65acb662fa6161d">More...</a><br /></td></tr>
<tr class="separator:a5e5e7ec78caaa3d0c65acb662fa6161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac705f1d608d5e33d03851a7639fdfa1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac705f1d608d5e33d03851a7639fdfa1f">OGR_F_FillUnsetWithDefault</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int bNotNullableOnly, char **papszOptions)</td></tr>
<tr class="memdesc:ac705f1d608d5e33d03851a7639fdfa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill unset fields with default values that might be defined.  <a href="#ac705f1d608d5e33d03851a7639fdfa1f">More...</a><br /></td></tr>
<tr class="separator:ac705f1d608d5e33d03851a7639fdfa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab798c73a20f4b311026232badda9701d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab798c73a20f4b311026232badda9701d">OGR_F_Validate</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int nValidateFlags, int bEmitError)</td></tr>
<tr class="memdesc:ab798c73a20f4b311026232badda9701d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate that a feature meets constraints of its schema.  <a href="#ab798c73a20f4b311026232badda9701d">More...</a><br /></td></tr>
<tr class="separator:ab798c73a20f4b311026232badda9701d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88facf4f8e8b32278101d52ae094255c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c">OGR_L_GetName</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a88facf4f8e8b32278101d52ae094255c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer name.  <a href="#a88facf4f8e8b32278101d52ae094255c">More...</a><br /></td></tr>
<tr class="separator:a88facf4f8e8b32278101d52ae094255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adea8ce1ca795ce0a6a76505f90f078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078">OGR_L_GetGeomType</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a0adea8ce1ca795ce0a6a76505f90f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer geometry type.  <a href="#a0adea8ce1ca795ce0a6a76505f90f078">More...</a><br /></td></tr>
<tr class="separator:a0adea8ce1ca795ce0a6a76505f90f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d61f311c9f8c172ad118659358c60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a">OGR_L_GetSpatialFilter</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a36d61f311c9f8c172ad118659358c60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current spatial filter for this layer.  <a href="#a36d61f311c9f8c172ad118659358c60a">More...</a><br /></td></tr>
<tr class="separator:a36d61f311c9f8c172ad118659358c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d1735bc82533614ac005691d1138c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c">OGR_L_SetSpatialFilter</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a678d1735bc82533614ac005691d1138c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a678d1735bc82533614ac005691d1138c">More...</a><br /></td></tr>
<tr class="separator:a678d1735bc82533614ac005691d1138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cba569e0779a02a95327f041d9f7a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13">OGR_L_SetSpatialFilterRect</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, double, double, double, double)</td></tr>
<tr class="memdesc:a5cba569e0779a02a95327f041d9f7a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#a5cba569e0779a02a95327f041d9f7a13">More...</a><br /></td></tr>
<tr class="separator:a5cba569e0779a02a95327f041d9f7a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c8a1a968542d389f86ed1b4edd5823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823">OGR_L_SetSpatialFilterEx</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iGeomField, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a00c8a1a968542d389f86ed1b4edd5823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a00c8a1a968542d389f86ed1b4edd5823">More...</a><br /></td></tr>
<tr class="separator:a00c8a1a968542d389f86ed1b4edd5823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489241dfe65d6e089809d3258c4f79f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5">OGR_L_SetSpatialFilterRectEx</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr class="memdesc:a489241dfe65d6e089809d3258c4f79f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#a489241dfe65d6e089809d3258c4f79f5">More...</a><br /></td></tr>
<tr class="separator:a489241dfe65d6e089809d3258c4f79f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000d426bf26ad7cc7d4012634c93f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09">OGR_L_SetAttributeFilter</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *)</td></tr>
<tr class="memdesc:a4000d426bf26ad7cc7d4012634c93f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new attribute query.  <a href="#a4000d426bf26ad7cc7d4012634c93f09">More...</a><br /></td></tr>
<tr class="separator:a4000d426bf26ad7cc7d4012634c93f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0383004bf637171648a9d03a80f15a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4">OGR_L_ResetReading</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:ab0383004bf637171648a9d03a80f15a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset feature reading to start on the first feature.  <a href="#ab0383004bf637171648a9d03a80f15a4">More...</a><br /></td></tr>
<tr class="separator:ab0383004bf637171648a9d03a80f15a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6ef6b70fee9f8cea92cb7a0236fcdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb">OGR_L_GetNextFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a4f6ef6b70fee9f8cea92cb7a0236fcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the next available feature from this layer.  <a href="#a4f6ef6b70fee9f8cea92cb7a0236fcdb">More...</a><br /></td></tr>
<tr class="separator:a4f6ef6b70fee9f8cea92cb7a0236fcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4427a82ea3de3bed7acff19b6e8e33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b4427a82ea3de3bed7acff19b6e8e33">OGR_L_SetNextByIndex</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:a8b4427a82ea3de3bed7acff19b6e8e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move read cursor to the nIndex'th feature in the current resultset.  <a href="#a8b4427a82ea3de3bed7acff19b6e8e33">More...</a><br /></td></tr>
<tr class="separator:a8b4427a82ea3de3bed7acff19b6e8e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdad5bebd6b71d136ce21e70ef4c63c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abdad5bebd6b71d136ce21e70ef4c63c7">OGR_L_GetFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:abdad5bebd6b71d136ce21e70ef4c63c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a feature by its identifier.  <a href="#abdad5bebd6b71d136ce21e70ef4c63c7">More...</a><br /></td></tr>
<tr class="separator:abdad5bebd6b71d136ce21e70ef4c63c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cccc8cad9a106ee23628ddf6ef6ece4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4">OGR_L_SetFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2cccc8cad9a106ee23628ddf6ef6ece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite an existing feature.  <a href="#a2cccc8cad9a106ee23628ddf6ef6ece4">More...</a><br /></td></tr>
<tr class="separator:a2cccc8cad9a106ee23628ddf6ef6ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5009bc8d78d7f00e2745f3e3ad133779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779">OGR_L_CreateFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a5009bc8d78d7f00e2745f3e3ad133779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="#a5009bc8d78d7f00e2745f3e3ad133779">More...</a><br /></td></tr>
<tr class="separator:a5009bc8d78d7f00e2745f3e3ad133779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a575c6bc193aee66e5c8d91eb170bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8a575c6bc193aee66e5c8d91eb170bde">OGR_L_DeleteFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a8a575c6bc193aee66e5c8d91eb170bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete feature from layer.  <a href="#a8a575c6bc193aee66e5c8d91eb170bde">More...</a><br /></td></tr>
<tr class="separator:a8a575c6bc193aee66e5c8d91eb170bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b67ea4ab5892c6720460dc7f66eca2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d">OGR_L_GetLayerDefn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a7b67ea4ab5892c6720460dc7f66eca2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the schema information for this layer.  <a href="#a7b67ea4ab5892c6720460dc7f66eca2d">More...</a><br /></td></tr>
<tr class="separator:a7b67ea4ab5892c6720460dc7f66eca2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2a10085f410aa84172eba413408c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39">OGR_L_GetSpatialRef</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a8b2a10085f410aa84172eba413408c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the spatial reference system for this layer.  <a href="#a8b2a10085f410aa84172eba413408c39">More...</a><br /></td></tr>
<tr class="separator:a8b2a10085f410aa84172eba413408c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc3cef62be82ec4f811a89b1855cbd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5">OGR_L_FindFieldIndex</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *, int bExactMatch)</td></tr>
<tr class="memdesc:affc3cef62be82ec4f811a89b1855cbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of field in a layer.  <a href="#affc3cef62be82ec4f811a89b1855cbd5">More...</a><br /></td></tr>
<tr class="separator:affc3cef62be82ec4f811a89b1855cbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08524b6961e52e1561308d2b0c598fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a08524b6961e52e1561308d2b0c598fb2">OGR_L_GetFeatureCount</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int)</td></tr>
<tr class="memdesc:a08524b6961e52e1561308d2b0c598fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the feature count in this layer.  <a href="#a08524b6961e52e1561308d2b0c598fb2">More...</a><br /></td></tr>
<tr class="separator:a08524b6961e52e1561308d2b0c598fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c495581900c8301dff91d8cd3ee12f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f">OGR_L_GetExtent</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *, int)</td></tr>
<tr class="memdesc:aa6c495581900c8301dff91d8cd3ee12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer.  <a href="#aa6c495581900c8301dff91d8cd3ee12f">More...</a><br /></td></tr>
<tr class="separator:aa6c495581900c8301dff91d8cd3ee12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dbfd4443c80dca0d93574f0c00d376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376">OGR_L_GetExtentEx</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iGeomField, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce)</td></tr>
<tr class="memdesc:ac3dbfd4443c80dca0d93574f0c00d376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer, on the specified geometry field.  <a href="#ac3dbfd4443c80dca0d93574f0c00d376">More...</a><br /></td></tr>
<tr class="separator:ac3dbfd4443c80dca0d93574f0c00d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480adc8b839b04597f49583371d366fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd">OGR_L_TestCapability</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *)</td></tr>
<tr class="memdesc:a480adc8b839b04597f49583371d366fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this layer supported the named capability.  <a href="#a480adc8b839b04597f49583371d366fd">More...</a><br /></td></tr>
<tr class="separator:a480adc8b839b04597f49583371d366fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab585ef1166c61c4819f7fd46ee4a275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275">OGR_L_CreateField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, int)</td></tr>
<tr class="memdesc:aab585ef1166c61c4819f7fd46ee4a275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field on a layer.  <a href="#aab585ef1166c61c4819f7fd46ee4a275">More...</a><br /></td></tr>
<tr class="separator:aab585ef1166c61c4819f7fd46ee4a275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6908931c4f3ad364fef8d6e831363bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc">OGR_L_CreateGeomField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, <a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hFieldDefn, int bForce)</td></tr>
<tr class="memdesc:af6908931c4f3ad364fef8d6e831363bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new geometry field on a layer.  <a href="#af6908931c4f3ad364fef8d6e831363bc">More...</a><br /></td></tr>
<tr class="separator:af6908931c4f3ad364fef8d6e831363bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc861413683418eba5d31e487da2f9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2">OGR_L_DeleteField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iField)</td></tr>
<tr class="memdesc:afc861413683418eba5d31e487da2f9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing field on a layer.  <a href="#afc861413683418eba5d31e487da2f9e2">More...</a><br /></td></tr>
<tr class="separator:afc861413683418eba5d31e487da2f9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc576cb39e1dd4a1f074125199245bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb">OGR_L_ReorderFields</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int *panMap)</td></tr>
<tr class="memdesc:a4cc576cb39e1dd4a1f074125199245bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder all the fields of a layer.  <a href="#a4cc576cb39e1dd4a1f074125199245bb">More...</a><br /></td></tr>
<tr class="separator:a4cc576cb39e1dd4a1f074125199245bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20a3796ee63935285976ee425878927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927">OGR_L_ReorderField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iOldFieldPos, int iNewFieldPos)</td></tr>
<tr class="memdesc:ad20a3796ee63935285976ee425878927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder an existing field on a layer.  <a href="#ad20a3796ee63935285976ee425878927">More...</a><br /></td></tr>
<tr class="separator:ad20a3796ee63935285976ee425878927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679904d97c1084f309706ac3c6228cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec">OGR_L_AlterFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iField, <a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hNewFieldDefn, int nFlags)</td></tr>
<tr class="memdesc:a679904d97c1084f309706ac3c6228cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the definition of an existing field on a layer.  <a href="#a679904d97c1084f309706ac3c6228cec">More...</a><br /></td></tr>
<tr class="separator:a679904d97c1084f309706ac3c6228cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab709fc5cdd7a204fe0220e898a981d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab709fc5cdd7a204fe0220e898a981d85">OGR_L_StartTransaction</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ab709fc5cdd7a204fe0220e898a981d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, StartTransaction creates a transaction.  <a href="#ab709fc5cdd7a204fe0220e898a981d85">More...</a><br /></td></tr>
<tr class="separator:ab709fc5cdd7a204fe0220e898a981d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f2e9557624952c68eaa46d272bd806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6f2e9557624952c68eaa46d272bd806">OGR_L_CommitTransaction</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aa6f2e9557624952c68eaa46d272bd806"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, CommitTransaction commits a transaction.  <a href="#aa6f2e9557624952c68eaa46d272bd806">More...</a><br /></td></tr>
<tr class="separator:aa6f2e9557624952c68eaa46d272bd806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823a6c351dccf751777f67801dd7f9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5">OGR_L_RollbackTransaction</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a823a6c351dccf751777f67801dd7f9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction.  <a href="#a823a6c351dccf751777f67801dd7f9c5">More...</a><br /></td></tr>
<tr class="separator:a823a6c351dccf751777f67801dd7f9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d845a6cf6652756925530418905471a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a">OGR_L_SyncToDisk</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a9d845a6cf6652756925530418905471a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending changes to disk.  <a href="#a9d845a6cf6652756925530418905471a">More...</a><br /></td></tr>
<tr class="separator:a9d845a6cf6652756925530418905471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeb6e1258f113c6c45c8d6a43c8cfa5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5">OGR_L_GetFIDColumn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:abfeb6e1258f113c6c45c8d6a43c8cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the FID column, or "" if not supported.  <a href="#abfeb6e1258f113c6c45c8d6a43c8cfa5">More...</a><br /></td></tr>
<tr class="separator:abfeb6e1258f113c6c45c8d6a43c8cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab060e07e277cebd1d8504c449d97b29f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f">OGR_L_GetGeometryColumn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:ab060e07e277cebd1d8504c449d97b29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the geometry column, or "" if not supported.  <a href="#ab060e07e277cebd1d8504c449d97b29f">More...</a><br /></td></tr>
<tr class="separator:ab060e07e277cebd1d8504c449d97b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceae9ba8158efda9d1bd016022c627ca"><td class="memItemLeft" align="right" valign="top"><a id="aceae9ba8158efda9d1bd016022c627ca"></a>
<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aceae9ba8158efda9d1bd016022c627ca">OGR_L_GetStyleTable</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:aceae9ba8158efda9d1bd016022c627ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get style table. <br /></td></tr>
<tr class="separator:aceae9ba8158efda9d1bd016022c627ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b700a54fb41ade2b3b090b2e0ef4be"><td class="memItemLeft" align="right" valign="top"><a id="ab6b700a54fb41ade2b3b090b2e0ef4be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab6b700a54fb41ade2b3b090b2e0ef4be">OGR_L_SetStyleTableDirectly</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:ab6b700a54fb41ade2b3b090b2e0ef4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table (and take ownership) <br /></td></tr>
<tr class="separator:ab6b700a54fb41ade2b3b090b2e0ef4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5965608098528549e585895cb62e92"><td class="memItemLeft" align="right" valign="top"><a id="a9c5965608098528549e585895cb62e92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9c5965608098528549e585895cb62e92">OGR_L_SetStyleTable</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:a9c5965608098528549e585895cb62e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table. <br /></td></tr>
<tr class="separator:a9c5965608098528549e585895cb62e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d43f1474201356bed2e6f92e7d37154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154">OGR_L_SetIgnoredFields</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char **)</td></tr>
<tr class="memdesc:a6d43f1474201356bed2e6f92e7d37154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which fields can be omitted when retrieving features from the layer.  <a href="#a6d43f1474201356bed2e6f92e7d37154">More...</a><br /></td></tr>
<tr class="separator:a6d43f1474201356bed2e6f92e7d37154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c353cc32c9dd02967a7bed1450d2524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524">OGR_L_Intersection</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a5c353cc32c9dd02967a7bed1450d2524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two layers.  <a href="#a5c353cc32c9dd02967a7bed1450d2524">More...</a><br /></td></tr>
<tr class="separator:a5c353cc32c9dd02967a7bed1450d2524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8edb8696c2b046370e29efdd73787f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7">OGR_L_Union</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:ac8edb8696c2b046370e29efdd73787f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two layers.  <a href="#ac8edb8696c2b046370e29efdd73787f7">More...</a><br /></td></tr>
<tr class="separator:ac8edb8696c2b046370e29efdd73787f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03249311ff4c88b2fac5f728be63b549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549">OGR_L_SymDifference</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a03249311ff4c88b2fac5f728be63b549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrical difference of two layers.  <a href="#a03249311ff4c88b2fac5f728be63b549">More...</a><br /></td></tr>
<tr class="separator:a03249311ff4c88b2fac5f728be63b549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67948074f2e2942cebdd0f90bbec8aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9">OGR_L_Identity</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a67948074f2e2942cebdd0f90bbec8aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the features of this layer with the ones from the identity layer.  <a href="#a67948074f2e2942cebdd0f90bbec8aa9">More...</a><br /></td></tr>
<tr class="separator:a67948074f2e2942cebdd0f90bbec8aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b478c971619145dee7d8d8deeac702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702">OGR_L_Update</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a87b478c971619145dee7d8d8deeac702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update this layer with features from the update layer.  <a href="#a87b478c971619145dee7d8d8deeac702">More...</a><br /></td></tr>
<tr class="separator:a87b478c971619145dee7d8d8deeac702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12dcd5dc6dc5f930218573658f1b5c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2">OGR_L_Clip</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:ae12dcd5dc6dc5f930218573658f1b5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip off areas that are not covered by the method layer.  <a href="#ae12dcd5dc6dc5f930218573658f1b5c2">More...</a><br /></td></tr>
<tr class="separator:ae12dcd5dc6dc5f930218573658f1b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c47bbeae70e609f4e51a239784285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285">OGR_L_Erase</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a0f8c47bbeae70e609f4e51a239784285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove areas that are covered by the method layer.  <a href="#a0f8c47bbeae70e609f4e51a239784285">More...</a><br /></td></tr>
<tr class="separator:a0f8c47bbeae70e609f4e51a239784285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4823e7c3513cd9d57254364de9a1d021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021">OGR_DS_Destroy</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a4823e7c3513cd9d57254364de9a1d021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes opened datasource and releases allocated resources.  <a href="#a4823e7c3513cd9d57254364de9a1d021">More...</a><br /></td></tr>
<tr class="separator:a4823e7c3513cd9d57254364de9a1d021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8cc826474b55371b1b4e24a24ba1db"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aea8cc826474b55371b1b4e24a24ba1db">OGR_DS_GetName</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:aea8cc826474b55371b1b4e24a24ba1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the data source.  <a href="#aea8cc826474b55371b1b4e24a24ba1db">More...</a><br /></td></tr>
<tr class="separator:aea8cc826474b55371b1b4e24a24ba1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da541cb655ab631df729e71da2e762"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762">OGR_DS_GetLayerCount</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:ac6da541cb655ab631df729e71da2e762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of layers in this data source.  <a href="#ac6da541cb655ab631df729e71da2e762">More...</a><br /></td></tr>
<tr class="separator:ac6da541cb655ab631df729e71da2e762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03998029f904d1c3b12de40114e7503e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03998029f904d1c3b12de40114e7503e">OGR_DS_GetLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, int)</td></tr>
<tr class="memdesc:a03998029f904d1c3b12de40114e7503e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a layer by index.  <a href="#a03998029f904d1c3b12de40114e7503e">More...</a><br /></td></tr>
<tr class="separator:a03998029f904d1c3b12de40114e7503e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74af4912b67bf2a7b6e3230711a40d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a74af4912b67bf2a7b6e3230711a40d0e">OGR_DS_GetLayerByName</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *)</td></tr>
<tr class="memdesc:a74af4912b67bf2a7b6e3230711a40d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a layer by name.  <a href="#a74af4912b67bf2a7b6e3230711a40d0e">More...</a><br /></td></tr>
<tr class="separator:a74af4912b67bf2a7b6e3230711a40d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85827a79cd2ddb5a55126e785bee427d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a85827a79cd2ddb5a55126e785bee427d">OGR_DS_DeleteLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, int)</td></tr>
<tr class="memdesc:a85827a79cd2ddb5a55126e785bee427d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the indicated layer from the datasource.  <a href="#a85827a79cd2ddb5a55126e785bee427d">More...</a><br /></td></tr>
<tr class="separator:a85827a79cd2ddb5a55126e785bee427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5def9c0aa6f6f60ab96369203330e326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5def9c0aa6f6f60ab96369203330e326">OGR_DS_GetDriver</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a5def9c0aa6f6f60ab96369203330e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the driver that the dataset was opened with.  <a href="#a5def9c0aa6f6f60ab96369203330e326">More...</a><br /></td></tr>
<tr class="separator:a5def9c0aa6f6f60ab96369203330e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424d383a37fbeaea58acaea11717f320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>, char **)</td></tr>
<tr class="memdesc:a424d383a37fbeaea58acaea11717f320"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type.  <a href="#a424d383a37fbeaea58acaea11717f320">More...</a><br /></td></tr>
<tr class="separator:a424d383a37fbeaea58acaea11717f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d34530517b618696c97b73de31df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a628d34530517b618696c97b73de31df7">OGR_DS_CopyLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *, char **)</td></tr>
<tr class="memdesc:a628d34530517b618696c97b73de31df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an existing layer.  <a href="#a628d34530517b618696c97b73de31df7">More...</a><br /></td></tr>
<tr class="separator:a628d34530517b618696c97b73de31df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fefab726442fa71ab5ef74fe8549a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *)</td></tr>
<tr class="memdesc:ad0fefab726442fa71ab5ef74fe8549a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if capability is available.  <a href="#ad0fefab726442fa71ab5ef74fe8549a6">More...</a><br /></td></tr>
<tr class="separator:ad0fefab726442fa71ab5ef74fe8549a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9892ecb0bf61add295bd9decdb13797a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a">OGR_DS_ExecuteSQL</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, const char *)</td></tr>
<tr class="memdesc:a9892ecb0bf61add295bd9decdb13797a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an SQL statement against the data store.  <a href="#a9892ecb0bf61add295bd9decdb13797a">More...</a><br /></td></tr>
<tr class="separator:a9892ecb0bf61add295bd9decdb13797a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7b521a05c1207e298a2b9dbf4a1181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181">OGR_DS_ReleaseResultSet</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:afc7b521a05c1207e298a2b9dbf4a1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release results of <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store. ">OGR_DS_ExecuteSQL()</a>.  <a href="#afc7b521a05c1207e298a2b9dbf4a1181">More...</a><br /></td></tr>
<tr class="separator:afc7b521a05c1207e298a2b9dbf4a1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139ab189c06d9f5f26e21b134928f882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a139ab189c06d9f5f26e21b134928f882">OGR_DS_SyncToDisk</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a139ab189c06d9f5f26e21b134928f882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending changes to disk.  <a href="#a139ab189c06d9f5f26e21b134928f882">More...</a><br /></td></tr>
<tr class="separator:a139ab189c06d9f5f26e21b134928f882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6164ac434dcd9660089c97fd59bab558"><td class="memItemLeft" align="right" valign="top"><a id="a6164ac434dcd9660089c97fd59bab558"></a>
<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6164ac434dcd9660089c97fd59bab558">OGR_DS_GetStyleTable</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a6164ac434dcd9660089c97fd59bab558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get style table. <br /></td></tr>
<tr class="separator:a6164ac434dcd9660089c97fd59bab558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf553bb35c9f1707b3c727af166c8a0a"><td class="memItemLeft" align="right" valign="top"><a id="aaf553bb35c9f1707b3c727af166c8a0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aaf553bb35c9f1707b3c727af166c8a0a">OGR_DS_SetStyleTableDirectly</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:aaf553bb35c9f1707b3c727af166c8a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table (and take ownership) <br /></td></tr>
<tr class="separator:aaf553bb35c9f1707b3c727af166c8a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03947d4ec069a83526274780c8a6f48b"><td class="memItemLeft" align="right" valign="top"><a id="a03947d4ec069a83526274780c8a6f48b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03947d4ec069a83526274780c8a6f48b">OGR_DS_SetStyleTable</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:a03947d4ec069a83526274780c8a6f48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table. <br /></td></tr>
<tr class="separator:a03947d4ec069a83526274780c8a6f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd11ea603491207a89c75b6b9480e091"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afd11ea603491207a89c75b6b9480e091">OGR_Dr_GetName</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>)</td></tr>
<tr class="memdesc:afd11ea603491207a89c75b6b9480e091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch name of driver (file format).  <a href="#afd11ea603491207a89c75b6b9480e091">More...</a><br /></td></tr>
<tr class="separator:afd11ea603491207a89c75b6b9480e091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464b2210400d91fb9c6fa76595ea3681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a464b2210400d91fb9c6fa76595ea3681">OGR_Dr_Open</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *, int) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a464b2210400d91fb9c6fa76595ea3681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to open file with this driver.  <a href="#a464b2210400d91fb9c6fa76595ea3681">More...</a><br /></td></tr>
<tr class="separator:a464b2210400d91fb9c6fa76595ea3681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9010219bbc2e32627064ed860048d979"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9010219bbc2e32627064ed860048d979">OGR_Dr_TestCapability</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *)</td></tr>
<tr class="memdesc:a9010219bbc2e32627064ed860048d979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if capability is available.  <a href="#a9010219bbc2e32627064ed860048d979">More...</a><br /></td></tr>
<tr class="separator:a9010219bbc2e32627064ed860048d979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b628f8ddc674f72c798829c738bbdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac2b628f8ddc674f72c798829c738bbdd">OGR_Dr_CreateDataSource</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *, char **) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ac2b628f8ddc674f72c798829c738bbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attempts to create a new data source based on the passed driver.  <a href="#ac2b628f8ddc674f72c798829c738bbdd">More...</a><br /></td></tr>
<tr class="separator:ac2b628f8ddc674f72c798829c738bbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94a7a1c0cb226c7ce04e0380a12a44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae94a7a1c0cb226c7ce04e0380a12a44e">OGR_Dr_CopyDataSource</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, <a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *, char **) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ae94a7a1c0cb226c7ce04e0380a12a44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new datasource by copying all the layers from the source datasource.  <a href="#ae94a7a1c0cb226c7ce04e0380a12a44e">More...</a><br /></td></tr>
<tr class="separator:ae94a7a1c0cb226c7ce04e0380a12a44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2314e22acd846e7e31ff5a5c5ec27f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4d2314e22acd846e7e31ff5a5c5ec27f">OGR_Dr_DeleteDataSource</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *)</td></tr>
<tr class="memdesc:a4d2314e22acd846e7e31ff5a5c5ec27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a datasource.  <a href="#a4d2314e22acd846e7e31ff5a5c5ec27f">More...</a><br /></td></tr>
<tr class="separator:a4d2314e22acd846e7e31ff5a5c5ec27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da3630231780d519543d1679c83e62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2da3630231780d519543d1679c83e62f">OGROpen</a> (const char *, int, <a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2da3630231780d519543d1679c83e62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file / data source with one of the registered drivers.  <a href="#a2da3630231780d519543d1679c83e62f">More...</a><br /></td></tr>
<tr class="separator:a2da3630231780d519543d1679c83e62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbd8a95412abe089084c1def2657b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2cbd8a95412abe089084c1def2657b15">OGROpenShared</a> (const char *, int, <a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2cbd8a95412abe089084c1def2657b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with <a class="el" href="ogr__api_8h.html#a2cbd8a95412abe089084c1def2657b15" title="Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with OGROpenShared() ">OGROpenShared()</a>  <a href="#a2cbd8a95412abe089084c1def2657b15">More...</a><br /></td></tr>
<tr class="separator:a2cbd8a95412abe089084c1def2657b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3abed0c3b232fe55a580726536fe6fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad3abed0c3b232fe55a580726536fe6fa">OGRReleaseDataSource</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:ad3abed0c3b232fe55a580726536fe6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource.  <a href="#ad3abed0c3b232fe55a580726536fe6fa">More...</a><br /></td></tr>
<tr class="separator:ad3abed0c3b232fe55a580726536fe6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f6d2bbd269b56a61d1c1841dac2575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad0f6d2bbd269b56a61d1c1841dac2575">OGRGetDriverCount</a> (void)</td></tr>
<tr class="memdesc:ad0f6d2bbd269b56a61d1c1841dac2575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the number of registered drivers.  <a href="#ad0f6d2bbd269b56a61d1c1841dac2575">More...</a><br /></td></tr>
<tr class="separator:ad0f6d2bbd269b56a61d1c1841dac2575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8080605cad5aeef9519c38fe160b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3f8080605cad5aeef9519c38fe160b51">OGRGetDriver</a> (int)</td></tr>
<tr class="memdesc:a3f8080605cad5aeef9519c38fe160b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the indicated driver.  <a href="#a3f8080605cad5aeef9519c38fe160b51">More...</a><br /></td></tr>
<tr class="separator:a3f8080605cad5aeef9519c38fe160b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814db7e2212b9bbb0fd8c361bee11fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae814db7e2212b9bbb0fd8c361bee11fe">OGRGetDriverByName</a> (const char *)</td></tr>
<tr class="memdesc:ae814db7e2212b9bbb0fd8c361bee11fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the indicated driver.  <a href="#ae814db7e2212b9bbb0fd8c361bee11fe">More...</a><br /></td></tr>
<tr class="separator:ae814db7e2212b9bbb0fd8c361bee11fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae904632d0bc86ba5501921ca594e18da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae904632d0bc86ba5501921ca594e18da">OGRRegisterAll</a> (void)</td></tr>
<tr class="memdesc:ae904632d0bc86ba5501921ca594e18da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all drivers.  <a href="#ae904632d0bc86ba5501921ca594e18da">More...</a><br /></td></tr>
<tr class="separator:ae904632d0bc86ba5501921ca594e18da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d5a052ed1046ec85236fe4a92733e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae5d5a052ed1046ec85236fe4a92733e2">OGRCleanupAll</a> (void)</td></tr>
<tr class="memdesc:ae5d5a052ed1046ec85236fe4a92733e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean-up all drivers (including raster ones starting with GDAL 2.0.  <a href="#ae5d5a052ed1046ec85236fe4a92733e2">More...</a><br /></td></tr>
<tr class="separator:ae5d5a052ed1046ec85236fe4a92733e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4d31b48c3c9ea6c1edbe4f0aa65866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aba4d31b48c3c9ea6c1edbe4f0aa65866">OGR_SM_Create</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aba4d31b48c3c9ea6c1edbe4f0aa65866"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRStyleMgr.html" title="This class represents a style manager. ">OGRStyleMgr</a> factory.  <a href="#aba4d31b48c3c9ea6c1edbe4f0aa65866">More...</a><br /></td></tr>
<tr class="separator:aba4d31b48c3c9ea6c1edbe4f0aa65866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474fca7d9327da916305ec1276a57443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a474fca7d9327da916305ec1276a57443">OGR_SM_Destroy</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM)</td></tr>
<tr class="memdesc:a474fca7d9327da916305ec1276a57443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Style Manager.  <a href="#a474fca7d9327da916305ec1276a57443">More...</a><br /></td></tr>
<tr class="separator:a474fca7d9327da916305ec1276a57443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca737ee6586ce8078b52108707b0b6a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afca737ee6586ce8078b52108707b0b6a">OGR_SM_InitFromFeature</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat)</td></tr>
<tr class="memdesc:afca737ee6586ce8078b52108707b0b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize style manager from the style string of a feature.  <a href="#afca737ee6586ce8078b52108707b0b6a">More...</a><br /></td></tr>
<tr class="separator:afca737ee6586ce8078b52108707b0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade49bffec1e796ddf4419f5cbe34fda8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade49bffec1e796ddf4419f5cbe34fda8">OGR_SM_InitStyleString</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, const char *pszStyleString)</td></tr>
<tr class="memdesc:ade49bffec1e796ddf4419f5cbe34fda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize style manager from the style string.  <a href="#ade49bffec1e796ddf4419f5cbe34fda8">More...</a><br /></td></tr>
<tr class="separator:ade49bffec1e796ddf4419f5cbe34fda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad272704a535c0fa8cfd7b097eb4968dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad272704a535c0fa8cfd7b097eb4968dc">OGR_SM_GetPartCount</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, const char *pszStyleString)</td></tr>
<tr class="memdesc:ad272704a535c0fa8cfd7b097eb4968dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of parts in a style.  <a href="#ad272704a535c0fa8cfd7b097eb4968dc">More...</a><br /></td></tr>
<tr class="separator:ad272704a535c0fa8cfd7b097eb4968dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4e04abb6e3c59ed570c62dffc4164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a61d4e04abb6e3c59ed570c62dffc4164">OGR_SM_GetPart</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, int nPartId, const char *pszStyleString)</td></tr>
<tr class="memdesc:a61d4e04abb6e3c59ed570c62dffc4164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a part (style tool) from the current style.  <a href="#a61d4e04abb6e3c59ed570c62dffc4164">More...</a><br /></td></tr>
<tr class="separator:a61d4e04abb6e3c59ed570c62dffc4164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358ec087124f355fca02bf33a1e0027"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af358ec087124f355fca02bf33a1e0027">OGR_SM_AddPart</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, <a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:af358ec087124f355fca02bf33a1e0027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a part (style tool) to the current style.  <a href="#af358ec087124f355fca02bf33a1e0027">More...</a><br /></td></tr>
<tr class="separator:af358ec087124f355fca02bf33a1e0027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358c1558e61951b2e1e338ead8401ad8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a358c1558e61951b2e1e338ead8401ad8">OGR_SM_AddStyle</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, const char *pszStyleName, const char *pszStyleString)</td></tr>
<tr class="memdesc:a358c1558e61951b2e1e338ead8401ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a style to the current style table.  <a href="#a358c1558e61951b2e1e338ead8401ad8">More...</a><br /></td></tr>
<tr class="separator:a358c1558e61951b2e1e338ead8401ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc7bc2b21febd7a78d44727ad7de30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4cc7bc2b21febd7a78d44727ad7de30f">OGR_ST_Create</a> (<a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a> eClassId) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a4cc7bc2b21febd7a78d44727ad7de30f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> factory.  <a href="#a4cc7bc2b21febd7a78d44727ad7de30f">More...</a><br /></td></tr>
<tr class="separator:a4cc7bc2b21febd7a78d44727ad7de30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1ecf398ee062f3f5a297f70244497a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a">OGR_ST_Destroy</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:a5d1ecf398ee062f3f5a297f70244497a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Style Tool.  <a href="#a5d1ecf398ee062f3f5a297f70244497a">More...</a><br /></td></tr>
<tr class="separator:a5d1ecf398ee062f3f5a297f70244497a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8d0ee36b82c9d1d8d1a0e9b36f2d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">OGR_ST_GetType</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:aae8d0ee36b82c9d1d8d1a0e9b36f2d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine type of Style Tool.  <a href="#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">More...</a><br /></td></tr>
<tr class="separator:aae8d0ee36b82c9d1d8d1a0e9b36f2d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb52e40f289848d1f228849b6dae2463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afb52e40f289848d1f228849b6dae2463">OGR_ST_GetUnit</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:afb52e40f289848d1f228849b6dae2463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool units.  <a href="#afb52e40f289848d1f228849b6dae2463">More...</a><br /></td></tr>
<tr class="separator:afb52e40f289848d1f228849b6dae2463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c5b94e6ca32cd53c6a7a9ebc73012c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac9c5b94e6ca32cd53c6a7a9ebc73012c">OGR_ST_SetUnit</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, <a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a> eUnit, double dfGroundPaperScale)</td></tr>
<tr class="memdesc:ac9c5b94e6ca32cd53c6a7a9ebc73012c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool units.  <a href="#ac9c5b94e6ca32cd53c6a7a9ebc73012c">More...</a><br /></td></tr>
<tr class="separator:ac9c5b94e6ca32cd53c6a7a9ebc73012c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecadf5738c3b96093605b352a95869f1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aecadf5738c3b96093605b352a95869f1">OGR_ST_GetParamStr</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int *bValueIsNull)</td></tr>
<tr class="memdesc:aecadf5738c3b96093605b352a95869f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool parameter value as string.  <a href="#aecadf5738c3b96093605b352a95869f1">More...</a><br /></td></tr>
<tr class="separator:aecadf5738c3b96093605b352a95869f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4168832561881cb75dcc7c35935cdd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad4168832561881cb75dcc7c35935cdd3">OGR_ST_GetParamNum</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int *bValueIsNull)</td></tr>
<tr class="memdesc:ad4168832561881cb75dcc7c35935cdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool parameter value as an integer.  <a href="#ad4168832561881cb75dcc7c35935cdd3">More...</a><br /></td></tr>
<tr class="separator:ad4168832561881cb75dcc7c35935cdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96082cdf432271acfa3b3777c3be853b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a96082cdf432271acfa3b3777c3be853b">OGR_ST_GetParamDbl</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int *bValueIsNull)</td></tr>
<tr class="memdesc:a96082cdf432271acfa3b3777c3be853b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool parameter value as a double.  <a href="#a96082cdf432271acfa3b3777c3be853b">More...</a><br /></td></tr>
<tr class="separator:a96082cdf432271acfa3b3777c3be853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e9561d9a62d6f8368d526eb0468b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88e9561d9a62d6f8368d526eb0468b3a">OGR_ST_SetParamStr</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, const char *pszValue)</td></tr>
<tr class="memdesc:a88e9561d9a62d6f8368d526eb0468b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool parameter value from a string.  <a href="#a88e9561d9a62d6f8368d526eb0468b3a">More...</a><br /></td></tr>
<tr class="separator:a88e9561d9a62d6f8368d526eb0468b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0397850aed3282865b444d65d2deb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac0397850aed3282865b444d65d2deb0e">OGR_ST_SetParamNum</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int nValue)</td></tr>
<tr class="memdesc:ac0397850aed3282865b444d65d2deb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool parameter value from an integer.  <a href="#ac0397850aed3282865b444d65d2deb0e">More...</a><br /></td></tr>
<tr class="separator:ac0397850aed3282865b444d65d2deb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764f52f8a72e950d0a5d84b7a7b37fc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a764f52f8a72e950d0a5d84b7a7b37fc8">OGR_ST_SetParamDbl</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, double dfValue)</td></tr>
<tr class="memdesc:a764f52f8a72e950d0a5d84b7a7b37fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool parameter value from a double.  <a href="#a764f52f8a72e950d0a5d84b7a7b37fc8">More...</a><br /></td></tr>
<tr class="separator:a764f52f8a72e950d0a5d84b7a7b37fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4089c70ce3b1cbea0e45c3375d5093f0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4089c70ce3b1cbea0e45c3375d5093f0">OGR_ST_GetStyleString</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:a4089c70ce3b1cbea0e45c3375d5093f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the style string for this Style Tool.  <a href="#a4089c70ce3b1cbea0e45c3375d5093f0">More...</a><br /></td></tr>
<tr class="separator:a4089c70ce3b1cbea0e45c3375d5093f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906f5e2b901413a0ab5fa35d649847fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a906f5e2b901413a0ab5fa35d649847fc">OGR_ST_GetRGBFromString</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, const char *pszColor, int *pnRed, int *pnGreen, int *pnBlue, int *pnAlpha)</td></tr>
<tr class="memdesc:a906f5e2b901413a0ab5fa35d649847fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format.  <a href="#a906f5e2b901413a0ab5fa35d649847fc">More...</a><br /></td></tr>
<tr class="separator:a906f5e2b901413a0ab5fa35d649847fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2d216b17d9f09ad6285ce61dcbe826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9c2d216b17d9f09ad6285ce61dcbe826">OGR_STBL_Create</a> (void) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a9c2d216b17d9f09ad6285ce61dcbe826"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRStyleTable.html" title="This class represents a style table. ">OGRStyleTable</a> factory.  <a href="#a9c2d216b17d9f09ad6285ce61dcbe826">More...</a><br /></td></tr>
<tr class="separator:a9c2d216b17d9f09ad6285ce61dcbe826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf4e22eb7ef07c4a3249c21dce48764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5cf4e22eb7ef07c4a3249c21dce48764">OGR_STBL_Destroy</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hSTBL)</td></tr>
<tr class="memdesc:a5cf4e22eb7ef07c4a3249c21dce48764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Style Table.  <a href="#a5cf4e22eb7ef07c4a3249c21dce48764">More...</a><br /></td></tr>
<tr class="separator:a5cf4e22eb7ef07c4a3249c21dce48764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd2a4f109627f282c42229eaad7cdfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aacd2a4f109627f282c42229eaad7cdfd">OGR_STBL_AddStyle</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszName, const char *pszStyleString)</td></tr>
<tr class="memdesc:aacd2a4f109627f282c42229eaad7cdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new style in the table.  <a href="#aacd2a4f109627f282c42229eaad7cdfd">More...</a><br /></td></tr>
<tr class="separator:aacd2a4f109627f282c42229eaad7cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e3aca0d4f3fefe3dd64da65814dda7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa3e3aca0d4f3fefe3dd64da65814dda7">OGR_STBL_SaveStyleTable</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszFilename)</td></tr>
<tr class="memdesc:aa3e3aca0d4f3fefe3dd64da65814dda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a style table to a file.  <a href="#aa3e3aca0d4f3fefe3dd64da65814dda7">More...</a><br /></td></tr>
<tr class="separator:aa3e3aca0d4f3fefe3dd64da65814dda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed731a5a6fbedde73ed5063d62f3004e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aed731a5a6fbedde73ed5063d62f3004e">OGR_STBL_LoadStyleTable</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszFilename)</td></tr>
<tr class="memdesc:aed731a5a6fbedde73ed5063d62f3004e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a style table from a file.  <a href="#aed731a5a6fbedde73ed5063d62f3004e">More...</a><br /></td></tr>
<tr class="separator:aed731a5a6fbedde73ed5063d62f3004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ca305147b3b5a6c3f5fafaee7bc06a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a57ca305147b3b5a6c3f5fafaee7bc06a">OGR_STBL_Find</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszName)</td></tr>
<tr class="memdesc:a57ca305147b3b5a6c3f5fafaee7bc06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a style string by name.  <a href="#a57ca305147b3b5a6c3f5fafaee7bc06a">More...</a><br /></td></tr>
<tr class="separator:a57ca305147b3b5a6c3f5fafaee7bc06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ccd53d6d374d66d42266b3543509f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a69ccd53d6d374d66d42266b3543509f7">OGR_STBL_ResetStyleStringReading</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable)</td></tr>
<tr class="memdesc:a69ccd53d6d374d66d42266b3543509f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the next style pointer to 0.  <a href="#a69ccd53d6d374d66d42266b3543509f7">More...</a><br /></td></tr>
<tr class="separator:a69ccd53d6d374d66d42266b3543509f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad901a29f17b139108cc6390b9a075e89"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad901a29f17b139108cc6390b9a075e89">OGR_STBL_GetNextStyle</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable)</td></tr>
<tr class="memdesc:ad901a29f17b139108cc6390b9a075e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next style string from the table.  <a href="#ad901a29f17b139108cc6390b9a075e89">More...</a><br /></td></tr>
<tr class="separator:ad901a29f17b139108cc6390b9a075e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8214328c6866f0eb85bba376d94a05e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af8214328c6866f0eb85bba376d94a05e">OGR_STBL_GetLastStyleName</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable)</td></tr>
<tr class="memdesc:af8214328c6866f0eb85bba376d94a05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the style name of the last style string fetched with OGR_STBL_GetNextStyle.  <a href="#af8214328c6866f0eb85bba376d94a05e">More...</a><br /></td></tr>
<tr class="separator:af8214328c6866f0eb85bba376d94a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C API and defines for <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a>, <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes. ">OGRGeometry</a>, and <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a> related classes. </p>
<p>See also: <a class="el" href="ogr__geometry_8h.html" title="Simple feature geometry classes. ">ogr_geometry.h</a>, <a class="el" href="ogr__feature_8h.html" title="Simple feature classes. ">ogr_feature.h</a>, <a class="el" href="ogrsf__frmts_8h.html" title="Classes related to registration of format support, and opening datasets. ">ogrsf_frmts.h</a>, <a class="el" href="ogr__featurestyle_8h.html" title="Simple feature style classes. ">ogr_featurestyle.h</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a261ecc4eb3468bae5f5deaed761f4221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261ecc4eb3468bae5f5deaed761f4221">&#9670;&nbsp;</a></span>OGR_FOR_EACH_FEATURE_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGR_FOR_EACH_FEATURE_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hFeat, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hLayer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">        OGRFeatureH hFeat = CPL_NULLPTR; \</div><div class="line">        OGR_L_ResetReading(hLayer); \</div><div class="line">        while( <span class="keyword">true</span>) \</div><div class="line">        { \</div><div class="line">            if( hFeat ) \</div><div class="line">                OGR_F_Destroy(hFeat); \</div><div class="line">            hFeat = <a class="code" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb">OGR_L_GetNextFeature</a>(hLayer); \</div><div class="line">            if( !hFeat ) \</div><div class="line">                break;</div><div class="ttc" id="ogr__api_8h_html_a4f6ef6b70fee9f8cea92cb7a0236fcdb"><div class="ttname"><a href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb">OGR_L_GetNextFeature</a></div><div class="ttdeci">OGRFeatureH OGR_L_GetNextFeature(OGRLayerH) CPL_WARN_UNUSED_RESULT</div><div class="ttdoc">Fetch the next available feature from this layer. </div><div class="ttdef"><b>Definition:</b> ogrlayer.cpp:541</div></div>
</div><!-- fragment -->
<p>Conveniency macro to iterate over features of a layer. </p>
<p>Typical usage is: </p><pre>
<a class="el" href="ogr__api_8h.html#a261ecc4eb3468bae5f5deaed761f4221" title="Conveniency macro to iterate over features of a layer. ">OGR_FOR_EACH_FEATURE_BEGIN(hFeat, hLayer)</a>
{
     // Do something, including continue, break;
     // Do not explicitly destroy the feature (unless you use return or goto
     // outside of the loop, in which case use OGR_F_Destroy(hFeat))
}
<a class="el" href="ogr__api_8h.html#a7c1c16c3af1f08084b3c261411beaf99" title="End of iterator. ">OGR_FOR_EACH_FEATURE_END(hFeat)</a>
</pre><p>In C++, you might want to use instead range-based loop: </p><pre>
for( auto&amp;&amp; poFeature: poLayer )
{
}
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>variable name for OGRFeatureH. The variable will be declared inside the macro body. </td></tr>
    <tr><td class="paramname">hLayer</td><td>layer to iterate over.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a7c1c16c3af1f08084b3c261411beaf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1c16c3af1f08084b3c261411beaf99">&#9670;&nbsp;</a></span>OGR_FOR_EACH_FEATURE_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGR_FOR_EACH_FEATURE_END</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hFeat</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">} \</div><div class="line">        OGR_F_Destroy(hFeat); \</div><div class="line">    }</div></div><!-- fragment -->
<p>End of iterator. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abfd327453a3ded09dad8dcfa88170dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd327453a3ded09dad8dcfa88170dbb">&#9670;&nbsp;</a></span>OGRGeomTransformerH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct OGRGeomTransformer* <a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a geometry transformer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3f3caffcd90d58c859cb51adef4c6c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3caffcd90d58c859cb51adef4c6c5d">&#9670;&nbsp;</a></span>OGR_AreTypeSubTypeCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_AreTypeSubTypeCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eSubType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if type and subtype are compatible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eType</td><td>the field type. </td></tr>
    <tr><td class="paramname">eSubType</td><td>the field subtype. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if type and subtype are compatible</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ae94a7a1c0cb226c7ce04e0380a12a44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94a7a1c0cb226c7ce04e0380a12a44e">&#9670;&nbsp;</a></span>OGR_Dr_CopyDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGR_Dr_CopyDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new datasource by copying all the layers from the source datasource. </p>
<p>It is important to call <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources. ">OGR_DS_Destroy()</a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a7e30145de0c454cb6c0661cfff12ee69" title="Create a copy of a dataset. ">GDALCreateCopy()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver on which data source creation is based. </td></tr>
    <tr><td class="paramname">hSrcDS</td><td>source datasource </td></tr>
    <tr><td class="paramname">pszNewName</td><td>the name for the new data source. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a> handle on success. </dd></dl>

</div>
</div>
<a id="ac2b628f8ddc674f72c798829c738bbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b628f8ddc674f72c798829c738bbdd">&#9670;&nbsp;</a></span>OGR_Dr_CreateDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGR_Dr_CreateDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attempts to create a new data source based on the passed driver. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<p>It is important to call <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources. ">OGR_DS_Destroy()</a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a791083781fefae0bb4b289c4b1b838e9" title="Create a new dataset with this driver. ">GDALCreate()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver on which data source creation is based. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name for the new data source. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a> handle on success. </dd></dl>

</div>
</div>
<a id="a4d2314e22acd846e7e31ff5a5c5ec27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2314e22acd846e7e31ff5a5c5ec27f">&#9670;&nbsp;</a></span>OGR_Dr_DeleteDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_Dr_DeleteDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDataSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a datasource. </p>
<p>Delete (from the disk, in the database, ...) the named datasource. Normally it would be safest if the datasource was not open at the time.</p>
<p>Whether this is a supported operation on this driver case be tested using TestCapability() on ODrCDeleteDataSource.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a97939d588e2b350b9ec7a440f3e06a7c" title="Delete named dataset. ">GDALDeleteDataset()</a> in GDAL 2</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver on which data source deletion is based.</td></tr>
    <tr><td class="paramname">pszDataSource</td><td>the name of the datasource to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, and OGRERR_UNSUPPORTED_OPERATION if this is not supported by this driver. </dd></dl>

</div>
</div>
<a id="afd11ea603491207a89c75b6b9480e091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd11ea603491207a89c75b6b9480e091">&#9670;&nbsp;</a></span>OGR_Dr_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_Dr_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch name of driver (file format). </p>
<p>This name should be relatively short (10-40 characters), and should reflect the underlying file format. For instance "ESRI Shapefile".</p>
<p>This function is the same as the C++ method OGRSFDriver::GetName().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>driver name. This is an internal string and should not be modified or freed. </dd></dl>

</div>
</div>
<a id="a464b2210400d91fb9c6fa76595ea3681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464b2210400d91fb9c6fa76595ea3681">&#9670;&nbsp;</a></span>OGR_Dr_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGR_Dr_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUpdate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to open file with this driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#aca05455472359964151f9c891d678d5e" title="Open a raster or vector file as a GDALDataset. ">GDALOpenEx()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver that is used to open file. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the file, or data source to try and open. </td></tr>
    <tr><td class="paramname">bUpdate</td><td>TRUE if update access is required, otherwise FALSE (the default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file. ">GDALDataset</a>. This <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file. ">GDALDataset</a> should be closed by deleting the object when it is no longer needed. </dd></dl>

</div>
</div>
<a id="a9010219bbc2e32627064ed860048d979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9010219bbc2e32627064ed860048d979">&#9670;&nbsp;</a></span>OGR_Dr_TestCapability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Dr_TestCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<ul>
<li>
<p class="startli"><b>ODrCCreateDataSource</b>: True if this driver can support creating data sources.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODrCDeleteDataSource</b>: True if this driver supports deleting data sources.</p>
<p class="endli"></p>
</li>
</ul>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Use GDALGetMetadataItem(hDriver, GDAL_DCAP_CREATE) in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver to test the capability against. </td></tr>
    <tr><td class="paramname">pszCap</td><td>the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if capability available otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a628d34530517b618696c97b73de31df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628d34530517b618696c97b73de31df7">&#9670;&nbsp;</a></span>OGR_DS_CopyLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_CopyLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hSrcLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate an existing layer. </p>
<p>This function creates a new layer, duplicate the field definitions of the source layer and then duplicate each features of the source layer. The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation. The source layer may come from another dataset.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#ad6bbc8895f27768a4ad644231b22cb24" title="Duplicate an existing layer. ">GDALDatasetCopyLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source where to create the new layer </td></tr>
    <tr><td class="paramname">hSrcLayer</td><td>handle to the source layer. </td></tr>
    <tr><td class="paramname">pszNewName</td><td>the name of the layer to create. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the layer, or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="a424d383a37fbeaea58acaea11717f320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d383a37fbeaea58acaea11717f320">&#9670;&nbsp;</a></span>OGR_DS_CreateLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_CreateLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSpatialRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a7f01d3d8584f29e4ef3c56b5af49d816" title="This function attempts to create a new layer on the dataset with the indicated name, coordinate system, geometry type. ">GDALDatasetCreateLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>The dataset handle. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name for the new layer. This should ideally not match any existing layer on the datasource. </td></tr>
    <tr><td class="paramname">hSpatialRef</td><td>handle to the coordinate system to use for the new layer, or NULL if no coordinate system is available. The driver might only increase the reference counter of the object to take ownership, and not make a full copy, so do not use <a class="el" href="ogr__srs__api_8h.html#aa1485e7c17fb7edc15a0dfda63f77333" title="OGRSpatialReference destructor. ">OSRDestroySpatialReference()</a>, but <a class="el" href="ogr__srs__api_8h.html#adb5e564701dab4e83b3d353745f4a054" title="Decrements the reference count by one, and destroy if zero. ">OSRRelease()</a> instead when you are done with the object. </td></tr>
    <tr><td class="paramname">eType</td><td>the geometry type for the layer. Use wkbUnknown if there are no constraints on the types geometry to be written. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> handle on success.</dd></dl>
<p><b>Example:</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ogrsf__frmts_8h.html">ogrsf_frmts.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cpl__string_8h.html">cpl_string.h</a>&quot;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">        <a class="code" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> *hLayer;</div><div class="line">        <span class="keywordtype">char</span>     **papszOptions;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>( <a class="code" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability</a>( hDS, <a class="code" href="ogr__core_8h.html#aef6b1c2b9b7081b6c0c2c14f44f89014">ODsCCreateLayer</a> ) )</div><div class="line">        {</div><div class="line">            ...</div><div class="line">        }</div><div class="line"></div><div class="line">        papszOptions = <a class="code" href="cpl__string_8h.html#aa1a048471042e6fcf4e01faf11774867">CSLSetNameValue</a>( papszOptions, <span class="stringliteral">&quot;DIM&quot;</span>, <span class="stringliteral">&quot;2&quot;</span> );</div><div class="line">        hLayer = <a class="code" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer</a>( hDS, <span class="stringliteral">&quot;NewLayer&quot;</span>, NULL, <a class="code" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a>,</div><div class="line">                                     papszOptions );</div><div class="line">        <a class="code" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy</a>( papszOptions );</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>( hLayer == NULL )</div><div class="line">        {</div><div class="line">            ...</div><div class="line">        }</div></div><!-- fragment --> 
</div>
</div>
<a id="a85827a79cd2ddb5a55126e785bee427d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85827a79cd2ddb5a55126e785bee427d">&#9670;&nbsp;</a></span>OGR_DS_DeleteLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_DS_DeleteLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the indicated layer from the datasource. </p>
<p>If this method is supported the ODsCDeleteLayer capability will test TRUE on the <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a6c71ac6976dbf150a5131f509669e56e" title="Delete the indicated layer from the datasource. ">GDALDatasetDeleteLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the datasource </td></tr>
    <tr><td class="paramname">iLayer</td><td>the index of the layer to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or OGRERR_UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource. </dd></dl>

</div>
</div>
<a id="a4823e7c3513cd9d57254364de9a1d021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4823e7c3513cd9d57254364de9a1d021">&#9670;&nbsp;</a></span>OGR_DS_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_DS_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDataSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes opened datasource and releases allocated resources. </p>
<p>This method is the same as the C++ method OGRDataSource::DestroyDataSource().</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc" title="Close GDAL dataset. ">GDALClose()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDataSource</td><td>handle to allocated datasource object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9892ecb0bf61add295bd9decdb13797a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9892ecb0bf61add295bd9decdb13797a">&#9670;&nbsp;</a></span>OGR_DS_ExecuteSQL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_ExecuteSQL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSQLCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hSpatialFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDialect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an SQL statement against the data store. </p>
<p>The result of an SQL query is either NULL for statements that are in error, or that have no results set, or an <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> handle representing a results set from the query. Note that this <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> is in addition to the layers in the data store and must be destroyed with <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181" title="Release results of OGR_DS_ExecuteSQL(). ">OGR_DS_ReleaseResultSet()</a> before the data source is closed (destroyed).</p>
<p>For more information on the SQL dialect supported internally by OGR review the <a href="ogr_sql.html">OGR SQL</a> document. Some drivers (i.e. Oracle and PostGIS) pass the SQL directly through to the underlying RDBMS.</p>
<p>Starting with OGR 1.10, the <a href="ogr_sql_sqlite.html">SQLITE dialect</a> can also be used.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#aac9f2b65105d825901bc6cbe07a4b298" title="Execute an SQL statement against the data store. ">GDALDatasetExecuteSQL()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source on which the SQL query is executed. </td></tr>
    <tr><td class="paramname">pszSQLCommand</td><td>the SQL statement to execute. </td></tr>
    <tr><td class="paramname">hSpatialFilter</td><td>handle to a geometry which represents a spatial filter. Can be NULL. </td></tr>
    <tr><td class="paramname">pszDialect</td><td>allows control of the statement dialect. If set to NULL, the OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine, unless OGRSQL is explicitly passed as the dialect. Starting with OGR 1.10, the SQLITE dialect can also be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to a <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> containing the results of the query. Deallocate with <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181" title="Release results of OGR_DS_ExecuteSQL(). ">OGR_DS_ReleaseResultSet()</a>. </dd></dl>

</div>
</div>
<a id="a5def9c0aa6f6f60ab96369203330e326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5def9c0aa6f6f60ab96369203330e326">&#9670;&nbsp;</a></span>OGR_DS_GetDriver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> OGR_DS_GetDriver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the driver that the dataset was opened with. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a115e56894fda0a51ad99820b1bc38391" title="Fetch the driver to which this dataset relates. ">GDALGetDatasetDriver()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the datasource </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if driver info is not available, or pointer to a driver owned by the OGRSFDriverManager. </dd></dl>

</div>
</div>
<a id="a03998029f904d1c3b12de40114e7503e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03998029f904d1c3b12de40114e7503e">&#9670;&nbsp;</a></span>OGR_DS_GetLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_GetLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a layer by index. </p>
<p>The returned layer remains owned by the <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a> and should not be deleted by the application.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a4c42c52e24e02fead69a3189db5585ab" title="Fetch a layer by index. ">GDALDatasetGetLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source from which to get the layer. </td></tr>
    <tr><td class="paramname">iLayer</td><td>a layer number between 0 and <a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762" title="Get the number of layers in this data source. ">OGR_DS_GetLayerCount()</a>-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the layer, or NULL if iLayer is out of range or an error occurs. </dd></dl>

</div>
</div>
<a id="a74af4912b67bf2a7b6e3230711a40d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74af4912b67bf2a7b6e3230711a40d0e">&#9670;&nbsp;</a></span>OGR_DS_GetLayerByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_GetLayerByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszLayerName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a layer by name. </p>
<p>The returned layer remains owned by the <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a> and should not be deleted by the application.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a06e1dfa7103356cbb11929a36c2ec139" title="Fetch a layer by name. ">GDALDatasetGetLayerByName()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source from which to get the layer. </td></tr>
    <tr><td class="paramname">pszLayerName</td><td>Layer the layer name of the layer to fetch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the layer, or NULL if the layer is not found or an error occurs. </dd></dl>

</div>
</div>
<a id="ac6da541cb655ab631df729e71da2e762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6da541cb655ab631df729e71da2e762">&#9670;&nbsp;</a></span>OGR_DS_GetLayerCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_DS_GetLayerCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of layers in this data source. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a8c9297e5115d559b27267b14122043ee" title="Get the number of layers in this dataset. ">GDALDatasetGetLayerCount()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source from which to get the number of layers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>layer count. </dd></dl>

</div>
</div>
<a id="aea8cc826474b55371b1b4e24a24ba1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8cc826474b55371b1b4e24a24ba1db">&#9670;&nbsp;</a></span>OGR_DS_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_DS_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the data source. </p>
<p>This string should be sufficient to open the data source if passed to the same <a class="el" href="classOGRSFDriver.html" title="LEGACY class. ">OGRSFDriver</a> that this data source was opened with, but it need not be exactly the same string that was used to open the data source. Normally this is a filename.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#acf7272f513f436a95572116ca9fb8885" title="Fetch object description. ">GDALGetDescription()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an internal name string which should not be modified or freed by the caller. </dd></dl>

</div>
</div>
<a id="afc7b521a05c1207e298a2b9dbf4a1181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7b521a05c1207e298a2b9dbf4a1181">&#9670;&nbsp;</a></span>OGR_DS_ReleaseResultSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_DS_ReleaseResultSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release results of <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store. ">OGR_DS_ExecuteSQL()</a>. </p>
<p>This function should only be used to deallocate OGRLayers resulting from an <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store. ">OGR_DS_ExecuteSQL()</a> call on the same <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a>. Failure to deallocate a results set before destroying the <a class="el" href="classOGRDataSource.html" title="LEGACY class. ">OGRDataSource</a> may cause errors.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#ac2fa4282c61ee085edefdd485efad952" title="Release results of ExecuteSQL(). ">GDALDatasetReleaseResultSet()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>an handle to the data source on which was executed an SQL query. </td></tr>
    <tr><td class="paramname">hLayer</td><td>handle to the result of a previous <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store. ">OGR_DS_ExecuteSQL()</a> call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a139ab189c06d9f5f26e21b134928f882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ab189c06d9f5f26e21b134928f882">&#9670;&nbsp;</a></span>OGR_DS_SyncToDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_DS_SyncToDisk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>See <a class="el" href="classGDALDataset.html#ab6421c7ec7068c274a030e22aa6609e1" title="Flush all write cached data to disk. ">GDALDataset::FlushCache()</a> </p>

</div>
</div>
<a id="ad0fefab726442fa71ab5ef74fe8549a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fefab726442fa71ab5ef74fe8549a6">&#9670;&nbsp;</a></span>OGR_DS_TestCapability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_DS_TestCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCapability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<ul>
<li>
<b>ODsCCreateLayer</b>: True if this datasource can create new layers. </li>
<li>
<p class="startli"><b>ODsCDeleteLayer</b>: True if this datasource can delete existing layers.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODsCCreateGeomFieldAfterCreateLayer</b>: True if the layers of this datasource support CreateGeomField() just after layer creation.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODsCCurveGeometries</b>: True if this datasource supports writing curve geometries. (GDAL 2.0). In that case, OLCCurveGeometries must also be declared in layers of that dataset.</p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a8dc635a536f123e1b03004dc74b4da86" title="Test if capability is available. ">GDALDatasetTestCapability()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source against which to test the capability. </td></tr>
    <tr><td class="paramname">pszCapability</td><td>the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if capability available otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a102988416ae11403cab68cbaea7386d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102988416ae11403cab68cbaea7386d1">&#9670;&nbsp;</a></span>OGR_F_Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_F_Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate feature. </p>
<p>The newly created feature is owned by the caller, and will have its own reference to the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a16fba4633e17322df19e85a737aebc1c" title="Duplicate feature. ">OGRFeature::Clone()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the new feature, exactly matching this feature. </dd></dl>

</div>
</div>
<a id="a335fbf2220d7f93437621cae723558ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335fbf2220d7f93437621cae723558ac">&#9670;&nbsp;</a></span>OGR_F_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_F_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feature factory. </p>
<p>Note that the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> will increment the reference count of its defining <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>. Destruction of the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> before destruction of all OGRFeatures that depend on it is likely to result in a crash.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae6559a9f3c26274d1253e5d043b2e852" title="Constructor. ">OGRFeature::OGRFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature class (layer) definition to which the feature will adhere.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the new feature object with null fields and no geometry, or, starting with GDAL 2.1, NULL in case out of memory situation. </dd></dl>

</div>
</div>
<a id="a16fb8126aa932f4b4acdaca5ea99bbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fb8126aa932f4b4acdaca5ea99bbbb">&#9670;&nbsp;</a></span>OGR_F_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy feature. </p>
<p>The feature is deleted, but within the context of the GDAL/OGR heap. This is necessary when higher level applications use GDAL/OGR from a DLL and they want to delete a feature created within the DLL. If the delete is done in the calling application the memory will be freed onto the application heap which is inappropriate.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature. ">OGRFeature::DestroyFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae38d330f942798fcbaaf27e5807fb567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38d330f942798fcbaaf27e5807fb567">&#9670;&nbsp;</a></span>OGR_F_DumpReadable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_DumpReadable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fpOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump this feature in a human readable form. </p>
<p>This dumps the attributes, and geometry; however, it doesn't definition information (other than field types and names), nor does it report the geometry spatial reference system.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a26eb15de8bbbe80e6cf9a47381f7df6b" title="Dump this feature in a human readable form. ">OGRFeature::DumpReadable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to dump. </td></tr>
    <tr><td class="paramname">fpOut</td><td>the stream to write to, such as strout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b6a502ec0b70f3de50e7184a087a264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6a502ec0b70f3de50e7184a087a264">&#9670;&nbsp;</a></span>OGR_F_Equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_Equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hOtherFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if two features are the same. </p>
<p>Two features are considered equal if the share them (handle equality) same <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>, have the same field values, and the same geometry (as tested by OGR_G_Equal()) as well as the same feature id.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a52b96b85923e2128f17bc049fbd548a2" title="Test if two features are the same. ">OGRFeature::Equal()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to one of the feature. </td></tr>
    <tr><td class="paramname">hOtherFeat</td><td>handle to the other feature to test this one against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are equal, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="ac705f1d608d5e33d03851a7639fdfa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac705f1d608d5e33d03851a7639fdfa1f">&#9670;&nbsp;</a></span>OGR_F_FillUnsetWithDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_FillUnsetWithDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNotNullableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill unset fields with default values that might be defined. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a2328a84586eda70f44128bd58a89efc4" title="Fill unset fields with default values that might be defined. ">OGRFeature::FillUnsetWithDefault()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
    <tr><td class="paramname">bNotNullableOnly</td><td>if we should fill only unset fields with a not-null constraint. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>unused currently. Must be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a123dfa431bf655aafd2dbd42247dd7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123dfa431bf655aafd2dbd42247dd7be">&#9670;&nbsp;</a></span>OGR_F_GetDefnRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> OGR_F_GetDefnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a01ef8d59265a7ab7a575387a8269bf92" title="Fetch feature definition. ">OGRFeature::GetDefnRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the feature definition from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the feature definition object on which feature depends. </dd></dl>

</div>
</div>
<a id="afc99defd1fb1f8f71ff89c38982f2103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc99defd1fb1f8f71ff89c38982f2103">&#9670;&nbsp;</a></span>OGR_F_GetFID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> OGR_F_GetFID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get feature identifier. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae7254201e4d96e8429c2509194740d58" title="Get feature identifier. ">OGRFeature::GetFID()</a>. Note: since GDAL 2.0, this method returns a GIntBig (previously a long)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature from which to get the feature identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>feature id or OGRNullFID if none has been assigned. </dd></dl>

</div>
</div>
<a id="a72727f2f59d1defa01cedfb884df1a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72727f2f59d1defa01cedfb884df1a09">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a>* OGR_F_GetFieldAsBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as binary. </p>
<p>This method only works for OFTBinary and OFTString fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a2bda1256e28dbb14d37e5b6920fbc8d9" title="Fetch field value as binary data. ">OGRFeature::GetFieldAsBinary()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnBytes</td><td>location to place count of bytes returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

</div>
</div>
<a id="a47ca681bb6099eb8c18004d1f7112d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ca681bb6099eb8c18004d1f7112d95">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDateTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsDateTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as date and time. </p>
<p>Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a54097fad3054b57cfc7b6b0b0dd805e2" title="Fetch field value as date and time. ">OGRFeature::GetFieldAsDateTime()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">pnMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">pnDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">pnHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">pnMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">pnSecond</td><td>(0-59) </td></tr>
    <tr><td class="paramname">pnTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Use <a class="el" href="ogr__api_8h.html#a748995fa28574b25f6b723013a405a8f" title="Fetch field value as date and time. ">OGR_F_GetFieldAsDateTimeEx()</a> for second with millisecond accuracy. </dd></dl>

</div>
</div>
<a id="a748995fa28574b25f6b723013a405a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748995fa28574b25f6b723013a405a8f">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDateTimeEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsDateTimeEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as date and time. </p>
<p>Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a54097fad3054b57cfc7b6b0b0dd805e2" title="Fetch field value as date and time. ">OGRFeature::GetFieldAsDateTime()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">pnMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">pnDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">pnHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">pnMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">pfSecond</td><td>(0-59 with millisecond accuracy) </td></tr>
    <tr><td class="paramname">pnTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a62252a0d4538c695d41956a96cdc6978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62252a0d4538c695d41956a96cdc6978">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_F_GetFieldAsDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a double. </p>
<p>OFTString features will be translated using <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number. ">CPLAtof()</a>. OFTInteger fields will be cast to double. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#af1e473ed4496676610640a3fbe15d8e3" title="Fetch field value as a double. ">OGRFeature::GetFieldAsDouble()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. </dd></dl>

</div>
</div>
<a id="a4a27f74a38506ac492ec8b6e00eb58c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a27f74a38506ac492ec8b6e00eb58c9">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDoubleList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* OGR_F_GetFieldAsDoubleList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of doubles. </p>
<p>Currently this function only works for OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a206f481869ded42b685a163cc97e04cd" title="Fetch field value as a list of doubles. ">OGRFeature::GetFieldAsDoubleList()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnCount</td><td>an integer to put the list count (number of doubles) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>

</div>
</div>
<a id="acfb4d2c0001af379e396021ecbdaf275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb4d2c0001af379e396021ecbdaf275">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as integer. </p>
<p>OFTString features will be translated using atoi(). OFTReal fields will be cast to integer. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#aa0fa233c76792a07bf2e72c2846502f1" title="Fetch field value as integer. ">OGRFeature::GetFieldAsInteger()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. </dd></dl>

</div>
</div>
<a id="a0e190099fd6ee40e206bf4bf74d3b784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e190099fd6ee40e206bf4bf74d3b784">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsInteger64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> OGR_F_GetFieldAsInteger64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as integer 64 bit. </p>
<p>OFTInteger are promoted to 64 bit. OFTString features will be translated using <a class="el" href="cpl__conv_8h.html#aa35579a348f417a35965d6be69cde090" title="Convert a string to a 64 bit signed integer. ">CPLAtoGIntBig()</a>. OFTReal fields will be cast to integer. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a7178e6fe945237da0595a934aba9e2ff" title="Fetch field value as integer 64 bit. ">OGRFeature::GetFieldAsInteger64()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a9df79763bd50aeef2581454bcab51ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df79763bd50aeef2581454bcab51ce6">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsInteger64List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>* OGR_F_GetFieldAsInteger64List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of 64 bit integers. </p>
<p>Currently this function only works for OFTInteger64List fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#afddc9cb3f91db6ba82b105a20b57cb6c" title="Fetch field value as a list of 64 bit integers. ">OGRFeature::GetFieldAsInteger64List()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnCount</td><td>an integer to put the list count (number of integers) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ac671852e05692c584b493b2acbd6b8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac671852e05692c584b493b2acbd6b8ce">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsIntegerList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int* OGR_F_GetFieldAsIntegerList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of integers. </p>
<p>Currently this function only works for OFTIntegerList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8f3817334dc5a0987d2a384708efc9af" title="Fetch field value as a list of integers. ">OGRFeature::GetFieldAsIntegerList()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnCount</td><td>an integer to put the list count (number of integers) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>

</div>
</div>
<a id="a42acfd1f4b49dddc1c308462ae800c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42acfd1f4b49dddc1c308462ae800c26">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetFieldAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a string. </p>
<p>OFTReal and OFTInteger fields will be translated to string using sprintf(), but not necessarily using the established formatting rules. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a92ecdc127eeb3fe7e2ead80f1d17d4b4" title="Fetch field value as a string. ">OGRFeature::GetFieldAsString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This string is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

</div>
</div>
<a id="a3e55ba4a06d4c4a392206518b390ac38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e55ba4a06d4c4a392206518b390ac38">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsStringList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** OGR_F_GetFieldAsStringList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of strings. </p>
<p>Currently this method only works for OFTStringList fields.</p>
<p>The returned list is terminated by a NULL pointer. The number of elements can also be calculated using <a class="el" href="cpl__string_8h.html#a827f21b7a67d16059c131d0946482bb1" title="Return number of items in a string list. ">CSLCount()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a317004e2ab87ff097bc76a7a7619e4b4" title="Fetch field value as a list of strings. ">OGRFeature::GetFieldAsStringList()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

</div>
</div>
<a id="af6c1440956ee56c0c160394bccf96990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c1440956ee56c0c160394bccf96990">&#9670;&nbsp;</a></span>OGR_F_GetFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of fields on this feature This will always be the same as the field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5f2125ed7986f684e835c3d44feda6fe" title="Fetch number of fields on this feature. ">OGRFeature::GetFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of fields. </dd></dl>

</div>
</div>
<a id="a6f8fc7fd6ecca789ad90db6d28391623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8fc7fd6ecca789ad90db6d28391623">&#9670;&nbsp;</a></span>OGR_F_GetFieldDefnRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> OGR_F_GetFieldDefnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch definition for this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a545a4c983e1fa557e64333fe63656637" title="Fetch definition for this field. ">OGRFeature::GetFieldDefnRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td class="paramname">i</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the field definition (from the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>). This is an internal reference, and should not be deleted or modified. </dd></dl>

</div>
</div>
<a id="a9a8a6b93ab97204b94f5c2b358f8f98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a6b93ab97204b94f5c2b358f8f98e">&#9670;&nbsp;</a></span>OGR_F_GetFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the field index given field name. </p>
<p>This is a cover for the <a class="el" href="classOGRFeatureDefn.html#adf94fefd88e82172e5279f5188b3873b" title="Find field by name. ">OGRFeatureDefn::GetFieldIndex()</a> method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a989153f429715d02e4d5c45d0e43f303" title="Fetch the field index given field name. ">OGRFeature::GetFieldIndex()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the field to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field index, or -1 if no matching field is found. </dd></dl>

</div>
</div>
<a id="a1bf9596756aeacec4da502383c378f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf9596756aeacec4da502383c378f5c">&#9670;&nbsp;</a></span>OGR_F_GetGeometryRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_F_GetGeometryRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch an handle to feature geometry. </p>
<p>This function is essentially the same as the C++ method <a class="el" href="classOGRFeature.html#acc966ce8c10ae3ddf9f14c2736fdce9a" title="Fetch pointer to feature geometry. ">OGRFeature::GetGeometryRef()</a> (the only difference is that this C function honours <a class="el" href="ogr__api_8h.html#af7f6cfab316f5f22962bcd85216c4684" title="Get flag to enable/disable returning non-linear geometries in the C API. ">OGRGetNonLinearGeometriesEnabledFlag()</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get geometry from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to internal feature geometry. This object should not be modified. </dd></dl>

</div>
</div>
<a id="a7975076d4ab247189487c0fd50d8365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7975076d4ab247189487c0fd50d8365c">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetGeomFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a372e4ace921fa830a342181328a5a4cf" title="Fetch number of geometry fields on this feature. ">OGRFeature::GetGeomFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the geometry fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of geometry fields.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a11c3d59a3854dad80c4257e788c5d881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c3d59a3854dad80c4257e788c5d881">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldDefnRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> OGR_F_GetGeomFieldDefnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch definition for this geometry field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ab0416401dc7d6a7634c2a24ca1f7d255" title="Fetch definition for this geometry field. ">OGRFeature::GetGeomFieldDefnRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td class="paramname">i</td><td>the field to fetch, from 0 to GetGeomFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the field definition (from the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>). This is an internal reference, and should not be deleted or modified.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a546acd0aad47128b1f178a8d01765e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546acd0aad47128b1f178a8d01765e63">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetGeomFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the geometry field index given geometry field name. </p>
<p>This is a cover for the <a class="el" href="classOGRFeatureDefn.html#af033ae277fade415ff13ed8b5643e4be" title="Find geometry field by name. ">OGRFeatureDefn::GetGeomFieldIndex()</a> method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#aae3ed6071596aea439843f1e4110ad40" title="Fetch the geometry field index given geometry field name. ">OGRFeature::GetGeomFieldIndex()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the geometry field is found. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the geometry field to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry field index, or -1 if no matching geometry field is found.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a37aa8b53b1fc8816c5b7bcbbcb6a46ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_F_GetGeomFieldRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch an handle to feature geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae54d999d4649730d5c7b37de731e4f69" title="Fetch pointer to feature geometry. ">OGRFeature::GetGeomFieldRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get geometry from. </td></tr>
    <tr><td class="paramname">iField</td><td>geometry field to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to internal feature geometry. This object should not be modified.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a3737dec6492741cd11c1767e04edec1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3737dec6492741cd11c1767e04edec1f">&#9670;&nbsp;</a></span>OGR_F_GetNativeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetNativeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the native data for the feature. </p>
<p>The native data is the representation in a "natural" form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by <a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6" title="Returns the native media type for the feature. ">OGR_F_GetNativeMediaType()</a>.</p>
<p>Note that most drivers do not support storing the native data in the feature object, and if they do, generally the NATIVE_DATA open option must be passed at dataset opening.</p>
<p>The "native data" does not imply it is something more performant or powerful than what can be obtained with the rest of the API, but it may be useful in round-tripping scenarios where some characteristics of the underlying format are not captured otherwise by the OGR abstraction.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8f91a40806d4207efb689b9c3cdf8e53" title="Returns the native data for the feature. ">OGRFeature::GetNativeData()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the native data, or NULL if there is none. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="abcfe5e7897623a97a2bdc0ec32323fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfe5e7897623a97a2bdc0ec32323fa6">&#9670;&nbsp;</a></span>OGR_F_GetNativeMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetNativeMediaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the native media type for the feature. </p>
<p>The native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see <a href="https://en.wikipedia.org/wiki/Media_type">https://en.wikipedia.org/wiki/Media_type</a>), e.g. "application/vnd.geo+json" for JSon.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6" title="Returns the native media type for the feature. ">OGR_F_GetNativeMediaType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the native media type, or NULL if there is none. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="af7043e9dfadbdeca8059ace336875d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7043e9dfadbdeca8059ace336875d4c">&#9670;&nbsp;</a></span>OGR_F_GetRawFieldRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionOGRField.html">OGRField</a>* OGR_F_GetRawFieldRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch an handle to the internal field value given the index. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae7f676d5a8e1f62d80b438c13b159ee0" title="Fetch a pointer to the internal field value given the index. ">OGRFeature::GetRawFieldRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which field is found. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the returned handle is to an internal data structure, and should not be freed, or modified. </dd></dl>

</div>
</div>
<a id="a10fb5f53d99ccf46280e4c38afe4a5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fb5f53d99ccf46280e4c38afe4a5a5">&#9670;&nbsp;</a></span>OGR_F_GetStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch style string for this feature. </p>
<p>Set the OGR Feature Style Specification for details on the format of this string, and <a class="el" href="ogr__featurestyle_8h.html" title="Simple feature style classes. ">ogr_featurestyle.h</a> for services available to parse it.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a6f0eba9faff40c251784217584ac97a4" title="Fetch style string for this feature. ">OGRFeature::GetStyleString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the style from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a representation in string format, or NULL if there isn't one. </dd></dl>

</div>
</div>
<a id="aa4d08c0ac3b9624955e682a9a2afe2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d08c0ac3b9624955e682a9a2afe2b1">&#9670;&nbsp;</a></span>OGR_F_IsFieldNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_IsFieldNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a field is null. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a655ee311e45188dcb5143ce3e408884e" title="Test if a field is null. ">OGRFeature::IsFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is null, otherwise false.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="abb018a9030ed76353ae26082deaaef11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb018a9030ed76353ae26082deaaef11">&#9670;&nbsp;</a></span>OGR_F_IsFieldSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_IsFieldSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a field has ever been assigned a value or not. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a905bb73fe5e6df57f1be5a8b77489b74" title="Test if a field has ever been assigned a value or not. ">OGRFeature::IsFieldSet()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field has been set, otherwise false. </dd></dl>

</div>
</div>
<a id="adf414eb3a145bcd7203fca727f7a2ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf414eb3a145bcd7203fca727f7a2ead">&#9670;&nbsp;</a></span>OGR_F_IsFieldSetAndNotNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_IsFieldSetAndNotNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a field is set and not null. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a55cee63d6370dc1123dfca2b8333b1ac" title="Test if a field is set and not null. ">OGRFeature::IsFieldSetAndNotNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is set and not null, otherwise false.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="adf24e93da4c03360d1d2e01664596e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf24e93da4c03360d1d2e01664596e29">&#9670;&nbsp;</a></span>OGR_F_SetFID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetFID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the feature identifier. </p>
<p>For specific types of features this operation may fail on illegal features ids. Generally it always succeeds. Feature ids should be greater than or equal to zero, with the exception of OGRNullFID (-1) indicating that the feature id is unknown.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ad159156f6e544343f3f24081208a4b42" title="Set the feature identifier. ">OGRFeature::SetFID()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set the feature id to. </td></tr>
    <tr><td class="paramname">nFID</td><td>the new feature identifier value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success OGRERR_NONE, or on failure some other value. </dd></dl>

</div>
</div>
<a id="a348b1423e9ae34290f2e32f3bdf8154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348b1423e9ae34290f2e32f3bdf8154b">&#9670;&nbsp;</a></span>OGR_F_SetFieldBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to binary data. </p>
<p>This function currently on has an effect of OFTBinary fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes in pabyData array. </td></tr>
    <tr><td class="paramname">pabyData</td><td>the data to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a627970180a20e2a4b1c7ae694923fd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627970180a20e2a4b1c7ae694923fd73">&#9670;&nbsp;</a></span>OGR_F_SetFieldDateTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDateTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to datetime. </p>
<p>This method currently only has an effect for OFTDate, OFTTime and OFTDateTime fields.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">nMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">nDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">nHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">nMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">nSecond</td><td>(0-59) </td></tr>
    <tr><td class="paramname">nTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Use <a class="el" href="ogr__api_8h.html#a71e1bc23b8a31553550775a212075da3" title="Set field to datetime. ">OGR_F_SetFieldDateTimeEx()</a> for second with millisecond accuracy. </dd></dl>

</div>
</div>
<a id="a71e1bc23b8a31553550775a212075da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e1bc23b8a31553550775a212075da3">&#9670;&nbsp;</a></span>OGR_F_SetFieldDateTimeEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDateTimeEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to datetime. </p>
<p>This method currently only has an effect for OFTDate, OFTTime and OFTDateTime fields.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">nMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">nDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">nHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">nMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">fSecond</td><td>(0-59, with millisecond accuracy) </td></tr>
    <tr><td class="paramname">nTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a9d28aa13b1b7c88f07066c36286d13b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d28aa13b1b7c88f07066c36286d13b9">&#9670;&nbsp;</a></span>OGR_F_SetFieldDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to double value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">dfValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83a56d01128bf247016c139faed157be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a56d01128bf247016c139faed157be">&#9670;&nbsp;</a></span>OGR_F_SetFieldDoubleList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDoubleList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of doubles value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List, OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nCount</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td class="paramname">padfValues</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad902fb7c7fe459aacf0b2c26b8e6d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad902fb7c7fe459aacf0b2c26b8e6d1ee">&#9670;&nbsp;</a></span>OGR_F_SetFieldInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to integer value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c95abf476d0ad250eb7499627f0e3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c95abf476d0ad250eb7499627f0e3b1">&#9670;&nbsp;</a></span>OGR_F_SetFieldInteger64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldInteger64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to 64 bit integer value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="af7538949a9e8b85920381809fadbe897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7538949a9e8b85920381809fadbe897">&#9670;&nbsp;</a></span>OGR_F_SetFieldInteger64List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldInteger64List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> *&#160;</td>
          <td class="paramname"><em>panValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of 64 bit integers value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List and OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nCount</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td class="paramname">panValues</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a984c8595693b4e94f3be5f796e6f7c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984c8595693b4e94f3be5f796e6f7c92">&#9670;&nbsp;</a></span>OGR_F_SetFieldIntegerList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldIntegerList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of integers value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List and OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nCount</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td class="paramname">panValues</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a090a6a8d699d4eed977ce9fcf028137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090a6a8d699d4eed977ce9fcf028137a">&#9670;&nbsp;</a></span>OGR_F_SetFieldNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a field, marking it as null. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a21e81c0995c1f2a8e5c9f6c76fdfb2f4" title="Clear a field, marking it as null. ">OGRFeature::SetFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set to null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="af3cfe4f766f5579f670bb651c53a99ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cfe4f766f5579f670bb651c53a99ca">&#9670;&nbsp;</a></span>OGR_F_SetFieldRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>psValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field. </p>
<p>The passed value <a class="el" href="unionOGRField.html" title="OGRFeature field attribute value union. ">OGRField</a> must be of exactly the same type as the target field, or an application crash may occur. The passed value is copied, and will not be affected. It remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">psValue</td><td>handle on the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1a3e8b4a08f9558807389bcdde85bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a3e8b4a08f9558807389bcdde85bab">&#9670;&nbsp;</a></span>OGR_F_SetFieldString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to string value. </p>
<p>OFTInteger fields will be set based on an atoi() conversion of the string. OFTInteger64 fields will be set based on an <a class="el" href="cpl__conv_8h.html#aa35579a348f417a35965d6be69cde090" title="Convert a string to a 64 bit signed integer. ">CPLAtoGIntBig()</a> conversion of the string. OFTReal fields will be set based on an <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number. ">CPLAtof()</a> conversion of the string. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35dd76723ae1acc91135054e64d7598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dd76723ae1acc91135054e64d7598e">&#9670;&nbsp;</a></span>OGR_F_SetFieldStringList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldStringList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of strings value. </p>
<p>This function currently on has an effect of OFTStringList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value. ">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">papszValues</td><td>the values to assign. List of NUL-terminated string, ending with a NULL pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7f7057a7a3764c526a4a59e2b587fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f7057a7a3764c526a4a59e2b587fba">&#9670;&nbsp;</a></span>OGR_F_SetFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hOtherFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForgiving</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>. Field values are copied by corresponding field names. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a32dda6780196687ef5f77b4915ed8243" title="Set one feature from another. ">OGRFeature::SetFrom()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set to. </td></tr>
    <tr><td class="paramname">hOtherFeat</td><td>handle to the feature from which geometry, and field values will be copied.</td></tr>
    <tr><td class="paramname">bForgiving</td><td>TRUE if the operation should continue despite lacking output fields matching some of the source fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </dd></dl>

</div>
</div>
<a id="a9c1b7383891a47387a9b48cb02918fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1b7383891a47387a9b48cb02918fde">&#9670;&nbsp;</a></span>OGR_F_SetFromWithMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetFromWithMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hOtherFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForgiving</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>. Field values are copied according to the provided indices map. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed. This is more efficient than <a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba" title="Set one feature from another. ">OGR_F_SetFrom()</a> in that this doesn't lookup the fields by their names. Particularly useful when the field names don't match.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a32dda6780196687ef5f77b4915ed8243" title="Set one feature from another. ">OGRFeature::SetFrom()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set to. </td></tr>
    <tr><td class="paramname">hOtherFeat</td><td>handle to the feature from which geometry, and field values will be copied.</td></tr>
    <tr><td class="paramname">panMap</td><td>Array of the indices of the destination feature's fields stored at the corresponding index of the source feature's fields. A value of -1 should be used to ignore the source's field. The array should not be NULL and be as long as the number of fields in the source feature.</td></tr>
    <tr><td class="paramname">bForgiving</td><td>TRUE if the operation should continue despite lacking output fields matching some of the source fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </dd></dl>

</div>
</div>
<a id="a7b9c524f5c01a6a4b4e50e351d03299f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9c524f5c01a6a4b4e50e351d03299f">&#9670;&nbsp;</a></span>OGR_F_SetGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeature.html#a67949569519c0de6ee3ea48f23ff11c9" title="Set feature geometry. ">OGRFeature::SetGeometry()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which new geometry is applied to. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

</div>
</div>
<a id="ad391d3197728bb6d12a6b0c2e2661aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad391d3197728bb6d12a6b0c2e2661aa4">&#9670;&nbsp;</a></span>OGR_F_SetGeometryDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeometryDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometry(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d" title="Set feature geometry. ">OGRFeature::SetGeometryDirectly</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a5009bc8d78d7f00e2745f3e3ad133779" title="Create and write a new feature within a layer. ">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which to apply the geometry. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

</div>
</div>
<a id="ad75b18930385432110aa8d3461854cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75b18930385432110aa8d3461854cce">&#9670;&nbsp;</a></span>OGR_F_SetGeomField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeomField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeature.html#ab03a00692c1ccd5da895b2b90593508c" title="Set feature geometry of a specified geometry field. ">OGRFeature::SetGeomField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which new geometry is applied to. </td></tr>
    <tr><td class="paramname">iField</td><td>geometry field to set. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

</div>
</div>
<a id="a01530e163973979cfd8248e3ecbf2640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01530e163973979cfd8248e3ecbf2640">&#9670;&nbsp;</a></span>OGR_F_SetGeomFieldDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeomFieldDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeomField(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae0ddbbc910727ada3b2cd00a357222da" title="Set feature geometry of a specified geometry field. ">OGRFeature::SetGeomFieldDirectly</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which to apply the geometry. </td></tr>
    <tr><td class="paramname">iField</td><td>geometry field to set. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is invalid, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> (checking not yet implemented).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="aeb0f1eb5d248e1d2131b877026cb2a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0f1eb5d248e1d2131b877026cb2a8a">&#9670;&nbsp;</a></span>OGR_F_SetNativeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetNativeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNativeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the native data for the feature. </p>
<p>The native data is the representation in a "natural" form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by <a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6" title="Returns the native media type for the feature. ">OGR_F_GetNativeMediaType()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ada90236daf06fa86e8ec9e59ec976908" title="Sets the native data for the feature. ">OGRFeature::SetNativeData()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
    <tr><td class="paramname">pszNativeData</td><td>a string with the native data, or NULL if there is none. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="a5e5e7ec78caaa3d0c65acb662fa6161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e7ec78caaa3d0c65acb662fa6161d">&#9670;&nbsp;</a></span>OGR_F_SetNativeMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetNativeMediaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNativeMediaType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the native media type for the feature. </p>
<p>The native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see <a href="https://en.wikipedia.org/wiki/Media_type">https://en.wikipedia.org/wiki/Media_type</a>), e.g. "application/vnd.geo+json" for JSon.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a68476551e589b220eadd02998d5c3a47" title="Sets the native media type for the feature. ">OGRFeature::SetNativeMediaType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
    <tr><td class="paramname">pszNativeMediaType</td><td>a string with the native media type, or NULL if there is none. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="afbe436a7a48ad5bbfb3aa34f44791a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe436a7a48ad5bbfb3aa34f44791a68">&#9670;&nbsp;</a></span>OGR_F_SetStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature style string. </p>
<p>This method operate exactly as <a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c" title="Set feature style string. ">OGR_F_SetStyleStringDirectly()</a> except that it does not assume ownership of the passed string, but instead makes a copy of it.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5d2c15d00845820e6382d48227ed7ff7" title="Set feature style string. ">OGRFeature::SetStyleString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set style to. </td></tr>
    <tr><td class="paramname">pszStyle</td><td>the style string to apply to this feature, cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1ab2f6fb7937a8b927e4c1d3fd057c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1ab2f6fb7937a8b927e4c1d3fd057c">&#9670;&nbsp;</a></span>OGR_F_SetStyleStringDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetStyleStringDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszStyle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature style string. </p>
<p>This method operate exactly as <a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68" title="Set feature style string. ">OGR_F_SetStyleString()</a> except that it assumes ownership of the passed string.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a7282982663cee5dd2fc18a093c3e386a" title="Set feature style string. ">OGRFeature::SetStyleStringDirectly()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set style to. </td></tr>
    <tr><td class="paramname">pszStyle</td><td>the style string to apply to this feature, cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2153b17a82c0026c20d710a79e6a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2153b17a82c0026c20d710a79e6a779">&#9670;&nbsp;</a></span>OGR_F_StealGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_F_StealGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take away ownership of geometry. </p>
<p>Fetch the geometry from this feature, and clear the reference to the geometry on the feature. This is a mechanism for the application to take over ownership of the geometry from the feature without copying. Sort of an inverse to OGR_FSetGeometryDirectly().</p>
<p>After this call the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> will have a NULL geometry.</p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the geometry. </dd></dl>

</div>
</div>
<a id="aa70b7675a003141e63f9603c752ee22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70b7675a003141e63f9603c752ee22e">&#9670;&nbsp;</a></span>OGR_F_UnsetField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_UnsetField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a field, marking it as unset. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a937b21e0137e40bc1473f354879975da" title="Clear a field, marking it as unset. ">OGRFeature::UnsetField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to unset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab798c73a20f4b311026232badda9701d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab798c73a20f4b311026232badda9701d">&#9670;&nbsp;</a></span>OGR_F_Validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_Validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValidateFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bEmitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate that a feature meets constraints of its schema. </p>
<p>The scope of test is specified with the nValidateFlags parameter.</p>
<p>Regarding OGR_F_VAL_WIDTH, the test is done assuming the string width must be interpreted as the number of UTF-8 characters. Some drivers might interpret the width as the number of bytes instead. So this test is rather conservative (if it fails, then it will fail for all interpretations).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8ddcb9dd93fc92f7c9c0c55cb39349fb" title="Validate that a feature meets constraints of its schema. ">OGRFeature::Validate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to validate. </td></tr>
    <tr><td class="paramname">nValidateFlags</td><td>OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL, OGR_F_VAL_GEOM_TYPE, OGR_F_VAL_WIDTH and OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with '|' operator </td></tr>
    <tr><td class="paramname">bEmitError</td><td>TRUE if a <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a> must be emitted when a check fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if all enabled validation tests pass. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a2a798e8d03299403418a7c87862f1acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a798e8d03299403418a7c87862f1acb">&#9670;&nbsp;</a></span>OGR_FD_AddFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_AddFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hNewField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275" title="Create a new field on a layer. ">OGR_L_CreateField()</a> instead.</p>
<p>This function should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>. The <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn. ">OGRFieldDefn</a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a40e681d8464b42f1a1fac655f16ac3dd" title="Add a new field definition. ">OGRFeatureDefn::AddFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to add the field definition to. </td></tr>
    <tr><td class="paramname">hNewField</td><td>handle to the new field definition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa080fdbe88c1829c1b7adcce208ec4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa080fdbe88c1829c1b7adcce208ec4b8">&#9670;&nbsp;</a></span>OGR_FD_AddGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_AddGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hNewGeomField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc" title="Create a new geometry field on a layer. ">OGR_L_CreateGeomField()</a> instead.</p>
<p>This function should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>. The <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn. ">OGRGeomFieldDefn</a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a99700a7f755c91c3382eaa65bc49f4f9" title="Add a new geometry field definition. ">OGRFeatureDefn::AddGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to add the geometry field definition to. </td></tr>
    <tr><td class="paramname">hNewGeomField</td><td>handle to the new field definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a8cbc5146fcab99667f021c40c714628c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbc5146fcab99667f021c40c714628c">&#9670;&nbsp;</a></span>OGR_FD_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> OGR_FD_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new feature definition object to hold the field definitions. </p>
<p>The <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> maintains a reference count, but this starts at zero, and should normally be incremented by the owner.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ada5564d238a73a8c98b30807c4c8db73" title="Constructor. ">OGRFeatureDefn::OGRFeatureDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name to be assigned to this layer/class. It does not need to be unique. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the newly created feature definition. </dd></dl>

</div>
</div>
<a id="a6283475163d911204f5ff45098c8479e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6283475163d911204f5ff45098c8479e">&#9670;&nbsp;</a></span>OGR_FD_DeleteFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_FD_DeleteFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing field definition. </p>
<p>To delete an existing field definition from a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2" title="Delete an existing field on a layer. ">OGR_L_DeleteField()</a> instead.</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ada48e1a3e90798bdccc2dd26f32f48cb" title="Delete an existing field definition. ">OGRFeatureDefn::DeleteFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition. </td></tr>
    <tr><td class="paramname">iField</td><td>the index of the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a1fb650102be3837fc220b086b17f4462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb650102be3837fc220b086b17f4462">&#9670;&nbsp;</a></span>OGR_FD_DeleteGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_FD_DeleteGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing geometry field definition. </p>
<p>To delete an existing geometry field definition from a layer definition, do not use this function directly, but use OGR_L_DeleteGeomField() instead (<em>not implemented yet</em>).</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2c67a35c58cfd9ac384858d1b7b7ec48" title="Delete an existing geometry field definition. ">OGRFeatureDefn::DeleteGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>the index of the geometry field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a107635936c90c7f4347d7b3f9fb06e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107635936c90c7f4347d7b3f9fb06e6d">&#9670;&nbsp;</a></span>OGR_FD_Dereference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_Dereference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the reference count by one. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a87a280dd42634206dfbcfc47b1ecfea4" title="Decrements the reference count by one. ">OGRFeatureDefn::Dereference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated reference count. </dd></dl>

</div>
</div>
<a id="a59d5cbb660cce8467a210caa4d68a011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d5cbb660cce8467a210caa4d68a011">&#9670;&nbsp;</a></span>OGR_FD_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a feature definition object and release all memory associated with it. </p>
<p>This function is the same as the C++ method OGRFeatureDefn::~OGRFeatureDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a586a14271a457387a2b5c0097a02c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586a14271a457387a2b5c0097a02c8da">&#9670;&nbsp;</a></span>OGR_FD_GetFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature. ">OGRFeatureDefn::GetFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of fields. </dd></dl>

</div>
</div>
<a id="a484456df86a01284769d0afe3beaa4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484456df86a01284769d0afe3beaa4f6">&#9670;&nbsp;</a></span>OGR_FD_GetFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> OGR_FD_GetFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a43b95ce699bbca73acb453cc959378e7" title="Fetch field definition. ">OGRFeatureDefn::GetFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the field definition from. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, between 0 and GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application. </dd></dl>

</div>
</div>
<a id="a1e54c3271dce0562209d78ae6eaae330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e54c3271dce0562209d78ae6eaae330">&#9670;&nbsp;</a></span>OGR_FD_GetFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find field by name. </p>
<p>The field index of the first field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#adf94fefd88e82172e5279f5188b3873b" title="Find field by name. ">OGRFeatureDefn::GetFieldIndex</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get field index from. </td></tr>
    <tr><td class="paramname">pszFieldName</td><td>the field name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field index, or -1 if no match found. </dd></dl>

</div>
</div>
<a id="a0b34027b691ea40e20b911290f863303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b34027b691ea40e20b911290f863303">&#9670;&nbsp;</a></span>OGR_FD_GetGeomFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetGeomFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of geometry fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeatureDefn.html#ad5e568a81eca8d6101ae4475b653f1c9" title="Fetch number of geometry fields on this feature. ">OGRFeatureDefn::GetGeomFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of geometry fields.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a82275ef1d2655817f6fe582f885c92c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82275ef1d2655817f6fe582f885c92c7">&#9670;&nbsp;</a></span>OGR_FD_GetGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> OGR_FD_GetGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#acacca3de3718ae525565e5130b5474dc" title="Fetch geometry field definition. ">OGRFeatureDefn::GetGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the field definition from. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>the geometry field to fetch, between 0 and GetGeomFieldCount() - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a69be97ea100c50bdaad8a1d3c30e7b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69be97ea100c50bdaad8a1d3c30e7b14">&#9670;&nbsp;</a></span>OGR_FD_GetGeomFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetGeomFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszGeomFieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find geometry field by name. </p>
<p>The geometry field index of the first geometry field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#af033ae277fade415ff13ed8b5643e4be" title="Find geometry field by name. ">OGRFeatureDefn::GetGeomFieldIndex</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get field index from. </td></tr>
    <tr><td class="paramname">pszGeomFieldName</td><td>the geometry field name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry field index, or -1 if no match found. </dd></dl>

</div>
</div>
<a id="add0b3a6b6062122e4f4316d194d2a1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0b3a6b6062122e4f4316d194d2a1cf">&#9670;&nbsp;</a></span>OGR_FD_GetGeomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_FD_GetGeomType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the geometry base type of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#acc3e3904d856b9c8b5b26204c68e916a" title="Fetch the geometry base type. ">OGRFeatureDefn::GetGeomType()</a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;GetType().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the geometry type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base type for all geometry related to this definition. </dd></dl>

</div>
</div>
<a id="a20f309bf10e5b76cc083848b710babb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f309bf10e5b76cc083848b710babb8">&#9670;&nbsp;</a></span>OGR_FD_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_FD_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> passed as an argument. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ab8fa2428efb085a0b5dd78342b535aeb" title="Get name of this OGRFeatureDefn. ">OGRFeatureDefn::GetName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name. This name is internal and should not be modified, or freed. </dd></dl>

</div>
</div>
<a id="a9e4e8867edeaf1a6f98e6ff284835811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e8867edeaf1a6f98e6ff284835811">&#9670;&nbsp;</a></span>OGR_FD_GetReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetReferenceCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch current reference count. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#aedb957000f22445d536d89c566f32526" title="Fetch current reference count. ">OGRFeatureDefn::GetReferenceCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current reference count. </dd></dl>

</div>
</div>
<a id="ad1208985f67db526136dbe74f490c8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1208985f67db526136dbe74f490c8d3">&#9670;&nbsp;</a></span>OGR_FD_IsGeometryIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsGeometryIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ab64252824a66afa3e1ada210a1f29d28" title="Determine whether the geometry can be omitted when fetching features. ">OGRFeatureDefn::IsGeometryIgnored()</a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;IsIgnored().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state </dd></dl>

</div>
</div>
<a id="ab07056d514160c26724f3a2d5319185f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07056d514160c26724f3a2d5319185f">&#9670;&nbsp;</a></span>OGR_FD_IsSame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsSame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hFDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hOtherFDefn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the feature definition is identical to the other one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
    <tr><td class="paramname">hOtherFDefn</td><td>handle to the other feature definition to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the feature definition is identical to the other one.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.11 </dd></dl>

</div>
</div>
<a id="aa9490e3e5d25b780723ad3f0ab3302eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9490e3e5d25b780723ad3f0ab3302eb">&#9670;&nbsp;</a></span>OGR_FD_IsStyleIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsStyleIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a7edc3d1a8add158e00475faec76c036a" title="Determine whether the style can be omitted when fetching features. ">OGRFeatureDefn::IsStyleIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on which <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state </dd></dl>

</div>
</div>
<a id="a6763104e7fafcab1b52d9b0f275e19e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6763104e7fafcab1b52d9b0f275e19e8">&#9670;&nbsp;</a></span>OGR_FD_Reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_Reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the reference count by one. </p>
<p>The reference count is used keep track of the number of <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> objects referencing this definition.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2c58c6238242dff3d472faf5e3803922" title="Increments the reference count by one. ">OGRFeatureDefn::Reference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated reference count. </dd></dl>

</div>
</div>
<a id="a0755b0360414095e15eaf2c1496f8c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0755b0360414095e15eaf2c1496f8c47">&#9670;&nbsp;</a></span>OGR_FD_Release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_Release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a reference, and destroy if unreferenced. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a75e1424e3ce755d4393f5b42736d13ee" title="Drop a reference to this object, and destroy if no longer referenced. ">OGRFeatureDefn::Release()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87da23094f3473a9a11bf2fdb6fd2dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87da23094f3473a9a11bf2fdb6fd2dc4">&#9670;&nbsp;</a></span>OGR_FD_ReorderFieldDefns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_FD_ReorderFieldDefns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the field definitions in the array of the feature definition. </p>
<p>To reorder the field definitions in a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer. ">OGR_L_ReorderFields()</a> instead.</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a9abb45931317ea5e6c62f4954451dba4" title="Reorder the field definitions in the array of the feature definition. ">OGRFeatureDefn::ReorderFieldDefns()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition. </td></tr>
    <tr><td class="paramname">panMap</td><td>an array of GetFieldCount() elements which is a permutation of [0, GetFieldCount()-1]. panMap is such that, for each field definition at position i after reordering, its position before reordering was panMap[i]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.1.0 </dd></dl>

</div>
</div>
<a id="a1bbc85e1ba2378679e4ce6bf3523bf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbc85e1ba2378679e4ce6bf3523bf8e">&#9670;&nbsp;</a></span>OGR_FD_SetGeometryIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetGeometryIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIgnore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a539b87cd1587dc928b246a211839e22a" title="Set whether the geometry can be omitted when fetching features. ">OGRFeatureDefn::SetGeometryIgnored()</a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetIgnored().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
    <tr><td class="paramname">bIgnore</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ca3a84b54ac36c5f68a03821f1fa78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ca3a84b54ac36c5f68a03821f1fa78">&#9670;&nbsp;</a></span>OGR_FD_SetGeomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetGeomType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the base geometry type for the passed layer (the same as the feature definition). </p>
<p>All geometry objects using this type must be of the defined type or a derived type. The default upon creation is wkbUnknown which allows for any geometry type. The geometry type should generally not be changed after any OGRFeatures have been created against this definition.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#aa0f50b39efbba6559a510d7afcfa5efb" title="Assign the base geometry type for this layer. ">OGRFeatureDefn::SetGeomType()</a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetType().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the layer or feature definition to set the geometry type to. </td></tr>
    <tr><td class="paramname">eType</td><td>the new type to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c09218e9ef9e49abcdd0b76858a514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c09218e9ef9e49abcdd0b76858a514b">&#9670;&nbsp;</a></span>OGR_FD_SetStyleIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetStyleIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIgnore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a18e45edc2008f3a73e8bf4fed39fddd9" title="Set whether the style can be omitted when fetching features. ">OGRFeatureDefn::SetStyleIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> are based on. </td></tr>
    <tr><td class="paramname">bIgnore</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24af159359797a83c354fdf6cced3265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24af159359797a83c354fdf6cced3265">&#9670;&nbsp;</a></span>OGR_Fld_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> OGR_Fld_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new field definition. </p>
<p>By default, fields have no width, precision, are nullable and not ignored.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#afc375f038b548b5a86b854c214fee114" title="Constructor. ">OGRFieldDefn::OGRFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the new field definition. </td></tr>
    <tr><td class="paramname">eType</td><td>the type of the new field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the new field definition. </dd></dl>

</div>
</div>
<a id="a455fa4a2c2451b1748facb6b7126a822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455fa4a2c2451b1748facb6b7126a822">&#9670;&nbsp;</a></span>OGR_Fld_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a field definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc96ddb37f8b8076e711e48ee9ead62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc96ddb37f8b8076e711e48ee9ead62">&#9670;&nbsp;</a></span>OGR_Fld_GetDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default field value. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ac4210fa7c6f10ed090a5558224447cfa" title="Get default field value. ">OGRFieldDefn::GetDefault()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default field value or NULL. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a0cf8a09826e47763e6bf667af0dae1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf8a09826e47763e6bf667af0dae1a7">&#9670;&nbsp;</a></span>OGR_Fld_GetJustify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a> OGR_Fld_GetJustify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the justification for this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a5ac2afcfb22e885321bf877d2d1fd99d" title="Get the justification for this field. ">OGRFieldDefn::GetJustify()</a>.</p>
<p>Note: no driver is know to use the concept of field justification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get justification from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the justification. </dd></dl>

</div>
</div>
<a id="a8d7640a6b6a47a95d83415f9271ffe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7640a6b6a47a95d83415f9271ffe30">&#9670;&nbsp;</a></span>OGR_Fld_GetNameRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetNameRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a0264c5e7e6ff31fbd6a2b55aab86c6a6" title="Fetch name of this field. ">OGRFieldDefn::GetNameRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the field definition. </dd></dl>

</div>
</div>
<a id="a120dd56ee23070922e4d84ed06b06e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120dd56ee23070922e4d84ed06b06e27">&#9670;&nbsp;</a></span>OGR_Fld_GetPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_GetPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the formatting precision for this field. </p>
<p>This should normally be zero for fields of types other than OFTReal.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a86337654bc490bdc3e3b17e292b09c4b" title="Get the formatting precision for this field. ">OGRFieldDefn::GetPrecision()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get precision from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the precision. </dd></dl>

</div>
</div>
<a id="a3ef13952aa38f83b0dc1da047870511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef13952aa38f83b0dc1da047870511f">&#9670;&nbsp;</a></span>OGR_Fld_GetSubType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> OGR_Fld_GetSubType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch subtype of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a3c18c491717be99e2e1a3c96cfc2ffd9" title="Fetch subtype of this field. ">OGRFieldDefn::GetSubType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get subtype from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field subtype. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ad8d150dfc678e0a2a7f5241ba38c5611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d150dfc678e0a2a7f5241ba38c5611">&#9670;&nbsp;</a></span>OGR_Fld_GetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> OGR_Fld_GetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch type of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a8bb642e3e582146e3090247a1673d715" title="Fetch type of this field. ">OGRFieldDefn::GetType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field type. </dd></dl>

</div>
</div>
<a id="aa6500186e3f22761a615428c55bba0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6500186e3f22761a615428c55bba0ce">&#9670;&nbsp;</a></span>OGR_Fld_GetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_GetWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the formatting width for this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#aa8c4090f59d60ca949ba3fd0eada9f36" title="Get the formatting width for this field. ">OGRFieldDefn::GetWidth()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get width from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the width, zero means no specified width. </dd></dl>

</div>
</div>
<a id="a4bf08ca1607bdc678f2ae166ad0f27e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf08ca1607bdc678f2ae166ad0f27e2">&#9670;&nbsp;</a></span>OGR_Fld_IsDefaultDriverSpecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsDefaultDriverSpecific </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the default value is driver specific. </p>
<p>Driver specific default values are those that are <em>not</em> NULL, a numeric value, a literal value enclosed between single quote characters, CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal value.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a979f31c748be9d066c888c549e410876" title="Returns whether the default value is driver specific. ">OGRFieldDefn::IsDefaultDriverSpecific()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the default value is driver specific. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a29bec35ae5a4c232ad850315bdc2b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bec35ae5a4c232ad850315bdc2b675">&#9670;&nbsp;</a></span>OGR_Fld_IsIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ae55ec65c6013cfbf0bd08b7acecb0b9f" title="Return whether this field should be omitted when fetching features. ">OGRFieldDefn::IsIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state </dd></dl>

</div>
</div>
<a id="a57bfc414977d37ee22edefd38c1f414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bfc414977d37ee22edefd38c1f414b">&#9670;&nbsp;</a></span>OGR_Fld_IsNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this field can receive null values. </p>
<p>By default, fields are nullable.</p>
<p>Even if this method returns FALSE (i.e not-nullable field), it doesn't mean that <a class="el" href="classOGRFeature.html#a905bb73fe5e6df57f1be5a8b77489b74" title="Test if a field has ever been assigned a value or not. ">OGRFeature::IsFieldSet()</a> will necessary return TRUE, as fields can be temporary unset and null/not-null validation is usually done when <a class="el" href="classOGRLayer.html#a5d6db0be3b8876142d54e8bfd5dc8324" title="Create and write a new feature within a layer. ">OGRLayer::CreateFeature()</a>/SetFeature() is called.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a0a610ad741b9a6d81689de70133937d0" title="Return whether this field can receive null values. ">OGRFieldDefn::IsNullable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is authorized to be null. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a5922e599fe8746b81adf251be6b5ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5922e599fe8746b81adf251be6b5ecf0">&#9670;&nbsp;</a></span>OGR_Fld_Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_Set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNameIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eTypeIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nWidthIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPrecisionIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&#160;</td>
          <td class="paramname"><em>eJustifyIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set defining parameters for a field in one call. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a9b08b348f111ecbfe2970b312d9ce54b" title="Set defining parameters for a field in one call. ">OGRFieldDefn::Set()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set to. </td></tr>
    <tr><td class="paramname">pszNameIn</td><td>the new name to assign. </td></tr>
    <tr><td class="paramname">eTypeIn</td><td>the new type (one of the OFT values like OFTInteger). </td></tr>
    <tr><td class="paramname">nWidthIn</td><td>the preferred formatting width. Defaults to zero indicating undefined. </td></tr>
    <tr><td class="paramname">nPrecisionIn</td><td>number of decimals places for formatting, defaults to zero indicating undefined. </td></tr>
    <tr><td class="paramname">eJustifyIn</td><td>the formatting justification (OJLeft or OJRight), defaults to OJUndefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0268ee60f240e6fa668b7c612354f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0268ee60f240e6fa668b7c612354f80">&#9670;&nbsp;</a></span>OGR_Fld_SetDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default field value. </p>
<p>The default field value is taken into account by drivers (generally those with a SQL interface) that support it at field creation time. OGR will generally not automatically set the default field value to null fields by itself when calling <a class="el" href="classOGRFeature.html#a0ef4455f24cfbec6cf37110f9116cf15" title="Feature factory. ">OGRFeature::CreateFeature()</a> / OGRFeature::SetFeature(), but will let the low-level layers to do the job. So retrieving the feature from the layer is recommended.</p>
<p>The accepted values are NULL, a numeric value, a literal value enclosed between single quote characters (and inner single quote characters escaped by repetition of the single quote character), CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or a driver specific expression (that might be ignored by other drivers). For a datetime literal value, format should be 'YYYY/MM/DD HH:MM:SS[.sss]' (considered as UTC time).</p>
<p>Drivers that support writing DEFAULT clauses will advertise the GDAL_DCAP_DEFAULT_FIELDS driver metadata item.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a2371ed1f14f00bd9aa9ee4bce11dd768" title="Set default field value. ">OGRFieldDefn::SetDefault()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. </td></tr>
    <tr><td class="paramname">pszDefault</td><td>new default field value or NULL pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="aeddf9aa9767cd28c90dc66ed2a7a7332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddf9aa9767cd28c90dc66ed2a7a7332">&#9670;&nbsp;</a></span>OGR_Fld_SetIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a5d8df84c8a8d87908b8416fef6913934" title="Set whether this field should be omitted when fetching features. ">OGRFieldDefn::SetIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">ignore</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4809f2fe957002b8e18aacc1bdca240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4809f2fe957002b8e18aacc1bdca240">&#9670;&nbsp;</a></span>OGR_Fld_SetJustify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetJustify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&#160;</td>
          <td class="paramname"><em>eJustify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the justification for this field. </p>
<p>Note: no driver is know to use the concept of field justification.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#acbd783e3b61ab388eab3f45c25cf1bc0" title="Set the justification for this field. ">OGRFieldDefn::SetJustify()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set justification to. </td></tr>
    <tr><td class="paramname">eJustify</td><td>the new justification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6599fa42bad3aba26574ae3260c6984d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6599fa42bad3aba26574ae3260c6984d">&#9670;&nbsp;</a></span>OGR_Fld_SetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a241585cd66a38311aa0322f34e6d5214" title="Reset the name of this field. ">OGRFieldDefn::SetName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to apply the new name to. </td></tr>
    <tr><td class="paramname">pszName</td><td>the new name to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a35def2d6766804a59f0b4c24e457d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a35def2d6766804a59f0b4c24e457d5">&#9670;&nbsp;</a></span>OGR_Fld_SetNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNullableIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this field can receive null values. </p>
<p>By default, fields are nullable, so this method is generally called with FALSE to set a not-null constraint.</p>
<p>Drivers that support writing not-null constraint will advertise the GDAL_DCAP_NOTNULL_FIELDS driver metadata item.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ac10a3da064cd17f9b5d377b690d3162c" title="Set whether this field can receive null values. ">OGRFieldDefn::SetNullable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">bNullableIn</td><td>FALSE if the field must have a not-null constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a13890f01f7d7e57bcd07e23f3e2947da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13890f01f7d7e57bcd07e23f3e2947da">&#9670;&nbsp;</a></span>OGR_Fld_SetPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPrecision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the formatting precision for this field in characters. </p>
<p>This should normally be zero for fields of types other than OFTReal.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#abea88d3ed96c46b4f0eda415460f8664" title="Set the formatting precision for this field in characters. ">OGRFieldDefn::SetPrecision()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set precision to. </td></tr>
    <tr><td class="paramname">nPrecision</td><td>the new precision. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab83497e3ce74c6abb615a234791850c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83497e3ce74c6abb615a234791850c1">&#9670;&nbsp;</a></span>OGR_Fld_SetSubType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetSubType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eSubType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the subtype of this field. </p>
<p>This should never be done to an <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn. ">OGRFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#af5e277ae923683e8b4982d9dd009740d" title="Set the subtype of this field. ">OGRFieldDefn::SetSubType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set type to. </td></tr>
    <tr><td class="paramname">eSubType</td><td>the new field subtype. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a76195990f814eb93e821c01ce0599a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76195990f814eb93e821c01ce0599a50">&#9670;&nbsp;</a></span>OGR_Fld_SetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the type of this field. </p>
<p>This should never be done to an <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn. ">OGRFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a26bf22b7d805b9e33dd5c5fe9b4a8363" title="Set the type of this field. ">OGRFieldDefn::SetType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set type to. </td></tr>
    <tr><td class="paramname">eType</td><td>the new field type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d7bf7c14a299448efac58f7bf364326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7bf7c14a299448efac58f7bf364326">&#9670;&nbsp;</a></span>OGR_Fld_SetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the formatting width for this field in characters. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#aa793194c45ccba5ec7e9f7aea49dc6f3" title="Set the formatting width for this field in characters. ">OGRFieldDefn::SetWidth()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set width to. </td></tr>
    <tr><td class="paramname">nNewWidth</td><td>the new width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a15e130614cb4c66fc99bb93dc6b3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a15e130614cb4c66fc99bb93dc6b3b5">&#9670;&nbsp;</a></span>OGR_G_AddGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_AddGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hNewSubGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a geometry to a geometry container. </p>
<p>Some subclasses of <a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects. ">OGRGeometryCollection</a> restrict the types of geometry that can be added, and may return an error. The passed geometry is cloned to make an internal copy.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#a3da519655d14346e591d22a547562b0c" title="Add a geometry to the container. ">OGRGeometryCollection::addGeometry</a>.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>existing geometry container. </td></tr>
    <tr><td class="paramname">hNewSubGeom</td><td>geometry to add to the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of existing geometry. </dd></dl>

</div>
</div>
<a id="aff56cae8305396a9c5b690d8356e39c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff56cae8305396a9c5b690d8356e39c9">&#9670;&nbsp;</a></span>OGR_G_AddGeometryDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_AddGeometryDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hNewSubGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a geometry directly to an existing geometry container. </p>
<p>Some subclasses of <a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects. ">OGRGeometryCollection</a> restrict the types of geometry that can be added, and may return an error. Ownership of the passed geometry is taken by the container rather than cloning as addGeometry() does.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#a8422907a01d088ec5ef916382bea8eb3" title="Add a geometry directly to the container. ">OGRGeometryCollection::addGeometryDirectly</a>.</p>
<p>There is no SFCOM analog to this method.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>existing geometry. </td></tr>
    <tr><td class="paramname">hNewSubGeom</td><td>geometry to add to the existing geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of geometry container. </dd></dl>

</div>
</div>
<a id="aa2702d812663bc767e3a8f8832fda089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2702d812663bc767e3a8f8832fda089">&#9670;&nbsp;</a></span>OGR_G_AddPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfZ</td><td>z coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a280275c1492d6426cfe0a918d4725374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280275c1492d6426cfe0a918d4725374">&#9670;&nbsp;</a></span>OGR_G_AddPoint_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPoint_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16370d0b3feb2505fa5f3a2acfffbf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16370d0b3feb2505fa5f3a2acfffbf17">&#9670;&nbsp;</a></span>OGR_G_AddPointM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPointM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfM</td><td>m coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf01e19ca7b9951a5201b345ea130325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf01e19ca7b9951a5201b345ea130325">&#9670;&nbsp;</a></span>OGR_G_AddPointZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPointZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfZ</td><td>z coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfM</td><td>m coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87f8bce40c82b3513e36109ea051dff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f8bce40c82b3513e36109ea051dff2">&#9670;&nbsp;</a></span>OGR_G_ApproximateArcAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ApproximateArcAngles </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfPrimaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfSecondaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfStartAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfEndAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stroke arc to linestring. </p>
<p>Stroke an arc of a circle to a linestring based on a center point, radius, start angle and end angle, all angles in degrees.</p>
<p>If the dfMaxAngleStepSizeDegrees is zero, then a default value will be used. This is currently 4 degrees unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use. ">CPLSetConfigOption()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfCenterX</td><td>center X </td></tr>
    <tr><td class="paramname">dfCenterY</td><td>center Y </td></tr>
    <tr><td class="paramname">dfZ</td><td>center Z </td></tr>
    <tr><td class="paramname">dfPrimaryRadius</td><td>X radius of ellipse. </td></tr>
    <tr><td class="paramname">dfSecondaryRadius</td><td>Y radius of ellipse. </td></tr>
    <tr><td class="paramname">dfRotation</td><td>rotation of the ellipse clockwise. </td></tr>
    <tr><td class="paramname">dfStartAngle</td><td>angle to first point on arc (clockwise of X-positive) </td></tr>
    <tr><td class="paramname">dfEndAngle</td><td>angle to last point on arc (clockwise of X-positive) </td></tr>
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classOGRLineString.html" title="Concrete representation of a multi-vertex line. ">OGRLineString</a> geometry representing an approximation of the arc.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a2a849c584cd22a199bcfb9b34b9a1a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a849c584cd22a199bcfb9b34b9a1a8f">&#9670;&nbsp;</a></span>OGR_G_Area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute geometry area. </p>
<p>Computes the area for an <a class="el" href="classOGRLinearRing.html" title="Concrete representation of a closed ring. ">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html" title="Concrete class representing polygons. ">OGRPolygon</a> or <a class="el" href="classOGRMultiPolygon.html" title="A collection of non-overlapping OGRPolygon. ">OGRMultiPolygon</a>. Undefined for all other geometry types (returns zero).</p>
<p>This function utilizes the C++ get_Area() methods such as <a class="el" href="classOGRCurvePolygon.html#a6159cf2c28cd236ad2aa593c005c473a" title="Get the area of the surface object. ">OGRPolygon::get_Area()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area or 0.0 for unsupported geometry types.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a4dfbd5861e1cd20b372d090539fa4536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfbd5861e1cd20b372d090539fa4536">&#9670;&nbsp;</a></span>OGR_G_AssignSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AssignSpatialReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, but does not copy it.</p>
<p>Starting with GDAL 2.3, this will also assign the spatial reference to potential sub-geometries of the geometry (<a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects. ">OGRGeometryCollection</a>, OGRCurvePolygon/OGRPolygon, <a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves. ">OGRCompoundCurve</a>, <a class="el" href="classOGRPolyhedralSurface.html" title="PolyhedralSurface class. ">OGRPolyhedralSurface</a> and their derived classes).</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0" title="Assign spatial reference to this object. ">OGRGeometry::assignSpatialReference</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to apply the new spatial reference system. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle on the new spatial reference system to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88e2ce6b8ad4347fa8bdbb1cdc0ad272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e2ce6b8ad4347fa8bdbb1cdc0ad272">&#9670;&nbsp;</a></span>OGR_G_Boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="el" href="ogr__api_8h.html#a88e2ce6b8ad4347fa8bdbb1cdc0ad272" title="Compute boundary. ">OGR_G_Boundary()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>The Geometry to calculate the boundary of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a650366258bd4aa2a5a5e55966299cfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650366258bd4aa2a5a5e55966299cfc1">&#9670;&nbsp;</a></span>OGR_G_Buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nQuadSegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segments should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#af1b450af88d10c763e5fb86e056fb307" title="Compute buffer of geometry. ">OGRGeometry::Buffer()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</td></tr>
    <tr><td class="paramname">nQuadSegs</td><td>the number of segments used to approximate a 90 degree (quadrant) of curvature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="a23f5a19a81628af7f9cc59a37378cb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f5a19a81628af7f9cc59a37378cb2b">&#9670;&nbsp;</a></span>OGR_G_Centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hCentroidPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="el" href="classOGRPoint.html" title="Point class. ">OGRPoint</a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a91787f669b2a148169667e270e7e40df" title="Compute the geometry centroid. ">OGRGeometry::Centroid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_FAILURE on error. </dd></dl>

</div>
</div>
<a id="aed1c08151c1873ebd4722cdf79a5ae2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1c08151c1873ebd4722cdf79a5ae2c">&#9670;&nbsp;</a></span>OGR_G_Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of this object. </p>
<p>This function relates to the SFCOM IGeometry::clone() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a678d3e4fc419b7b714ecb80cbf603eb5" title="Make a copy of this object. ">OGRGeometry::clone()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to clone from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle on the copy of the geometry with the spatial reference system as the original. </dd></dl>

</div>
</div>
<a id="acfeb849dcfd4fdf4d6dab66e6ea697c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeb849dcfd4fdf4d6dab66e6ea697c0">&#9670;&nbsp;</a></span>OGR_G_CloseRings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_CloseRings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad87e37380f0320faddbe5e67e23312f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87e37380f0320faddbe5e67e23312f8">&#9670;&nbsp;</a></span>OGR_G_Contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if this geometry contains the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ae818178178f80c2987c6173ab4da041e" title="Test for containment. ">OGRGeometry::Contains()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if hThis contains hOther geometry, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="ad5408cae52870b2d162f166f42cd684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5408cae52870b2d162f166f42cd684b">&#9670;&nbsp;</a></span>OGR_G_ConvexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ConvexHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a94d1ef564a0423a7619b2acc61cdc0dd" title="Compute convex hull. ">OGRGeometry::ConvexHull()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>The Geometry to calculate the convex hull of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ac4843a200c0c4e57bbdc99e509f68baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4843a200c0c4e57bbdc99e509f68baf">&#9670;&nbsp;</a></span>OGR_G_CoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_CoordinateDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this geometry. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a35c4f4d75ec84fa225a9a4dee0a609c1" title="Get the dimension of the coordinates in this object. ">OGRGeometry::CoordinateDimension()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the dimension of the coordinates from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a3ab486f7ab98a4b592d25e4b8a0ac698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab486f7ab98a4b592d25e4b8a0ac698">&#9670;&nbsp;</a></span>OGR_G_CreateFromFgf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_CreateFromFgf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>phGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBytesConsumed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representation. </p>
<p>See <a class="el" href="classOGRGeometryFactory.html#a99be8486694e4b99384c38aab094ebdc" title="Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representa...">OGRGeometryFactory::createFromFgf()</a> </p>

</div>
</div>
<a id="a216201a5f821e553bd484d6953fa2ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216201a5f821e553bd484d6953fa2ffb">&#9670;&nbsp;</a></span>OGR_G_CreateFromGML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_CreateFromGML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszGML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create geometry from GML. </p>
<p>This method translates a fragment of GML containing only the geometry portion into a corresponding <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes. ">OGRGeometry</a>. There are many limitations on the forms of GML geometries supported by this parser, but they are too numerous to list here.</p>
<p>The following GML2 elements are parsed : Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.</p>
<p>(OGR &gt;= 1.8.0) The following GML3 elements are parsed : Surface, MultiSurface, PolygonPatch, Triangle, Rectangle, Curve, MultiCurve, CompositeCurve, LineStringSegment, Arc, Circle, CompositeSurface, OrientableSurface, Solid, Tin, TriangulatedSurface.</p>
<p>Arc and Circle elements are stroked to linestring, by using a 4 degrees step, unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>The C++ method <a class="el" href="classOGRGeometryFactory.html#af8714df4e6b6c5d5b2cdbdeec78af08c" title="Create geometry from GML. ">OGRGeometryFactory::createFromGML()</a> is the same as this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszGML</td><td>The GML fragment for the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a geometry on success, or NULL on error. </dd></dl>

</div>
</div>
<a id="a65af51cbb3d62789dee6f96044f4dcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65af51cbb3d62789dee6f96044f4dcb6">&#9670;&nbsp;</a></span>OGR_G_CreateFromWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_CreateFromWkb </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>phGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation. ">OGR_G_WkbSize()</a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>The <a class="el" href="classOGRGeometryFactory.html#a66de314779c192b94e2e8cf2836c13c8" title="Create a geometry object of the appropriate type from its well known binary representation. ">OGRGeometryFactory::createFromWkb()</a> CPP method is the same as this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">phGeometry</td><td>the newly created geometry object will be assigned to the indicated handle on return. This will be NULL in case of failure. If not NULL, *phGeometry should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object. ">OGR_G_DestroyGeometry()</a> after use. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes of data available in pabyData, or -1 if it is not known, but assumed to be sufficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="ac02c3ed5f7ebd5039dc2ae70154fd94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02c3ed5f7ebd5039dc2ae70154fd94a">&#9670;&nbsp;</a></span>OGR_G_CreateFromWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_CreateFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>phGeometry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known text representation. </p>
<p>The <a class="el" href="classOGRGeometryFactory.html#a955f997c743af4220655285eda8724a9" title="Create a geometry object of the appropriate type from its well known text representation. ">OGRGeometryFactory::createFromWkt</a> CPP method is the same as this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszData</td><td>input zero terminated string containing well known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">phGeometry</td><td>the newly created geometry object will be assigned to the indicated handle on return. This will be NULL if the method fails. If not NULL, *phGeometry should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object. ">OGR_G_DestroyGeometry()</a> after use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a60311342f2a329f433ea66e2d6fedadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60311342f2a329f433ea66e2d6fedadc">&#9670;&nbsp;</a></span>OGR_G_CreateGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_CreateGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eGeometryType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty geometry of desired type. </p>
<p>This is equivalent to allocating the desired geometry with new, but the allocation is guaranteed to take place in the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryFactory.html#ae4887e270d5099357f9a19b1eda6027a" title="Create an empty geometry of desired type. ">OGRGeometryFactory::createGeometry</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eGeometryType</td><td>the type code of the geometry to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the newly create geometry or NULL on failure. Should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object. ">OGR_G_DestroyGeometry()</a> after use. </dd></dl>

</div>
</div>
<a id="a7af82e14406879c08841331b2a4cfe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af82e14406879c08841331b2a4cfe7c">&#9670;&nbsp;</a></span>OGR_G_Crosses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Crosses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for crossing. </p>
<p>Tests if this geometry and the other geometry are crossing.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#adf30cb59307e8d5889e9fcf71d371afb" title="Test for crossing. ">OGRGeometry::Crosses()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are crossing, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a8fff3faa236d12e0374f5c65f61972ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fff3faa236d12e0374f5c65f61972ae">&#9670;&nbsp;</a></span>OGR_G_DelaunayTriangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_DelaunayTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bOnlyEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Delaunay triangulation of the vertices of the geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ab7d3c3e5b033ca6bbb470016e7661da7" title="Return a Delaunay triangulation of the vertices of the geometry. ">OGRGeometry::DelaunayTriangulation()</a>.</p>
<p>This function is built on the GEOS library, v3.4 or above. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dfTolerance</td><td>optional snapping tolerance to use for improved robustness </td></tr>
    <tr><td class="paramname">bOnlyEdges</td><td>if TRUE, will return a MULTILINESTRING, otherwise it will return a GEOMETRYCOLLECTION containing triangular POLYGONs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry resulting from the Delaunay triangulation or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.1 </dd></dl>

</div>
</div>
<a id="ac4e665f5f9690c4fa0c190b930fe9492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e665f5f9690c4fa0c190b930fe9492">&#9670;&nbsp;</a></span>OGR_G_DestroyGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_DestroyGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy geometry object. </p>
<p>Equivalent to invoking delete on a geometry, but it guaranteed to take place within the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object. ">OGRGeometryFactory::destroyGeometry</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4a22abdb38514237f13828dc1a987f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4a22abdb38514237f13828dc1a987f">&#9670;&nbsp;</a></span>OGR_G_Difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the other geometry removed.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a817c860c39a7b2848f0ff2105faaa25a" title="Compute difference. ">OGRGeometry::Difference()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </dd></dl>

</div>
</div>
<a id="a7980d65f3d82d5a5442c5141efe3f503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7980d65f3d82d5a5442c5141efe3f503">&#9670;&nbsp;</a></span>OGR_G_Disjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Disjoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for disjointness. </p>
<p>Tests if this geometry and the other geometry are disjoint.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#aaa4f0b34b165b589ffbef7d3ea65c00c" title="Test for disjointness. ">OGRGeometry::Disjoint()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are disjoint, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="ab01002a9fd4175832af965930f069401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01002a9fd4175832af965930f069401">&#9670;&nbsp;</a></span>OGR_G_Distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a72e832f8dc1001de35e9e888a4bae8b3" title="Compute distance between two geometries. ">OGRGeometry::Distance()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFirst</td><td>the first geometry to compare against. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a7313a805a15bf78a26c52ff1bc6242e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7313a805a15bf78a26c52ff1bc6242e2">&#9670;&nbsp;</a></span>OGR_G_Distance3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Distance3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 3D distance between two geometries. </p>
<p>The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is built on the SFCGAL library, check it for the definition of the geometry operation. If OGR is built without the SFCGAL library, this method will always return -1.0</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#aa2e39301afc475f5fff022af690fcf84" title="Returns the 3D distance between two geometries. ">OGRGeometry::Distance3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFirst</td><td>the first geometry to compare against. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>distance between the two geometries </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a3a99330bd108940f8a33036c0f83119f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a99330bd108940f8a33036c0f83119f">&#9670;&nbsp;</a></span>OGR_G_DumpReadable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_DumpReadable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>This method is the same as the CPP method <a class="el" href="classOGRGeometry.html#a846513c8437824899bcc6059f5070a23" title="Dump geometry in well known text format to indicated output file. ">OGRGeometry::dumpReadable</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to dump. </td></tr>
    <tr><td class="paramname">fp</td><td>the text file to write the geometry to. </td></tr>
    <tr><td class="paramname">pszPrefix</td><td>the prefix to put on each line of output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90cc83b0a3052b8fbe2ed77a86323bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cc83b0a3052b8fbe2ed77a86323bf2">&#9670;&nbsp;</a></span>OGR_G_Empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear geometry information. </p>
<p>This restores the geometry to its initial state after construction, and before assignment of actual geometry.</p>
<p>This function relates to the SFCOM IGeometry::Empty() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05" title="Clear geometry information. ">OGRGeometry::empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaed0c4fb6f08abc280f91619e2e47d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaed0c4fb6f08abc280f91619e2e47d3">&#9670;&nbsp;</a></span>OGR_G_Equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This operation implements the SQL/MM ST_OrderingEquals() operation.</p>
<p>The comparison is done in a structural way, that is to say that the geometry types must be identical, as well as the number and ordering of sub-geometries and vertices. Or equivalently, two geometries are considered equal by this method if their WKT/WKB representation is equal. Note: this must be distinguished for equality in a spatial way (which is the purpose of the ST_Equals() operation).</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a1b80c7f464de1d332215f16d35138590" title="Returns TRUE if two geometries are equivalent. ">OGRGeometry::Equals()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the first geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>handle on the other geometry to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ad273f59c62bc1354fb5d1b3758622955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad273f59c62bc1354fb5d1b3758622955">&#9670;&nbsp;</a></span>OGR_G_ExportEnvelopeToGMLTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* OGR_G_ExportEnvelopeToGMLTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the envelope of a geometry as a gml:Box. </p>

</div>
</div>
<a id="ac0cde7d88247415bf2d015b312ebb00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cde7d88247415bf2d015b312ebb00d">&#9670;&nbsp;</a></span>OGR_G_ExportToGML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToGML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#abbd63002f416db1ea0eb24857b5ef9f2" title="Convert a geometry into GML format. ">OGRGeometry::exportToGML()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ab95226e12c2de1cdd2837c1ca15366fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95226e12c2de1cdd2837c1ca15366fd">&#9670;&nbsp;</a></span>OGR_G_ExportToGMLEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToGMLEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>The supported options are : </p><ul>
<li>
FORMAT=GML2/GML3/GML32 (GML2 or GML32 added in GDAL 2.1). If not set, it will default to GML 2.1.2 output. </li>
<li>
GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used . </li>
<li>
GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3, deprecated by SRSNAME_FORMAT in GDAL &gt;=2.2). Defaults to YES. If YES, SRS with EPSG authority will be written with the "urn:ogc:def:crs:EPSG::" prefix. In the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it. If set to NO, SRS with EPSG authority will be written with the "EPSG:" prefix, even if they are in lat/long order. </li>
<li>
SRSNAME_FORMAT=SHORT/OGC_URN/OGC_URL (Only valid for FORMAT=GML3, added in GDAL 2.2). Defaults to OGC_URN. If SHORT, then srsName will be in the form AUTHORITY_NAME:AUTHORITY_CODE. If OGC_URN, then srsName will be in the form urn:ogc:def:crs:AUTHORITY_NAME::AUTHORITY_CODE. If OGC_URL, then srsName will be in the form <a href="http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE">http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE</a>. For OGC_URN and OGC_URL, in the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it. </li>
<li>
GMLID=astring. If specified, a gml:id attribute will be written in the top-level geometry element with the provided value. Required for GML 3.2 compatibility. </li>
<li>
<p class="startli">SRSDIMENSION_LOC=POSLIST/GEOMETRY/GEOMETRY,POSLIST. (Only valid for FORMAT=GML3/GML32, GDAL &gt;= 2.0) Default to POSLIST. For 2.5D geometries, define the location where to attach the srsDimension attribute. There are diverging implementations. Some put in on the &lt;gml:posList&gt; element, other on the top geometry element.</p>
<p class="endli"></p>
</li>
<li>
NAMESPACE_DECL=YES/NO. If set to YES, xmlns:gml="http://www.opengis.net/gml" will be added to the root node for GML &lt; 3.2 or xmlns:gml="http://www.opengis.net/gml/3.2" for GML 3.2 </li>
</ul>
<p>Note that curve geometries like CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE are not supported in GML 2.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#abbd63002f416db1ea0eb24857b5ef9f2" title="Convert a geometry into GML format. ">OGRGeometry::exportToGML()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GML fragment or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a556102dd03db654301035ad5ed1e14ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556102dd03db654301035ad5ed1e14ac">&#9670;&nbsp;</a></span>OGR_G_ExportToGMLTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* OGR_G_ExportToGMLTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>

</div>
</div>
<a id="a622a18776e6d51515d0f2ff0ee211d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622a18776e6d51515d0f2ff0ee211d91">&#9670;&nbsp;</a></span>OGR_G_ExportToIsoWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToIsoWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyDstBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method. It exports the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types.</p>
<p>This function is the same as the CPP method OGRGeometry::exportToWkb(OGRwkbByteOrder, unsigned char *, OGRwkbVariant) with eWkbVariant = wkbVariantIso.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a well know binary data from. </td></tr>
    <tr><td class="paramname">eOrder</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td class="paramname">pabyDstBuffer</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation. ">OGR_G_WkbSize()</a> byte in size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a0d988d220539479601e1a80a58864d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d988d220539479601e1a80a58864d1e">&#9670;&nbsp;</a></span>OGR_G_ExportToIsoWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToIsoWkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszSrcText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKT() method. It exports the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types.</p>
<p>This function is the same as the CPP method OGRGeometry::exportToWkt(wkbVariantIso).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a text format from. </td></tr>
    <tr><td class="paramname">ppszSrcText</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="aaf6d95725bd9fdb110b42d3c2749dd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6d95725bd9fdb110b42d3c2749dd38">&#9670;&nbsp;</a></span>OGR_G_ExportToJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToJson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#a7ae299ed972272fef0caea9d1949e98f" title="Convert a geometry into GeoJSON format. ">OGRGeometry::exportToJson()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GeoJSON fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="a9e034548ba5f4c24d6fe72688e26f5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e034548ba5f4c24d6fe72688e26f5ef">&#9670;&nbsp;</a></span>OGR_G_ExportToJsonEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToJsonEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>The following options are supported : </p><ul>
<li>
COORDINATE_PRECISION=number: maximum number of figures after decimal separator to write in coordinates. </li>
<li>
SIGNIFICANT_FIGURES=number: maximum number of significant figures (GDAL &gt;= 2.1). </li>
</ul>
<p>If COORDINATE_PRECISION is defined, SIGNIFICANT_FIGURES will be ignored if specified. When none are defined, the default is COORDINATE_PRECISION=15.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#a7ae299ed972272fef0caea9d1949e98f" title="Convert a geometry into GeoJSON format. ">OGRGeometry::exportToJson()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a null terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GeoJSON fragment or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a5a2d35d3f6f10b4ca936a40a76d70d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2d35d3f6f10b4ca936a40a76d70d20">&#9670;&nbsp;</a></span>OGR_G_ExportToKML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToKML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAltitudeMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#ab73487475ea43a2e677fe0556bf738e0" title="Convert a geometry into KML format. ">OGRGeometry::exportToKML()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">pszAltitudeMode</td><td>value to write in altitudeMode element, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A KML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ad5c94ae76c09774dba8725c24daeefd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c94ae76c09774dba8725c24daeefd6">&#9670;&nbsp;</a></span>OGR_G_ExportToWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyDstBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>For backward compatibility purposes, it exports the Old-style 99-402 extended dimension (Z) WKB types for types Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For other geometry types, it is equivalent to <a class="el" href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91" title="Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format. ">OGR_G_ExportToIsoWkb()</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a9a3ad2f9b55285be500ca6ac5dc75d1d" title="Convert a geometry into well known binary format. ">OGRGeometry::exportToWkb</a>(OGRwkbByteOrder, unsigned char *, OGRwkbVariant) with eWkbVariant = wkbVariantOldOgc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a well know binary data from. </td></tr>
    <tr><td class="paramname">eOrder</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td class="paramname">pabyDstBuffer</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation. ">OGR_G_WkbSize()</a> byte in size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="a3bc9310302e2dbfaab1690de9e2fd2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc9310302e2dbfaab1690de9e2fd2fb">&#9670;&nbsp;</a></span>OGR_G_ExportToWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToWkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszSrcText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>For backward compatibility purposes, it exports the Old-style 99-402 extended dimension (Z) WKB types for types Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For other geometry types, it is equivalent to <a class="el" href="ogr__api_8h.html#a0d988d220539479601e1a80a58864d1e" title="Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format. ">OGR_G_ExportToIsoWkt()</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ad17cfebfd9826a22763dff6280ba196e" title="Convert a geometry into well known text format. ">OGRGeometry::exportToWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a text format from. </td></tr>
    <tr><td class="paramname">ppszSrcText</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="afdb7354b55c7448b60b44cd9e36073b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb7354b55c7448b60b44cd9e36073b8">&#9670;&nbsp;</a></span>OGR_G_FlattenTo2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_FlattenTo2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert geometry to strictly 2D. </p>
<p>In a sense this converts all Z coordinates to 0.0.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9" title="Convert geometry to strictly 2D. ">OGRGeometry::flattenTo2D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a37c25a9b628982e86b1821446e3a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a37c25a9b628982e86b1821446e3a0e">&#9670;&nbsp;</a></span>OGR_G_ForceTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eTargetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to another geometry type. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a26120382ccfec8ac4b5f932dd3a67c5f" title="Convert to another geometry type. ">OGRGeometryFactory::forceTo()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the input geometry - ownership is passed to the method. </td></tr>
    <tr><td class="paramname">eTargetType</td><td>target output geometry type. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a5cee9b0081977f61681a909231608146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cee9b0081977f61681a909231608146">&#9670;&nbsp;</a></span>OGR_G_ForceToLineString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to line string. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3" title="Convert to line string. ">OGRGeometryFactory::forceToLineString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.10.0 </dd></dl>

</div>
</div>
<a id="a0776505ab4794d50e425b5333415cf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0776505ab4794d50e425b5333415cf9b">&#9670;&nbsp;</a></span>OGR_G_ForceToMultiLineString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToMultiLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to multilinestring. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39" title="Convert to multilinestring. ">OGRGeometryFactory::forceToMultiLineString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="abb60e8b68ba76843577df5ebab22ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb60e8b68ba76843577df5ebab22ab95">&#9670;&nbsp;</a></span>OGR_G_ForceToMultiPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToMultiPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to multipoint. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3" title="Convert to multipoint. ">OGRGeometryFactory::forceToMultiPoint()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a4c0c5be9aa982ba776f4cfdab4d8b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0c5be9aa982ba776f4cfdab4d8b798">&#9670;&nbsp;</a></span>OGR_G_ForceToMultiPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToMultiPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to multipolygon. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e" title="Convert to multipolygon. ">OGRGeometryFactory::forceToMultiPolygon()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a0fc3d5b213a7891355329d205aaa0d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc3d5b213a7891355329d205aaa0d2c">&#9670;&nbsp;</a></span>OGR_G_ForceToPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to polygon. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08" title="Convert to polygon. ">OGRGeometryFactory::forceToPolygon()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a8a5e78b0753339d1cdd282b0e151d28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5e78b0753339d1cdd282b0e151d28f">&#9670;&nbsp;</a></span>OGR_G_GetCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this geometry. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a4a6fdd4df7c043558b5428d8f1c35b16" title="Get the dimension of the coordinates in this object. ">OGRGeometry::getCoordinateDimension()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the dimension of the coordinates from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>use <a class="el" href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf" title="Get the dimension of the coordinates in this geometry. ">OGR_G_CoordinateDimension()</a>, <a class="el" href="ogr__api_8h.html#af2d4c2fb8935e9ee9584f0243e4bd0ca" title="See whether this geometry has Z coordinates. ">OGR_G_Is3D()</a>, or <a class="el" href="ogr__api_8h.html#a84a8bf231d721ac04ed465d5208bac6e" title="See whether this geometry is measured. ">OGR_G_IsMeasured()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 or 3. </dd></dl>

</div>
</div>
<a id="a4989d5287899041d70f4176d41ceeac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4989d5287899041d70f4176d41ceeac2">&#9670;&nbsp;</a></span>OGR_G_GetCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_GetCurveGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return curve version of this geometry. </p>
<p>Returns a geometry that has possibly CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by de-approximating linear into curve geometries.</p>
<p>If the geometry has no curve portion, the returned geometry will be a clone of it.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse function is <a class="el" href="ogr__api_8h.html#a6bd069f8338954fc8a6215594a37a8db" title="Return, possibly approximate, linear version of this geometry. ">OGR_G_GetLinearGeometry()</a>.</p>
<p>This function is the same as C++ method <a class="el" href="classOGRGeometry.html#a49749581ed7c99f9923029333f7c834c" title="Return curve version of this geometry. ">OGRGeometry::getCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. Unused for now. Must be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a94b633e1acd208c258ad49f8d4fd4104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b633e1acd208c258ad49f8d4fd4104">&#9670;&nbsp;</a></span>OGR_G_GetDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of this geometry. </p>
<p>This function corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the geometry, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f" title="Get the dimension of the coordinates in this geometry. ">OGR_G_GetCoordinateDimension()</a> function).</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb" title="Get the dimension of this object. ">OGRGeometry::getDimension()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the dimension from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

</div>
</div>
<a id="a617a9c9ea85157661619a1d8f0a69cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617a9c9ea85157661619a1d8f0a69cf9">&#9670;&nbsp;</a></span>OGR_G_GetEnvelope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle of the geometry to get envelope from. </td></tr>
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a950633ac824042b0afdb88c670c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a950633ac824042b0afdb88c670c5ce">&#9670;&nbsp;</a></span>OGR_G_GetEnvelope3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetEnvelope3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle of the geometry to get envelope from. </td></tr>
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a1fa07ddf969f97f6444de6ae5128d842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa07ddf969f97f6444de6ae5128d842">&#9670;&nbsp;</a></span>OGR_G_GetGeometryCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetGeometryCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the number of elements in a geometry or number of geometries in container. </p>
<p>Only geometries of type wkbPolygon[25D], wkbMultiPoint[25D], wkbMultiLineString[25D], wkbMultiPolygon[25D] or wkbGeometryCollection[25D] may return a valid value. Other geometry types will silently return 0.</p>
<p>For a polygon, the returned number is the number of rings (exterior ring + interior rings).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>single geometry or geometry container from which to get the number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements. </dd></dl>

</div>
</div>
<a id="a18121f835b2fb724a0c1a87beb1a437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18121f835b2fb724a0c1a87beb1a437a">&#9670;&nbsp;</a></span>OGR_G_GetGeometryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_G_GetGeometryName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this function.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8" title="Fetch WKT name for geometry type. ">OGRGeometry::getGeometryName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name used for this geometry type in well known text format. </dd></dl>

</div>
</div>
<a id="a6bac93150529a5c98811db29e289dd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bac93150529a5c98811db29e289dd66">&#9670;&nbsp;</a></span>OGR_G_GetGeometryRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_GetGeometryRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iSubGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry from a geometry container. </p>
<p>This function returns an handle to a geometry within the container. The returned geometry remains owned by the container, and should not be modified. The handle is only valid until the next change to the geometry container. Use <a class="el" href="ogr__api_8h.html#aed1c08151c1873ebd4722cdf79a5ae2c" title="Make a copy of this object. ">OGR_G_Clone()</a> to make a copy.</p>
<p>This function relates to the SFCOM IGeometryCollection::get_Geometry() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3" title="Fetch geometry from container. ">OGRGeometryCollection::getGeometryRef()</a>.</p>
<p>For a polygon, OGR_G_GetGeometryRef(iSubGeom) returns the exterior ring if iSubGeom == 0, and the interior rings for iSubGeom &gt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry container from which to get a geometry from. </td></tr>
    <tr><td class="paramname">iSubGeom</td><td>the index of the geometry to fetch, between 0 and getNumGeometries() - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the requested geometry. </dd></dl>

</div>
</div>
<a id="a8fae58102f5c4a4cf2526e5ca8369a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fae58102f5c4a4cf2526e5ca8369a76">&#9670;&nbsp;</a></span>OGR_G_GetGeometryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_G_GetGeometryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten()</a> macro to the return result.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type. ">OGRGeometry::getGeometryType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry type code. </dd></dl>

</div>
</div>
<a id="a6bd069f8338954fc8a6215594a37a8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd069f8338954fc8a6215594a37a8db">&#9670;&nbsp;</a></span>OGR_G_GetLinearGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_GetLinearGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return, possibly approximate, linear version of this geometry. </p>
<p>Returns a geometry that has no CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by approximating curve geometries.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse function is <a class="el" href="ogr__api_8h.html#a4989d5287899041d70f4176d41ceeac2" title="Return curve version of this geometry. ">OGR_G_GetCurveGeometry()</a>.</p>
<p>This method relates to the ISO SQL/MM Part 3 ICurve::CurveToLine() and CurvePolygon::CurvePolyToPoly() methods.</p>
<p>This function is the same as C++ method <a class="el" href="classOGRGeometry.html#ac13fa59ae1a0d46070e05d8007bd295e" title="Return, possibly approximate, non-curve version of this geometry. ">OGRGeometry::getLinearGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings or NULL. See <a class="el" href="classOGRGeometryFactory.html#a6f661d6691fcf745ca185ae4d586156c" title="Converts an arc circle into an approximate line string. ">OGRGeometryFactory::curveToLineString()</a> for valid options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a49fa1c4594aa103068870ef4b4ef094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fa1c4594aa103068870ef4b4ef094f">&#9670;&nbsp;</a></span>OGR_G_GetM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the m coordinate of a point from a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the M coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the M coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the M coordinate of this point. </dd></dl>

</div>
</div>
<a id="a67b897ffcd88a83832964c3735fa1dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b897ffcd88a83832964c3735fa1dcb">&#9670;&nbsp;</a></span>OGR_G_GetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a point in line string or a point geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">i</td><td>the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. </td></tr>
    <tr><td class="paramname">pdfX</td><td>value of x coordinate. </td></tr>
    <tr><td class="paramname">pdfY</td><td>value of y coordinate. </td></tr>
    <tr><td class="paramname">pdfZ</td><td>value of z coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec43cbe83609bc7b43739d67858846c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec43cbe83609bc7b43739d67858846c1">&#9670;&nbsp;</a></span>OGR_G_GetPointCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPointCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of points from a geometry. </p>
<p>Only wkbPoint[25D] or wkbLineString[25D] may return a valid value. Other geometry types will silently return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points. </dd></dl>

</div>
</div>
<a id="a6c22d91b27d7a42c225a7dfde28f09c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c22d91b27d7a42c225a7dfde28f09c4">&#9670;&nbsp;</a></span>OGR_G_GetPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutive elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">pabyX</td><td>a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td class="paramname">pabyY</td><td>a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td class="paramname">pabyZ</td><td>a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pabyZ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a0ce63762b79f4d882e1498981a4c26ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce63762b79f4d882e1498981a4c26ba">&#9670;&nbsp;</a></span>OGR_G_GetPointsZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPointsZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutive elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">pabyX</td><td>a buffer of at least (nXStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td class="paramname">pabyY</td><td>a buffer of at least (nYStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td class="paramname">pabyZ</td><td>a buffer of at last size (nZStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pabyZ. </td></tr>
    <tr><td class="paramname">pabyM</td><td>a buffer of at last size (nMStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nMStride</td><td>the number of bytes between 2 elements of pabyM.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a362999cdf708959829209e9d885d923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362999cdf708959829209e9d885d923d">&#9670;&nbsp;</a></span>OGR_G_GetPointZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetPointZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a point in line string or a point geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">i</td><td>the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. </td></tr>
    <tr><td class="paramname">pdfX</td><td>value of x coordinate. </td></tr>
    <tr><td class="paramname">pdfY</td><td>value of y coordinate. </td></tr>
    <tr><td class="paramname">pdfZ</td><td>value of z coordinate. </td></tr>
    <tr><td class="paramname">pdfM</td><td>value of m coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc393e40282eec3801fb4a4abc9e25bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc393e40282eec3801fb4a4abc9e25bf">&#9670;&nbsp;</a></span>OGR_G_GetSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> OGR_G_GetSpatialReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns spatial reference system for geometry. </p>
<p>This function relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a66a53c103e37c6d1ead00d2d74586ddd" title="Returns spatial reference system for object. ">OGRGeometry::getSpatialReference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get spatial reference from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the spatial reference geometry. </dd></dl>

</div>
</div>
<a id="a354146161d0a087b63ab6e350bae4d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354146161d0a087b63ab6e350bae4d86">&#9670;&nbsp;</a></span>OGR_G_GetX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the x coordinate of a point from a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the x coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the x coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the X coordinate of this point. </dd></dl>

</div>
</div>
<a id="a8405350c9aea2ab7d0f759f0b09b926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8405350c9aea2ab7d0f759f0b09b926f">&#9670;&nbsp;</a></span>OGR_G_GetY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the x coordinate of a point from a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the y coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the Y coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Y coordinate of this point. </dd></dl>

</div>
</div>
<a id="a1d8c6aeb013325f33b8e642003fc17ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8c6aeb013325f33b8e642003fc17ad">&#9670;&nbsp;</a></span>OGR_G_GetZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the z coordinate of a point from a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the Z coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the Z coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Z coordinate of this point. </dd></dl>

</div>
</div>
<a id="af4f8e7d05f06a1fe69ea9638085e5e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f8e7d05f06a1fe69ea9638085e5e26">&#9670;&nbsp;</a></span>OGR_G_HasCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_HasCurveGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bLookForNonLinear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if this geometry is or has curve geometry. </p>
<p>Returns if a geometry is or has CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it.</p>
<p>If bLookForNonLinear is set to TRUE, it will be actually looked if the geometry or its subgeometries are or contain a non-linear geometry in them. In which case, if the method returns TRUE, it means that <a class="el" href="ogr__api_8h.html#a6bd069f8338954fc8a6215594a37a8db" title="Return, possibly approximate, linear version of this geometry. ">OGR_G_GetLinearGeometry()</a> would return an approximate version of the geometry. Otherwise, <a class="el" href="ogr__api_8h.html#a6bd069f8338954fc8a6215594a37a8db" title="Return, possibly approximate, linear version of this geometry. ">OGR_G_GetLinearGeometry()</a> would do a conversion, but with just converting container type, like COMPOUNDCURVE -&gt; LINESTRING, MULTICURVE -&gt; MULTILINESTRING or MULTISURFACE -&gt; MULTIPOLYGON, resulting in a "loss-less" conversion.</p>
<p>This function is the same as C++ method <a class="el" href="classOGRGeometry.html#a15afb03f64091205af0530d8d1262798" title="Returns if this geometry is or has curve geometry. ">OGRGeometry::hasCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
    <tr><td class="paramname">bLookForNonLinear</td><td>set it to TRUE to check if the geometry is or contains a CIRCULARSTRING. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this geometry is or has curve geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ae523fe14c8c87dffcee706438ec2e81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae523fe14c8c87dffcee706438ec2e81f">&#9670;&nbsp;</a></span>OGR_G_ImportFromWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ImportFromWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a0e604e7393db0dd511b458f3ecd0b819" title="Assign geometry from well known binary data. ">OGRGeometry::importFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to assign the well know binary data to. </td></tr>
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a4286ba243fb05a831a49f52aabcbc6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4286ba243fb05a831a49f52aabcbc6f8">&#9670;&nbsp;</a></span>OGR_G_ImportFromWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ImportFromWkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszSrcText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66" title="Assign geometry from well known text data. ">OGRGeometry::importFromWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to assign well know text data to. </td></tr>
    <tr><td class="paramname">ppszSrcText</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a96d73915584c997f9bd79c8940379578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d73915584c997f9bd79c8940379578">&#9670;&nbsp;</a></span>OGR_G_Intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87" title="Do these features intersect? ">OGR_G_Intersects()</a> function can be used to test if two geometries intersect.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a83adb426e79958c90aecb418d91c765c" title="Compute intersection. ">OGRGeometry::Intersection()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </dd></dl>

</div>
</div>
<a id="acaed6926b75cd33a42b284c10def6e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaed6926b75cd33a42b284c10def6e87">&#9670;&nbsp;</a></span>OGR_G_Intersects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOtherGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do these features intersect? </p>
<p>Determines whether two geometries intersect. If GEOS is enabled, then this is done in rigorous fashion otherwise TRUE is returned if the envelopes (bounding boxes) of the two geometries overlap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a12b9bf1e607908703d68bcdd5a82440c" title="Do these features intersect? ">OGRGeometry::Intersects</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the first geometry. </td></tr>
    <tr><td class="paramname">hOtherGeom</td><td>handle on the other geometry to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometries intersect, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="af2d4c2fb8935e9ee9584f0243e4bd0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d4c2fb8935e9ee9584f0243e4bd0ca">&#9670;&nbsp;</a></span>OGR_G_Is3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Is3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See whether this geometry has Z coordinates. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ae9867dbbd6b840ca9c9240c7cb9c3b8c">OGRGeometry::Is3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to check whether it has Z coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has Z coordinates. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a737b0c4d73928e7406d69c658209dbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737b0c4d73928e7406d69c658209dbbf">&#9670;&nbsp;</a></span>OGR_G_IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the geometry is empty. </p>
<p>This method is the same as the CPP method <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111" title="Returns TRUE (non-zero) if the object has no points. ">OGRGeometry::IsEmpty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a84a8bf231d721ac04ed465d5208bac6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a8bf231d721ac04ed465d5208bac6e">&#9670;&nbsp;</a></span>OGR_G_IsMeasured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsMeasured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See whether this geometry is measured. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a959d5776c17018e362b580b1e61e1caa">OGRGeometry::IsMeasured()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to check whether it is measured.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has M coordinates. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ab9e99b4792042aca861866cb29bdf826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e99b4792042aca861866cb29bdf826">&#9670;&nbsp;</a></span>OGR_G_IsRing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the geometry is a ring. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#afe3c69f5b89fa5eb0bfb03e4880822bf" title="Test if the geometry is a ring. ">OGRGeometry::IsRing()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a3cb66472d7e302d16aacf0d66c01ac73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb66472d7e302d16aacf0d66c01ac73">&#9670;&nbsp;</a></span>OGR_G_IsSimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsSimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the geometry is simple. </p>
<p>Returns TRUE if the geometry has no anomalous geometric points, such as self intersection or self tangency. The description of each instantiable geometric class will include the specific conditions that cause an instance of that class to be classified as not simple.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#afe41ef903c94999a81a98c356b32e624" title="Test if the geometry is simple. ">OGRGeometry::IsSimple()</a> method.</p>
<p>If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if object is simple, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a4df68924f3b41fd377c5b4aa6631a00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df68924f3b41fd377c5b4aa6631a00b">&#9670;&nbsp;</a></span>OGR_G_IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the geometry is valid. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid. ">OGRGeometry::IsValid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a5eb038c3271dbf41ac7ebc02fad3907f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb038c3271dbf41ac7ebc02fad3907f">&#9670;&nbsp;</a></span>OGR_G_Length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute length of a geometry. </p>
<p>Computes the length for <a class="el" href="classOGRCurve.html" title="Abstract curve base class for OGRLineString, OGRCircularString and OGRCompoundCurve. ">OGRCurve</a> or MultiCurve objects. Undefined for all other geometry types (returns zero).</p>
<p>This function utilizes the C++ get_Length() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length or 0.0 for unsupported geometry types.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a60dbb0e05a715b16404a673d1ae2c9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dbb0e05a715b16404a673d1ae2c9f5">&#9670;&nbsp;</a></span>OGR_G_MakeValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_MakeValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to make an invalid geometry valid without losing vertices. </p>
<p>Already-valid geometries are cloned without further intervention.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a26664b35c9a65737ccb26a38dc161214" title="Attempts to make an invalid geometry valid without losing vertices. ">OGRGeometry::MakeValid()</a>.</p>
<p>This function is built on the GEOS &gt;= 3.8 library, check it for the definition of the geometry operation. If OGR is built without the GEOS &gt;= 3.8 library, this function will return a clone of the input geometry if it is valid, or NULL if it is invalid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to make valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a07acfe1bef39cd2cd1ad4a5ec26f2ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">&#9670;&nbsp;</a></span>OGR_G_Overlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Overlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for overlap. </p>
<p>Tests if this geometry and the other geometry overlap, that is their intersection has a non-zero area.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a432b89868f8094004467e8e9b51ad5ca" title="Test for overlap. ">OGRGeometry::Overlaps()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are overlapping, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a1b43b2b0a38c1d63d785c37b392dc9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b43b2b0a38c1d63d785c37b392dc9ec">&#9670;&nbsp;</a></span>OGR_G_PointOnSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_PointOnSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a point guaranteed to lie on the surface. </p>
<p>This method relates to the SFCOM ISurface::get_PointOnSurface() method however the current implementation based on GEOS can operate on other geometry types than the types that are supported by SQL/MM-Part 3 : surfaces (polygons) and multisurfaces (multipolygons).</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a point guaranteed to lie on the surface or NULL if an error occurred.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="ad7c6a082065407712ff865471ad7136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c6a082065407712ff865471ad7136f">&#9670;&nbsp;</a></span>OGR_G_Polygonize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Polygonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topological inconsistencies.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a5524faa1746d9b6646ce5c6f28d31291" title="Polygonizes a set of sparse edges. ">OGRGeometry::Polygonize()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>The Geometry to be polygonized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a54ea024bb659e48d3297404e53800237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ea024bb659e48d3297404e53800237">&#9670;&nbsp;</a></span>OGR_G_RemoveGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_RemoveGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a geometry from an exiting geometry container. </p>
<p>Removing a geometry will cause the geometry count to drop by one, and all "higher" geometries will shuffle down one in index.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#ae37405203118eeb0430ef38668a385b7" title="Remove a geometry from the container. ">OGRGeometryCollection::removeGeometry()</a> for geometry collections, <a class="el" href="classOGRCurvePolygon.html#af7fb46dfd0cd7eebe68555ac1b6da76f" title="Remove a geometry from the container. ">OGRCurvePolygon::removeRing()</a> for polygons / curve polygons and <a class="el" href="classOGRPolyhedralSurface.html#afb16af941e5fc7d2758c033c490cac4b" title="Remove a geometry from the container. ">OGRPolyhedralSurface::removeGeometry()</a> for polyhedral surfaces and TINs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the existing geometry to delete from. </td></tr>
    <tr><td class="paramname">iGeom</td><td>the index of the geometry to delete. A value of -1 is a special flag meaning that all geometries should be removed.</td></tr>
    <tr><td class="paramname">bDelete</td><td>if TRUE the geometry will be destroyed, otherwise it will not. The default is TRUE as the existing geometry is considered to own the geometries in it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is out of range. </dd></dl>

</div>
</div>
<a id="af244bd6a0608d0b817efb7747c9a1ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af244bd6a0608d0b817efb7747c9a1ef6">&#9670;&nbsp;</a></span>OGR_G_RemoveLowerDimensionSubGeoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_RemoveLowerDimensionSubGeoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove sub-geometries from a geometry collection that do not have the maximum topological dimensionality of the collection. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a9dda76280700944f813f6b4c8e7be7a0" title="Remove sub-geometries from a geometry collection that do not have the maximum topological dimensional...">OGRGeometryFactory::removeLowerDimensionSubGeoms()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="ade9f08c8d63bc0e726cb20c201c86423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9f08c8d63bc0e726cb20c201c86423">&#9670;&nbsp;</a></span>OGR_G_Segmentize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Segmentize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5" title="Modify the geometry such it has no segment longer then the given distance. ">OGRGeometry::segmentize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to segmentize </td></tr>
    <tr><td class="paramname">dfMaxLength</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13c109c8afc2c614f206f8f610c7c4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c109c8afc2c614f206f8f610c7c4be">&#9670;&nbsp;</a></span>OGR_G_Set3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Set3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIs3D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add or remove the Z coordinate dimension. </p>
<p>This method adds or removes the explicit Z coordinate dimension. Removing the Z coordinate dimension of a geometry will remove any existing Z values. Adding the Z dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to set or unset the Z dimension. </td></tr>
    <tr><td class="paramname">bIs3D</td><td>Should the geometry have a Z dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ac6bcad9553f488f7d8b6c8674cf7771c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bcad9553f488f7d8b6c8674cf7771c">&#9670;&nbsp;</a></span>OGR_G_SetCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewDimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection, a compound curve, a polygon, etc. will affect the children geometries. This will also remove the M dimension if present before this call.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>use <a class="el" href="ogr__api_8h.html#a13c109c8afc2c614f206f8f610c7c4be" title="Add or remove the Z coordinate dimension. ">OGR_G_Set3D()</a> or <a class="el" href="ogr__api_8h.html#a8840ed4e65bfbf50a6a52779305a78f6" title="Add or remove the M coordinate dimension. ">OGR_G_SetMeasured()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to set the dimension of the coordinates. </td></tr>
    <tr><td class="paramname">nNewDimension</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8840ed4e65bfbf50a6a52779305a78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8840ed4e65bfbf50a6a52779305a78f6">&#9670;&nbsp;</a></span>OGR_G_SetMeasured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetMeasured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIsMeasured</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add or remove the M coordinate dimension. </p>
<p>This method adds or removes the explicit M coordinate dimension. Removing the M coordinate dimension of a geometry will remove any existing M values. Adding the M dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to set or unset the M dimension. </td></tr>
    <tr><td class="paramname">bIsMeasured</td><td>Should the geometry have a M dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a303fb1a2a94363c15f9e61dc46b710e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303fb1a2a94363c15f9e61dc46b710e8">&#9670;&nbsp;</a></span>OGR_G_SetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
    <tr><td class="paramname">dfZ</td><td>input Z coordinate to assign (defaults to zero). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab14b9730d6f9fc829fe6be9bc2a5ec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14b9730d6f9fc829fe6be9bc2a5ec48">&#9670;&nbsp;</a></span>OGR_G_SetPoint_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoint_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f4f7bff0d685b2713504bd89b14d0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4f7bff0d685b2713504bd89b14d0fc">&#9670;&nbsp;</a></span>OGR_G_SetPointCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewPointCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set number of points in a geometry. </p>
<p>This method primary exists to preset the number of points in a linestring geometry before setPoint() is used to assign them to avoid reallocating the array larger with each call to addPoint().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">nNewPointCount</td><td>the new number of points for geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4ce9b54d1e821bd020a7a6731d2f529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ce9b54d1e821bd020a7a6731d2f529">&#9670;&nbsp;</a></span>OGR_G_SetPointM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
    <tr><td class="paramname">dfM</td><td>input M coordinate to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51438701454d7e86988efc62b25d6aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51438701454d7e86988efc62b25d6aeb">&#9670;&nbsp;</a></span>OGR_G_SetPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign all points in a point or a line string geometry. </p>
<p>This method clear any existing points assigned to this geometry, and assigns a whole new set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to set the coordinates. </td></tr>
    <tr><td class="paramname">nPointsIn</td><td>number of points being passed in padfX and padfY. </td></tr>
    <tr><td class="paramname">pabyX</td><td>list of X coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td class="paramname">pabyY</td><td>list of Y coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td class="paramname">pabyZ</td><td>list of Z coordinates (double values) of points being assigned (defaults to NULL for 2D objects). </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pabyZ. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac54402dc365f496b29ad1f01261e4576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54402dc365f496b29ad1f01261e4576">&#9670;&nbsp;</a></span>OGR_G_SetPointsZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointsZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign all points in a point or a line string geometry. </p>
<p>This method clear any existing points assigned to this geometry, and assigns a whole new set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to set the coordinates. </td></tr>
    <tr><td class="paramname">nPointsIn</td><td>number of points being passed in padfX and padfY. </td></tr>
    <tr><td class="paramname">pX</td><td>list of X coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pX. </td></tr>
    <tr><td class="paramname">pY</td><td>list of Y coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pY. </td></tr>
    <tr><td class="paramname">pZ</td><td>list of Z coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have Z coordinate). </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pZ. </td></tr>
    <tr><td class="paramname">pM</td><td>list of M coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have M coordinate). </td></tr>
    <tr><td class="paramname">nMStride</td><td>the number of bytes between 2 elements of pM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a034b6b1bae3843345cbfc78e07fa7075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034b6b1bae3843345cbfc78e07fa7075">&#9670;&nbsp;</a></span>OGR_G_SetPointZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
    <tr><td class="paramname">dfZ</td><td>input Z coordinate to assign. </td></tr>
    <tr><td class="paramname">dfM</td><td>input M coordinate to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7727c1e3f1aea8740020a75d150b09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7727c1e3f1aea8740020a75d150b09c">&#9670;&nbsp;</a></span>OGR_G_Simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a simplified geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#acf92969a640cdd29c4c4eaacc95e6093" title="Simplify the geometry. ">OGRGeometry::Simplify()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a2393494229046406871c38e58ffaf156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2393494229046406871c38e58ffaf156">&#9670;&nbsp;</a></span>OGR_G_SimplifyPreserveTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_SimplifyPreserveTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a0f4d7948332d9efd6548e1cf87bb6c8f" title="Simplify the geometry while preserving topology. ">OGRGeometry::SimplifyPreserveTopology()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a4cacbe8ef1bbacdcee7ad7c3d74ed593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cacbe8ef1bbacdcee7ad7c3d74ed593">&#9670;&nbsp;</a></span>OGR_G_SwapXY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SwapXY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.3.0 </dd></dl>

</div>
</div>
<a id="af59305c5838b6118e2d3f57f919ae666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59305c5838b6118e2d3f57f919ae666">&#9670;&nbsp;</a></span>OGR_G_SymDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_SymDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method OGRGeometry::SymmetricDifference().</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a6f67616eb88f479eba50f9783c8494d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f67616eb88f479eba50f9783c8494d9">&#9670;&nbsp;</a></span>OGR_G_Touches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Touches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for touching. </p>
<p>Tests if this geometry and the other geometry are touching.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#abd1be78538ab56a7c16cfa65797eeb0c" title="Test for touching. ">OGRGeometry::Touches()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are touching, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a59a5b3f954b11cfbf6e78807c28d6090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a5b3f954b11cfbf6e78807c28d6090">&#9670;&nbsp;</a></span>OGR_G_Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>&#160;</td>
          <td class="paramname"><em>hTransform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this function does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba" title="Apply arbitrary coordinate transformation to geometry. ">OGRGeometry::transform</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to apply the transform to. </td></tr>
    <tr><td class="paramname">hTransform</td><td>handle on the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a id="a43af4c2127cea0a5059692a62c0feb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43af4c2127cea0a5059692a62c0feb63">&#9670;&nbsp;</a></span>OGR_G_TransformTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_TransformTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform geometry to new spatial reference system. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This function will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this function requires internal creation and initialization of an <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> object it is significantly more expensive to use this function to transform many geometries than it is to create the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> in advance, and call transform() with that transformation. This function exists primarily for convenience when only transforming a single geometry.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ae3f0b441fbf2f66ce3ef3571268ab10f" title="Transform geometry to new spatial reference system. ">OGRGeometry::transformTo</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to apply the transform to. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle on the spatial reference system to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code. </dd></dl>

</div>
</div>
<a id="a59a695a0e26f4992ba58d79eac92ed25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a695a0e26f4992ba58d79eac92ed25">&#9670;&nbsp;</a></span>OGR_G_Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a939bb2b738337a3af1fc715187822171" title="Compute union. ">OGRGeometry::Union()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="ad6a2be7e6f0e16a18df2d0d54f55554f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a2be7e6f0e16a18df2d0d54f55554f">&#9670;&nbsp;</a></span>OGR_G_UnionCascaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_UnionCascaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute union using cascading. </p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a3413bfa82a0afc6b5fa77fafa3933549" title="Compute union using cascading. ">OGRGeometry::UnionCascaded()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="a40fe6b95093ed248db61791cbf48b017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fe6b95093ed248db61791cbf48b017">&#9670;&nbsp;</a></span>OGR_G_Value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch point at given distance along curve. </p>
<p>This function relates to the SF COM ICurve::get_Value() method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRCurve.html#a690570c5282483c043c0badbf94ce38b" title="Fetch point at given distance along curve. ">OGRCurve::Value()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>curve geometry. </td></tr>
    <tr><td class="paramname">dfDistance</td><td>distance along the curve at which to sample position. This distance should be between zero and get_Length() for this curve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a point or NULL.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a80ba9e516ccae381ae7240cc9684eb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ba9e516ccae381ae7240cc9684eb72">&#9670;&nbsp;</a></span>OGR_G_Within()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Within </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if this geometry is within the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a9803164ead0c4fbea9eafce64184160c" title="Test for containment. ">OGRGeometry::Within()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if hThis is within hOther, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a5f7035a933b957a9d453184c154c237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7035a933b957a9d453184c154c237c">&#9670;&nbsp;</a></span>OGR_G_WkbSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_WkbSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This function returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This function relates to the SFCOM IWks::WkbSize() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation. ">OGRGeometry::WkbSize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the binary size from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of binary representation in bytes. </dd></dl>

</div>
</div>
<a id="adcc3ea8bd6aeffdbe26bbc519cc16882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc3ea8bd6aeffdbe26bbc519cc16882">&#9670;&nbsp;</a></span>OGR_GeomTransformer_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a> OGR_GeomTransformer_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>&#160;</td>
          <td class="paramname"><em>hCT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry transformer. </p>
<p>This is a enhanced version of <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry. ">OGR_G_Transform()</a>.</p>
<p>When reprojecting geometries from a Polar Stereographic projection or a projection naturally crossing the antimeridian (like UTM Zone 60) to a geographic CRS, it will cut geometries along the antimeridian. So a LineString might be returned as a MultiLineString.</p>
<p>The WRAPDATELINE=YES option might be specified for circumstances to correct geometries that incorrectly go from a longitude on a side of the antimeridian to the other side, like a LINESTRING(-179 0,179 0) will be transformed to a MULTILINESTRING ((-179 0,-180 0),(180 0,179 0)). For that use case, hCT might be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hCT</td><td>Coordinate transformation object (will be cloned) or NULL. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options, or NULL. Supported options are: <ul>
<li>
WRAPDATELINE=YES </li>
<li>
DATELINEOFFSET=longitude_gap_in_degree. Defaults to 10. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformer object to free with <a class="el" href="ogr__api_8h.html#ae5729c801d758baee9dc23b95ac80f55" title="Destroy a geometry transformer allocated with OGR_GeomTransformer_Create() ">OGR_GeomTransformer_Destroy()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="ae5729c801d758baee9dc23b95ac80f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5729c801d758baee9dc23b95ac80f55">&#9670;&nbsp;</a></span>OGR_GeomTransformer_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GeomTransformer_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a>&#160;</td>
          <td class="paramname"><em>hTransformer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a geometry transformer allocated with <a class="el" href="ogr__api_8h.html#adcc3ea8bd6aeffdbe26bbc519cc16882" title="Create a geometry transformer. ">OGR_GeomTransformer_Create()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTransformer</td><td>transformer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="aed5ac945d4635e074c7e09816ea13efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5ac945d4635e074c7e09816ea13efe">&#9670;&nbsp;</a></span>OGR_GeomTransformer_Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_GeomTransformer_Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a>&#160;</td>
          <td class="paramname"><em>hTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTransformer</td><td>transformer object. </td></tr>
    <tr><td class="paramname">hGeom</td><td>Source geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry (or NULL) to destroy with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object. ">OGR_G_DestroyGeometry()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="a9611cba58f204544ecad73fd8defe3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9611cba58f204544ecad73fd8defe3f3">&#9670;&nbsp;</a></span>OGR_GetFieldSubTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GetFieldSubTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eSubType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch human readable name for a field subtype. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a51ec3ceae06d8a5113fc2a8e2e52e954" title="Fetch human readable name for a field subtype. ">OGRFieldDefn::GetFieldSubTypeName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eSubType</td><td>the field subtype to get name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="af1e61b89ae2d799cf5e217d01ef7b415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e61b89ae2d799cf5e217d01ef7b415">&#9670;&nbsp;</a></span>OGR_GetFieldTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GetFieldTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch human readable name for a field type. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#afc2a020f72be8296b6e09f5ab979f930" title="Fetch human readable name for a field type. ">OGRFieldDefn::GetFieldTypeName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eType</td><td>the field type to get name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name. </dd></dl>

</div>
</div>
<a id="a4681750642cae49933ba4fc962744b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4681750642cae49933ba4fc962744b78">&#9670;&nbsp;</a></span>OGR_GFld_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> OGR_GFld_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new field geometry definition. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ac69cdfca5b480465569b88bc4f9f7765" title="Constructor. ">OGRGeomFieldDefn::OGRGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the new field definition. </td></tr>
    <tr><td class="paramname">eType</td><td>the type of the new field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the new field definition.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a0f3e65993ea2b8b907e43ffa8b106871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e65993ea2b8b907e43ffa8b106871">&#9670;&nbsp;</a></span>OGR_GFld_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a geometry field definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="ad9914366a6cc3b4169a3359c2b1ef614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9914366a6cc3b4169a3359c2b1ef614">&#9670;&nbsp;</a></span>OGR_GFld_GetNameRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GFld_GetNameRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#afee61d406460dd46eeaa48a77f477991" title="Fetch name of this field. ">OGRGeomFieldDefn::GetNameRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the geometry field definition.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a7927b11a85659d8ce6da8857f52b05c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7927b11a85659d8ce6da8857f52b05c4">&#9670;&nbsp;</a></span>OGR_GFld_GetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> OGR_GFld_GetSpatialRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch spatial reference system of this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#acf7ddda34f67658433de5ccaedcd91e9" title="Fetch spatial reference system of this field. ">OGRGeomFieldDefn::GetSpatialRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field spatial reference system.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a323f4350c2e90c6e67df37f68d244a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323f4350c2e90c6e67df37f68d244a0d">&#9670;&nbsp;</a></span>OGR_GFld_GetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_GFld_GetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry type of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ac06e4141dee676afc00d33166c01d13f" title="Fetch geometry type of this field. ">OGRGeomFieldDefn::GetType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field geometry type.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="ab232798830d8dcae0742d83948e33d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab232798830d8dcae0742d83948e33d1a">&#9670;&nbsp;</a></span>OGR_GFld_IsIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_GFld_IsIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#aec9839abc6fa2633310ef691d753329a" title="Return whether this field should be omitted when fetching features. ">OGRGeomFieldDefn::IsIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a9bfbda2b68e11227611ff74ee0105d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfbda2b68e11227611ff74ee0105d47">&#9670;&nbsp;</a></span>OGR_GFld_IsNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_GFld_IsNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this geometry field can receive null values. </p>
<p>By default, fields are nullable.</p>
<p>Even if this method returns FALSE (i.e not-nullable field), it doesn't mean that <a class="el" href="classOGRFeature.html#a905bb73fe5e6df57f1be5a8b77489b74" title="Test if a field has ever been assigned a value or not. ">OGRFeature::IsFieldSet()</a> will necessary return TRUE, as fields can be temporary unset and null/not-null validation is usually done when <a class="el" href="classOGRLayer.html#a5d6db0be3b8876142d54e8bfd5dc8324" title="Create and write a new feature within a layer. ">OGRLayer::CreateFeature()</a>/SetFeature() is called.</p>
<p>Note that not-nullable geometry fields might also contain 'empty' geometries.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a7c56d7cea54c57f9be60b0b76f9a03ff" title="Return whether this geometry field can receive null values. ">OGRGeomFieldDefn::IsNullable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is authorized to be null. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="af3a4e5e2af01140209e9d2814869eb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a4e5e2af01140209e9d2814869eb41">&#9670;&nbsp;</a></span>OGR_GFld_SetIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a0266cdd27bf12420f0eb2107091a49b7" title="Set whether this field should be omitted when fetching features. ">OGRGeomFieldDefn::SetIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition </td></tr>
    <tr><td class="paramname">ignore</td><td>ignore state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a6c9b9d56381cae346c5129943641f628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9b9d56381cae346c5129943641f628">&#9670;&nbsp;</a></span>OGR_GFld_SetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ae3ca3a2ccdea222a2675cd0f7eeb57f7" title="Reset the name of this field. ">OGRGeomFieldDefn::SetName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to apply the new name to. </td></tr>
    <tr><td class="paramname">pszName</td><td>the new name to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1">&#9670;&nbsp;</a></span>OGR_GFld_SetNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNullableIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this geometry field can receive null values. </p>
<p>By default, fields are nullable, so this method is generally called with FALSE to set a not-null constraint.</p>
<p>Drivers that support writing not-null constraint will advertise the GDAL_DCAP_NOTNULL_GEOMFIELDS driver metadata item.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#aac631bcd6cd10d531aa11062c9f2453c" title="Set whether this geometry field can receive null values. ">OGRGeomFieldDefn::SetNullable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">bNullableIn</td><td>FALSE if the field must have a not-null constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="aa717acc8f4f5f33825334fe72edc2be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa717acc8f4f5f33825334fe72edc2be9">&#9670;&nbsp;</a></span>OGR_GFld_SetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetSpatialRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the spatial reference of this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a4a00f45c93467aa5f85d3c01c4dd4cec" title="Set the spatial reference of this field. ">OGRGeomFieldDefn::SetSpatialRef()</a>.</p>
<p>This function drops the reference of the previously set SRS object and acquires a new reference on the passed object (if non-NULL).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition </td></tr>
    <tr><td class="paramname">hSRS</td><td>the new SRS to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="affb3691474967ca5f0c9789e0626d55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3691474967ca5f0c9789e0626d55f">&#9670;&nbsp;</a></span>OGR_GFld_SetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the geometry type of this field. </p>
<p>This should never be done to an <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn. ">OGRGeomFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#a9b030e08d01a09b1917c1d01638a4ac8" title="Set the geometry type of this field. ">OGRGeomFieldDefn::SetType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to set type to. </td></tr>
    <tr><td class="paramname">eType</td><td>the new field geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a679904d97c1084f309706ac3c6228cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679904d97c1084f309706ac3c6228cec">&#9670;&nbsp;</a></span>OGR_L_AlterFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_AlterFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hNewFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer. ">OGRLayer::AlterFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">iField</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td class="paramname">hNewFieldDefn</td><td>new field definition </td></tr>
    <tr><td class="paramname">nFlags</td><td>combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG, ALTER_WIDTH_PRECISION_FLAG, ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to indicate which of the name and/or type and/or width and precision fields and/or nullability from the new field definition must be taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="ae12dcd5dc6dc5f930218573658f1b5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12dcd5dc6dc5f930218573658f1b5c2">&#9670;&nbsp;</a></span>OGR_L_Clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clip off areas that are not covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer and in the method layer. The features in the result layer have the (possibly clipped) areas of features in the input layer and the attributes from the same features. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a822deb3b2d047185e3a454692619291c" title="Clip off areas that are not covered by the method layer. ">OGRLayer::Clip()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="aa6f2e9557624952c68eaa46d272bd806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f2e9557624952c68eaa46d272bd806">&#9670;&nbsp;</a></span>OGR_L_CommitTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CommitTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For datasources which support transactions, CommitTransaction commits a transaction. </p>
<p>If no transaction is active, or the commit fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ae9f7fd669006a858f53115172f14a2eb" title="For datasources which support transactions, CommitTransaction commits a transaction. ">OGRLayer::CommitTransaction()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="a5009bc8d78d7f00e2745f3e3ad133779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5009bc8d78d7f00e2745f3e3ad133779">&#9670;&nbsp;</a></span>OGR_L_CreateFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CreateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and write a new feature within a layer. </p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a5d6db0be3b8876142d54e8bfd5dc8324" title="Create and write a new feature within a layer. ">OGRLayer::CreateFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the feature to. </td></tr>
    <tr><td class="paramname">hFeat</td><td>the handle of the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="aab585ef1166c61c4819f7fd46ee4a275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab585ef1166c61c4819f7fd46ee4a275">&#9670;&nbsp;</a></span>OGR_L_CreateField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CreateField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a00b1376a1eabb1298ef278f92f6d84be" title="Create a new field on a layer. ">OGRLayer::CreateField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the field definition. </td></tr>
    <tr><td class="paramname">hField</td><td>handle of the field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="af6908931c4f3ad364fef8d6e831363bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6908931c4f3ad364fef8d6e831363bc">&#9670;&nbsp;</a></span>OGR_L_CreateGeomField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CreateGeomField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a00b1376a1eabb1298ef278f92f6d84be" title="Create a new field on a layer. ">OGRLayer::CreateField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the field definition. </td></tr>
    <tr><td class="paramname">hField</td><td>handle of the geometry field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.11 </dd></dl>

</div>
</div>
<a id="a8a575c6bc193aee66e5c8d91eb170bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a575c6bc193aee66e5c8d91eb170bde">&#9670;&nbsp;</a></span>OGR_L_DeleteFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_DeleteFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd" title="Test if this layer supported the named capability. ">OGR_L_TestCapability()</a> function may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#ab7f892e23860b43aebb544e29845359d" title="Delete feature from layer. ">OGRLayer::DeleteFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
    <tr><td class="paramname">nFID</td><td>the feature id to be deleted from the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </dd></dl>

</div>
</div>
<a id="afc861413683418eba5d31e487da2f9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc861413683418eba5d31e487da2f9e2">&#9670;&nbsp;</a></span>OGR_L_DeleteField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_DeleteField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a" title="Delete an existing field on a layer. ">OGRLayer::DeleteField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">iField</td><td>index of the field to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a0f8c47bbeae70e609f4e51a239784285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8c47bbeae70e609f4e51a239784285">&#9670;&nbsp;</a></span>OGR_L_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove areas that are covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer but not in the method layer. The features in the result layer have attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a23fa292ae87af3bc0d3abb3963a71914" title="Remove areas that are covered by the method layer. ">OGRLayer::Erase()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="affc3cef62be82ec4f811a89b1855cbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc3cef62be82ec4f811a89b1855cbd5">&#9670;&nbsp;</a></span>OGR_L_FindFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_L_FindFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bExactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of field in a layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn't exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c" title="Find the index of field in the layer. ">OGRLayer::FindFieldIndex()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>field index, or -1 if the field doesn't exist </dd></dl>

</div>
</div>
<a id="aa6c495581900c8301dff91d8cd3ee12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c495581900c8301dff91d8cd3ee12f">&#9670;&nbsp;</a></span>OGR_L_GetExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_GetExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer. ">OGR_L_GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a753d30a98f1155306f482438af78e6db" title="Fetch the extent of this layer. ">OGRLayer::GetExtent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer from which to get extent. </td></tr>
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

</div>
</div>
<a id="ac3dbfd4443c80dca0d93574f0c00d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dbfd4443c80dca0d93574f0c00d376">&#9670;&nbsp;</a></span>OGR_L_GetExtentEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_GetExtentEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer. ">OGR_L_GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a753d30a98f1155306f482438af78e6db" title="Fetch the extent of this layer. ">OGRLayer::GetExtent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer from which to get extent. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>the index of the geometry field on which to compute the extent. </td></tr>
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

</div>
</div>
<a id="abdad5bebd6b71d136ce21e70ef4c63c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdad5bebd6b71d136ce21e70ef4c63c7">&#9670;&nbsp;</a></span>OGR_L_GetFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_L_GetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFeatureId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this function returns a non-NULL feature, it is guaranteed that its feature id (<a class="el" href="ogr__api_8h.html#afc99defd1fb1f8f71ff89c38982f2103" title="Get feature identifier. ">OGR_F_GetFID()</a>) will be the same as nFID.</p>
<p>Use OGR_L_TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="el" href="ogr__api_8h.html#abdad5bebd6b71d136ce21e70ef4c63c7" title="Fetch a feature by its identifier. ">OGR_L_GetFeature()</a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb" title="Fetch the next available feature from this layer. ">OGR_L_GetNextFeature()</a>) are generally considered interrupted by a <a class="el" href="ogr__api_8h.html#abdad5bebd6b71d136ce21e70ef4c63c7" title="Fetch a feature by its identifier. ">OGR_L_GetFeature()</a> call.</p>
<p>The returned feature should be free with <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb" title="Destroy feature. ">OGR_F_Destroy()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a7b39284997972eb198ed754594d52ec2" title="Fetch a feature by its identifier. ">OGRLayer::GetFeature( )</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer that owned the feature. </td></tr>
    <tr><td class="paramname">nFeatureId</td><td>the feature id of the feature to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to a feature now owned by the caller, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a08524b6961e52e1561308d2b0c598fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08524b6961e52e1561308d2b0c598fb2">&#9670;&nbsp;</a></span>OGR_L_GetFeatureCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> OGR_L_GetFeatureCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the CPP <a class="el" href="classOGRLayer.html#a2d0e1a43fd1a0a6d55d766384da7b6a5" title="Fetch the feature count in this layer. ">OGRLayer::GetFeatureCount()</a>.</p>
<p>Note: since GDAL 2.0, this method returns a GIntBig (previously a int)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer that owned the features. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the count should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>feature count, -1 if count not known. </dd></dl>

</div>
</div>
<a id="abfeb6e1258f113c6c45c8d6a43c8cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfeb6e1258f113c6c45c8d6a43c8cfa5">&#9670;&nbsp;</a></span>OGR_L_GetFIDColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetFIDColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the FID column, or "" if not supported. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61" title="This method returns the name of the underlying database column being used as the FID column...">OGRLayer::GetFIDColumn()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fid column name. </dd></dl>

</div>
</div>
<a id="ab060e07e277cebd1d8504c449d97b29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab060e07e277cebd1d8504c449d97b29f">&#9670;&nbsp;</a></span>OGR_L_GetGeometryColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetGeometryColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the geometry column, or "" if not supported. </p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use OGR_GFld_GetNameRef(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i)).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724" title="This method returns the name of the underlying database column being used as the geometry column...">OGRLayer::GetGeometryColumn()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geometry column name. </dd></dl>

</div>
</div>
<a id="a0adea8ce1ca795ce0a6a76505f90f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adea8ce1ca795ce0a6a76505f90f078">&#9670;&nbsp;</a></span>OGR_L_GetGeomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_L_GetGeomType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the layer geometry type. </p>
<p>This returns the same result as OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type. ">OGR_L_GetGeomType()</a> directly can avoid lengthy layer definition initialization.</p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use OGR_GFld_GetType(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i)). For layers without any geometry field, this method returns wkbNone.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type. ">OGRLayer::GetGeomType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry type </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a7b67ea4ab5892c6720460dc7f66eca2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b67ea4ab5892c6720460dc7f66eca2d">&#9670;&nbsp;</a></span>OGR_L_GetLayerDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> OGR_L_GetLayerDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the schema information for this layer. </p>
<p>The returned handle to the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer. ">OGRLayer::GetLayerDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the schema information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the feature definition. </dd></dl>

</div>
</div>
<a id="a88facf4f8e8b32278101d52ae094255c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88facf4f8e8b32278101d52ae094255c">&#9670;&nbsp;</a></span>OGR_L_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the layer name. </p>
<p>This returns the same content as OGR_FD_GetName(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c" title="Return the layer name. ">OGR_L_GetName()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name. ">OGRLayer::GetName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the layer name (must not been freed) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a4f6ef6b70fee9f8cea92cb7a0236fcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6ef6b70fee9f8cea92cb7a0236fcdb">&#9670;&nbsp;</a></span>OGR_L_GetNextFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_L_GetNextFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsibility of the caller to delete with <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb" title="Destroy feature. ">OGR_F_Destroy()</a>. It is critical that all features associated with an <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> (more specifically an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with SetSpatialFilter()) will be returned.</p>
<p>This function implements sequential access to the features of a layer. The <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature. ">OGR_L_ResetReading()</a> function can be used to start at the beginning again.</p>
<p>Features returned by OGR_GetNextFeature() may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature. ">OGR_L_ResetReading()</a> on layers where OGR_GetNextFeature() has been called, before reading again. Structural changes in layers (field addition, deletion, ...) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature. ">OGR_L_ResetReading()</a> might be needed.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a466c14ed1b3cca83abda52729d590dd2" title="Fetch the next available feature from this layer. ">OGRLayer::GetNextFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer from which feature are read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to a feature, or NULL if no more features are available. </dd></dl>

</div>
</div>
<a id="a36d61f311c9f8c172ad118659358c60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d61f311c9f8c172ad118659358c60a">&#9670;&nbsp;</a></span>OGR_L_GetSpatialFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_L_GetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#adc3735e444204d46f517eec251712f4d" title="This method returns the current spatial filter for this layer. ">OGRLayer::GetSpatialFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the spatial filter from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the spatial filter geometry. </dd></dl>

</div>
</div>
<a id="a8b2a10085f410aa84172eba413408c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2a10085f410aa84172eba413408c39">&#9670;&nbsp;</a></span>OGR_L_GetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> OGR_L_GetSpatialRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> and should not be modified or freed by the application.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer. ">OGRLayer::GetSpatialRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the spatial reference from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>spatial reference, or NULL if there isn't one. </dd></dl>

</div>
</div>
<a id="a67948074f2e2942cebdd0f90bbec8aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67948074f2e2942cebdd0f90bbec8aa9">&#9670;&nbsp;</a></span>OGR_L_Identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the features of this layer with the ones from the identity layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer. </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is to add but only if the result layer has an unknown geometry type. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a385ff64cc8b070819da0a7e121ff07b3" title="Identify the features of this layer with the ones from the identity layer. ">OGRLayer::Identity()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a5c353cc32c9dd02967a7bed1450d2524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c353cc32c9dd02967a7bed1450d2524">&#9670;&nbsp;</a></span>OGR_L_Intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersection of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are common between features in the input layer and in the method layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer. </li>
<li>
PRETEST_CONTAINMENT=YES/NO. Set to YES to pretest the containment of features of method layer within the features of this layer. This will speed up the method significantly in some cases. Requires that the prepared geometries are in effect. </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is to add but only if the result layer has an unknown geometry type. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a5202606175f7e7dcd76c3eb237ac8303" title="Intersection of two layers. ">OGRLayer::Intersection()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="ad20a3796ee63935285976ee425878927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20a3796ee63935285976ee425878927">&#9670;&nbsp;</a></span>OGR_L_ReorderField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_ReorderField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iOldFieldPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iNewFieldPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder an existing field on a layer. </p>
<p>This function is a convenience wrapper of <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer. ">OGR_L_ReorderFields()</a> dedicated to move a single field.</p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>The field definition that was at initial position iOldFieldPos will be moved at position iNewFieldPos, and elements between will be shuffled accordingly.</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderField(1, 3) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8" title="Reorder an existing field on a layer. ">OGRLayer::ReorderField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">iOldFieldPos</td><td>previous position of the field to move. Must be in the range [0,GetFieldCount()-1]. </td></tr>
    <tr><td class="paramname">iNewFieldPos</td><td>new position of the field to move. Must be in the range [0,GetFieldCount()-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a4cc576cb39e1dd4a1f074125199245bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc576cb39e1dd4a1f074125199245bb">&#9670;&nbsp;</a></span>OGR_L_ReorderFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_ReorderFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderFields([0,2,3,1,4]) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer. ">OGRLayer::ReorderFields()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">panMap</td><td>an array of GetLayerDefn()-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature. ">OGRFeatureDefn::GetFieldCount()</a> elements which is a permutation of [0, GetLayerDefn()-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature. ">OGRFeatureDefn::GetFieldCount()</a>-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="ab0383004bf637171648a9d03a80f15a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0383004bf637171648a9d03a80f15a4">&#9670;&nbsp;</a></span>OGR_L_ResetReading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_ResetReading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset feature reading to start on the first feature. </p>
<p>This affects GetNextFeature().</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature. ">OGRLayer::ResetReading()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which features are read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a823a6c351dccf751777f67801dd7f9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823a6c351dccf751777f67801dd7f9c5">&#9670;&nbsp;</a></span>OGR_L_RollbackTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_RollbackTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. </p>
<p>If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ab046dbffc4fbd5bacc6ef75da0686d82" title="For datasources which support transactions, RollbackTransaction will roll back a datasource to its st...">OGRLayer::RollbackTransaction()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="a4000d426bf26ad7cc7d4012634c93f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4000d426bf26ad7cc7d4012634c93f09">&#9670;&nbsp;</a></span>OGR_L_SetAttributeFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetAttributeFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszQuery</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new attribute query. </p>
<p>This function sets the attribute query string to be used when fetching features via the <a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb" title="Fetch the next available feature from this layer. ">OGR_L_GetNextFeature()</a> function. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance "population &gt; 1000000 and population &lt; 5000000" where population is an attribute in the layer. The query format is a restricted form of SQL WHERE clause as defined "eq_format=restricted_where" about half way through this document:</p>
<p><a href="http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html">http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html</a></p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature. ">OGR_L_ResetReading()</a>).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde" title="Set a new attribute query. ">OGRLayer::SetAttributeFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which attribute query will be executed. </td></tr>
    <tr><td class="paramname">pszQuery</td><td>query in restricted SQL WHERE format, or NULL to clear the current query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </dd></dl>

</div>
</div>
<a id="a2cccc8cad9a106ee23628ddf6ef6ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cccc8cad9a106ee23628ddf6ef6ece4">&#9670;&nbsp;</a></span>OGR_L_SetFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite an existing feature. </p>
<p>This function will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a>.</p>
<p>Use OGR_L_TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="el" href="ogr__api_8h.html#a2cccc8cad9a106ee23628ddf6ef6ece4" title="Rewrite an existing feature. ">OGR_L_SetFeature()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a6e7dfe0f900ac7fb0f457e7a49b3a5e3" title="Rewrite an existing feature. ">OGRLayer::SetFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the feature. </td></tr>
    <tr><td class="paramname">hFeat</td><td>the feature to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </dd></dl>

</div>
</div>
<a id="a6d43f1474201356bed2e6f92e7d37154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d43f1474201356bed2e6f92e7d37154">&#9670;&nbsp;</a></span>OGR_L_SetIgnoredFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetIgnoredFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>papszFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to GetFeature() / GetNextFeature() and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: "OGR_GEOMETRY" to ignore geometry and "OGR_STYLE" to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#a5e0c3427f64249d1c35cefb487546b10" title="Set which fields can be omitted when retrieving features from the layer. ">OGRLayer::SetIgnoredFields()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszFields</td><td>an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </dd></dl>

</div>
</div>
<a id="a8b4427a82ea3de3bed7acff19b6e8e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4427a82ea3de3bed7acff19b6e8e33">&#9670;&nbsp;</a></span>OGR_L_SetNextByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetNextByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the GetNextFeature() call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with GetNextFeature() would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is SetNextByIndex() efficiently implemented. In all other cases the default implementation which calls ResetReading() and then calls GetNextFeature() nIndex times is used. To determine if fast seeking is available on the current layer use the TestCapability() method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#ac0b0869ff6fcadda35cbac1f3edf8eae" title="Move read cursor to the nIndex&#39;th feature in the current resultset. ">OGRLayer::SetNextByIndex()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
    <tr><td class="paramname">nIndex</td><td>the index indicating how many steps into the result set to seek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a id="a678d1735bc82533614ac005691d1138c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678d1735bc82533614ac005691d1138c">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb" title="Fetch the next available feature from this layer. ">OGR_L_GetNextFeature()</a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features whose envelope (as returned by <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>Starting with GDAL 2.3, features with null or empty geometries will never be considered as matching a spatial filter.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39" title="Fetch the spatial reference system for this layer. ">OGR_L_GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter. ">OGRLayer::SetSpatialFilter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00c8a1a968542d389f86ed1b4edd5823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c8a1a968542d389f86ed1b4edd5823">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilterEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb" title="Fetch the next available feature from this layer. ">OGR_L_GetNextFeature()</a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter. ">OGRLayer::SetSpatialFilter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a5cba569e0779a02a95327f041d9f7a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cba569e0779a02a95327f041d9f7a13">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilterRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb" title="Fetch the next available feature from this layer. ">OGR_L_GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer. ">OGRLayer::GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter. ">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460" title="Set a new rectangular spatial filter. ">OGRLayer::SetSpatialFilterRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a489241dfe65d6e089809d3258c4f79f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489241dfe65d6e089809d3258c4f79f5">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilterRectEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterRectEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb" title="Fetch the next available feature from this layer. ">OGR_L_GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter. ">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460" title="Set a new rectangular spatial filter. ">OGRLayer::SetSpatialFilterRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="ab709fc5cdd7a204fe0220e898a981d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab709fc5cdd7a204fe0220e898a981d85">&#9670;&nbsp;</a></span>OGR_L_StartTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_StartTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For datasources which support transactions, StartTransaction creates a transaction. </p>
<p>If starting the transaction fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>Note: as of GDAL 2.0, use of this API is discouraged when the dataset offers dataset level transaction with <a class="el" href="classGDALDataset.html#a3e4161f148fac57dac5cfe4900421348" title="For datasources which support transactions, StartTransaction creates a `transaction. ">GDALDataset::StartTransaction()</a>. The reason is that most drivers can only offer transactions at dataset level, and not layer level. Very few drivers really support transactions at layer scope.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ac3cdf24212ec4719ade6065dcb63bb37" title="For datasources which support transactions, StartTransaction creates a transaction. ">OGRLayer::StartTransaction()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="a03249311ff4c88b2fac5f728be63b549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03249311ff4c88b2fac5f728be63b549">&#9670;&nbsp;</a></span>OGR_L_SymDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SymDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrical difference of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer but not in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b" title="Symmetrical difference of two layers. ">OGRLayer::SymDifference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a9d845a6cf6652756925530418905471a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d845a6cf6652756925530418905471a">&#9670;&nbsp;</a></span>OGR_L_SyncToDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SyncToDisk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources. ">OGR_DS_Destroy()</a> that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#aebb07284c734e485d8611b7c8599254f" title="Flush pending changes to disk. ">OGRLayer::SyncToDisk()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </dd></dl>

</div>
</div>
<a id="a480adc8b839b04597f49583371d366fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480adc8b839b04597f49583371d366fd">&#9670;&nbsp;</a></span>OGR_L_TestCapability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_L_TestCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<ul>
<li>
<p class="startli"><b>OLCRandomRead</b> / "RandomRead": TRUE if the GetFeature() method is implemented in an optimized way for this layer, as opposed to the default implementation using ResetReading() and GetNextFeature() to find the requested feature id.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCSequentialWrite</b> / "SequentialWrite": TRUE if the CreateFeature() method works for this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCRandomWrite</b> / "RandomWrite": TRUE if the SetFeature() method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSpatialFilter</b> / "FastSpatialFilter": TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastFeatureCount</b> / "FastFeatureCount": TRUE if this layer can return a feature count (via <a class="el" href="ogr__api_8h.html#a08524b6961e52e1561308d2b0c598fb2" title="Fetch the feature count in this layer. ">OGR_L_GetFeatureCount()</a>) efficiently, i.e. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastGetExtent</b> / "FastGetExtent": TRUE if this layer can return its data extent (via <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer. ">OGR_L_GetExtent()</a>) efficiently, i.e. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSetNextByIndex</b> / "FastSetNextByIndex": TRUE if this layer can perform the SetNextByIndex() call efficiently, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateField</b> / "CreateField": TRUE if this layer can create new fields on the current layer using CreateField(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateGeomField</b> / "CreateGeomField": (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using CreateGeomField(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteField</b> / "DeleteField": TRUE if this layer can delete existing fields on the current layer using DeleteField(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCReorderFields</b> / "ReorderFields": TRUE if this layer can reorder existing fields on the current layer using ReorderField() or ReorderFields(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterFieldDefn</b> / "AlterFieldDefn": TRUE if this layer can alter the definition of an existing field on the current layer using AlterFieldDefn(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteFeature</b> / "DeleteFeature": TRUE if the DeleteFeature() method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCStringsAsUTF8</b> / "StringsAsUTF8": TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCTransactions</b> / "Transactions": TRUE if the StartTransaction(), CommitTransaction() and RollbackTransaction() methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCurveGeometries</b> / "CurveGeometries": TRUE if this layer supports writing curve geometries or may return such geometries. (GDAL 2.0).</p>
<p></p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286" title="Test if this layer supported the named capability. ">OGRLayer::TestCapability()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the capability from. </td></tr>
    <tr><td class="paramname">pszCap</td><td>the name of the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</dd></dl>

</div>
</div>
<a id="ac8edb8696c2b046370e29efdd73787f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8edb8696c2b046370e29efdd73787f7">&#9670;&nbsp;</a></span>OGR_L_Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer, in the method layer, or in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer. </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is to add but only if the result layer has an unknown geometry type. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#adf0598c7dab1f4dbe3e2735e27450c9c" title="Union of two layers. ">OGRLayer::Union()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a87b478c971619145dee7d8d8deeac702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b478c971619145dee7d8d8deeac702">&#9670;&nbsp;</a></span>OGR_L_Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update this layer with features from the update layer. </p>
<p>The result layer contains features whose geometries represent areas that are either in the input layer or in the method layer. The features in the result layer have areas of the features of the method layer or those ares of the features of the input layer that are not covered by the method layer. The features of the result layer get their attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in the method layer, then the attribute in the result feature the originates from the method layer will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a6b86f3a070fe99e39631c994be4fce08" title="Update this layer with features from the update layer. ">OGRLayer::Update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="aa9a401e6dbd5577396b567791cf85115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a401e6dbd5577396b567791cf85115">&#9670;&nbsp;</a></span>OGR_RawField_IsNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_RawField_IsNull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a raw field is null. </p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#aa4d08c0ac3b9624955e682a9a2afe2b1" title="Test if a field is null. ">OGR_F_IsFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="ae23095c63fc350d712940bdbf440bbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23095c63fc350d712940bdbf440bbcb">&#9670;&nbsp;</a></span>OGR_RawField_IsUnset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_RawField_IsUnset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a raw field is unset. </p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11" title="Test if a field has ever been assigned a value or not. ">OGR_F_IsFieldSet()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="acf6c613c24de0e11fe259e86160157d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6c613c24de0e11fe259e86160157d3">&#9670;&nbsp;</a></span>OGR_RawField_SetNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_RawField_SetNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a raw field as null. </p>
<p>This should be called on a un-initialized field. In particular this will not free any memory dynamically allocated.</p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#a090a6a8d699d4eed977ce9fcf028137a" title="Clear a field, marking it as null. ">OGR_F_SetFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="acaac3d8e8d01fa83a52dd2d95aac0cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaac3d8e8d01fa83a52dd2d95aac0cc3">&#9670;&nbsp;</a></span>OGR_RawField_SetUnset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_RawField_SetUnset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a raw field as unset. </p>
<p>This should be called on a un-initialized field. In particular this will not free any memory dynamically allocated.</p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e" title="Clear a field, marking it as unset. ">OGR_F_UnsetField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="af358ec087124f355fca02bf33a1e0027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af358ec087124f355fca02bf33a1e0027">&#9670;&nbsp;</a></span>OGR_SM_AddPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_AddPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a part (style tool) to the current style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a3b893dd11e0f009fca53bf42d16abf47" title="Add a part (style tool) to the current style. ">OGRStyleMgr::AddPart()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">hST</td><td>the style tool defining the part to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on errors. </dd></dl>

</div>
</div>
<a id="a358c1558e61951b2e1e338ead8401ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358c1558e61951b2e1e338ead8401ad8">&#9670;&nbsp;</a></span>OGR_SM_AddStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_AddStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a style to the current style table. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#ae0846db4a996586b38ea31e69e71b697" title="Add a style to the current style table. ">OGRStyleMgr::AddStyle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">pszStyleName</td><td>the name of the style to add. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>the style string to use, or NULL to use the style stored in the manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on errors. </dd></dl>

</div>
</div>
<a id="aba4d31b48c3c9ea6c1edbe4f0aa65866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4d31b48c3c9ea6c1edbe4f0aa65866">&#9670;&nbsp;</a></span>OGR_SM_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> OGR_SM_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOGRStyleMgr.html" title="This class represents a style manager. ">OGRStyleMgr</a> factory. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#af360b6a3d0fee4af9a7716fb2a563269" title="Constructor. ">OGRStyleMgr::OGRStyleMgr()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>pointer to <a class="el" href="classOGRStyleTable.html" title="This class represents a style table. ">OGRStyleTable</a> or NULL if not working with a style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the new style manager object. </dd></dl>

</div>
</div>
<a id="a474fca7d9327da916305ec1276a57443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474fca7d9327da916305ec1276a57443">&#9670;&nbsp;</a></span>OGR_SM_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SM_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Style Manager. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a534a68c59c66901a6fc01d72130337ae" title="Destructor. ">OGRStyleMgr::~OGRStyleMgr()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61d4e04abb6e3c59ed570c62dffc4164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d4e04abb6e3c59ed570c62dffc4164">&#9670;&nbsp;</a></span>OGR_SM_GetPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> OGR_SM_GetPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPartId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a part (style tool) from the current style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a49a82adac48cbd82bfe5c7bb2ccf8376" title="Fetch a part (style tool) from the current style. ">OGRStyleMgr::GetPart()</a>.</p>
<p>This function instantiates a new object that should be freed with <a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a" title="Destroy Style Tool. ">OGR_ST_Destroy()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">nPartId</td><td>the part number (0-based index). </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>(optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRStyleToolH of the requested part (style tools) or NULL on error. </dd></dl>

</div>
</div>
<a id="ad272704a535c0fa8cfd7b097eb4968dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad272704a535c0fa8cfd7b097eb4968dc">&#9670;&nbsp;</a></span>OGR_SM_GetPartCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_GetPartCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of parts in a style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a5745b19d32448c321fcb0e0e9c88843b" title="Get the number of parts in a style. ">OGRStyleMgr::GetPartCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>(optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of parts (style tools) in the style. </dd></dl>

</div>
</div>
<a id="afca737ee6586ce8078b52108707b0b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca737ee6586ce8078b52108707b0b6a">&#9670;&nbsp;</a></span>OGR_SM_InitFromFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_SM_InitFromFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize style manager from the style string of a feature. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#adadbb0a44c3ca3bd11801ee64568d2a6" title="Initialize style manager from the style string of a feature. ">OGRStyleMgr::InitFromFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">hFeat</td><td>handle to the new feature from which to read the style.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the style string read from the feature, or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ade49bffec1e796ddf4419f5cbe34fda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade49bffec1e796ddf4419f5cbe34fda8">&#9670;&nbsp;</a></span>OGR_SM_InitStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_InitStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize style manager from the style string. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a31e29e999940de709c00f3e985ab3365" title="Initialize style manager from the style string. ">OGRStyleMgr::InitStyleString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>the style string to use (can be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on errors. </dd></dl>

</div>
</div>
<a id="a4cc7bc2b21febd7a78d44727ad7de30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc7bc2b21febd7a78d44727ad7de30f">&#9670;&nbsp;</a></span>OGR_ST_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> OGR_ST_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a>&#160;</td>
          <td class="paramname"><em>eClassId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> factory. </p>
<p>This function is a constructor for <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> derived classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eClassId</td><td>subclass of style tool to create. One of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the new style tool object or NULL if the creation failed. </dd></dl>

</div>
</div>
<a id="a5d1ecf398ee062f3f5a297f70244497a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1ecf398ee062f3f5a297f70244497a">&#9670;&nbsp;</a></span>OGR_ST_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Style Tool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96082cdf432271acfa3b3777c3be853b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96082cdf432271acfa3b3777c3be853b">&#9670;&nbsp;</a></span>OGR_ST_GetParamDbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_ST_GetParamDbl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bValueIsNull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool parameter value as a double. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> subclasses' GetParamDbl() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">bValueIsNull</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameter value as double and sets bValueIsNull. </dd></dl>

</div>
</div>
<a id="ad4168832561881cb75dcc7c35935cdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4168832561881cb75dcc7c35935cdd3">&#9670;&nbsp;</a></span>OGR_ST_GetParamNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_ST_GetParamNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bValueIsNull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool parameter value as an integer. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> subclasses' GetParamNum() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">bValueIsNull</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameter value as integer and sets bValueIsNull. </dd></dl>

</div>
</div>
<a id="aecadf5738c3b96093605b352a95869f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecadf5738c3b96093605b352a95869f1">&#9670;&nbsp;</a></span>OGR_ST_GetParamStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_ST_GetParamStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bValueIsNull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool parameter value as string. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> subclasses' GetParamStr() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">bValueIsNull</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameter value as string and sets bValueIsNull. </dd></dl>

</div>
</div>
<a id="a906f5e2b901413a0ab5fa35d649847fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906f5e2b901413a0ab5fa35d649847fc">&#9670;&nbsp;</a></span>OGR_ST_GetRGBFromString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_ST_GetRGBFromString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnRed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnGreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBlue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format. </p>
<p>Maps to <a class="el" href="classOGRStyleTool.html#ac52668cd3fe4b74860137d36f6e9f0d4" title="Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format. ">OGRStyleTool::GetRGBFromString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">pszColor</td><td>the color to parse </td></tr>
    <tr><td class="paramname">pnRed</td><td>pointer to an int in which the red value will be returned </td></tr>
    <tr><td class="paramname">pnGreen</td><td>pointer to an int in which the green value will be returned </td></tr>
    <tr><td class="paramname">pnBlue</td><td>pointer to an int in which the blue value will be returned </td></tr>
    <tr><td class="paramname">pnAlpha</td><td>pointer to an int in which the (optional) alpha value will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the color could be successfully parsed, or FALSE in case of errors. </dd></dl>

</div>
</div>
<a id="a4089c70ce3b1cbea0e45c3375d5093f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4089c70ce3b1cbea0e45c3375d5093f0">&#9670;&nbsp;</a></span>OGR_ST_GetStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_ST_GetStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the style string for this Style Tool. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> subclasses' GetStyleString() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style string for this style tool or "" if the hST is invalid. </dd></dl>

</div>
</div>
<a id="aae8d0ee36b82c9d1d8d1a0e9b36f2d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">&#9670;&nbsp;</a></span>OGR_ST_GetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a> OGR_ST_GetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine type of Style Tool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style tool type, one of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4). Returns OGRSTCNone (0) if the OGRStyleToolH is invalid. </dd></dl>

</div>
</div>
<a id="afb52e40f289848d1f228849b6dae2463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb52e40f289848d1f228849b6dae2463">&#9670;&nbsp;</a></span>OGR_ST_GetUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a> OGR_ST_GetUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style tool units. </dd></dl>

</div>
</div>
<a id="a764f52f8a72e950d0a5d84b7a7b37fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764f52f8a72e950d0a5d84b7a7b37fc8">&#9670;&nbsp;</a></span>OGR_ST_SetParamDbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamDbl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool parameter value from a double. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> subclasses' SetParamDbl() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">dfValue</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0397850aed3282865b444d65d2deb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0397850aed3282865b444d65d2deb0e">&#9670;&nbsp;</a></span>OGR_ST_SetParamNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool parameter value from an integer. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> subclasses' SetParamNum() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">nValue</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88e9561d9a62d6f8368d526eb0468b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e9561d9a62d6f8368d526eb0468b3a">&#9670;&nbsp;</a></span>OGR_ST_SetParamStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool parameter value from a string. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool. ">OGRStyleTool</a> subclasses' SetParamStr() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">pszValue</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9c5b94e6ca32cd53c6a7a9ebc73012c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c5b94e6ca32cd53c6a7a9ebc73012c">&#9670;&nbsp;</a></span>OGR_ST_SetUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a>&#160;</td>
          <td class="paramname"><em>eUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfGroundPaperScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool units. </p>
<p>This function is the same as <a class="el" href="classOGRStyleTool.html#abfc35434fef971aa98be8f15059a81da" title="Set Style Tool units. ">OGRStyleTool::SetUnit()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eUnit</td><td>the new unit. </td></tr>
    <tr><td class="paramname">dfGroundPaperScale</td><td>ground to paper scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacd2a4f109627f282c42229eaad7cdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd2a4f109627f282c42229eaad7cdfd">&#9670;&nbsp;</a></span>OGR_STBL_AddStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_AddStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new style in the table. </p>
<p>No comparison will be done on the Style string, only on the name. This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#aff722d3fc7c167259dd79986a2574993" title="Add a new style in the table. ">OGRStyleTable::AddStyle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name the style to add. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>the style string to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a id="a9c2d216b17d9f09ad6285ce61dcbe826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2d216b17d9f09ad6285ce61dcbe826">&#9670;&nbsp;</a></span>OGR_STBL_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> OGR_STBL_Create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOGRStyleTable.html" title="This class represents a style table. ">OGRStyleTable</a> factory. </p>
<p>This function is the same as the C++ method OGRStyleTable::OGRStyleTable().</p>
<dl class="section return"><dt>Returns</dt><dd>an handle to the new style table object. </dd></dl>

</div>
</div>
<a id="a5cf4e22eb7ef07c4a3249c21dce48764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf4e22eb7ef07c4a3249c21dce48764">&#9670;&nbsp;</a></span>OGR_STBL_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_STBL_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hSTBL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Style Table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSTBL</td><td>handle to the style table to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ca305147b3b5a6c3f5fafaee7bc06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ca305147b3b5a6c3f5fafaee7bc06a">&#9670;&nbsp;</a></span>OGR_STBL_Find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_Find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a style string by name. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a83347c8a447e454b825784c8f7ce1661" title="Get a style string by name. ">OGRStyleTable::Find()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the style string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style string matching the name or NULL if not found or error. </dd></dl>

</div>
</div>
<a id="af8214328c6866f0eb85bba376d94a05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8214328c6866f0eb85bba376d94a05e">&#9670;&nbsp;</a></span>OGR_STBL_GetLastStyleName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_GetLastStyleName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the style name of the last style string fetched with OGR_STBL_GetNextStyle. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#afc78310da48449b9f6a79d20d73e5944" title="Get style name by style string. ">OGRStyleTable::GetStyleName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Name of the last style string or NULL on error. </dd></dl>

</div>
</div>
<a id="ad901a29f17b139108cc6390b9a075e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad901a29f17b139108cc6390b9a075e89">&#9670;&nbsp;</a></span>OGR_STBL_GetNextStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_GetNextStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next style string from the table. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a51ec658481656b3a3c7748622924eaf5" title="Get the next style string from the table. ">OGRStyleTable::GetNextStyle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next style string or NULL on error. </dd></dl>

</div>
</div>
<a id="aed731a5a6fbedde73ed5063d62f3004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed731a5a6fbedde73ed5063d62f3004e">&#9670;&nbsp;</a></span>OGR_STBL_LoadStyleTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_LoadStyleTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a style table from a file. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a1d8b2702ca6c6469d03316b6c9341739" title="Load a style table from a file. ">OGRStyleTable::LoadStyleTable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszFilename</td><td>the name of the file to load from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a id="a69ccd53d6d374d66d42266b3543509f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ccd53d6d374d66d42266b3543509f7">&#9670;&nbsp;</a></span>OGR_STBL_ResetStyleStringReading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_STBL_ResetStyleStringReading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the next style pointer to 0. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#aeb0398e3eb69ff4bacebf5fb928f5482" title="Reset the next style pointer to 0. ">OGRStyleTable::ResetStyleStringReading()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3e3aca0d4f3fefe3dd64da65814dda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e3aca0d4f3fefe3dd64da65814dda7">&#9670;&nbsp;</a></span>OGR_STBL_SaveStyleTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_SaveStyleTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a style table to a file. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a5395e712fa91a3d26f6aed779760983c" title="Save a style table to a file. ">OGRStyleTable::SaveStyleTable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszFilename</td><td>the name of the file to save to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a id="ac96ffb0c7265926d107dadde9a634763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96ffb0c7265926d107dadde9a634763">&#9670;&nbsp;</a></span>OGRBuildPolygonFromEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGRBuildPolygonFromEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bBestEffort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bAutoClose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>peErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a ring from a bunch of arcs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLines</td><td>handle to an <a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects. ">OGRGeometryCollection</a> (or <a class="el" href="classOGRMultiLineString.html" title="A collection of OGRLineString. ">OGRMultiLineString</a>) containing the line string geometries to be built into rings. </td></tr>
    <tr><td class="paramname">bBestEffort</td><td>not yet implemented???. </td></tr>
    <tr><td class="paramname">bAutoClose</td><td>indicates if the ring should be close when first and last points of the ring are the same. </td></tr>
    <tr><td class="paramname">dfTolerance</td><td>tolerance into which two arcs are considered close enough to be joined. </td></tr>
    <tr><td class="paramname">peErr</td><td>OGRERR_NONE on success, or OGRERR_FAILURE on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle to the new geometry, a polygon. </dd></dl>

</div>
</div>
<a id="ae5d5a052ed1046ec85236fe4a92733e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d5a052ed1046ec85236fe4a92733e2">&#9670;&nbsp;</a></span>OGRCleanupAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCleanupAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean-up all drivers (including raster ones starting with GDAL 2.0. </p>
<p>See <a class="el" href="gdal_8h.html#a4769d3eda338f797b30405062deb9180" title="Destroy the driver manager. ">GDALDestroyDriverManager()</a> </p>

</div>
</div>
<a id="a3f8080605cad5aeef9519c38fe160b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8080605cad5aeef9519c38fe160b51">&#9670;&nbsp;</a></span>OGRGetDriver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> OGRGetDriver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the indicated driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a391569a2a964a17ca4d77d32da150dc6" title="Fetch driver by index. ">GDALGetDriver()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDriver</td><td>the driver index, from 0 to GetDriverCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the driver, or NULL if iDriver is out of range. </dd></dl>

</div>
</div>
<a id="ae814db7e2212b9bbb0fd8c361bee11fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814db7e2212b9bbb0fd8c361bee11fe">&#9670;&nbsp;</a></span>OGRGetDriverByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> OGRGetDriverByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the indicated driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#ae8ae868eef1e4773283d137b0a1adfc4" title="Fetch a driver based on the short name. ">GDALGetDriverByName()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the driver name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the driver, or NULL if no driver with that name is found </dd></dl>

</div>
</div>
<a id="ad0f6d2bbd269b56a61d1c1841dac2575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f6d2bbd269b56a61d1c1841dac2575">&#9670;&nbsp;</a></span>OGRGetDriverCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGetDriverCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the number of registered drivers. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#aa506c0cdcb923528f3e7d4f1dec9b4b5" title="Fetch the number of registered drivers. ">GDALGetDriverCount()</a> in GDAL 2.0</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the drivers count. </dd></dl>

</div>
</div>
<a id="af7f6cfab316f5f22962bcd85216c4684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f6cfab316f5f22962bcd85216c4684">&#9670;&nbsp;</a></span>OGRGetNonLinearGeometriesEnabledFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGetNonLinearGeometriesEnabledFlag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flag to enable/disable returning non-linear geometries in the C API. </p>
<p>return TRUE if non-linear geometries might be returned (default value is TRUE).</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a31febe0b845d7cc0052767e6257e7349" title="Set flag to enable/disable returning non-linear geometries in the C API. ">OGRSetNonLinearGeometriesEnabledFlag()</a> </dd></dl>

</div>
</div>
<a id="a2da3630231780d519543d1679c83e62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da3630231780d519543d1679c83e62f">&#9670;&nbsp;</a></span>OGROpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGROpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *&#160;</td>
          <td class="paramname"><em>pahDriverList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file / data source with one of the registered drivers. </p>
<p>This function loops through all the drivers registered with the driver manager trying each until one succeeds with the given data source.</p>
<p>If this function fails, <a class="el" href="cpl__error_8h.html#a7f71ade3bb0a0e9e45802975ec59ff5e" title="Get the last error message. ">CPLGetLastErrorMsg()</a> can be used to check if there is an error message explaining why.</p>
<p>For drivers supporting the VSI virtual file API, it is possible to open a file in a .zip archive (see <a class="el" href="cpl__vsi_8h.html#a884fac3cd6be2c09deb807e959d78b3a" title="Install ZIP file system handler. ">VSIInstallZipFileHandler()</a>), in a .tar/.tar.gz/.tgz archive (see <a class="el" href="cpl__vsi_8h.html#ad6dd983338849e7da4eaa88f6458ab64" title="Install /vsitar/ file system handler. ">VSIInstallTarFileHandler()</a>) or on a HTTP / FTP server (see <a class="el" href="cpl__vsi_8h.html#a4f791960f2d86713d16e99e9c0c36258" title="Install /vsicurl/ HTTP/FTP file system handler (requires libcurl) ">VSIInstallCurlFileHandler()</a>)</p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#aca05455472359964151f9c891d678d5e" title="Open a raster or vector file as a GDALDataset. ">GDALOpenEx()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the file, or data source to open. </td></tr>
    <tr><td class="paramname">bUpdate</td><td>FALSE for read-only access (the default) or TRUE for read-write access. </td></tr>
    <tr><td class="paramname">pahDriverList</td><td>if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file. ">GDALDataset</a>. This <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file. ">GDALDataset</a> should be closed by deleting the object when it is no longer needed.</dd></dl>
<p><b>Example:</b></p>
<pre>
  OGRDataSourceH        hDS;
  OGRSFDriverH        *pahDriver;</pre><pre>  hDS = OGROpen( "polygon.shp", 0, pahDriver );
  if( hDS == NULL )
  {
      return;
  }</pre><pre>  ... use the data source ...</pre><pre>  OGRReleaseDataSource( hDS );
</pre> 
</div>
</div>
<a id="a2cbd8a95412abe089084c1def2657b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbd8a95412abe089084c1def2657b15">&#9670;&nbsp;</a></span>OGROpenShared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGROpenShared </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *&#160;</td>
          <td class="paramname"><em>pahDriverList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with <a class="el" href="ogr__api_8h.html#a2cbd8a95412abe089084c1def2657b15" title="Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with OGROpenShared() ">OGROpenShared()</a> </p>
<p>This function loops through all the drivers registered with the driver manager trying each until one succeeds with the given data source.</p>
<p>If this function fails, <a class="el" href="cpl__error_8h.html#a7f71ade3bb0a0e9e45802975ec59ff5e" title="Get the last error message. ">CPLGetLastErrorMsg()</a> can be used to check if there is an error message explaining why.</p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#aca05455472359964151f9c891d678d5e" title="Open a raster or vector file as a GDALDataset. ">GDALOpenEx()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the file, or data source to open. </td></tr>
    <tr><td class="paramname">bUpdate</td><td>FALSE for read-only access (the default) or TRUE for read-write access. </td></tr>
    <tr><td class="paramname">pahDriverList</td><td>if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise an handle to a <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file. ">GDALDataset</a>. This <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file. ">GDALDataset</a> should be closed by deleting the object when it is no longer needed.</dd></dl>
<p><b>Example:</b></p>
<pre>
  OGRDataSourceH  hDS;
  OGRSFDriverH        *pahDriver;</pre><pre>  hDS = OGROpenShared( "polygon.shp", 0, pahDriver );
  if( hDS == NULL )
  {
      return;
  }</pre><pre>  ... use the data source ...</pre><pre>  OGRReleaseDataSource( hDS );
</pre> 
</div>
</div>
<a id="ae904632d0bc86ba5501921ca594e18da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae904632d0bc86ba5501921ca594e18da">&#9670;&nbsp;</a></span>OGRRegisterAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRRegisterAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all drivers. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a9d40bc998bd6ed07ccde96028e85ae26" title="Register all known configured GDAL drivers. ">GDALAllRegister()</a> in GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ad3abed0c3b232fe55a580726536fe6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3abed0c3b232fe55a580726536fe6fa">&#9670;&nbsp;</a></span>OGRReleaseDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRReleaseDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource. </p>
<p>Internally this actually calls the OGRSFDriverRegistrar::ReleaseDataSource() method. This method is essentially a convenient alias.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc" title="Close GDAL dataset. ">GDALClose()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source to release</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a id="a31febe0b845d7cc0052767e6257e7349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31febe0b845d7cc0052767e6257e7349">&#9670;&nbsp;</a></span>OGRSetNonLinearGeometriesEnabledFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRSetNonLinearGeometriesEnabledFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flag to enable/disable returning non-linear geometries in the C API. </p>
<p>This flag has only an effect on the <a class="el" href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c" title="Fetch an handle to feature geometry. ">OGR_F_GetGeometryRef()</a>, <a class="el" href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca" title="Fetch an handle to feature geometry. ">OGR_F_GetGeomFieldRef()</a>, <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type. ">OGR_L_GetGeomType()</a>, <a class="el" href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d" title="Fetch geometry type of this field. ">OGR_GFld_GetType()</a> and <a class="el" href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf" title="Fetch the geometry base type of the passed feature definition. ">OGR_FD_GetGeomType()</a> C API, and corresponding methods in the SWIG bindings. It is meant as making it simple for applications using the OGR C API not to have to deal with non-linear geometries, even if such geometries might be returned by drivers. In which case, they will be transformed into their closest linear geometry, by doing linear approximation, with <a class="el" href="ogr__api_8h.html#a3a37c25a9b628982e86b1821446e3a0e" title="Convert to another geometry type. ">OGR_G_ForceTo()</a>.</p>
<p>Libraries should generally <em>not</em> use that method, since that could interfere with other libraries or applications.</p>
<p>Note that it <em>does</em> not affect the behavior of the C++ API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bFlag</td><td>TRUE if non-linear geometries might be returned (default value). FALSE to ask for non-linear geometries to be approximated as linear geometries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
