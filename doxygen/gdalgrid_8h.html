<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: gdalgrid.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c9839ac9bd42e86e6159886378237831.html">alg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gdalgrid.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>GDAL gridder related entry points and definitions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="gdal__alg_8h_source.html">gdal_alg.h</a>&quot;</code><br />
</div>
<p><a href="gdalgrid_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac8f080bcefc5f13e73d572be68a69fc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ac8f080bcefc5f13e73d572be68a69fc1">GDALGridInverseDistanceToAPower</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:ac8f080bcefc5f13e73d572be68a69fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse distance to a power.  <a href="#ac8f080bcefc5f13e73d572be68a69fc1">More...</a><br /></td></tr>
<tr class="separator:ac8f080bcefc5f13e73d572be68a69fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8412fae657618e232324056bea8455e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a8412fae657618e232324056bea8455e7">GDALGridInverseDistanceToAPowerNearestNeighbor</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:a8412fae657618e232324056bea8455e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse distance to a power with nearest neighbor search, ideal when max_points used.  <a href="#a8412fae657618e232324056bea8455e7">More...</a><br /></td></tr>
<tr class="separator:a8412fae657618e232324056bea8455e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f738c9330ad36df7acbf8de5b3f7105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a9f738c9330ad36df7acbf8de5b3f7105">GDALGridInverseDistanceToAPowerNoSearch</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:a9f738c9330ad36df7acbf8de5b3f7105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse distance to a power for whole data set.  <a href="#a9f738c9330ad36df7acbf8de5b3f7105">More...</a><br /></td></tr>
<tr class="separator:a9f738c9330ad36df7acbf8de5b3f7105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697dc64e23f0228146ddebf48743bb02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a697dc64e23f0228146ddebf48743bb02">GDALGridMovingAverage</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:a697dc64e23f0228146ddebf48743bb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moving average.  <a href="#a697dc64e23f0228146ddebf48743bb02">More...</a><br /></td></tr>
<tr class="separator:a697dc64e23f0228146ddebf48743bb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac497ce19f63f4d22e18685077fedf6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ac497ce19f63f4d22e18685077fedf6ed">GDALGridNearestNeighbor</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:ac497ce19f63f4d22e18685077fedf6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbor.  <a href="#ac497ce19f63f4d22e18685077fedf6ed">More...</a><br /></td></tr>
<tr class="separator:ac497ce19f63f4d22e18685077fedf6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b7e824fadf9697fc9da4b204263f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a301b7e824fadf9697fc9da4b204263f3">GDALGridDataMetricMinimum</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:a301b7e824fadf9697fc9da4b204263f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum data value (data metric).  <a href="#a301b7e824fadf9697fc9da4b204263f3">More...</a><br /></td></tr>
<tr class="separator:a301b7e824fadf9697fc9da4b204263f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131d5a851413c39708b285a6c3e0bf1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a131d5a851413c39708b285a6c3e0bf1d">GDALGridDataMetricMaximum</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:a131d5a851413c39708b285a6c3e0bf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum data value (data metric).  <a href="#a131d5a851413c39708b285a6c3e0bf1d">More...</a><br /></td></tr>
<tr class="separator:a131d5a851413c39708b285a6c3e0bf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c980b4fe3f58df17df0d9d6035f667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ae9c980b4fe3f58df17df0d9d6035f667">GDALGridDataMetricRange</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:ae9c980b4fe3f58df17df0d9d6035f667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data range (data metric).  <a href="#ae9c980b4fe3f58df17df0d9d6035f667">More...</a><br /></td></tr>
<tr class="separator:ae9c980b4fe3f58df17df0d9d6035f667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2804df02327d19f5923d79dd593813e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#aa2804df02327d19f5923d79dd593813e">GDALGridDataMetricCount</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:aa2804df02327d19f5923d79dd593813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of data points (data metric).  <a href="#aa2804df02327d19f5923d79dd593813e">More...</a><br /></td></tr>
<tr class="separator:aa2804df02327d19f5923d79dd593813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e729ec25e035ed32c307195c005d9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ae3e729ec25e035ed32c307195c005d9f">GDALGridDataMetricAverageDistance</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:ae3e729ec25e035ed32c307195c005d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average distance (data metric).  <a href="#ae3e729ec25e035ed32c307195c005d9f">More...</a><br /></td></tr>
<tr class="separator:ae3e729ec25e035ed32c307195c005d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee3f9584ebda977a6df1130c959784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#aaaee3f9584ebda977a6df1130c959784">GDALGridDataMetricAverageDistancePts</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:aaaee3f9584ebda977a6df1130c959784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average distance between points (data metric).  <a href="#aaaee3f9584ebda977a6df1130c959784">More...</a><br /></td></tr>
<tr class="separator:aaaee3f9584ebda977a6df1130c959784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c046179d3d83eaee06716e0c17a29d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a6c046179d3d83eaee06716e0c17a29d7">GDALGridLinear</a> (const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr class="memdesc:a6c046179d3d83eaee06716e0c17a29d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation.  <a href="#a6c046179d3d83eaee06716e0c17a29d7">More...</a><br /></td></tr>
<tr class="separator:a6c046179d3d83eaee06716e0c17a29d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7de1627876aa46c3b66759930e8fe4"><td class="memItemLeft" align="right" valign="top"><a id="a3a7de1627876aa46c3b66759930e8fe4"></a>
<a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a3a7de1627876aa46c3b66759930e8fe4">ParseAlgorithmAndOptions</a> (const char *, <a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a> *, void **)</td></tr>
<tr class="memdesc:a3a7de1627876aa46c3b66759930e8fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates mnemonic gridding algorithm names into GDALGridAlgorithm code, parse control parameters and assign defaults. <br /></td></tr>
<tr class="separator:a3a7de1627876aa46c3b66759930e8fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GDAL gridder related entry points and definitions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae3e729ec25e035ed32c307195c005d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e729ec25e035ed32c307195c005d9f">&#9670;&nbsp;</a></span>GDALGridDataMetricAverageDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridDataMetricAverageDistance </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average distance (data metric). </p>
<p>An average distance between the grid node (center of the search ellipse) and all of the data points found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i = 1}^n r_i}{n} \]" src="form_15.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$r_i$" src="form_4.png"/> is an Euclidean distance from the grid node to point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options. ">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values (unused) </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters (unused)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="aaaee3f9584ebda977a6df1130c959784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaee3f9584ebda977a6df1130c959784">&#9670;&nbsp;</a></span>GDALGridDataMetricAverageDistancePts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridDataMetricAverageDistancePts </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average distance between points (data metric). </p>
<p>An average distance between the data points found in grid node search ellipse. The distance between each pair of points within ellipse is calculated and average of all distances is set as a grid node value. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i = 1}^{n-1}\sum_{j=i+1}^{n} r_{ij}}{\left(n-1\right)\,n-\frac{n+{\left(n-1\right)}^{2}-1}{2}} \]" src="form_16.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$r_{ij}$" src="form_17.png"/> is an Euclidean distance between points <img class="formulaInl" alt="$i$" src="form_3.png"/> and <img class="formulaInl" alt="$j$" src="form_18.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options. ">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values (unused) </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters (unused)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="aa2804df02327d19f5923d79dd593813e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2804df02327d19f5923d79dd593813e">&#9670;&nbsp;</a></span>GDALGridDataMetricCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridDataMetricCount </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of data points (data metric). </p>
<p>A number of data points found in grid node search ellipse.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=n \]" src="form_14.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options. ">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters (unused)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="a131d5a851413c39708b285a6c3e0bf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131d5a851413c39708b285a6c3e0bf1d">&#9670;&nbsp;</a></span>GDALGridDataMetricMaximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridDataMetricMaximum </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum data value (data metric). </p>
<p>Maximum value found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\max{(Z_1,Z_2,\ldots,Z_n)} \]" src="form_12.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options. ">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters (unused)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="a301b7e824fadf9697fc9da4b204263f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301b7e824fadf9697fc9da4b204263f3">&#9670;&nbsp;</a></span>GDALGridDataMetricMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridDataMetricMinimum </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum data value (data metric). </p>
<p>Minimum value found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\min{(Z_1,Z_2,\ldots,Z_n)} \]" src="form_11.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options. ">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>unused.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="ae9c980b4fe3f58df17df0d9d6035f667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c980b4fe3f58df17df0d9d6035f667">&#9670;&nbsp;</a></span>GDALGridDataMetricRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridDataMetricRange </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data range (data metric). </p>
<p>A difference between the minimum and maximum values found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\max{(Z_1,Z_2,\ldots,Z_n)}-\min{(Z_1,Z_2,\ldots,Z_n)} \]" src="form_13.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options. ">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters (unused)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="ac8f080bcefc5f13e73d572be68a69fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f080bcefc5f13e73d572be68a69fc1">&#9670;&nbsp;</a></span>GDALGridInverseDistanceToAPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridInverseDistanceToAPower </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse distance to a power. </p>
<p>The Inverse Distance to a Power gridding method is a weighted average interpolator. You should supply the input arrays with the scattered data values including coordinates of every data point and output grid geometry. The function will compute interpolated value for the given position in output grid.</p>
<p>For every grid node the resulting value <img class="formulaInl" alt="$Z$" src="form_0.png"/> will be calculated using formula:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i=1}^n{\frac{Z_i}{r_i^p}}}{\sum_{i=1}^n{\frac{1}{r_i^p}}} \]" src="form_1.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$r_i$" src="form_4.png"/> is an Euclidean distance from the grid node to point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$p$" src="form_5.png"/> is a weighting power, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<p>In this method the weighting factor <img class="formulaInl" alt="$w$" src="form_7.png"/> is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ w=\frac{1}{r^p} \]" src="form_8.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridInverseDistanceToAPowerOptions.html" title="Inverse distance to a power method control options. ">GDALGridInverseDistanceToAPowerOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters (unused)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="a8412fae657618e232324056bea8455e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8412fae657618e232324056bea8455e7">&#9670;&nbsp;</a></span>GDALGridInverseDistanceToAPowerNearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridInverseDistanceToAPowerNearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse distance to a power with nearest neighbor search, ideal when max_points used. </p>
<p>The Inverse Distance to a Power gridding method is a weighted average interpolator. You should supply the input arrays with the scattered data values including coordinates of every data point and output grid geometry. The function will compute interpolated value for the given position in output grid.</p>
<p>For every grid node the resulting value <img class="formulaInl" alt="$Z$" src="form_0.png"/> will be calculated using formula for nearest matches:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i=1}^n{\frac{Z_i}{r_i^p}}}{\sum_{i=1}^n{\frac{1}{r_i^p}}} \]" src="form_1.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$r_i$" src="form_4.png"/> is an Euclidean distance from the grid node to point <img class="formulaInl" alt="$i$" src="form_3.png"/> (with an optional smoothing parameter <img class="formulaInl" alt="$s$" src="form_9.png"/>), </li>
<li>
<img class="formulaInl" alt="$p$" src="form_5.png"/> is a weighting power, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<p>In this method the weighting factor <img class="formulaInl" alt="$w$" src="form_7.png"/> is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ w=\frac{1}{r^p} \]" src="form_8.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridInverseDistanceToAPowerNearestNeighborOptions.html" title="Inverse distance to a power, with nearest neighbour search, control options. ">GDALGridInverseDistanceToAPowerNearestNeighborOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="a9f738c9330ad36df7acbf8de5b3f7105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f738c9330ad36df7acbf8de5b3f7105">&#9670;&nbsp;</a></span>GDALGridInverseDistanceToAPowerNoSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridInverseDistanceToAPowerNoSearch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse distance to a power for whole data set. </p>
<p>This is somewhat optimized version of the Inverse Distance to a Power method. It is used when the search ellips is not set. The algorithm and parameters are the same as in <a class="el" href="gdalgrid_8h.html#ac8f080bcefc5f13e73d572be68a69fc1" title="Inverse distance to a power. ">GDALGridInverseDistanceToAPower()</a>, but this implementation works faster, because of no search.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="gdalgrid_8h.html#ac8f080bcefc5f13e73d572be68a69fc1" title="Inverse distance to a power. ">GDALGridInverseDistanceToAPower()</a> </dd></dl>

</div>
</div>
<a id="a6c046179d3d83eaee06716e0c17a29d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c046179d3d83eaee06716e0c17a29d7">&#9670;&nbsp;</a></span>GDALGridLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridLinear </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear interpolation. </p>
<p>The Linear method performs linear interpolation by finding in which triangle of a Delaunay triangulation the point is, and by doing interpolation from its barycentric coordinates within the triangle. If the point is not in any triangle, depending on the radius, the algorithm will use the value of the nearest point (radius != 0), or the nodata value (radius == 0)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridLinearOptions.html" title="Linear method control options. ">GDALGridLinearOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParams</td><td>extra parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a697dc64e23f0228146ddebf48743bb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697dc64e23f0228146ddebf48743bb02">&#9670;&nbsp;</a></span>GDALGridMovingAverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridMovingAverage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moving average. </p>
<p>The Moving Average is a simple data averaging algorithm. It uses a moving window of elliptic form to search values and averages all data points within the window. Search ellipse can be rotated by specified angle, the center of ellipse located at the grid node. Also the minimum number of data points to average can be set, if there are not enough points in window, the grid node considered empty and will be filled with specified NODATA value.</p>
<p>Mathematically it can be expressed with the formula:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i=1}^n{Z_i}}{n} \]" src="form_10.png"/>
</p>
<p>where </p><ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridMovingAverageOptions.html" title="Moving average method control options. ">GDALGridMovingAverageOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters (unused)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="ac497ce19f63f4d22e18685077fedf6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac497ce19f63f4d22e18685077fedf6ed">&#9670;&nbsp;</a></span>GDALGridNearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridNearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptionsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hExtraParamsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nearest neighbor. </p>
<p>The Nearest Neighbor method doesn't perform any interpolation or smoothing, it just takes the value of nearest point found in grid node search ellipse and returns it as a result. If there are no points found, the specified NODATA value will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOptionsIn</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridNearestNeighborOptions.html" title="Nearest neighbor method control options. ">GDALGridNearestNeighborOptions</a> object. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXPoint</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">dfYPoint</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td class="paramname">pdfValue</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td class="paramname">hExtraParamsIn</td><td>extra parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
