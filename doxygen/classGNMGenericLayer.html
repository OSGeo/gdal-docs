<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: GNMGenericLayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGNMGenericLayer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GNMGenericLayer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>GNM layer which represents a geography network layer of generic format.  
 <a href="classGNMGenericLayer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gnm_8h_source.html">gnm.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GNMGenericLayer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classGNMGenericLayer.png" usemap="#GNMGenericLayer_map" alt=""/>
  <map id="GNMGenericLayer_map" name="GNMGenericLayer_map">
<area href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. " alt="OGRLayer" shape="rect" coords="0,56,119,80"/>
<area href="classGDALMajorObject.html" title="Object with metadata. " alt="GDALMajorObject" shape="rect" coords="0,0,119,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae548d3a02284e50e01a994abbe120c9c"><td class="memItemLeft" align="right" valign="top"><a id="ae548d3a02284e50e01a994abbe120c9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#ae548d3a02284e50e01a994abbe120c9c">GNMGenericLayer</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *poLayer, <a class="el" href="classGNMGenericNetwork.html">GNMGenericNetwork</a> *poNetwork)</td></tr>
<tr class="memdesc:ae548d3a02284e50e01a994abbe120c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGNMGenericLayer.html" title="GNM layer which represents a geography network layer of generic format. ">GNMGenericLayer</a>. <br /></td></tr>
<tr class="separator:ae548d3a02284e50e01a994abbe120c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fff7c6b0216f2eac292789edd7fc6b"><td class="memItemLeft" align="right" valign="top"><a id="a42fff7c6b0216f2eac292789edd7fc6b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a42fff7c6b0216f2eac292789edd7fc6b">~GNMGenericLayer</a> ()</td></tr>
<tr class="memdesc:a42fff7c6b0216f2eac292789edd7fc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">~GNMGenericLayer <br /></td></tr>
<tr class="separator:a42fff7c6b0216f2eac292789edd7fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3e82b584b59d94ec34e2c4ab8beced"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#aae3e82b584b59d94ec34e2c4ab8beced">GetSpatialFilter</a> () override</td></tr>
<tr class="memdesc:aae3e82b584b59d94ec34e2c4ab8beced"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the current spatial filter for this layer.  <a href="#aae3e82b584b59d94ec34e2c4ab8beced">More...</a><br /></td></tr>
<tr class="separator:aae3e82b584b59d94ec34e2c4ab8beced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605821b486c96a1691ba3701f9946299"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a605821b486c96a1691ba3701f9946299">SetSpatialFilter</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) override</td></tr>
<tr class="memdesc:a605821b486c96a1691ba3701f9946299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a605821b486c96a1691ba3701f9946299">More...</a><br /></td></tr>
<tr class="separator:a605821b486c96a1691ba3701f9946299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c7e3b89822cbd078b5fb3118471d98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a81c7e3b89822cbd078b5fb3118471d98">SetSpatialFilterRect</a> (double dfMinX, double dfMinY, double dfMaxX, double dfMaxY) override</td></tr>
<tr class="memdesc:a81c7e3b89822cbd078b5fb3118471d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#a81c7e3b89822cbd078b5fb3118471d98">More...</a><br /></td></tr>
<tr class="separator:a81c7e3b89822cbd078b5fb3118471d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd9f62ec3a5e334a6a8ae5b32f2cbda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a7dd9f62ec3a5e334a6a8ae5b32f2cbda">SetSpatialFilter</a> (int iGeomField, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) override</td></tr>
<tr class="memdesc:a7dd9f62ec3a5e334a6a8ae5b32f2cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a7dd9f62ec3a5e334a6a8ae5b32f2cbda">More...</a><br /></td></tr>
<tr class="separator:a7dd9f62ec3a5e334a6a8ae5b32f2cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde8cd58988f17b2f7d6c6e997f22293"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#abde8cd58988f17b2f7d6c6e997f22293">SetSpatialFilterRect</a> (int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY) override</td></tr>
<tr class="memdesc:abde8cd58988f17b2f7d6c6e997f22293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#abde8cd58988f17b2f7d6c6e997f22293">More...</a><br /></td></tr>
<tr class="separator:abde8cd58988f17b2f7d6c6e997f22293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa900b33c9e5272514739266f70f57383"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#aa900b33c9e5272514739266f70f57383">SetAttributeFilter</a> (const char *) override</td></tr>
<tr class="memdesc:aa900b33c9e5272514739266f70f57383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new attribute query.  <a href="#aa900b33c9e5272514739266f70f57383">More...</a><br /></td></tr>
<tr class="separator:aa900b33c9e5272514739266f70f57383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479d90adb91ed34e34417e98caf787c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2">ResetReading</a> () override</td></tr>
<tr class="memdesc:a479d90adb91ed34e34417e98caf787c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset feature reading to start on the first feature.  <a href="#a479d90adb91ed34e34417e98caf787c2">More...</a><br /></td></tr>
<tr class="separator:a479d90adb91ed34e34417e98caf787c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9103cc8308203034828993fc1e0b23db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db">GetNextFeature</a> () override</td></tr>
<tr class="memdesc:a9103cc8308203034828993fc1e0b23db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the next available feature from this layer.  <a href="#a9103cc8308203034828993fc1e0b23db">More...</a><br /></td></tr>
<tr class="separator:a9103cc8308203034828993fc1e0b23db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd391cf8015675b45c7553cd02906e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a67cd391cf8015675b45c7553cd02906e">SetNextByIndex</a> (<a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nIndex) override</td></tr>
<tr class="memdesc:a67cd391cf8015675b45c7553cd02906e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move read cursor to the nIndex'th feature in the current resultset.  <a href="#a67cd391cf8015675b45c7553cd02906e">More...</a><br /></td></tr>
<tr class="separator:a67cd391cf8015675b45c7553cd02906e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0d4b235a725ad16faac2e0b659e33b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#ade0d4b235a725ad16faac2e0b659e33b">DeleteFeature</a> (<a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nFID) override</td></tr>
<tr class="memdesc:ade0d4b235a725ad16faac2e0b659e33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete feature from layer.  <a href="#ade0d4b235a725ad16faac2e0b659e33b">More...</a><br /></td></tr>
<tr class="separator:ade0d4b235a725ad16faac2e0b659e33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fea999cd24d7eb5b11657c82d78b8d"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a14fea999cd24d7eb5b11657c82d78b8d">GetName</a> () override</td></tr>
<tr class="memdesc:a14fea999cd24d7eb5b11657c82d78b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer name.  <a href="#a14fea999cd24d7eb5b11657c82d78b8d">More...</a><br /></td></tr>
<tr class="separator:a14fea999cd24d7eb5b11657c82d78b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831c4f8baebf8167196106cb8de71e26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a831c4f8baebf8167196106cb8de71e26">GetGeomType</a> () override</td></tr>
<tr class="memdesc:a831c4f8baebf8167196106cb8de71e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer geometry type.  <a href="#a831c4f8baebf8167196106cb8de71e26">More...</a><br /></td></tr>
<tr class="separator:a831c4f8baebf8167196106cb8de71e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a51b83925df6eee668a3417ac9105c8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8">GetLayerDefn</a> () override</td></tr>
<tr class="memdesc:a1a51b83925df6eee668a3417ac9105c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the schema information for this layer.  <a href="#a1a51b83925df6eee668a3417ac9105c8">More...</a><br /></td></tr>
<tr class="separator:a1a51b83925df6eee668a3417ac9105c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf969adb8b5e2358846844a58b890fd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a3cf969adb8b5e2358846844a58b890fd">FindFieldIndex</a> (const char *pszFieldName, int bExactMatch) override</td></tr>
<tr class="memdesc:a3cf969adb8b5e2358846844a58b890fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of field in the layer.  <a href="#a3cf969adb8b5e2358846844a58b890fd">More...</a><br /></td></tr>
<tr class="separator:a3cf969adb8b5e2358846844a58b890fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da7edd25c416684f858cb4a81ab92b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a6da7edd25c416684f858cb4a81ab92b2">GetSpatialRef</a> () override</td></tr>
<tr class="memdesc:a6da7edd25c416684f858cb4a81ab92b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the spatial reference system for this layer.  <a href="#a6da7edd25c416684f858cb4a81ab92b2">More...</a><br /></td></tr>
<tr class="separator:a6da7edd25c416684f858cb4a81ab92b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f73cdc43100a0443da3e5549a152490"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a3f73cdc43100a0443da3e5549a152490">GetFeatureCount</a> (int bForce=TRUE) override</td></tr>
<tr class="memdesc:a3f73cdc43100a0443da3e5549a152490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the feature count in this layer.  <a href="#a3f73cdc43100a0443da3e5549a152490">More...</a><br /></td></tr>
<tr class="separator:a3f73cdc43100a0443da3e5549a152490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246b6f98cb4e51ea10514945ec505369"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a246b6f98cb4e51ea10514945ec505369">GetExtent</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE) override</td></tr>
<tr class="memdesc:a246b6f98cb4e51ea10514945ec505369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer.  <a href="#a246b6f98cb4e51ea10514945ec505369">More...</a><br /></td></tr>
<tr class="separator:a246b6f98cb4e51ea10514945ec505369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35416294aac0b338d5a2d881ff1fdee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#aa35416294aac0b338d5a2d881ff1fdee">GetExtent</a> (int iGeomField, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE) override</td></tr>
<tr class="memdesc:aa35416294aac0b338d5a2d881ff1fdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer, on the specified geometry field.  <a href="#aa35416294aac0b338d5a2d881ff1fdee">More...</a><br /></td></tr>
<tr class="separator:aa35416294aac0b338d5a2d881ff1fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6756f1d50d6aa06a66a5bb3483bdacfd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a6756f1d50d6aa06a66a5bb3483bdacfd">TestCapability</a> (const char *) override</td></tr>
<tr class="memdesc:a6756f1d50d6aa06a66a5bb3483bdacfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this layer supported the named capability.  <a href="#a6756f1d50d6aa06a66a5bb3483bdacfd">More...</a><br /></td></tr>
<tr class="separator:a6756f1d50d6aa06a66a5bb3483bdacfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212e4e971abae3336511e6b258d099aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a212e4e971abae3336511e6b258d099aa">CreateField</a> (<a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *poField, int bApproxOK=TRUE) override</td></tr>
<tr class="memdesc:a212e4e971abae3336511e6b258d099aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field on a layer.  <a href="#a212e4e971abae3336511e6b258d099aa">More...</a><br /></td></tr>
<tr class="separator:a212e4e971abae3336511e6b258d099aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958d03d3b963bce513902e7a94a1dd0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a7958d03d3b963bce513902e7a94a1dd0">DeleteField</a> (int iField) override</td></tr>
<tr class="memdesc:a7958d03d3b963bce513902e7a94a1dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing field on a layer.  <a href="#a7958d03d3b963bce513902e7a94a1dd0">More...</a><br /></td></tr>
<tr class="separator:a7958d03d3b963bce513902e7a94a1dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171a2be1c00ce80a9ba93139fd5149ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a171a2be1c00ce80a9ba93139fd5149ed">ReorderFields</a> (int *panMap) override</td></tr>
<tr class="memdesc:a171a2be1c00ce80a9ba93139fd5149ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder all the fields of a layer.  <a href="#a171a2be1c00ce80a9ba93139fd5149ed">More...</a><br /></td></tr>
<tr class="separator:a171a2be1c00ce80a9ba93139fd5149ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f80c8342c6ad3b6d16ad33d8b2153c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a69f80c8342c6ad3b6d16ad33d8b2153c">AlterFieldDefn</a> (int iField, <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *poNewFieldDefn, int nFlagsIn) override</td></tr>
<tr class="memdesc:a69f80c8342c6ad3b6d16ad33d8b2153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the definition of an existing field on a layer.  <a href="#a69f80c8342c6ad3b6d16ad33d8b2153c">More...</a><br /></td></tr>
<tr class="separator:a69f80c8342c6ad3b6d16ad33d8b2153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dfb15c43df4f62e721fcb77f22ae5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#ae2dfb15c43df4f62e721fcb77f22ae5b">CreateGeomField</a> (<a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *poField, int bApproxOK=TRUE) override</td></tr>
<tr class="memdesc:ae2dfb15c43df4f62e721fcb77f22ae5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new geometry field on a layer.  <a href="#ae2dfb15c43df4f62e721fcb77f22ae5b">More...</a><br /></td></tr>
<tr class="separator:ae2dfb15c43df4f62e721fcb77f22ae5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5b4e4b8e3d7a132d6a3d40c2a2dea7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a2c5b4e4b8e3d7a132d6a3d40c2a2dea7">SyncToDisk</a> () override</td></tr>
<tr class="memdesc:a2c5b4e4b8e3d7a132d6a3d40c2a2dea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending changes to disk.  <a href="#a2c5b4e4b8e3d7a132d6a3d40c2a2dea7">More...</a><br /></td></tr>
<tr class="separator:a2c5b4e4b8e3d7a132d6a3d40c2a2dea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4c6c2d6fd1330851749eb87fc9143a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a5d4c6c2d6fd1330851749eb87fc9143a">GetStyleTable</a> () override</td></tr>
<tr class="memdesc:a5d4c6c2d6fd1330851749eb87fc9143a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns layer style table.  <a href="#a5d4c6c2d6fd1330851749eb87fc9143a">More...</a><br /></td></tr>
<tr class="separator:a5d4c6c2d6fd1330851749eb87fc9143a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bd0cdf55e1249cdbe9b222e6100209"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#ad3bd0cdf55e1249cdbe9b222e6100209">SetStyleTableDirectly</a> (<a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *poStyleTable) override</td></tr>
<tr class="memdesc:ad3bd0cdf55e1249cdbe9b222e6100209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set layer style table.  <a href="#ad3bd0cdf55e1249cdbe9b222e6100209">More...</a><br /></td></tr>
<tr class="separator:ad3bd0cdf55e1249cdbe9b222e6100209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b8c67af40323b91e191f05a0086eb2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a22b8c67af40323b91e191f05a0086eb2">SetStyleTable</a> (<a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *poStyleTable) override</td></tr>
<tr class="memdesc:a22b8c67af40323b91e191f05a0086eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set layer style table.  <a href="#a22b8c67af40323b91e191f05a0086eb2">More...</a><br /></td></tr>
<tr class="separator:a22b8c67af40323b91e191f05a0086eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51170039be88e1cafa99c9483408127"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#aa51170039be88e1cafa99c9483408127">StartTransaction</a> () override</td></tr>
<tr class="memdesc:aa51170039be88e1cafa99c9483408127"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, StartTransaction creates a transaction.  <a href="#aa51170039be88e1cafa99c9483408127">More...</a><br /></td></tr>
<tr class="separator:aa51170039be88e1cafa99c9483408127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92933b3aeef549807394bf578416aad2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a92933b3aeef549807394bf578416aad2">CommitTransaction</a> () override</td></tr>
<tr class="memdesc:a92933b3aeef549807394bf578416aad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, CommitTransaction commits a transaction.  <a href="#a92933b3aeef549807394bf578416aad2">More...</a><br /></td></tr>
<tr class="separator:a92933b3aeef549807394bf578416aad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dfbdab339aa69aca5aea6d454567e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a50dfbdab339aa69aca5aea6d454567e8">RollbackTransaction</a> () override</td></tr>
<tr class="memdesc:a50dfbdab339aa69aca5aea6d454567e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction.  <a href="#a50dfbdab339aa69aca5aea6d454567e8">More...</a><br /></td></tr>
<tr class="separator:a50dfbdab339aa69aca5aea6d454567e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1153cc46ed17cb4ac1398d6ac6b0cc5d"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a1153cc46ed17cb4ac1398d6ac6b0cc5d">GetFIDColumn</a> () override</td></tr>
<tr class="memdesc:a1153cc46ed17cb4ac1398d6ac6b0cc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the FID column, or "" if not supported.  <a href="#a1153cc46ed17cb4ac1398d6ac6b0cc5d">More...</a><br /></td></tr>
<tr class="separator:a1153cc46ed17cb4ac1398d6ac6b0cc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab97b4895cc5831b0e927d70e8f44961"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#aab97b4895cc5831b0e927d70e8f44961">GetGeometryColumn</a> () override</td></tr>
<tr class="memdesc:aab97b4895cc5831b0e927d70e8f44961"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the geometry column, or "" if not supported.  <a href="#aab97b4895cc5831b0e927d70e8f44961">More...</a><br /></td></tr>
<tr class="separator:aab97b4895cc5831b0e927d70e8f44961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a499269c587a39637a2f76320e75fec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a1a499269c587a39637a2f76320e75fec">SetIgnoredFields</a> (const char **papszFields) override</td></tr>
<tr class="memdesc:a1a499269c587a39637a2f76320e75fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which fields can be omitted when retrieving features from the layer.  <a href="#a1a499269c587a39637a2f76320e75fec">More...</a><br /></td></tr>
<tr class="separator:a1a499269c587a39637a2f76320e75fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa592a7e479b74d289cb460b26bfe0a73"><td class="memItemLeft" align="right" valign="top"><a id="aa592a7e479b74d289cb460b26bfe0a73"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#aa592a7e479b74d289cb460b26bfe0a73">Intersection</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:aa592a7e479b74d289cb460b26bfe0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection. <br /></td></tr>
<tr class="separator:aa592a7e479b74d289cb460b26bfe0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e7acbfb8dbe0d4043474f77f827f5"><td class="memItemLeft" align="right" valign="top"><a id="a3b1e7acbfb8dbe0d4043474f77f827f5"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a3b1e7acbfb8dbe0d4043474f77f827f5">Union</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a3b1e7acbfb8dbe0d4043474f77f827f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union. <br /></td></tr>
<tr class="separator:a3b1e7acbfb8dbe0d4043474f77f827f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47c1c1228ad08b7323e9c451bc8ab79"><td class="memItemLeft" align="right" valign="top"><a id="ae47c1c1228ad08b7323e9c451bc8ab79"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#ae47c1c1228ad08b7323e9c451bc8ab79">SymDifference</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:ae47c1c1228ad08b7323e9c451bc8ab79"><td class="mdescLeft">&#160;</td><td class="mdescRight">SymDifference. <br /></td></tr>
<tr class="separator:ae47c1c1228ad08b7323e9c451bc8ab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68b55b62ba91bd95373bc838d079dee"><td class="memItemLeft" align="right" valign="top"><a id="af68b55b62ba91bd95373bc838d079dee"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#af68b55b62ba91bd95373bc838d079dee">Identity</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:af68b55b62ba91bd95373bc838d079dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity. <br /></td></tr>
<tr class="separator:af68b55b62ba91bd95373bc838d079dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9b0f8ccdd63a212af3407f7e2f6f6f"><td class="memItemLeft" align="right" valign="top"><a id="a6c9b0f8ccdd63a212af3407f7e2f6f6f"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a6c9b0f8ccdd63a212af3407f7e2f6f6f">Update</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a6c9b0f8ccdd63a212af3407f7e2f6f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update. <br /></td></tr>
<tr class="separator:a6c9b0f8ccdd63a212af3407f7e2f6f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2d8efb2913012393a9e143d3770a67"><td class="memItemLeft" align="right" valign="top"><a id="a4f2d8efb2913012393a9e143d3770a67"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a4f2d8efb2913012393a9e143d3770a67">Clip</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a4f2d8efb2913012393a9e143d3770a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip. <br /></td></tr>
<tr class="separator:a4f2d8efb2913012393a9e143d3770a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb41eca34d6ed6f0d92522c087333802"><td class="memItemLeft" align="right" valign="top"><a id="afb41eca34d6ed6f0d92522c087333802"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#afb41eca34d6ed6f0d92522c087333802">Erase</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:afb41eca34d6ed6f0d92522c087333802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase. <br /></td></tr>
<tr class="separator:afb41eca34d6ed6f0d92522c087333802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a0bcbe51c151be05d30d7c5ea537c2"><td class="memItemLeft" align="right" valign="top"><a id="a93a0bcbe51c151be05d30d7c5ea537c2"></a>
<a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#a93a0bcbe51c151be05d30d7c5ea537c2">GetFeaturesRead</a> ()</td></tr>
<tr class="memdesc:a93a0bcbe51c151be05d30d7c5ea537c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetFeaturesRead. <br /></td></tr>
<tr class="separator:a93a0bcbe51c151be05d30d7c5ea537c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac103415659cd503be92436420fedb0a9"><td class="memItemLeft" align="right" valign="top"><a id="ac103415659cd503be92436420fedb0a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGNMGenericLayer.html#ac103415659cd503be92436420fedb0a9">AttributeFilterEvaluationNeedsGeometry</a> ()</td></tr>
<tr class="memdesc:ac103415659cd503be92436420fedb0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">AttributeFilterEvaluationNeedsGeometry. <br /></td></tr>
<tr class="separator:ac103415659cd503be92436420fedb0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classOGRLayer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classOGRLayer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classOGRLayer.html">OGRLayer</a></td></tr>
<tr class="memitem:a95f19fa71f244c4408ceb92d5fe6b308 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">FeatureIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a95f19fa71f244c4408ceb92d5fe6b308">begin</a> ()</td></tr>
<tr class="memdesc:a95f19fa71f244c4408ceb92d5fe6b308 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin of feature iterator.  <a href="classOGRLayer.html#a95f19fa71f244c4408ceb92d5fe6b308">More...</a><br /></td></tr>
<tr class="separator:a95f19fa71f244c4408ceb92d5fe6b308 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd93204c89e3cafa062507c60f41cb9 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">FeatureIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a8cd93204c89e3cafa062507c60f41cb9">end</a> ()</td></tr>
<tr class="memdesc:a8cd93204c89e3cafa062507c60f41cb9 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end of feature iterator.  <a href="classOGRLayer.html#a8cd93204c89e3cafa062507c60f41cb9">More...</a><br /></td></tr>
<tr class="separator:a8cd93204c89e3cafa062507c60f41cb9 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b39284997972eb198ed754594d52ec2 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a7b39284997972eb198ed754594d52ec2">GetFeature</a> (<a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nFID) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a7b39284997972eb198ed754594d52ec2 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a feature by its identifier.  <a href="classOGRLayer.html#a7b39284997972eb198ed754594d52ec2">More...</a><br /></td></tr>
<tr class="separator:a7b39284997972eb198ed754594d52ec2 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7dfe0f900ac7fb0f457e7a49b3a5e3 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6e7dfe0f900ac7fb0f457e7a49b3a5e3">SetFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a6e7dfe0f900ac7fb0f457e7a49b3a5e3 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite an existing feature.  <a href="classOGRLayer.html#a6e7dfe0f900ac7fb0f457e7a49b3a5e3">More...</a><br /></td></tr>
<tr class="separator:a6e7dfe0f900ac7fb0f457e7a49b3a5e3 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6db0be3b8876142d54e8bfd5dc8324 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a5d6db0be3b8876142d54e8bfd5dc8324">CreateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a5d6db0be3b8876142d54e8bfd5dc8324 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="classOGRLayer.html#a5d6db0be3b8876142d54e8bfd5dc8324">More...</a><br /></td></tr>
<tr class="separator:a5d6db0be3b8876142d54e8bfd5dc8324 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5202606175f7e7dcd76c3eb237ac8303 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a5202606175f7e7dcd76c3eb237ac8303">Intersection</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a5202606175f7e7dcd76c3eb237ac8303 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two layers.  <a href="classOGRLayer.html#a5202606175f7e7dcd76c3eb237ac8303">More...</a><br /></td></tr>
<tr class="separator:a5202606175f7e7dcd76c3eb237ac8303 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0598c7dab1f4dbe3e2735e27450c9c inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adf0598c7dab1f4dbe3e2735e27450c9c">Union</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:adf0598c7dab1f4dbe3e2735e27450c9c inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two layers.  <a href="classOGRLayer.html#adf0598c7dab1f4dbe3e2735e27450c9c">More...</a><br /></td></tr>
<tr class="separator:adf0598c7dab1f4dbe3e2735e27450c9c inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781aa76c6b44b19de09f61816e32245b inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a781aa76c6b44b19de09f61816e32245b inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrical difference of two layers.  <a href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">More...</a><br /></td></tr>
<tr class="separator:a781aa76c6b44b19de09f61816e32245b inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ff64cc8b070819da0a7e121ff07b3 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a385ff64cc8b070819da0a7e121ff07b3">Identity</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a385ff64cc8b070819da0a7e121ff07b3 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the features of this layer with the ones from the identity layer.  <a href="classOGRLayer.html#a385ff64cc8b070819da0a7e121ff07b3">More...</a><br /></td></tr>
<tr class="separator:a385ff64cc8b070819da0a7e121ff07b3 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b86f3a070fe99e39631c994be4fce08 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6b86f3a070fe99e39631c994be4fce08">Update</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a6b86f3a070fe99e39631c994be4fce08 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update this layer with features from the update layer.  <a href="classOGRLayer.html#a6b86f3a070fe99e39631c994be4fce08">More...</a><br /></td></tr>
<tr class="separator:a6b86f3a070fe99e39631c994be4fce08 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822deb3b2d047185e3a454692619291c inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a822deb3b2d047185e3a454692619291c">Clip</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a822deb3b2d047185e3a454692619291c inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip off areas that are not covered by the method layer.  <a href="classOGRLayer.html#a822deb3b2d047185e3a454692619291c">More...</a><br /></td></tr>
<tr class="separator:a822deb3b2d047185e3a454692619291c inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fa292ae87af3bc0d3abb3963a71914 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a23fa292ae87af3bc0d3abb3963a71914">Erase</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a23fa292ae87af3bc0d3abb3963a71914 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove areas that are covered by the method layer.  <a href="classOGRLayer.html#a23fa292ae87af3bc0d3abb3963a71914">More...</a><br /></td></tr>
<tr class="separator:a23fa292ae87af3bc0d3abb3963a71914 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae783de2e9ee2629e6bf27fd3b8622fb5 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ae783de2e9ee2629e6bf27fd3b8622fb5">Reference</a> ()</td></tr>
<tr class="memdesc:ae783de2e9ee2629e6bf27fd3b8622fb5 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment layer reference count.  <a href="classOGRLayer.html#ae783de2e9ee2629e6bf27fd3b8622fb5">More...</a><br /></td></tr>
<tr class="separator:ae783de2e9ee2629e6bf27fd3b8622fb5 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2271d53f75d4f6ff2f4a8aeb71e825d6 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2271d53f75d4f6ff2f4a8aeb71e825d6">Dereference</a> ()</td></tr>
<tr class="memdesc:a2271d53f75d4f6ff2f4a8aeb71e825d6 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement layer reference count.  <a href="classOGRLayer.html#a2271d53f75d4f6ff2f4a8aeb71e825d6">More...</a><br /></td></tr>
<tr class="separator:a2271d53f75d4f6ff2f4a8aeb71e825d6 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3cea24856572302ae11ed97ca33375 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adf3cea24856572302ae11ed97ca33375">GetRefCount</a> () const</td></tr>
<tr class="memdesc:adf3cea24856572302ae11ed97ca33375 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch reference count.  <a href="classOGRLayer.html#adf3cea24856572302ae11ed97ca33375">More...</a><br /></td></tr>
<tr class="separator:adf3cea24856572302ae11ed97ca33375 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c02b991bfa78552eeb0cbcdcf1aed8 inherit pub_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8">ReorderField</a> (int iOldFieldPos, int iNewFieldPos)</td></tr>
<tr class="memdesc:ab4c02b991bfa78552eeb0cbcdcf1aed8 inherit pub_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder an existing field on a layer.  <a href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8">More...</a><br /></td></tr>
<tr class="separator:ab4c02b991bfa78552eeb0cbcdcf1aed8 inherit pub_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGDALMajorObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGDALMajorObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGDALMajorObject.html">GDALMajorObject</a></td></tr>
<tr class="memitem:aafb345b2a42f86842b520e09069526f0 inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#aafb345b2a42f86842b520e09069526f0">GetMOFlags</a> () const</td></tr>
<tr class="memdesc:aafb345b2a42f86842b520e09069526f0 inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GMO_ flags.  <a href="classGDALMajorObject.html#aafb345b2a42f86842b520e09069526f0">More...</a><br /></td></tr>
<tr class="separator:aafb345b2a42f86842b520e09069526f0 inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1af15d780eba6cc9937160d8cc6b2b7 inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#ae1af15d780eba6cc9937160d8cc6b2b7">SetMOFlags</a> (int nFlagsIn)</td></tr>
<tr class="memdesc:ae1af15d780eba6cc9937160d8cc6b2b7 inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign GMO_flags.  <a href="classGDALMajorObject.html#ae1af15d780eba6cc9937160d8cc6b2b7">More...</a><br /></td></tr>
<tr class="separator:ae1af15d780eba6cc9937160d8cc6b2b7 inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af769554a8632dda9f99db325664a37cf inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#af769554a8632dda9f99db325664a37cf">GetDescription</a> () const</td></tr>
<tr class="memdesc:af769554a8632dda9f99db325664a37cf inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch object description.  <a href="classGDALMajorObject.html#af769554a8632dda9f99db325664a37cf">More...</a><br /></td></tr>
<tr class="separator:af769554a8632dda9f99db325664a37cf inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af334bc8d152f130a55783ea36938735b inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#af334bc8d152f130a55783ea36938735b">SetDescription</a> (const char *)</td></tr>
<tr class="memdesc:af334bc8d152f130a55783ea36938735b inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set object description.  <a href="classGDALMajorObject.html#af334bc8d152f130a55783ea36938735b">More...</a><br /></td></tr>
<tr class="separator:af334bc8d152f130a55783ea36938735b inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2cebbfa60a5e3f5cb4aa2e9b80d12 inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">virtual char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a83e2cebbfa60a5e3f5cb4aa2e9b80d12">GetMetadataDomainList</a> ()</td></tr>
<tr class="memdesc:a83e2cebbfa60a5e3f5cb4aa2e9b80d12 inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch list of metadata domains.  <a href="classGDALMajorObject.html#a83e2cebbfa60a5e3f5cb4aa2e9b80d12">More...</a><br /></td></tr>
<tr class="separator:a83e2cebbfa60a5e3f5cb4aa2e9b80d12 inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce3bf5795bbebfe9bc643e2152bb360 inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">virtual char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a8ce3bf5795bbebfe9bc643e2152bb360">GetMetadata</a> (const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:a8ce3bf5795bbebfe9bc643e2152bb360 inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch metadata.  <a href="classGDALMajorObject.html#a8ce3bf5795bbebfe9bc643e2152bb360">More...</a><br /></td></tr>
<tr class="separator:a8ce3bf5795bbebfe9bc643e2152bb360 inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ab7226d95b20e3e1f42461a1f62906 inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a61ab7226d95b20e3e1f42461a1f62906">SetMetadata</a> (char **papszMetadata, const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:a61ab7226d95b20e3e1f42461a1f62906 inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set metadata.  <a href="classGDALMajorObject.html#a61ab7226d95b20e3e1f42461a1f62906">More...</a><br /></td></tr>
<tr class="separator:a61ab7226d95b20e3e1f42461a1f62906 inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17f496c8b6d0c0be6f52437d3ba8a6d inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#ad17f496c8b6d0c0be6f52437d3ba8a6d">GetMetadataItem</a> (const char *pszName, const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:ad17f496c8b6d0c0be6f52437d3ba8a6d inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch single metadata item.  <a href="classGDALMajorObject.html#ad17f496c8b6d0c0be6f52437d3ba8a6d">More...</a><br /></td></tr>
<tr class="separator:ad17f496c8b6d0c0be6f52437d3ba8a6d inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e157735f6ff6e11935c2a2dbcc24c92 inherit pub_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a3e157735f6ff6e11935c2a2dbcc24c92">SetMetadataItem</a> (const char *pszName, const char *pszValue, const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:a3e157735f6ff6e11935c2a2dbcc24c92 inherit pub_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set single metadata item.  <a href="classGDALMajorObject.html#a3e157735f6ff6e11935c2a2dbcc24c92">More...</a><br /></td></tr>
<tr class="separator:a3e157735f6ff6e11935c2a2dbcc24c92 inherit pub_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classOGRLayer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classOGRLayer')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classOGRLayer.html">OGRLayer</a></td></tr>
<tr class="memitem:a6f202957750f4477a94a1a76c3ae91f3 inherit pub_static_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6f202957750f4477a94a1a76c3ae91f3">ToHandle</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *poLayer)</td></tr>
<tr class="memdesc:a6f202957750f4477a94a1a76c3ae91f3 inherit pub_static_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRLayer* to a OGRLayerH.  <a href="classOGRLayer.html#a6f202957750f4477a94a1a76c3ae91f3">More...</a><br /></td></tr>
<tr class="separator:a6f202957750f4477a94a1a76c3ae91f3 inherit pub_static_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6114f65f0fa09b55b4324a876623c7d3 inherit pub_static_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6114f65f0fa09b55b4324a876623c7d3">FromHandle</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer)</td></tr>
<tr class="memdesc:a6114f65f0fa09b55b4324a876623c7d3 inherit pub_static_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRLayerH to a OGRLayer*.  <a href="classOGRLayer.html#a6114f65f0fa09b55b4324a876623c7d3">More...</a><br /></td></tr>
<tr class="separator:a6114f65f0fa09b55b4324a876623c7d3 inherit pub_static_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classGDALMajorObject"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classGDALMajorObject')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classGDALMajorObject.html">GDALMajorObject</a></td></tr>
<tr class="memitem:a341ee268785b7e54714f789de59f23fe inherit pub_static_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="gdal_8h.html#ace297748fac88851533c56ddec20084f">GDALMajorObjectH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a341ee268785b7e54714f789de59f23fe">ToHandle</a> (<a class="el" href="classGDALMajorObject.html">GDALMajorObject</a> *poMajorObject)</td></tr>
<tr class="memdesc:a341ee268785b7e54714f789de59f23fe inherit pub_static_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a GDALMajorObject* to a GDALMajorObjectH.  <a href="classGDALMajorObject.html#a341ee268785b7e54714f789de59f23fe">More...</a><br /></td></tr>
<tr class="separator:a341ee268785b7e54714f789de59f23fe inherit pub_static_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add373059b1d1dda8223140e5b38ce94d inherit pub_static_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGDALMajorObject.html">GDALMajorObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#add373059b1d1dda8223140e5b38ce94d">FromHandle</a> (<a class="el" href="gdal_8h.html#ace297748fac88851533c56ddec20084f">GDALMajorObjectH</a> hMajorObject)</td></tr>
<tr class="memdesc:add373059b1d1dda8223140e5b38ce94d inherit pub_static_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a GDALMajorObjectH to a GDALMajorObject*.  <a href="classGDALMajorObject.html#add373059b1d1dda8223140e5b38ce94d">More...</a><br /></td></tr>
<tr class="separator:add373059b1d1dda8223140e5b38ce94d inherit pub_static_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classOGRLayer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classOGRLayer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classOGRLayer.html">OGRLayer</a></td></tr>
<tr class="memitem:ad57f606f304700e0e853d168cdca38a4 inherit pro_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ad57f606f304700e0e853d168cdca38a4">ISetFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ad57f606f304700e0e853d168cdca38a4 inherit pro_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite an existing feature.  <a href="classOGRLayer.html#ad57f606f304700e0e853d168cdca38a4">More...</a><br /></td></tr>
<tr class="separator:ad57f606f304700e0e853d168cdca38a4 inherit pro_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8b2f6d49385ac3a7446222a42ec6e2 inherit pro_methods_classOGRLayer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a3d8b2f6d49385ac3a7446222a42ec6e2">ICreateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature) <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a3d8b2f6d49385ac3a7446222a42ec6e2 inherit pro_methods_classOGRLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="classOGRLayer.html#a3d8b2f6d49385ac3a7446222a42ec6e2">More...</a><br /></td></tr>
<tr class="separator:a3d8b2f6d49385ac3a7446222a42ec6e2 inherit pro_methods_classOGRLayer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classGDALMajorObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGDALMajorObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGDALMajorObject.html">GDALMajorObject</a></td></tr>
<tr class="memitem:aa3a75ef69ecc93177d0f57f8d745b111 inherit pro_methods_classGDALMajorObject"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#aa3a75ef69ecc93177d0f57f8d745b111">BuildMetadataDomainList</a> (char **papszList, int bCheckNonEmpty,...) <a class="el" href="cpl__port_8h.html#a3181c953b783da525be0a6c1975be31a">CPL_NULL_TERMINATED</a></td></tr>
<tr class="memdesc:aa3a75ef69ecc93177d0f57f8d745b111 inherit pro_methods_classGDALMajorObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for custom implementations of <a class="el" href="classGDALMajorObject.html#a83e2cebbfa60a5e3f5cb4aa2e9b80d12" title="Fetch list of metadata domains. ">GetMetadataDomainList()</a>  <a href="classGDALMajorObject.html#aa3a75ef69ecc93177d0f57f8d745b111">More...</a><br /></td></tr>
<tr class="separator:aa3a75ef69ecc93177d0f57f8d745b111 inherit pro_methods_classGDALMajorObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GNM layer which represents a geography network layer of generic format. </p>
<p>The class override some <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> methods to fulfill the network requirements.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a69f80c8342c6ad3b6d16ad33d8b2153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f80c8342c6ad3b6d16ad33d8b2153c">&#9670;&nbsp;</a></span>AlterFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::AlterFieldDefn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *&#160;</td>
          <td class="paramname"><em>poNewFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec" title="Alter the definition of an existing field on a layer. ">OGR_L_AlterFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iField</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td class="paramname">poNewFieldDefn</td><td>new field definition </td></tr>
    <tr><td class="paramname">nFlags</td><td>combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG, ALTER_WIDTH_PRECISION_FLAG, ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to indicate which of the name and/or type and/or width and precision fields and/or nullability from the new field definition must be taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4">OGRLayer</a>.</p>

</div>
</div>
<a id="a92933b3aeef549807394bf578416aad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92933b3aeef549807394bf578416aad2">&#9670;&nbsp;</a></span>CommitTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::CommitTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For datasources which support transactions, CommitTransaction commits a transaction. </p>
<p>If no transaction is active, or the commit fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aa6f2e9557624952c68eaa46d272bd806" title="For datasources which support transactions, CommitTransaction commits a transaction. ">OGR_L_CommitTransaction()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#ae9f7fd669006a858f53115172f14a2eb">OGRLayer</a>.</p>

</div>
</div>
<a id="a212e4e971abae3336511e6b258d099aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212e4e971abae3336511e6b258d099aa">&#9670;&nbsp;</a></span>CreateField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::CreateField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *&#160;</td>
          <td class="paramname"><em>poField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275" title="Create a new field on a layer. ">OGR_L_CreateField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poField</td><td>field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a00b1376a1eabb1298ef278f92f6d84be">OGRLayer</a>.</p>

</div>
</div>
<a id="ae2dfb15c43df4f62e721fcb77f22ae5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2dfb15c43df4f62e721fcb77f22ae5b">&#9670;&nbsp;</a></span>CreateGeomField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::CreateGeomField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *&#160;</td>
          <td class="paramname"><em>poField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateGeomField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc" title="Create a new geometry field on a layer. ">OGR_L_CreateGeomField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poField</td><td>geometry field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.11 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#af3c68cad279ad80a476c6fb307cf5e48">OGRLayer</a>.</p>

</div>
</div>
<a id="ade0d4b235a725ad16faac2e0b659e33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0d4b235a725ad16faac2e0b659e33b">&#9670;&nbsp;</a></span>DeleteFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::DeleteFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="el" href="classGNMGenericLayer.html#a6756f1d50d6aa06a66a5bb3483bdacfd" title="Test if this layer supported the named capability. ">TestCapability()</a> layer method may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8a575c6bc193aee66e5c8d91eb170bde" title="Delete feature from layer. ">OGR_L_DeleteFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nFID</td><td>the feature id to be deleted from the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#ab7f892e23860b43aebb544e29845359d">OGRLayer</a>.</p>

</div>
</div>
<a id="a7958d03d3b963bce513902e7a94a1dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7958d03d3b963bce513902e7a94a1dd0">&#9670;&nbsp;</a></span>DeleteField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::DeleteField </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an existing field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2" title="Delete an existing field on a layer. ">OGR_L_DeleteField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iField</td><td>index of the field to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a">OGRLayer</a>.</p>

</div>
</div>
<a id="a3cf969adb8b5e2358846844a58b890fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf969adb8b5e2358846844a58b890fd">&#9670;&nbsp;</a></span>FindFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GNMGenericLayer::FindFieldIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bExactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the index of field in the layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn't exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5" title="Find the index of field in a layer. ">OGR_L_FindFieldIndex()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>field index, or -1 if the field doesn't exist </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c">OGRLayer</a>.</p>

</div>
</div>
<a id="a246b6f98cb4e51ea10514945ec505369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246b6f98cb4e51ea10514945ec505369">&#9670;&nbsp;</a></span>GetExtent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classGNMGenericLayer.html#a246b6f98cb4e51ea10514945ec505369" title="Fetch the extent of this layer. ">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer. ">OGR_L_GetExtent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a753d30a98f1155306f482438af78e6db">OGRLayer</a>.</p>

</div>
</div>
<a id="aa35416294aac0b338d5a2d881ff1fdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35416294aac0b338d5a2d881ff1fdee">&#9670;&nbsp;</a></span>GetExtent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classGNMGenericLayer.html#a246b6f98cb4e51ea10514945ec505369" title="Fetch the extent of this layer. ">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>Note to driver implementer: if you implement <a class="el" href="classGNMGenericLayer.html#aa35416294aac0b338d5a2d881ff1fdee" title="Fetch the extent of this layer, on the specified geometry field. ">GetExtent(int,OGREnvelope*,int)</a>, you must also implement <a class="el" href="classGNMGenericLayer.html#a246b6f98cb4e51ea10514945ec505369" title="Fetch the extent of this layer. ">GetExtent(OGREnvelope*, int)</a> to make it call GetExtent(0,OGREnvelope*,int).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376" title="Fetch the extent of this layer, on the specified geometry field. ">OGR_L_GetExtentEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>the index of the geometry field on which to compute the extent. </td></tr>
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a56f350bebef37e0e98bc739ef45a3116">OGRLayer</a>.</p>

</div>
</div>
<a id="a3f73cdc43100a0443da3e5549a152490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f73cdc43100a0443da3e5549a152490">&#9670;&nbsp;</a></span>GetFeatureCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> GNMGenericLayer::GetFeatureCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em> = <code>TRUE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a08524b6961e52e1561308d2b0c598fb2" title="Fetch the feature count in this layer. ">OGR_L_GetFeatureCount()</a>.</p>
<p>Note: since GDAL 2.0, this method returns a GIntBig (previously a int)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the count should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>feature count, -1 if count not known. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a2d0e1a43fd1a0a6d55d766384da7b6a5">OGRLayer</a>.</p>

</div>
</div>
<a id="a1153cc46ed17cb4ac1398d6ac6b0cc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153cc46ed17cb4ac1398d6ac6b0cc5d">&#9670;&nbsp;</a></span>GetFIDColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * GNMGenericLayer::GetFIDColumn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the FID column, or "" if not supported. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5" title="This method returns the name of the underlying database column being used as the FID column...">OGR_L_GetFIDColumn()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>fid column name. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61">OGRLayer</a>.</p>

</div>
</div>
<a id="aab97b4895cc5831b0e927d70e8f44961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab97b4895cc5831b0e927d70e8f44961">&#9670;&nbsp;</a></span>GetGeometryColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * GNMGenericLayer::GetGeometryColumn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the geometry column, or "" if not supported. </p>
<p>For layers with multiple geometry fields, this method only returns the name of the first geometry column. For other columns, use <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(i)-&gt;GetNameRef().</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f" title="This method returns the name of the underlying database column being used as the geometry column...">OGR_L_GetGeometryColumn()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>geometry column name. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724">OGRLayer</a>.</p>

</div>
</div>
<a id="a831c4f8baebf8167196106cb8de71e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831c4f8baebf8167196106cb8de71e26">&#9670;&nbsp;</a></span>GetGeomType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> GNMGenericLayer::GetGeomType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the layer geometry type. </p>
<p>This returns the same result as <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#acc3e3904d856b9c8b5b26204c68e916a" title="Fetch the geometry base type. ">OGRFeatureDefn::GetGeomType()</a>, but for a few drivers, calling <a class="el" href="classGNMGenericLayer.html#a831c4f8baebf8167196106cb8de71e26" title="Return the layer geometry type. ">GetGeomType()</a> directly can avoid lengthy layer definition initialization.</p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(i)-&gt;GetType(). For layers without any geometry field, this method returns wkbNone.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type. ">OGR_L_GetGeomType()</a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#acc3e3904d856b9c8b5b26204c68e916a" title="Fetch the geometry base type. ">OGRFeatureDefn::GetGeomType()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604">OGRLayer</a>.</p>

</div>
</div>
<a id="a1a51b83925df6eee668a3417ac9105c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a51b83925df6eee668a3417ac9105c8">&#9670;&nbsp;</a></span>GetLayerDefn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> * GNMGenericLayer::GetLayerDefn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the schema information for this layer. </p>
<p>The returned <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d" title="Fetch the schema information for this layer. ">OGR_L_GetLayerDefn()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>feature definition. </dd></dl>

<p>Implements <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">OGRLayer</a>.</p>

</div>
</div>
<a id="a14fea999cd24d7eb5b11657c82d78b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fea999cd24d7eb5b11657c82d78b8d">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * GNMGenericLayer::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the layer name. </p>
<p>This returns the same content as <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#ab8fa2428efb085a0b5dd78342b535aeb" title="Get name of this OGRFeatureDefn. ">OGRFeatureDefn::GetName()</a>, but for a few drivers, calling <a class="el" href="classGNMGenericLayer.html#a14fea999cd24d7eb5b11657c82d78b8d" title="Return the layer name. ">GetName()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c" title="Return the layer name. ">OGR_L_GetName()</a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#ab8fa2428efb085a0b5dd78342b535aeb" title="Get name of this OGRFeatureDefn. ">OGRFeatureDefn::GetName()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the layer name (must not been freed) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e">OGRLayer</a>.</p>

</div>
</div>
<a id="a9103cc8308203034828993fc1e0b23db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9103cc8308203034828993fc1e0b23db">&#9670;&nbsp;</a></span>GetNextFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeature.html">OGRFeature</a> * GNMGenericLayer::GetNextFeature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsibility of the caller to delete with <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature. ">OGRFeature::DestroyFeature()</a>. It is critical that all features associated with an <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> (more specifically an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with <a class="el" href="classGNMGenericLayer.html#a605821b486c96a1691ba3701f9946299" title="Set a new spatial filter. ">SetSpatialFilter()</a>) will be returned.</p>
<p>This method implements sequential access to the features of a layer. The <a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2" title="Reset feature reading to start on the first feature. ">ResetReading()</a> method can be used to start at the beginning again.</p>
<p>Features returned by <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call <a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2" title="Reset feature reading to start on the first feature. ">ResetReading()</a> on layers where <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> has been called, before reading again. Structural changes in layers (field addition, deletion, ...) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to <a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2" title="Reset feature reading to start on the first feature. ">ResetReading()</a> might be needed.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4f6ef6b70fee9f8cea92cb7a0236fcdb" title="Fetch the next available feature from this layer. ">OGR_L_GetNextFeature()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a feature, or NULL if no more features are available. </dd></dl>

<p>Implements <a class="el" href="classOGRLayer.html#a466c14ed1b3cca83abda52729d590dd2">OGRLayer</a>.</p>

</div>
</div>
<a id="aae3e82b584b59d94ec34e2c4ab8beced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3e82b584b59d94ec34e2c4ab8beced">&#9670;&nbsp;</a></span>GetSpatialFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * GNMGenericLayer::GetSpatialFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a" title="This function returns the current spatial filter for this layer. ">OGR_L_GetSpatialFilter()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>spatial filter geometry. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#adc3735e444204d46f517eec251712f4d">OGRLayer</a>.</p>

</div>
</div>
<a id="a6da7edd25c416684f858cb4a81ab92b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da7edd25c416684f858cb4a81ab92b2">&#9670;&nbsp;</a></span>GetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * GNMGenericLayer::GetSpatialRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> and should not be modified or freed by the application.</p>
<p>Starting with OGR 1.11, several geometry fields can be associated to a feature definition. Each geometry field can have its own spatial reference system, which is returned by <a class="el" href="classOGRGeomFieldDefn.html#acf7ddda34f67658433de5ccaedcd91e9" title="Fetch spatial reference system of this field. ">OGRGeomFieldDefn::GetSpatialRef()</a>. <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer. ">OGRLayer::GetSpatialRef()</a> is equivalent to <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(0)-&gt;<a class="el" href="classGNMGenericLayer.html#a6da7edd25c416684f858cb4a81ab92b2" title="Fetch the spatial reference system for this layer. ">GetSpatialRef()</a></p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39" title="Fetch the spatial reference system for this layer. ">OGR_L_GetSpatialRef()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>spatial reference, or NULL if there isn't one. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab">OGRLayer</a>.</p>

</div>
</div>
<a id="a5d4c6c2d6fd1330851749eb87fc9143a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4c6c2d6fd1330851749eb87fc9143a">&#9670;&nbsp;</a></span>GetStyleTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> * GNMGenericLayer::GetStyleTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns layer style table. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aceae9ba8158efda9d1bd016022c627ca" title="Get style table. ">OGR_L_GetStyleTable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to a style table which should not be modified or freed by the caller. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#ac65f762d5b3c6fc4ca0f0cc4aafcdcbe">OGRLayer</a>.</p>

</div>
</div>
<a id="a171a2be1c00ce80a9ba93139fd5149ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171a2be1c00ce80a9ba93139fd5149ed">&#9670;&nbsp;</a></span>ReorderFields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::ReorderFields </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer. ">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderFields([0,2,3,1,4]) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer. ">OGR_L_ReorderFields()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">panMap</td><td>an array of <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature. ">OGRFeatureDefn::GetFieldCount()</a> elements which is a permutation of [0, <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature. ">OGRFeatureDefn::GetFieldCount()</a>-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3">OGRLayer</a>.</p>

</div>
</div>
<a id="a479d90adb91ed34e34417e98caf787c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479d90adb91ed34e34417e98caf787c2">&#9670;&nbsp;</a></span>ResetReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GNMGenericLayer::ResetReading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset feature reading to start on the first feature. </p>
<p>This affects <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature. ">OGR_L_ResetReading()</a>. </p>

<p>Implements <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">OGRLayer</a>.</p>

</div>
</div>
<a id="a50dfbdab339aa69aca5aea6d454567e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dfbdab339aa69aca5aea6d454567e8">&#9670;&nbsp;</a></span>RollbackTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::RollbackTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. </p>
<p>If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5" title="For datasources which support transactions, RollbackTransaction will roll back a datasource to its st...">OGR_L_RollbackTransaction()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#ab046dbffc4fbd5bacc6ef75da0686d82">OGRLayer</a>.</p>

</div>
</div>
<a id="aa900b33c9e5272514739266f70f57383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa900b33c9e5272514739266f70f57383">&#9670;&nbsp;</a></span>SetAttributeFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::SetAttributeFilter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszQuery</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new attribute query. </p>
<p>This method sets the attribute query string to be used when fetching features via the <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> method. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance "population &gt; 1000000 and population &lt; 5000000" where population is an attribute in the layer. The query format is normally a restricted form of SQL WHERE clause as described in the "WHERE" section of the <a href="ogr_sql.html">OGR SQL</a> tutorial. In some cases (RDBMS backed drivers) the native capabilities of the database may be used to interpret the WHERE clause in which case the capabilities will be broader than those of OGR SQL.</p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2" title="Reset feature reading to start on the first feature. ">ResetReading()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09" title="Set a new attribute query. ">OGR_L_SetAttributeFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszQuery</td><td>query in restricted SQL WHERE format, or NULL to clear the current query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde">OGRLayer</a>.</p>

</div>
</div>
<a id="a1a499269c587a39637a2f76320e75fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a499269c587a39637a2f76320e75fec">&#9670;&nbsp;</a></span>SetIgnoredFields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::SetIgnoredFields </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>papszFields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to <a class="el" href="classOGRLayer.html#a7b39284997972eb198ed754594d52ec2" title="Fetch a feature by its identifier. ">GetFeature()</a> / <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: "OGR_GEOMETRY" to ignore geometry and "OGR_STYLE" to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154" title="Set which fields can be omitted when retrieving features from the layer. ">OGR_L_SetIgnoredFields()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszFields</td><td>an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a5e0c3427f64249d1c35cefb487546b10">OGRLayer</a>.</p>

</div>
</div>
<a id="a67cd391cf8015675b45c7553cd02906e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cd391cf8015675b45c7553cd02906e">&#9670;&nbsp;</a></span>SetNextByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::SetNextByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is <a class="el" href="classGNMGenericLayer.html#a67cd391cf8015675b45c7553cd02906e" title="Move read cursor to the nIndex&#39;th feature in the current resultset. ">SetNextByIndex()</a> efficiently implemented. In all other cases the default implementation which calls <a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2" title="Reset feature reading to start on the first feature. ">ResetReading()</a> and then calls <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> nIndex times is used. To determine if fast seeking is available on the current layer use the <a class="el" href="classGNMGenericLayer.html#a6756f1d50d6aa06a66a5bb3483bdacfd" title="Test if this layer supported the named capability. ">TestCapability()</a> method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8b4427a82ea3de3bed7acff19b6e8e33" title="Move read cursor to the nIndex&#39;th feature in the current resultset. ">OGR_L_SetNextByIndex()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nIndex</td><td>the index indicating how many steps into the result set to seek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#ac0b0869ff6fcadda35cbac1f3edf8eae">OGRLayer</a>.</p>

</div>
</div>
<a id="a605821b486c96a1691ba3701f9946299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605821b486c96a1691ba3701f9946299">&#9670;&nbsp;</a></span>SetSpatialFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GNMGenericLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features whose envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>Starting with GDAL 2.3, features with null or empty geometries will never be considered as matching a spatial filter.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer. ">OGRLayer::GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c" title="Set a new spatial filter. ">OGR_L_SetSpatialFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFilter</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">OGRLayer</a>.</p>

</div>
</div>
<a id="a7dd9f62ec3a5e334a6a8ae5b32f2cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd9f62ec3a5e334a6a8ae5b32f2cbda">&#9670;&nbsp;</a></span>SetSpatialFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GNMGenericLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classGNMGenericLayer.html#a6da7edd25c416684f858cb4a81ab92b2" title="Fetch the spatial reference system for this layer. ">GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>Note to driver implementer: if you implement <a class="el" href="classGNMGenericLayer.html#a7dd9f62ec3a5e334a6a8ae5b32f2cbda" title="Set a new spatial filter. ">SetSpatialFilter(int,OGRGeometry*)</a>, you must also implement <a class="el" href="classGNMGenericLayer.html#a605821b486c96a1691ba3701f9946299" title="Set a new spatial filter. ">SetSpatialFilter(OGRGeometry*)</a> to make it call SetSpatialFilter(0,OGRGeometry*).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823" title="Set a new spatial filter. ">OGR_L_SetSpatialFilterEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">poFilter</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3">OGRLayer</a>.</p>

</div>
</div>
<a id="a81c7e3b89822cbd078b5fb3118471d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c7e3b89822cbd078b5fb3118471d98">&#9670;&nbsp;</a></span>SetSpatialFilterRect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GNMGenericLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer. ">OGRLayer::GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter. ">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13" title="Set a new rectangular spatial filter. ">OGR_L_SetSpatialFilterRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460">OGRLayer</a>.</p>

</div>
</div>
<a id="abde8cd58988f17b2f7d6c6e997f22293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde8cd58988f17b2f7d6c6e997f22293">&#9670;&nbsp;</a></span>SetSpatialFilterRect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GNMGenericLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8" title="Fetch the schema information for this layer. ">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classGNMGenericLayer.html#a6da7edd25c416684f858cb4a81ab92b2" title="Fetch the spatial reference system for this layer. ">GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter. ">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5" title="Set a new rectangular spatial filter. ">OGR_L_SetSpatialFilterRectEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a5cd4ceb8f4ec20594be63280c8e4498a">OGRLayer</a>.</p>

</div>
</div>
<a id="a22b8c67af40323b91e191f05a0086eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b8c67af40323b91e191f05a0086eb2">&#9670;&nbsp;</a></span>SetStyleTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GNMGenericLayer::SetStyleTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&#160;</td>
          <td class="paramname"><em>poStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set layer style table. </p>
<p>This method operate exactly as <a class="el" href="classOGRLayer.html#a2687d4312c044bb3a20bd13974ba8905" title="Set layer style table. ">OGRLayer::SetStyleTableDirectly()</a> except that it does not assume ownership of the passed table.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9c5965608098528549e585895cb62e92" title="Set style table. ">OGR_L_SetStyleTable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poStyleTable</td><td>pointer to style table to set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a33fa0802c0686fb0e6ca6337e11cd7d5">OGRLayer</a>.</p>

</div>
</div>
<a id="ad3bd0cdf55e1249cdbe9b222e6100209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bd0cdf55e1249cdbe9b222e6100209">&#9670;&nbsp;</a></span>SetStyleTableDirectly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GNMGenericLayer::SetStyleTableDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&#160;</td>
          <td class="paramname"><em>poStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set layer style table. </p>
<p>This method operate exactly as <a class="el" href="classOGRLayer.html#a33fa0802c0686fb0e6ca6337e11cd7d5" title="Set layer style table. ">OGRLayer::SetStyleTable()</a> except that it assumes ownership of the passed table.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab6b700a54fb41ade2b3b090b2e0ef4be" title="Set style table (and take ownership) ">OGR_L_SetStyleTableDirectly()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poStyleTable</td><td>pointer to style table to set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#a2687d4312c044bb3a20bd13974ba8905">OGRLayer</a>.</p>

</div>
</div>
<a id="aa51170039be88e1cafa99c9483408127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51170039be88e1cafa99c9483408127">&#9670;&nbsp;</a></span>StartTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::StartTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For datasources which support transactions, StartTransaction creates a transaction. </p>
<p>If starting the transaction fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>Note: as of GDAL 2.0, use of this API is discouraged when the dataset offers dataset level transaction with <a class="el" href="classGDALDataset.html#a3e4161f148fac57dac5cfe4900421348" title="For datasources which support transactions, StartTransaction creates a `transaction. ">GDALDataset::StartTransaction()</a>. The reason is that most drivers can only offer transactions at dataset level, and not layer level. Very few drivers really support transactions at layer scope.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ab709fc5cdd7a204fe0220e898a981d85" title="For datasources which support transactions, StartTransaction creates a transaction. ">OGR_L_StartTransaction()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#ac3cdf24212ec4719ade6065dcb63bb37">OGRLayer</a>.</p>

</div>
</div>
<a id="a2c5b4e4b8e3d7a132d6a3d40c2a2dea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5b4e4b8e3d7a132d6a3d40c2a2dea7">&#9670;&nbsp;</a></span>SyncToDisk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> GNMGenericLayer::SyncToDisk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with OGRDataSource::DestroyDataSource() that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a" title="Flush pending changes to disk. ">OGR_L_SyncToDisk()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayer.html#aebb07284c734e485d8611b7c8599254f">OGRLayer</a>.</p>

</div>
</div>
<a id="a6756f1d50d6aa06a66a5bb3483bdacfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6756f1d50d6aa06a66a5bb3483bdacfd">&#9670;&nbsp;</a></span>TestCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GNMGenericLayer::TestCapability </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<ul>
<li>
<p class="startli"><b>OLCRandomRead</b> / "RandomRead": TRUE if the <a class="el" href="classOGRLayer.html#a7b39284997972eb198ed754594d52ec2" title="Fetch a feature by its identifier. ">GetFeature()</a> method is implemented in an optimized way for this layer, as opposed to the default implementation using <a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2" title="Reset feature reading to start on the first feature. ">ResetReading()</a> and <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db" title="Fetch the next available feature from this layer. ">GetNextFeature()</a> to find the requested feature id.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCSequentialWrite</b> / "SequentialWrite": TRUE if the <a class="el" href="classOGRLayer.html#a5d6db0be3b8876142d54e8bfd5dc8324" title="Create and write a new feature within a layer. ">CreateFeature()</a> method works for this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCRandomWrite</b> / "RandomWrite": TRUE if the <a class="el" href="classOGRLayer.html#a6e7dfe0f900ac7fb0f457e7a49b3a5e3" title="Rewrite an existing feature. ">SetFeature()</a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods. ">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSpatialFilter</b> / "FastSpatialFilter": TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes. ">OGRFeature</a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastFeatureCount</b> / "FastFeatureCount": TRUE if this layer can return a feature count (via <a class="el" href="classGNMGenericLayer.html#a3f73cdc43100a0443da3e5549a152490" title="Fetch the feature count in this layer. ">GetFeatureCount()</a>) efficiently. i.e. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastGetExtent</b> / "FastGetExtent": TRUE if this layer can return its data extent (via <a class="el" href="classGNMGenericLayer.html#a246b6f98cb4e51ea10514945ec505369" title="Fetch the extent of this layer. ">GetExtent()</a>) efficiently, i.e. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSetNextByIndex</b> / "FastSetNextByIndex": TRUE if this layer can perform the <a class="el" href="classGNMGenericLayer.html#a67cd391cf8015675b45c7553cd02906e" title="Move read cursor to the nIndex&#39;th feature in the current resultset. ">SetNextByIndex()</a> call efficiently, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateField</b> / "CreateField": TRUE if this layer can create new fields on the current layer using <a class="el" href="classGNMGenericLayer.html#a212e4e971abae3336511e6b258d099aa" title="Create a new field on a layer. ">CreateField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateGeomField</b> / "CreateGeomField": (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using <a class="el" href="classGNMGenericLayer.html#ae2dfb15c43df4f62e721fcb77f22ae5b" title="Create a new geometry field on a layer. ">CreateGeomField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteField</b> / "DeleteField": TRUE if this layer can delete existing fields on the current layer using <a class="el" href="classGNMGenericLayer.html#a7958d03d3b963bce513902e7a94a1dd0" title="Delete an existing field on a layer. ">DeleteField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCReorderFields</b> / "ReorderFields": TRUE if this layer can reorder existing fields on the current layer using <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8" title="Reorder an existing field on a layer. ">ReorderField()</a> or <a class="el" href="classGNMGenericLayer.html#a171a2be1c00ce80a9ba93139fd5149ed" title="Reorder all the fields of a layer. ">ReorderFields()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterFieldDefn</b> / "AlterFieldDefn": TRUE if this layer can alter the definition of an existing field on the current layer using <a class="el" href="classGNMGenericLayer.html#a69f80c8342c6ad3b6d16ad33d8b2153c" title="Alter the definition of an existing field on a layer. ">AlterFieldDefn()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteFeature</b> / "DeleteFeature": TRUE if the <a class="el" href="classGNMGenericLayer.html#ade0d4b235a725ad16faac2e0b659e33b" title="Delete feature from layer. ">DeleteFeature()</a> method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCStringsAsUTF8</b> / "StringsAsUTF8": TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCTransactions</b> / "Transactions": TRUE if the <a class="el" href="classGNMGenericLayer.html#aa51170039be88e1cafa99c9483408127" title="For datasources which support transactions, StartTransaction creates a transaction. ">StartTransaction()</a>, <a class="el" href="classGNMGenericLayer.html#a92933b3aeef549807394bf578416aad2" title="For datasources which support transactions, CommitTransaction commits a transaction. ">CommitTransaction()</a> and <a class="el" href="classGNMGenericLayer.html#a50dfbdab339aa69aca5aea6d454567e8" title="For datasources which support transactions, RollbackTransaction will roll back a datasource to its st...">RollbackTransaction()</a> methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCIgnoreFields</b> / "IgnoreFields": TRUE if fields, geometry and style will be omitted when fetching features as set by <a class="el" href="classGNMGenericLayer.html#a1a499269c587a39637a2f76320e75fec" title="Set which fields can be omitted when retrieving features from the layer. ">SetIgnoredFields()</a> method.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCurveGeometries</b> / "CurveGeometries": TRUE if this layer supports writing curve geometries or may return such geometries. (GDAL 2.0).</p>
<p></p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd" title="Test if this layer supported the named capability. ">OGR_L_TestCapability()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCap</td><td>the name of the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</dd></dl>

<p>Implements <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286">OGRLayer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="gnm_8h_source.html">gnm.h</a></li>
<li>gnmlayer.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
