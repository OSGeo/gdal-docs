<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: cpl_virtualmem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_651562d8bf6cfd3e81eff5b570d7df50.html">port</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cpl_virtualmem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Virtual memory management.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br />
</div>
<p><a href="cpl__virtualmem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aac693188a82d797c5a651f275fddab82"><td class="memItemLeft" align="right" valign="top">typedef struct CPLVirtualMem&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a></td></tr>
<tr class="memdesc:aac693188a82d797c5a651f275fddab82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type that represents a virtual memory mapping.  <a href="#aac693188a82d797c5a651f275fddab82">More...</a><br /></td></tr>
<tr class="separator:aac693188a82d797c5a651f275fddab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaa49a430d8b44b95caeffd3fa24b28"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a2eaa49a430d8b44b95caeffd3fa24b28">CPLVirtualMemCachePageCbk</a>) (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData)</td></tr>
<tr class="memdesc:a2eaa49a430d8b44b95caeffd3fa24b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback triggered when a still unmapped page of virtual memory is accessed.  <a href="#a2eaa49a430d8b44b95caeffd3fa24b28">More...</a><br /></td></tr>
<tr class="separator:a2eaa49a430d8b44b95caeffd3fa24b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ad0e765022546be709d8b80bc99632"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a71ad0e765022546be709d8b80bc99632">CPLVirtualMemUnCachePageCbk</a>) (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, const void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData)</td></tr>
<tr class="memdesc:a71ad0e765022546be709d8b80bc99632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback triggered when a dirty mapped page is going to be freed.  <a href="#a71ad0e765022546be709d8b80bc99632">More...</a><br /></td></tr>
<tr class="separator:a71ad0e765022546be709d8b80bc99632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fac15ae099b3328095f663bb69be0a0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a7fac15ae099b3328095f663bb69be0a0">CPLVirtualMemFreeUserData</a>) (void *pUserData)</td></tr>
<tr class="memdesc:a7fac15ae099b3328095f663bb69be0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback triggered when a virtual memory mapping is destroyed.  <a href="#a7fac15ae099b3328095f663bb69be0a0">More...</a><br /></td></tr>
<tr class="separator:a7fac15ae099b3328095f663bb69be0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aeba7fc305d946740f9e88513220c73a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> { <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79">VIRTUALMEM_READONLY</a>, 
<a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97">VIRTUALMEM_READONLY_ENFORCED</a>, 
<a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169">VIRTUALMEM_READWRITE</a>
 }<tr class="memdesc:aeba7fc305d946740f9e88513220c73a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access mode of a virtual memory mapping.  <a href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aeba7fc305d946740f9e88513220c73a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af7db376bca14d8aeb40dc171b969fbad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#af7db376bca14d8aeb40dc171b969fbad">CPLGetPageSize</a> (void)</td></tr>
<tr class="memdesc:af7db376bca14d8aeb40dc171b969fbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of a page of virtual memory.  <a href="#af7db376bca14d8aeb40dc171b969fbad">More...</a><br /></td></tr>
<tr class="separator:af7db376bca14d8aeb40dc171b969fbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f4f669f48fc2755a43566524725878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878">CPLVirtualMemNew</a> (size_t nSize, size_t nCacheSize, size_t nPageSizeHint, int bSingleThreadUsage, <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> eAccessMode, <a class="el" href="cpl__virtualmem_8h.html#a2eaa49a430d8b44b95caeffd3fa24b28">CPLVirtualMemCachePageCbk</a> pfnCachePage, <a class="el" href="cpl__virtualmem_8h.html#a71ad0e765022546be709d8b80bc99632">CPLVirtualMemUnCachePageCbk</a> pfnUnCachePage, <a class="el" href="cpl__virtualmem_8h.html#a7fac15ae099b3328095f663bb69be0a0">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr class="memdesc:ae3f4f669f48fc2755a43566524725878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new virtual memory mapping.  <a href="#ae3f4f669f48fc2755a43566524725878">More...</a><br /></td></tr>
<tr class="separator:ae3f4f669f48fc2755a43566524725878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d1f6e9104464fc2052be91c2a20cd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a00d1f6e9104464fc2052be91c2a20cd2">CPLIsVirtualMemFileMapAvailable</a> (void)</td></tr>
<tr class="memdesc:a00d1f6e9104464fc2052be91c2a20cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if virtual memory mapping of a file is available.  <a href="#a00d1f6e9104464fc2052be91c2a20cd2">More...</a><br /></td></tr>
<tr class="separator:a00d1f6e9104464fc2052be91c2a20cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a1fc455ba063709c4c7acd3def44ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a51a1fc455ba063709c4c7acd3def44ea">CPLVirtualMemFileMapNew</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *fp, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength, <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> eAccessMode, <a class="el" href="cpl__virtualmem_8h.html#a7fac15ae099b3328095f663bb69be0a0">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr class="memdesc:a51a1fc455ba063709c4c7acd3def44ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new virtual memory mapping from a file.  <a href="#a51a1fc455ba063709c4c7acd3def44ea">More...</a><br /></td></tr>
<tr class="separator:a51a1fc455ba063709c4c7acd3def44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5e12022cf50ba82ab31d5d8cba2fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#abc5e12022cf50ba82ab31d5d8cba2fa7">CPLVirtualMemDerivedNew</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *pVMemBase, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nSize, <a class="el" href="cpl__virtualmem_8h.html#a7fac15ae099b3328095f663bb69be0a0">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr class="memdesc:abc5e12022cf50ba82ab31d5d8cba2fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new virtual memory mapping derived from an other virtual memory mapping.  <a href="#abc5e12022cf50ba82ab31d5d8cba2fa7">More...</a><br /></td></tr>
<tr class="separator:abc5e12022cf50ba82ab31d5d8cba2fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e397a190759c66d3ee1130a20fb279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279">CPLVirtualMemFree</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:ac7e397a190759c66d3ee1130a20fb279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a virtual memory mapping.  <a href="#ac7e397a190759c66d3ee1130a20fb279">More...</a><br /></td></tr>
<tr class="separator:ac7e397a190759c66d3ee1130a20fb279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fbbf1e7a217655fdd19231154a8cfa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa">CPLVirtualMemGetAddr</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:a36fbbf1e7a217655fdd19231154a8cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the start of a virtual memory mapping.  <a href="#a36fbbf1e7a217655fdd19231154a8cfa">More...</a><br /></td></tr>
<tr class="separator:a36fbbf1e7a217655fdd19231154a8cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e9db855ad1ee7bde1657d91209b72"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a0b3e9db855ad1ee7bde1657d91209b72">CPLVirtualMemGetSize</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:a0b3e9db855ad1ee7bde1657d91209b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the virtual memory mapping.  <a href="#a0b3e9db855ad1ee7bde1657d91209b72">More...</a><br /></td></tr>
<tr class="separator:a0b3e9db855ad1ee7bde1657d91209b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53512758f6e597b095dcd8a146d7838e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a53512758f6e597b095dcd8a146d7838e">CPLVirtualMemIsFileMapping</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:a53512758f6e597b095dcd8a146d7838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the virtual memory mapping is a direct file mapping.  <a href="#a53512758f6e597b095dcd8a146d7838e">More...</a><br /></td></tr>
<tr class="separator:a53512758f6e597b095dcd8a146d7838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8d6a1df28c479c9dbb4c1086e570f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a8c8d6a1df28c479c9dbb4c1086e570f3">CPLVirtualMemGetAccessMode</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:a8c8d6a1df28c479c9dbb4c1086e570f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the access mode of the virtual memory mapping.  <a href="#a8c8d6a1df28c479c9dbb4c1086e570f3">More...</a><br /></td></tr>
<tr class="separator:a8c8d6a1df28c479c9dbb4c1086e570f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee835258a343e77447f54b9e078cddc5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aee835258a343e77447f54b9e078cddc5">CPLVirtualMemGetPageSize</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:aee835258a343e77447f54b9e078cddc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the page size associated to a virtual memory mapping.  <a href="#aee835258a343e77447f54b9e078cddc5">More...</a><br /></td></tr>
<tr class="separator:aee835258a343e77447f54b9e078cddc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf17d57f9361d6b71341b96c188e904"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#abdf17d57f9361d6b71341b96c188e904">CPLVirtualMemIsAccessThreadSafe</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:abdf17d57f9361d6b71341b96c188e904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if this memory mapping can be accessed safely from concurrent threads.  <a href="#abdf17d57f9361d6b71341b96c188e904">More...</a><br /></td></tr>
<tr class="separator:abdf17d57f9361d6b71341b96c188e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94d9fee83792450f556ea68f3a27f31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aa94d9fee83792450f556ea68f3a27f31">CPLVirtualMemDeclareThread</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:aa94d9fee83792450f556ea68f3a27f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare that a thread will access a virtual memory mapping.  <a href="#aa94d9fee83792450f556ea68f3a27f31">More...</a><br /></td></tr>
<tr class="separator:aa94d9fee83792450f556ea68f3a27f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a2dba5c24c0c7c478202928fecf93c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a60a2dba5c24c0c7c478202928fecf93c">CPLVirtualMemUnDeclareThread</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="memdesc:a60a2dba5c24c0c7c478202928fecf93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare that a thread will stop accessing a virtual memory mapping.  <a href="#a60a2dba5c24c0c7c478202928fecf93c">More...</a><br /></td></tr>
<tr class="separator:a60a2dba5c24c0c7c478202928fecf93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f98d8a992f8bf393719c51c5551c07e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a4f98d8a992f8bf393719c51c5551c07e">CPLVirtualMemPin</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, void *pAddr, size_t nSize, int bWriteOp)</td></tr>
<tr class="memdesc:a4f98d8a992f8bf393719c51c5551c07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure that a region of virtual memory will be realized.  <a href="#a4f98d8a992f8bf393719c51c5551c07e">More...</a><br /></td></tr>
<tr class="separator:a4f98d8a992f8bf393719c51c5551c07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e690c9c5b7f636cd8c0254eba63cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a33e690c9c5b7f636cd8c0254eba63cb8">CPLVirtualMemManagerTerminate</a> (void)</td></tr>
<tr class="memdesc:a33e690c9c5b7f636cd8c0254eba63cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup any resource and handlers related to virtual memory.  <a href="#a33e690c9c5b7f636cd8c0254eba63cb8">More...</a><br /></td></tr>
<tr class="separator:a33e690c9c5b7f636cd8c0254eba63cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Virtual memory management. </p>
<p>This file provides mechanism to define virtual memory mappings, whose content is allocated transparently and filled on-the-fly. Those virtual memory mappings can be much larger than the available RAM, but only parts of the virtual memory mapping, in the limit of the allowed the cache size, will actually be physically allocated.</p>
<p>This exploits low-level mechanisms of the operating system (virtual memory allocation, page protection and handler of virtual memory exceptions).</p>
<p>It is also possible to create a virtual memory mapping from a file or part of a file.</p>
<p>The current implementation is Linux only. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aac693188a82d797c5a651f275fddab82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac693188a82d797c5a651f275fddab82">&#9670;&nbsp;</a></span>CPLVirtualMem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct CPLVirtualMem CPLVirtualMem</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type that represents a virtual memory mapping. </p>

</div>
</div>
<a id="a2eaa49a430d8b44b95caeffd3fa24b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaa49a430d8b44b95caeffd3fa24b28">&#9670;&nbsp;</a></span>CPLVirtualMemCachePageCbk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CPLVirtualMemCachePageCbk) (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback triggered when a still unmapped page of virtual memory is accessed. </p>
<p>The callback has the responsibility of filling the page with relevant values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>virtual memory handle. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset of the page in the memory mapping. </td></tr>
    <tr><td class="paramname">pPageToFill</td><td>address of the page to fill. Note that the address might be a temporary location, and not at <a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa" title="Return the pointer to the start of a virtual memory mapping. ">CPLVirtualMemGetAddr()</a> + nOffset. </td></tr>
    <tr><td class="paramname">nToFill</td><td>number of bytes of the page. </td></tr>
    <tr><td class="paramname">pUserData</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fac15ae099b3328095f663bb69be0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fac15ae099b3328095f663bb69be0a0">&#9670;&nbsp;</a></span>CPLVirtualMemFreeUserData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CPLVirtualMemFreeUserData) (void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback triggered when a virtual memory mapping is destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUserData</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71ad0e765022546be709d8b80bc99632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ad0e765022546be709d8b80bc99632">&#9670;&nbsp;</a></span>CPLVirtualMemUnCachePageCbk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CPLVirtualMemUnCachePageCbk) (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, const void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback triggered when a dirty mapped page is going to be freed. </p>
<p>(saturation of cache, or termination of the virtual memory mapping).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>virtual memory handle. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset of the page in the memory mapping. </td></tr>
    <tr><td class="paramname">pPageToBeEvicted</td><td>address of the page that will be flushed. Note that the address might be a temporary location, and not at <a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa" title="Return the pointer to the start of a virtual memory mapping. ">CPLVirtualMemGetAddr()</a> + nOffset. </td></tr>
    <tr><td class="paramname">nToBeEvicted</td><td>number of bytes of the page. </td></tr>
    <tr><td class="paramname">pUserData</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aeba7fc305d946740f9e88513220c73a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba7fc305d946740f9e88513220c73a1">&#9670;&nbsp;</a></span>CPLVirtualMemAccessMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access mode of a virtual memory mapping. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79"></a>VIRTUALMEM_READONLY&#160;</td><td class="fielddoc"><p>The mapping is meant at being read-only, but writes will not be prevented. Note that any content written will be lost. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97"></a>VIRTUALMEM_READONLY_ENFORCED&#160;</td><td class="fielddoc"><p>The mapping is meant at being read-only, and this will be enforced through the operating system page protection mechanism. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169"></a>VIRTUALMEM_READWRITE&#160;</td><td class="fielddoc"><p>The mapping is meant at being read-write, and modified pages can be saved thanks to the pfnUnCachePage callback </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af7db376bca14d8aeb40dc171b969fbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7db376bca14d8aeb40dc171b969fbad">&#9670;&nbsp;</a></span>CPLGetPageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLGetPageSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of a page of virtual memory. </p>
<dl class="section return"><dt>Returns</dt><dd>the page size.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a00d1f6e9104464fc2052be91c2a20cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d1f6e9104464fc2052be91c2a20cd2">&#9670;&nbsp;</a></span>CPLIsVirtualMemFileMapAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLIsVirtualMemFileMapAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if virtual memory mapping of a file is available. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if virtual memory mapping of a file is available. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="aa94d9fee83792450f556ea68f3a27f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94d9fee83792450f556ea68f3a27f31">&#9670;&nbsp;</a></span>CPLVirtualMemDeclareThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemDeclareThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare that a thread will access a virtual memory mapping. </p>
<p>This function must be called by a thread that wants to access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="el" href="cpl__virtualmem_8h.html#a60a2dba5c24c0c7c478202928fecf93c" title="Declare that a thread will stop accessing a virtual memory mapping. ">CPLVirtualMemUnDeclareThread()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="abc5e12022cf50ba82ab31d5d8cba2fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5e12022cf50ba82ab31d5d8cba2fa7">&#9670;&nbsp;</a></span>CPLVirtualMemDerivedNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>* CPLVirtualMemDerivedNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>pVMemBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#a7fac15ae099b3328095f663bb69be0a0">CPLVirtualMemFreeUserData</a>&#160;</td>
          <td class="paramname"><em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCbkUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new virtual memory mapping derived from an other virtual memory mapping. </p>
<p>This may be useful in case of creating mapping for pixel interleaved data.</p>
<p>The new mapping takes a reference on the base mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVMemBase</td><td>Base virtual memory mapping </td></tr>
    <tr><td class="paramname">nOffset</td><td>Offset in the base virtual memory mapping from which to start the new mapping. </td></tr>
    <tr><td class="paramname">nSize</td><td>Size of the base virtual memory mapping to expose in the the new mapping. </td></tr>
    <tr><td class="paramname">pfnFreeUserData</td><td>callback that is called when the object is destroyed. </td></tr>
    <tr><td class="paramname">pCbkUserData</td><td>user data passed to pfnFreeUserData. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping. ">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a51a1fc455ba063709c4c7acd3def44ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a1fc455ba063709c4c7acd3def44ea">&#9670;&nbsp;</a></span>CPLVirtualMemFileMapNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>* CPLVirtualMemFileMapNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&#160;</td>
          <td class="paramname"><em>eAccessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#a7fac15ae099b3328095f663bb69be0a0">CPLVirtualMemFreeUserData</a>&#160;</td>
          <td class="paramname"><em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCbkUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new virtual memory mapping from a file. </p>
<p>The file must be a "real" file recognized by the operating system, and not a VSI extended virtual file.</p>
<p>In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written in the file.</p>
<p>On Linux AMD64 platforms, the maximum value for nLength is 128 TB. On Linux x86 platforms, the maximum value for nLength is 2 GB.</p>
<p>Supported on Linux only in GDAL &lt;= 2.0, and all POSIX systems supporting mmap() in GDAL &gt;= 2.1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>Virtual file handle. </td></tr>
    <tr><td class="paramname">nOffset</td><td>Offset in the file to start the mapping from. </td></tr>
    <tr><td class="paramname">nLength</td><td>Length of the portion of the file to map into memory. </td></tr>
    <tr><td class="paramname">eAccessMode</td><td>Permission to use for the virtual memory mapping. This must be consistent with how the file has been opened. </td></tr>
    <tr><td class="paramname">pfnFreeUserData</td><td>callback that is called when the object is destroyed. </td></tr>
    <tr><td class="paramname">pCbkUserData</td><td>user data passed to pfnFreeUserData. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping. ">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="ac7e397a190759c66d3ee1130a20fb279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e397a190759c66d3ee1130a20fb279">&#9670;&nbsp;</a></span>CPLVirtualMemFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a virtual memory mapping. </p>
<p>The pointer returned by <a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa" title="Return the pointer to the start of a virtual memory mapping. ">CPLVirtualMemGetAddr()</a> will no longer be valid. If the virtual memory mapping was created with read/write permissions and that they are dirty (i.e. modified) pages, they will be flushed through the pfnUnCachePage callback before being freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a8c8d6a1df28c479c9dbb4c1086e570f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8d6a1df28c479c9dbb4c1086e570f3">&#9670;&nbsp;</a></span>CPLVirtualMemGetAccessMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> CPLVirtualMemGetAccessMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the access mode of the virtual memory mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the access mode of the virtual memory mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a36fbbf1e7a217655fdd19231154a8cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fbbf1e7a217655fdd19231154a8cfa">&#9670;&nbsp;</a></span>CPLVirtualMemGetAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLVirtualMemGetAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the pointer to the start of a virtual memory mapping. </p>
<p>The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer returned by this function will be valid, until <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping. ">CPLVirtualMemFree()</a> is called.</p>
<p>Note that if a range of bytes used as an argument of a system call (such as read() or write()) contains pages that have not been "realized", the system call will fail with EFAULT. <a class="el" href="cpl__virtualmem_8h.html#a4f98d8a992f8bf393719c51c5551c07e" title="Make sure that a region of virtual memory will be realized. ">CPLVirtualMemPin()</a> can be used to work around this issue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the start of a virtual memory mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="aee835258a343e77447f54b9e078cddc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee835258a343e77447f54b9e078cddc5">&#9670;&nbsp;</a></span>CPLVirtualMemGetPageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLVirtualMemGetPageSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the page size associated to a virtual memory mapping. </p>
<p>The value returned will be at least <a class="el" href="cpl__virtualmem_8h.html#af7db376bca14d8aeb40dc171b969fbad" title="Return the size of a page of virtual memory. ">CPLGetPageSize()</a>, but potentially larger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the page size</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a0b3e9db855ad1ee7bde1657d91209b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e9db855ad1ee7bde1657d91209b72">&#9670;&nbsp;</a></span>CPLVirtualMemGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLVirtualMemGetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the virtual memory mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the virtual memory mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="abdf17d57f9361d6b71341b96c188e904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf17d57f9361d6b71341b96c188e904">&#9670;&nbsp;</a></span>CPLVirtualMemIsAccessThreadSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLVirtualMemIsAccessThreadSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if this memory mapping can be accessed safely from concurrent threads. </p>
<p>The situation that can cause problems is when several threads try to access a page of the mapping that is not yet mapped.</p>
<p>The return value of this function depends on whether bSingleThreadUsage has been set of not in <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a> and/or the implementation.</p>
<p>On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this memory mapping can be accessed safely from concurrent threads.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a53512758f6e597b095dcd8a146d7838e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53512758f6e597b095dcd8a146d7838e">&#9670;&nbsp;</a></span>CPLVirtualMemIsFileMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLVirtualMemIsFileMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if the virtual memory mapping is a direct file mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the virtual memory mapping is a direct file mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a33e690c9c5b7f636cd8c0254eba63cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e690c9c5b7f636cd8c0254eba63cb8">&#9670;&nbsp;</a></span>CPLVirtualMemManagerTerminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemManagerTerminate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup any resource and handlers related to virtual memory. </p>
<p>This function must be called after the last CPLVirtualMem object has been freed.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ae3f4f669f48fc2755a43566524725878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f4f669f48fc2755a43566524725878">&#9670;&nbsp;</a></span>CPLVirtualMemNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>* CPLVirtualMemNew </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nPageSizeHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bSingleThreadUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&#160;</td>
          <td class="paramname"><em>eAccessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#a2eaa49a430d8b44b95caeffd3fa24b28">CPLVirtualMemCachePageCbk</a>&#160;</td>
          <td class="paramname"><em>pfnCachePage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#a71ad0e765022546be709d8b80bc99632">CPLVirtualMemUnCachePageCbk</a>&#160;</td>
          <td class="paramname"><em>pfnUnCachePage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#a7fac15ae099b3328095f663bb69be0a0">CPLVirtualMemFreeUserData</a>&#160;</td>
          <td class="paramname"><em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCbkUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new virtual memory mapping. </p>
<p>This will reserve an area of virtual memory of size nSize, whose size might be potentially much larger than the physical memory available. Initially, no physical memory will be allocated. As soon as memory pages will be accessed, they will be allocated transparently and filled with the pfnCachePage callback. When the allowed cache size is reached, the least recently used pages will be unallocated.</p>
<p>On Linux AMD64 platforms, the maximum value for nSize is 128 TB. On Linux x86 platforms, the maximum value for nSize is 2 GB.</p>
<p>Only supported on Linux for now.</p>
<p>Note that on Linux, this function will install a SIGSEGV handler. The original handler will be restored by <a class="el" href="cpl__virtualmem_8h.html#a33e690c9c5b7f636cd8c0254eba63cb8" title="Cleanup any resource and handlers related to virtual memory. ">CPLVirtualMemManagerTerminate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>size in bytes of the virtual memory mapping. </td></tr>
    <tr><td class="paramname">nCacheSize</td><td>size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM). </td></tr>
    <tr><td class="paramname">nPageSizeHint</td><td>hint for the page size. Must be a multiple of the system page size, returned by <a class="el" href="cpl__virtualmem_8h.html#af7db376bca14d8aeb40dc171b969fbad" title="Return the size of a page of virtual memory. ">CPLGetPageSize()</a>. Minimum value is generally 4096. Might be set to 0 to let the function determine a default page size. </td></tr>
    <tr><td class="paramname">bSingleThreadUsage</td><td>set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. </td></tr>
    <tr><td class="paramname">eAccessMode</td><td>permission to use for the virtual memory mapping. </td></tr>
    <tr><td class="paramname">pfnCachePage</td><td>callback triggered when a still unmapped page of virtual memory is accessed. The callback has the responsibility of filling the page with relevant values. </td></tr>
    <tr><td class="paramname">pfnUnCachePage</td><td>callback triggered when a dirty mapped page is going to be freed (saturation of cache, or termination of the virtual memory mapping). Might be NULL. </td></tr>
    <tr><td class="paramname">pfnFreeUserData</td><td>callback that can be used to free pCbkUserData. Might be NULL </td></tr>
    <tr><td class="paramname">pCbkUserData</td><td>user data passed to pfnCachePage and pfnUnCachePage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping. ">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a4f98d8a992f8bf393719c51c5551c07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f98d8a992f8bf393719c51c5551c07e">&#9670;&nbsp;</a></span>CPLVirtualMemPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemPin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bWriteOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure that a region of virtual memory will be realized. </p>
<p>Calling this function is not required, but might be useful when debugging a process with tools like gdb or valgrind that do not naturally like segmentation fault signals.</p>
<p>It is also needed when wanting to provide part of virtual memory mapping to a system call such as read() or write(). If read() or write() is called on a memory region not yet realized, the call will fail with EFAULT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>. </td></tr>
    <tr><td class="paramname">pAddr</td><td>the memory region to pin. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of the memory region. </td></tr>
    <tr><td class="paramname">bWriteOp</td><td>set to TRUE if the memory are will be accessed in write mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a60a2dba5c24c0c7c478202928fecf93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a2dba5c24c0c7c478202928fecf93c">&#9670;&nbsp;</a></span>CPLVirtualMemUnDeclareThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemUnDeclareThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare that a thread will stop accessing a virtual memory mapping. </p>
<p>This function must be called by a thread that will no longer access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="el" href="cpl__virtualmem_8h.html#aa94d9fee83792450f556ea68f3a27f31" title="Declare that a thread will access a virtual memory mapping. ">CPLVirtualMemDeclareThread()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping. ">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
