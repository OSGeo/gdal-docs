<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: gdal_alg.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c9839ac9bd42e86e6159886378237831.html">alg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gdal_alg.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public (C callable) GDAL algorithm entry points, and definitions.  
<a href="#details">More...</a></p>

<p><a href="gdal__alg_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridInverseDistanceToAPowerOptions.html">GDALGridInverseDistanceToAPowerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse distance to a power method control options.  <a href="structGDALGridInverseDistanceToAPowerOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridInverseDistanceToAPowerNearestNeighborOptions.html">GDALGridInverseDistanceToAPowerNearestNeighborOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse distance to a power, with nearest neighbour search, control options.  <a href="structGDALGridInverseDistanceToAPowerNearestNeighborOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridMovingAverageOptions.html">GDALGridMovingAverageOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moving average method control options.  <a href="structGDALGridMovingAverageOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridNearestNeighborOptions.html">GDALGridNearestNeighborOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbor method control options.  <a href="structGDALGridNearestNeighborOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridDataMetricsOptions.html">GDALGridDataMetricsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data metrics method control options.  <a href="structGDALGridDataMetricsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridLinearOptions.html">GDALGridLinearOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear method control options.  <a href="structGDALGridLinearOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALTriFacet.html">GDALTriFacet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle fact.  <a href="structGDALTriFacet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALTriBarycentricCoefficients.html">GDALTriBarycentricCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle barycentric coefficients.  <a href="structGDALTriBarycentricCoefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALTriangulation.html">GDALTriangulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulation structure.  <a href="structGDALTriangulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaede67ca444a06f0a6fed538e05d2220"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>) (void *pTransformerArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="separator:aaede67ca444a06f0a6fed538e05d2220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc7569c65e4b14e36a2173143e6beea"><td class="memItemLeft" align="right" valign="top"><a id="aadc7569c65e4b14e36a2173143e6beea"></a>
typedef <a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aadc7569c65e4b14e36a2173143e6beea">GDALContourWriter</a>) (double dfLevel, int nPoints, double *padfX, double *padfY, void *)</td></tr>
<tr class="memdesc:aadc7569c65e4b14e36a2173143e6beea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contour writer callback type. <br /></td></tr>
<tr class="separator:aadc7569c65e4b14e36a2173143e6beea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac929ac526110faa3f666d18f7a680958"><td class="memItemLeft" align="right" valign="top"><a id="ac929ac526110faa3f666d18f7a680958"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ac929ac526110faa3f666d18f7a680958">GDALContourGeneratorH</a></td></tr>
<tr class="memdesc:ac929ac526110faa3f666d18f7a680958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contour generator opaque type. <br /></td></tr>
<tr class="separator:ac929ac526110faa3f666d18f7a680958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081f51e38cd0ac6d9e8a6e20a9a3332b"><td class="memItemLeft" align="right" valign="top"><a id="a081f51e38cd0ac6d9e8a6e20a9a3332b"></a>
typedef struct GDALGridContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a081f51e38cd0ac6d9e8a6e20a9a3332b">GDALGridContext</a></td></tr>
<tr class="memdesc:a081f51e38cd0ac6d9e8a6e20a9a3332b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid context opaque type. <br /></td></tr>
<tr class="separator:a081f51e38cd0ac6d9e8a6e20a9a3332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a49244316dfeefdbbb188f2570911717d"><td class="memItemLeft" align="right" valign="top"><a id="a49244316dfeefdbbb188f2570911717d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a49244316dfeefdbbb188f2570911717d">GDALViewshedMode</a> { <b>GVM_Diagonal</b> = 1, 
<b>GVM_Edge</b> = 2, 
<b>GVM_Max</b> = 3, 
<b>GVM_Min</b> = 4
 }<tr class="memdesc:a49244316dfeefdbbb188f2570911717d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Viewshed Modes. <br /></td></tr>
</td></tr>
<tr class="separator:a49244316dfeefdbbb188f2570911717d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ee2833f6486e61e24903fe0f4dad4a"><td class="memItemLeft" align="right" valign="top"><a id="aa5ee2833f6486e61e24903fe0f4dad4a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aa5ee2833f6486e61e24903fe0f4dad4a">GDALViewshedOutputType</a> { <b>GVOT_NORMAL</b> = 1, 
<b>GVOT_MIN_TARGET_HEIGHT_FROM_DEM</b> = 2, 
<b>GVOT_MIN_TARGET_HEIGHT_FROM_GROUND</b> = 3
 }<tr class="memdesc:aa5ee2833f6486e61e24903fe0f4dad4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Viewshed output types. <br /></td></tr>
</td></tr>
<tr class="separator:aa5ee2833f6486e61e24903fe0f4dad4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590d1a2d0bac1d34b95034c1f616de21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a> { <br />
&#160;&#160;<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a5955211b72d8b07518815d544e5fa192">GGA_InverseDistanceToAPower</a> = 1, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21aaafac5453ea6a64e9c84c5143cfbdcaf">GGA_MovingAverage</a> = 2, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a70c30cb508518172fbce051a7927eb68">GGA_NearestNeighbor</a> = 3, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a114443c69d10fafd0e4a6195cb178e75">GGA_MetricMinimum</a> = 4, 
<br />
&#160;&#160;<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a62e4fcf09890e32a287364ca165f78e2">GGA_MetricMaximum</a> = 5, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21aed976fb5778362e9c51e5859d19ac917">GGA_MetricRange</a> = 6, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21ac41203ffb292f6fadf155a5d3ff80219">GGA_MetricCount</a> = 7, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a90cfa34b606733fcbc4c7b15e36fefcf">GGA_MetricAverageDistance</a> = 8, 
<br />
&#160;&#160;<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a5c0dc83a00305d4a1beda88406aefbb6">GGA_MetricAverageDistancePts</a> = 9, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21af36d730cc83998d3dd4c6bb8128e9f5e">GGA_Linear</a> = 10, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a147a475881c01b46c1371f576310cfe2">GGA_InverseDistanceToAPowerNearestNeighbor</a> = 11
<br />
 }<tr class="memdesc:a590d1a2d0bac1d34b95034c1f616de21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gridding Algorithms.  <a href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a590d1a2d0bac1d34b95034c1f616de21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61e48f88c3b4b3cf7957c61dc7bd1ead"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a61e48f88c3b4b3cf7957c61dc7bd1ead">GDALComputeMedianCutPCT</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hRed, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hGreen, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBlue, int(*pfnIncludePixel)(int, int, void *), int nColors, <a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a> hColorTable, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a61e48f88c3b4b3cf7957c61dc7bd1ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute optimal PCT for RGB image.  <a href="#a61e48f88c3b4b3cf7957c61dc7bd1ead">More...</a><br /></td></tr>
<tr class="separator:a61e48f88c3b4b3cf7957c61dc7bd1ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284dbcc27295b7e678b1f7d4fa1506cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a284dbcc27295b7e678b1f7d4fa1506cb">GDALDitherRGB2PCT</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hRed, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hGreen, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBlue, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hTarget, <a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a> hColorTable, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a284dbcc27295b7e678b1f7d4fa1506cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">24bit to 8bit conversion with dithering.  <a href="#a284dbcc27295b7e678b1f7d4fa1506cb">More...</a><br /></td></tr>
<tr class="separator:a284dbcc27295b7e678b1f7d4fa1506cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2846ac3a350c24f07dc9ceac8f4d14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#abe2846ac3a350c24f07dc9ceac8f4d14">GDALChecksumImage</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBand, int nXOff, int nYOff, int nXSize, int nYSize)</td></tr>
<tr class="memdesc:abe2846ac3a350c24f07dc9ceac8f4d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum for image region.  <a href="#abe2846ac3a350c24f07dc9ceac8f4d14">More...</a><br /></td></tr>
<tr class="separator:abe2846ac3a350c24f07dc9ceac8f4d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851815400a579aae9de01199b416fa42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a851815400a579aae9de01199b416fa42">GDALComputeProximity</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hProximityBand, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a851815400a579aae9de01199b416fa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the proximity of all pixels in the image to a set of pixels in the source image.  <a href="#a851815400a579aae9de01199b416fa42">More...</a><br /></td></tr>
<tr class="separator:a851815400a579aae9de01199b416fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a079afef61968f224b159d48423d1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a0a079afef61968f224b159d48423d1c6">GDALFillNodata</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hTargetBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, double dfMaxSearchDist, int bDeprecatedOption, int nSmoothingIterations, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a0a079afef61968f224b159d48423d1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill selected raster regions by interpolation from the edges.  <a href="#a0a079afef61968f224b159d48423d1c6">More...</a><br /></td></tr>
<tr class="separator:a0a079afef61968f224b159d48423d1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f522a9035d3512b5d414fb4752671b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a3f522a9035d3512b5d414fb4752671b1">GDALPolygonize</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hOutLayer, int iPixValField, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a3f522a9035d3512b5d414fb4752671b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polygon coverage from raster data.  <a href="#a3f522a9035d3512b5d414fb4752671b1">More...</a><br /></td></tr>
<tr class="separator:a3f522a9035d3512b5d414fb4752671b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a789015334d677afcbef67e5a6b4a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a7a789015334d677afcbef67e5a6b4a7c">GDALFPolygonize</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hOutLayer, int iPixValField, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a7a789015334d677afcbef67e5a6b4a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create polygon coverage from raster data.  <a href="#a7a789015334d677afcbef67e5a6b4a7c">More...</a><br /></td></tr>
<tr class="separator:a7a789015334d677afcbef67e5a6b4a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33309c0a316b223bd33ae5753cc7f616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a33309c0a316b223bd33ae5753cc7f616">GDALSieveFilter</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hDstBand, int nSizeThreshold, int nConnectedness, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a33309c0a316b223bd33ae5753cc7f616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes small raster polygons.  <a href="#a33309c0a316b223bd33ae5753cc7f616">More...</a><br /></td></tr>
<tr class="separator:a33309c0a316b223bd33ae5753cc7f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7671696d085085a0bfba3c3df9ffcc0a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a">GDALCreateGenImgProjTransformer</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, const char *pszSrcWKT, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDstDS, const char *pszDstWKT, int bGCPUseOK, double dfGCPErrorThreshold, int nOrder)</td></tr>
<tr class="memdesc:a7671696d085085a0bfba3c3df9ffcc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image to image transformer.  <a href="#a7671696d085085a0bfba3c3df9ffcc0a">More...</a><br /></td></tr>
<tr class="separator:a7671696d085085a0bfba3c3df9ffcc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cd172f78dbc41d6f407d662914f2e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a94cd172f78dbc41d6f407d662914f2e3">GDALCreateGenImgProjTransformer2</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDstDS, char **papszOptions)</td></tr>
<tr class="memdesc:a94cd172f78dbc41d6f407d662914f2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image to image transformer.  <a href="#a94cd172f78dbc41d6f407d662914f2e3">More...</a><br /></td></tr>
<tr class="separator:a94cd172f78dbc41d6f407d662914f2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f5de51947234a0481088bed2d7ce53"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a05f5de51947234a0481088bed2d7ce53">GDALCreateGenImgProjTransformer3</a> (const char *pszSrcWKT, const double *padfSrcGeoTransform, const char *pszDstWKT, const double *padfDstGeoTransform)</td></tr>
<tr class="memdesc:a05f5de51947234a0481088bed2d7ce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image to image transformer.  <a href="#a05f5de51947234a0481088bed2d7ce53">More...</a><br /></td></tr>
<tr class="separator:a05f5de51947234a0481088bed2d7ce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7307bae38fe0f59679172f82492cc02d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a7307bae38fe0f59679172f82492cc02d">GDALCreateGenImgProjTransformer4</a> (<a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hSrcSRS, const double *padfSrcGeoTransform, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hDstSRS, const double *padfDstGeoTransform, const char *const *papszOptions)</td></tr>
<tr class="memdesc:a7307bae38fe0f59679172f82492cc02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image to image transformer.  <a href="#a7307bae38fe0f59679172f82492cc02d">More...</a><br /></td></tr>
<tr class="separator:a7307bae38fe0f59679172f82492cc02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e841864cf6d93596626981d26c3000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a18e841864cf6d93596626981d26c3000">GDALSetGenImgProjTransformerDstGeoTransform</a> (void *, const double *)</td></tr>
<tr class="memdesc:a18e841864cf6d93596626981d26c3000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set GenImgProj output geotransform.  <a href="#a18e841864cf6d93596626981d26c3000">More...</a><br /></td></tr>
<tr class="separator:a18e841864cf6d93596626981d26c3000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb383c4e5197e8e37ae1265cca8124d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d">GDALDestroyGenImgProjTransformer</a> (void *)</td></tr>
<tr class="memdesc:a5fb383c4e5197e8e37ae1265cca8124d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GenImgProjTransformer deallocator.  <a href="#a5fb383c4e5197e8e37ae1265cca8124d">More...</a><br /></td></tr>
<tr class="separator:a5fb383c4e5197e8e37ae1265cca8124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109c26234c2f934164e29649353532b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6">GDALGenImgProjTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="memdesc:a109c26234c2f934164e29649353532b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform general image reprojection transformation.  <a href="#a109c26234c2f934164e29649353532b6">More...</a><br /></td></tr>
<tr class="separator:a109c26234c2f934164e29649353532b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55a29540c5af804a75818eeaabfbfd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ac55a29540c5af804a75818eeaabfbfd4">GDALSetTransformerDstGeoTransform</a> (void *, const double *)</td></tr>
<tr class="memdesc:ac55a29540c5af804a75818eeaabfbfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ApproxTransformer or GenImgProj output geotransform.  <a href="#ac55a29540c5af804a75818eeaabfbfd4">More...</a><br /></td></tr>
<tr class="separator:ac55a29540c5af804a75818eeaabfbfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a032e9bf590c95781321115df855cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a8a032e9bf590c95781321115df855cd2">GDALGetTransformerDstGeoTransform</a> (void *, double *)</td></tr>
<tr class="memdesc:a8a032e9bf590c95781321115df855cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ApproxTransformer or GenImgProj output geotransform.  <a href="#a8a032e9bf590c95781321115df855cd2">More...</a><br /></td></tr>
<tr class="separator:a8a032e9bf590c95781321115df855cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce63548b884096e55d1685d4bbd7e63"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#adce63548b884096e55d1685d4bbd7e63">GDALCreateReprojectionTransformer</a> (const char *pszSrcWKT, const char *pszDstWKT)</td></tr>
<tr class="memdesc:adce63548b884096e55d1685d4bbd7e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create reprojection transformer.  <a href="#adce63548b884096e55d1685d4bbd7e63">More...</a><br /></td></tr>
<tr class="separator:adce63548b884096e55d1685d4bbd7e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac026c145117134bc754bf25c84b207e1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ac026c145117134bc754bf25c84b207e1">GDALCreateReprojectionTransformerEx</a> (<a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hSrcSRS, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hDstSRS, const char *const *papszOptions)</td></tr>
<tr class="memdesc:ac026c145117134bc754bf25c84b207e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create reprojection transformer.  <a href="#ac026c145117134bc754bf25c84b207e1">More...</a><br /></td></tr>
<tr class="separator:ac026c145117134bc754bf25c84b207e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cffb245df6fba275423f1333d89f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ae6cffb245df6fba275423f1333d89f08">GDALDestroyReprojectionTransformer</a> (void *)</td></tr>
<tr class="memdesc:ae6cffb245df6fba275423f1333d89f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy reprojection transformation.  <a href="#ae6cffb245df6fba275423f1333d89f08">More...</a><br /></td></tr>
<tr class="separator:ae6cffb245df6fba275423f1333d89f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00f74e03c57842b359130ca73857521"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521">GDALReprojectionTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="memdesc:af00f74e03c57842b359130ca73857521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform reprojection transformation.  <a href="#af00f74e03c57842b359130ca73857521">More...</a><br /></td></tr>
<tr class="separator:af00f74e03c57842b359130ca73857521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57c80f7bf6752fac1dff8c2a21a15a3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3">GDALCreateGCPTransformer</a> (int nGCPCount, const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *pasGCPList, int nReqOrder, int bReversed)</td></tr>
<tr class="memdesc:ac57c80f7bf6752fac1dff8c2a21a15a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create GCP based polynomial transformer.  <a href="#ac57c80f7bf6752fac1dff8c2a21a15a3">More...</a><br /></td></tr>
<tr class="separator:ac57c80f7bf6752fac1dff8c2a21a15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac936c02335b159a70d940b725a0d3160"><td class="memItemLeft" align="right" valign="top"><a id="ac936c02335b159a70d940b725a0d3160"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ac936c02335b159a70d940b725a0d3160">GDALCreateGCPRefineTransformer</a> (int nGCPCount, const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *pasGCPList, int nReqOrder, int bReversed, double tolerance, int minimumGcps)</td></tr>
<tr class="memdesc:ac936c02335b159a70d940b725a0d3160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create GCP based polynomial transformer, with a tolerance threshold to discard GCPs that transform badly. <br /></td></tr>
<tr class="separator:ac936c02335b159a70d940b725a0d3160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1acbe5387ac769f7fee1de93b81011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a4b1acbe5387ac769f7fee1de93b81011">GDALDestroyGCPTransformer</a> (void *pTransformArg)</td></tr>
<tr class="memdesc:a4b1acbe5387ac769f7fee1de93b81011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy GCP transformer.  <a href="#a4b1acbe5387ac769f7fee1de93b81011">More...</a><br /></td></tr>
<tr class="separator:a4b1acbe5387ac769f7fee1de93b81011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acdfd7db1541c1df5e29a031994d61b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b">GDALGCPTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="memdesc:a9acdfd7db1541c1df5e29a031994d61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms point based on GCP derived polynomial model.  <a href="#a9acdfd7db1541c1df5e29a031994d61b">More...</a><br /></td></tr>
<tr class="separator:a9acdfd7db1541c1df5e29a031994d61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245802b88a8126c138d24febe6c9822a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a">GDALCreateTPSTransformer</a> (int nGCPCount, const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *pasGCPList, int bReversed)</td></tr>
<tr class="memdesc:a245802b88a8126c138d24febe6c9822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Thin Plate Spline transformer from GCPs.  <a href="#a245802b88a8126c138d24febe6c9822a">More...</a><br /></td></tr>
<tr class="separator:a245802b88a8126c138d24febe6c9822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5fccffbcc853230bc631441dc38469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#afe5fccffbcc853230bc631441dc38469">GDALDestroyTPSTransformer</a> (void *pTransformArg)</td></tr>
<tr class="memdesc:afe5fccffbcc853230bc631441dc38469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy TPS transformer.  <a href="#afe5fccffbcc853230bc631441dc38469">More...</a><br /></td></tr>
<tr class="separator:afe5fccffbcc853230bc631441dc38469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ba2028a33f1f4eede6fc05ded7cbd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ab8ba2028a33f1f4eede6fc05ded7cbd6">GDALTPSTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="memdesc:ab8ba2028a33f1f4eede6fc05ded7cbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms point based on GCP derived polynomial model.  <a href="#ab8ba2028a33f1f4eede6fc05ded7cbd6">More...</a><br /></td></tr>
<tr class="separator:ab8ba2028a33f1f4eede6fc05ded7cbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c3c0d4c79218995b3a1f0bac3700a0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#af4c3c0d4c79218995b3a1f0bac3700a0">GDALCreateRPCTransformer</a> (<a class="el" href="structGDALRPCInfo.html">GDALRPCInfo</a> *psRPC, int bReversed, double dfPixErrThreshold, char **papszOptions)</td></tr>
<tr class="memdesc:af4c3c0d4c79218995b3a1f0bac3700a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an RPC based transformer.  <a href="#af4c3c0d4c79218995b3a1f0bac3700a0">More...</a><br /></td></tr>
<tr class="separator:af4c3c0d4c79218995b3a1f0bac3700a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63aa70d17c44424eb17ee550e5f4c8e"><td class="memItemLeft" align="right" valign="top"><a id="ad63aa70d17c44424eb17ee550e5f4c8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ad63aa70d17c44424eb17ee550e5f4c8e">GDALDestroyRPCTransformer</a> (void *pTransformArg)</td></tr>
<tr class="memdesc:ad63aa70d17c44424eb17ee550e5f4c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy RPC tranformer. <br /></td></tr>
<tr class="separator:ad63aa70d17c44424eb17ee550e5f4c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b22697860cbdf1fe6f93e57c22bc7c"><td class="memItemLeft" align="right" valign="top"><a id="a60b22697860cbdf1fe6f93e57c22bc7c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a60b22697860cbdf1fe6f93e57c22bc7c">GDALRPCTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="memdesc:a60b22697860cbdf1fe6f93e57c22bc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">RPC transform. <br /></td></tr>
<tr class="separator:a60b22697860cbdf1fe6f93e57c22bc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1418a2caa399b1278516d0a3d99543b"><td class="memItemLeft" align="right" valign="top"><a id="ab1418a2caa399b1278516d0a3d99543b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ab1418a2caa399b1278516d0a3d99543b">GDALCreateGeoLocTransformer</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hBaseDS, char **papszGeolocationInfo, int bReversed)</td></tr>
<tr class="memdesc:ab1418a2caa399b1278516d0a3d99543b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create GeoLocation transformer. <br /></td></tr>
<tr class="separator:ab1418a2caa399b1278516d0a3d99543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d06a68980e94b6ccb6397046a97e6bf"><td class="memItemLeft" align="right" valign="top"><a id="a1d06a68980e94b6ccb6397046a97e6bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a1d06a68980e94b6ccb6397046a97e6bf">GDALDestroyGeoLocTransformer</a> (void *pTransformArg)</td></tr>
<tr class="memdesc:a1d06a68980e94b6ccb6397046a97e6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy GeoLocation transformer. <br /></td></tr>
<tr class="separator:a1d06a68980e94b6ccb6397046a97e6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a535116fb06e20871fe52c0efb6a77"><td class="memItemLeft" align="right" valign="top"><a id="af2a535116fb06e20871fe52c0efb6a77"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#af2a535116fb06e20871fe52c0efb6a77">GDALGeoLocTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="memdesc:af2a535116fb06e20871fe52c0efb6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use GeoLocation transformer. <br /></td></tr>
<tr class="separator:af2a535116fb06e20871fe52c0efb6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec403b75384f0a71130eb009078426f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f">GDALCreateApproxTransformer</a> (<a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnRawTransformer, void *pRawTransformerArg, double dfMaxError)</td></tr>
<tr class="memdesc:a4ec403b75384f0a71130eb009078426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an approximating transformer.  <a href="#a4ec403b75384f0a71130eb009078426f">More...</a><br /></td></tr>
<tr class="separator:a4ec403b75384f0a71130eb009078426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d60f9a27bad206047e6ef1a75bc7fc0"><td class="memItemLeft" align="right" valign="top"><a id="a6d60f9a27bad206047e6ef1a75bc7fc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a6d60f9a27bad206047e6ef1a75bc7fc0">GDALApproxTransformerOwnsSubtransformer</a> (void *pCBData, int bOwnFlag)</td></tr>
<tr class="memdesc:a6d60f9a27bad206047e6ef1a75bc7fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bOwnSubtransformer flag. <br /></td></tr>
<tr class="separator:a6d60f9a27bad206047e6ef1a75bc7fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a1fd0719f5405e856e2103b23f1d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aa8a1fd0719f5405e856e2103b23f1d9c">GDALDestroyApproxTransformer</a> (void *pApproxArg)</td></tr>
<tr class="memdesc:aa8a1fd0719f5405e856e2103b23f1d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup approximate transformer.  <a href="#aa8a1fd0719f5405e856e2103b23f1d9c">More...</a><br /></td></tr>
<tr class="separator:aa8a1fd0719f5405e856e2103b23f1d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766ccb23b021d30d86908c08ad8d1668"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a766ccb23b021d30d86908c08ad8d1668">GDALApproxTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr class="memdesc:a766ccb23b021d30d86908c08ad8d1668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform approximate transformation.  <a href="#a766ccb23b021d30d86908c08ad8d1668">More...</a><br /></td></tr>
<tr class="separator:a766ccb23b021d30d86908c08ad8d1668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15910acb317cef94f3fd49dca6e4bab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ae15910acb317cef94f3fd49dca6e4bab">GDALSimpleImageWarp</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDstDS, int nBandCount, int *panBandList, <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnTransform, void *pTransformArg, GDALProgressFunc pfnProgress, void *pProgressArg, char **papszWarpOptions)</td></tr>
<tr class="memdesc:ae15910acb317cef94f3fd49dca6e4bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform simple image warp.  <a href="#ae15910acb317cef94f3fd49dca6e4bab">More...</a><br /></td></tr>
<tr class="separator:ae15910acb317cef94f3fd49dca6e4bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816819e7495bfce06dbd110f7c57af65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a816819e7495bfce06dbd110f7c57af65">GDALSuggestedWarpOutput</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfGeoTransformOut, int *pnPixels, int *pnLines)</td></tr>
<tr class="memdesc:a816819e7495bfce06dbd110f7c57af65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suggest output file size.  <a href="#a816819e7495bfce06dbd110f7c57af65">More...</a><br /></td></tr>
<tr class="separator:a816819e7495bfce06dbd110f7c57af65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae26881b86e42ff958a8e81c4976fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a8ae26881b86e42ff958a8e81c4976fb3">GDALSuggestedWarpOutput2</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfGeoTransformOut, int *pnPixels, int *pnLines, double *padfExtents, int nOptions)</td></tr>
<tr class="memdesc:a8ae26881b86e42ff958a8e81c4976fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suggest output file size.  <a href="#a8ae26881b86e42ff958a8e81c4976fb3">More...</a><br /></td></tr>
<tr class="separator:a8ae26881b86e42ff958a8e81c4976fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ce288fe21fe395fc93c0026419f494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a89ce288fe21fe395fc93c0026419f494">GDALTransformGeolocations</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hXBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hYBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hZBand, <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, GDALProgressFunc pfnProgress, void *pProgressArg, char **papszOptions)</td></tr>
<tr class="memdesc:a89ce288fe21fe395fc93c0026419f494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform locations held in bands.  <a href="#a89ce288fe21fe395fc93c0026419f494">More...</a><br /></td></tr>
<tr class="separator:a89ce288fe21fe395fc93c0026419f494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f8f668cbacea097c06cece3ef522ef"><td class="memItemLeft" align="right" valign="top"><a id="a11f8f668cbacea097c06cece3ef522ef"></a>
<a class="el" href="gdal__alg_8h.html#ac929ac526110faa3f666d18f7a680958">GDALContourGeneratorH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a11f8f668cbacea097c06cece3ef522ef">GDAL_CG_Create</a> (int nWidth, int nHeight, int bNoDataSet, double dfNoDataValue, double dfContourInterval, double dfContourBase, <a class="el" href="gdal__alg_8h.html#aadc7569c65e4b14e36a2173143e6beea">GDALContourWriter</a> pfnWriter, void *pCBData)</td></tr>
<tr class="memdesc:a11f8f668cbacea097c06cece3ef522ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create contour generator. <br /></td></tr>
<tr class="separator:a11f8f668cbacea097c06cece3ef522ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979fe84abd948839e911202daf0136e3"><td class="memItemLeft" align="right" valign="top"><a id="a979fe84abd948839e911202daf0136e3"></a>
<a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a979fe84abd948839e911202daf0136e3">GDAL_CG_FeedLine</a> (<a class="el" href="gdal__alg_8h.html#ac929ac526110faa3f666d18f7a680958">GDALContourGeneratorH</a> hCG, double *padfScanline)</td></tr>
<tr class="memdesc:a979fe84abd948839e911202daf0136e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed a line to the contour generator. <br /></td></tr>
<tr class="separator:a979fe84abd948839e911202daf0136e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662f0efbbd5fbe4cc01338272ab84c9e"><td class="memItemLeft" align="right" valign="top"><a id="a662f0efbbd5fbe4cc01338272ab84c9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a662f0efbbd5fbe4cc01338272ab84c9e">GDAL_CG_Destroy</a> (<a class="el" href="gdal__alg_8h.html#ac929ac526110faa3f666d18f7a680958">GDALContourGeneratorH</a> hCG)</td></tr>
<tr class="memdesc:a662f0efbbd5fbe4cc01338272ab84c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy contour generator. <br /></td></tr>
<tr class="separator:a662f0efbbd5fbe4cc01338272ab84c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaf98ad40f159cbfb626988c054c085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aceaf98ad40f159cbfb626988c054c085">GDALContourGenerate</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBand, double dfContourInterval, double dfContourBase, int nFixedLevelCount, double *padfFixedLevels, int bUseNoData, double dfNoDataValue, void *hLayer, int iIDField, int iElevField, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:aceaf98ad40f159cbfb626988c054c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create vector contours from raster DEM.  <a href="#aceaf98ad40f159cbfb626988c054c085">More...</a><br /></td></tr>
<tr class="separator:aceaf98ad40f159cbfb626988c054c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b3ec0026fe8b23d85c7c4d920613d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a03b3ec0026fe8b23d85c7c4d920613d9">GDALContourGenerateEx</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBand, void *hLayer, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> options, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a03b3ec0026fe8b23d85c7c4d920613d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create vector contours from raster DEM.  <a href="#a03b3ec0026fe8b23d85c7c4d920613d9">More...</a><br /></td></tr>
<tr class="separator:a03b3ec0026fe8b23d85c7c4d920613d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f01fd3f2e027e04f7b4f964c5fc3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a95f01fd3f2e027e04f7b4f964c5fc3fb">GDALViewshedGenerate</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBand, const char *pszDriverName, const char *pszTargetRasterName, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszCreationOptions, double dfObserverX, double dfObserverY, double dfObserverHeight, double dfTargetHeight, double dfVisibleVal, double dfInvisibleVal, double dfOutOfRangeVal, double dfNoDataVal, double dfCurvCoeff, <a class="el" href="gdal__alg_8h.html#a49244316dfeefdbbb188f2570911717d">GDALViewshedMode</a> eMode, double dfMaxDistance, GDALProgressFunc pfnProgress, void *pProgressArg, <a class="el" href="gdal__alg_8h.html#aa5ee2833f6486e61e24903fe0f4dad4a">GDALViewshedOutputType</a> heightMode, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszExtraOptions)</td></tr>
<tr class="memdesc:a95f01fd3f2e027e04f7b4f964c5fc3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create viewshed from raster DEM.  <a href="#a95f01fd3f2e027e04f7b4f964c5fc3fb">More...</a><br /></td></tr>
<tr class="separator:a95f01fd3f2e027e04f7b4f964c5fc3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50caf4bc34703f0bcf515ecbe5061a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a50caf4bc34703f0bcf515ecbe5061a0a">GDALRasterizeGeometries</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDS, int nBandCount, int *panBandList, int nGeomCount, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *pahGeometries, <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfGeomBurnValue, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a50caf4bc34703f0bcf515ecbe5061a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Burn geometries into raster.  <a href="#a50caf4bc34703f0bcf515ecbe5061a0a">More...</a><br /></td></tr>
<tr class="separator:a50caf4bc34703f0bcf515ecbe5061a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe5e5d287d6c184aab03acbfa567cb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#adfe5e5d287d6c184aab03acbfa567cb1">GDALRasterizeLayers</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDS, int nBandCount, int *panBandList, int nLayerCount, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> *pahLayers, <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfLayerBurnValues, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:adfe5e5d287d6c184aab03acbfa567cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Burn geometries from the specified list of layers into raster.  <a href="#adfe5e5d287d6c184aab03acbfa567cb1">More...</a><br /></td></tr>
<tr class="separator:adfe5e5d287d6c184aab03acbfa567cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab791949af233e16c119e4f49ee573cae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ab791949af233e16c119e4f49ee573cae">GDALRasterizeLayersBuf</a> (void *pData, int nBufXSize, int nBufYSize, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> eBufType, int nPixelSpace, int nLineSpace, int nLayerCount, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> *pahLayers, const char *pszDstProjection, double *padfDstGeoTransform, <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double dfBurnValue, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:ab791949af233e16c119e4f49ee573cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Burn geometries from the specified list of layer into raster.  <a href="#ab791949af233e16c119e4f49ee573cae">More...</a><br /></td></tr>
<tr class="separator:ab791949af233e16c119e4f49ee573cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdef40bcdbc98eff2328b0d093d3a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a1fdef40bcdbc98eff2328b0d093d3a22">GDALGridCreate</a> (<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a>, const void *, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, const double *, const double *, const double *, double, double, double, double, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>, void *, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a1fdef40bcdbc98eff2328b0d093d3a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create regular grid from the scattered data.  <a href="#a1fdef40bcdbc98eff2328b0d093d3a22">More...</a><br /></td></tr>
<tr class="separator:a1fdef40bcdbc98eff2328b0d093d3a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95ca80bfa63d375c9242f8d10ba946f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gdal__alg_8h.html#a081f51e38cd0ac6d9e8a6e20a9a3332b">GDALGridContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ab95ca80bfa63d375c9242f8d10ba946f">GDALGridContextCreate</a> (<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a> eAlgorithm, const void *poOptions, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> nPoints, const double *padfX, const double *padfY, const double *padfZ, int bCallerWillKeepPointArraysAlive)</td></tr>
<tr class="memdesc:ab95ca80bfa63d375c9242f8d10ba946f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a context to do regular gridding from the scattered data.  <a href="#ab95ca80bfa63d375c9242f8d10ba946f">More...</a><br /></td></tr>
<tr class="separator:ab95ca80bfa63d375c9242f8d10ba946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2d6dce1e7b14d8a26e03fb52e37286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a1d2d6dce1e7b14d8a26e03fb52e37286">GDALGridContextFree</a> (<a class="el" href="gdal__alg_8h.html#a081f51e38cd0ac6d9e8a6e20a9a3332b">GDALGridContext</a> *psContext)</td></tr>
<tr class="memdesc:a1d2d6dce1e7b14d8a26e03fb52e37286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a context used created by <a class="el" href="gdal__alg_8h.html#ab95ca80bfa63d375c9242f8d10ba946f" title="Creates a context to do regular gridding from the scattered data. ">GDALGridContextCreate()</a>  <a href="#a1d2d6dce1e7b14d8a26e03fb52e37286">More...</a><br /></td></tr>
<tr class="separator:a1d2d6dce1e7b14d8a26e03fb52e37286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da520568b6aaa37d76396d668f96390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a7da520568b6aaa37d76396d668f96390">GDALGridContextProcess</a> (<a class="el" href="gdal__alg_8h.html#a081f51e38cd0ac6d9e8a6e20a9a3332b">GDALGridContext</a> *psContext, double dfXMin, double dfXMax, double dfYMin, double dfYMax, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> nXSize, <a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a> nYSize, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> eType, void *pData, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a7da520568b6aaa37d76396d668f96390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the gridding of a window of a raster.  <a href="#a7da520568b6aaa37d76396d668f96390">More...</a><br /></td></tr>
<tr class="separator:a7da520568b6aaa37d76396d668f96390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee648e2898ddca419ce0f682fcf99389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aee648e2898ddca419ce0f682fcf99389">GDALComputeMatchingPoints</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hFirstImage, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSecondImage, char **papszOptions, int *pnGCPCount)</td></tr>
<tr class="memdesc:aee648e2898ddca419ce0f682fcf99389"><td class="mdescLeft">&#160;</td><td class="mdescRight">GDALComputeMatchingPoints.  <a href="#aee648e2898ddca419ce0f682fcf99389">More...</a><br /></td></tr>
<tr class="separator:aee648e2898ddca419ce0f682fcf99389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb871f9f1bb30353e681c38a83c685a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aadb871f9f1bb30353e681c38a83c685a">GDALHasTriangulation</a> (void)</td></tr>
<tr class="memdesc:aadb871f9f1bb30353e681c38a83c685a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if GDAL is built with Delaunay triangulation support.  <a href="#aadb871f9f1bb30353e681c38a83c685a">More...</a><br /></td></tr>
<tr class="separator:aadb871f9f1bb30353e681c38a83c685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498205ae5f4f0ec9f43e5c65bb392060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a498205ae5f4f0ec9f43e5c65bb392060">GDALTriangulationCreateDelaunay</a> (int nPoints, const double *padfX, const double *padfY)</td></tr>
<tr class="memdesc:a498205ae5f4f0ec9f43e5c65bb392060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a Delaunay triangulation of the passed points.  <a href="#a498205ae5f4f0ec9f43e5c65bb392060">More...</a><br /></td></tr>
<tr class="separator:a498205ae5f4f0ec9f43e5c65bb392060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cb9c1fa87a9054fcfe9f5f45720fa9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a99cb9c1fa87a9054fcfe9f5f45720fa9">GDALTriangulationComputeBarycentricCoefficients</a> (<a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *psDT, const double *padfX, const double *padfY)</td></tr>
<tr class="memdesc:a99cb9c1fa87a9054fcfe9f5f45720fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes barycentric coefficients for each triangles of the triangulation.  <a href="#a99cb9c1fa87a9054fcfe9f5f45720fa9">More...</a><br /></td></tr>
<tr class="separator:a99cb9c1fa87a9054fcfe9f5f45720fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f846755f21f789d7a41ce2825713ee7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a2f846755f21f789d7a41ce2825713ee7">GDALTriangulationComputeBarycentricCoordinates</a> (const <a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *psDT, int nFacetIdx, double dfX, double dfY, double *pdfL1, double *pdfL2, double *pdfL3)</td></tr>
<tr class="memdesc:a2f846755f21f789d7a41ce2825713ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycentric coordinates of a point.  <a href="#a2f846755f21f789d7a41ce2825713ee7">More...</a><br /></td></tr>
<tr class="separator:a2f846755f21f789d7a41ce2825713ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63207eb23887a93ca97ee218848231f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a63207eb23887a93ca97ee218848231f0">GDALTriangulationFindFacetBruteForce</a> (const <a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *psDT, double dfX, double dfY, int *panOutputFacetIdx)</td></tr>
<tr class="memdesc:a63207eb23887a93ca97ee218848231f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the triangle that contains the point by iterating over all triangles.  <a href="#a63207eb23887a93ca97ee218848231f0">More...</a><br /></td></tr>
<tr class="separator:a63207eb23887a93ca97ee218848231f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e3912995c59830c6bfcdf4ec1112fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#af4e3912995c59830c6bfcdf4ec1112fc">GDALTriangulationFindFacetDirected</a> (const <a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *psDT, int nFacetIdx, double dfX, double dfY, int *panOutputFacetIdx)</td></tr>
<tr class="memdesc:af4e3912995c59830c6bfcdf4ec1112fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the triangle that contains the point by walking in the triangulation.  <a href="#af4e3912995c59830c6bfcdf4ec1112fc">More...</a><br /></td></tr>
<tr class="separator:af4e3912995c59830c6bfcdf4ec1112fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ddc2b9ee90b2f9984e020d8f099f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a1d9ddc2b9ee90b2f9984e020d8f099f6">GDALTriangulationFree</a> (<a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *psDT)</td></tr>
<tr class="memdesc:a1d9ddc2b9ee90b2f9984e020d8f099f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a triangulation.  <a href="#a1d9ddc2b9ee90b2f9984e020d8f099f6">More...</a><br /></td></tr>
<tr class="separator:a1d9ddc2b9ee90b2f9984e020d8f099f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e6a52db0d3bd8dd1aba937a0e8b052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a64e6a52db0d3bd8dd1aba937a0e8b052">GDALOpenVerticalShiftGrid</a> (const char *pszProj4Geoidgrids, int *pbError)</td></tr>
<tr class="memdesc:a64e6a52db0d3bd8dd1aba937a0e8b052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load proj.4 geoidgrids as GDAL dataset.  <a href="#a64e6a52db0d3bd8dd1aba937a0e8b052">More...</a><br /></td></tr>
<tr class="separator:a64e6a52db0d3bd8dd1aba937a0e8b052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365c29462f64484e80600559d493d6d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a365c29462f64484e80600559d493d6d5">GDALApplyVerticalShiftGrid</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDataset, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hGridDataset, int bInverse, double dfSrcUnitToMeter, double dfDstUnitToMeter, const char *const *papszOptions)</td></tr>
<tr class="memdesc:a365c29462f64484e80600559d493d6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a vertical shift grid to a source (DEM typically) dataset.  <a href="#a365c29462f64484e80600559d493d6d5">More...</a><br /></td></tr>
<tr class="separator:a365c29462f64484e80600559d493d6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public (C callable) GDAL algorithm entry points, and definitions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aaede67ca444a06f0a6fed538e05d2220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaede67ca444a06f0a6fed538e05d2220">&#9670;&nbsp;</a></span>GDALTransformerFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* GDALTransformerFunc)(void *pTransformerArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic signature for spatial point transformers.</p>
<p>This function signature is used for a variety of functions that accept passed in functions used to transform point locations between two coordinate spaces.</p>
<p>The <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer()</a>, <a class="el" href="gdal__alg_8h.html#ac026c145117134bc754bf25c84b207e1" title="Create reprojection transformer. ">GDALCreateReprojectionTransformerEx()</a>, <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer. ">GDALCreateGCPTransformer()</a> and <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer. ">GDALCreateApproxTransformer()</a> functions can be used to prepare argument data for some built-in transformers. As well, applications can implement their own transformers to the following signature.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> int</div><div class="line">(*<a class="code" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>)( <span class="keywordtype">void</span> *pTransformerArg,</div><div class="line">                        <span class="keywordtype">int</span> bDstToSrc, <span class="keywordtype">int</span> nPointCount,</div><div class="line">                        <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">double</span> *z, <span class="keywordtype">int</span> *panSuccess );</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformerArg</td><td>application supplied callback data used by the transformer.</td></tr>
    <tr><td class="paramname">bDstToSrc</td><td>if TRUE the transformation will be from the destination coordinate space to the source coordinate system, otherwise the transformation will be from the source coordinate system to the destination coordinate system.</td></tr>
    <tr><td class="paramname">nPointCount</td><td>number of points in the x, y and z arrays.</td></tr>
    <tr><td class="paramname">x</td><td>input X coordinates. Results returned in same array.</td></tr>
    <tr><td class="paramname">y</td><td>input Y coordinates. Results returned in same array.</td></tr>
    <tr><td class="paramname">z</td><td>input Z coordinates. Results returned in same array.</td></tr>
    <tr><td class="paramname">panSuccess</td><td>array of ints in which success (TRUE) or failure (FALSE) flags are returned for the translation of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the overall transformation succeeds (though some individual points may have failed) or FALSE if the overall transformation fails. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a590d1a2d0bac1d34b95034c1f616de21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590d1a2d0bac1d34b95034c1f616de21">&#9670;&nbsp;</a></span>GDALGridAlgorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gridding Algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21a5955211b72d8b07518815d544e5fa192"></a>GGA_InverseDistanceToAPower&#160;</td><td class="fielddoc"><p>Inverse distance to a power </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21aaafac5453ea6a64e9c84c5143cfbdcaf"></a>GGA_MovingAverage&#160;</td><td class="fielddoc"><p>Moving Average </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21a70c30cb508518172fbce051a7927eb68"></a>GGA_NearestNeighbor&#160;</td><td class="fielddoc"><p>Nearest Neighbor </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21a114443c69d10fafd0e4a6195cb178e75"></a>GGA_MetricMinimum&#160;</td><td class="fielddoc"><p>Minimum Value (Data Metric) </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21a62e4fcf09890e32a287364ca165f78e2"></a>GGA_MetricMaximum&#160;</td><td class="fielddoc"><p>Maximum Value (Data Metric) </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21aed976fb5778362e9c51e5859d19ac917"></a>GGA_MetricRange&#160;</td><td class="fielddoc"><p>Data Range (Data Metric) </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21ac41203ffb292f6fadf155a5d3ff80219"></a>GGA_MetricCount&#160;</td><td class="fielddoc"><p>Number of Points (Data Metric) </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21a90cfa34b606733fcbc4c7b15e36fefcf"></a>GGA_MetricAverageDistance&#160;</td><td class="fielddoc"><p>Average Distance (Data Metric) </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21a5c0dc83a00305d4a1beda88406aefbb6"></a>GGA_MetricAverageDistancePts&#160;</td><td class="fielddoc"><p>Average Distance Between Data Points (Data Metric) </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21af36d730cc83998d3dd4c6bb8128e9f5e"></a>GGA_Linear&#160;</td><td class="fielddoc"><p>Linear interpolation (from Delaunay triangulation. Since GDAL 2.1 </p>
</td></tr>
<tr><td class="fieldname"><a id="a590d1a2d0bac1d34b95034c1f616de21a147a475881c01b46c1371f576310cfe2"></a>GGA_InverseDistanceToAPowerNearestNeighbor&#160;</td><td class="fielddoc"><p>Inverse distance to a power with nearest neighbor search for max points </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a365c29462f64484e80600559d493d6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365c29462f64484e80600559d493d6d5">&#9670;&nbsp;</a></span>GDALApplyVerticalShiftGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> GDALApplyVerticalShiftGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hSrcDataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hGridDataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bInverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfSrcUnitToMeter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDstUnitToMeter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a vertical shift grid to a source (DEM typically) dataset. </p>
<p>hGridDataset will typically use WGS84 as horizontal datum (but this is not a requirement) and its values are the values to add to go from geoid elevations to WGS84 ellipsoidal heights.</p>
<p>hGridDataset will be on-the-fly reprojected and resampled to the projection and resolution of hSrcDataset, using bilinear resampling by default.</p>
<p>Both hSrcDataset and hGridDataset must be single band datasets, and have a valid geotransform and projection.</p>
<p>On success, a reference will be taken on hSrcDataset and hGridDataset. Reference counting semantics on the source and grid datasets should be honoured. That is, don't just <a class="el" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc" title="Close GDAL dataset. ">GDALClose()</a> it, unless it was opened with <a class="el" href="gdal_8h.html#a46a02c21047d78f88f8abb1ff6b14ae2" title="Open a raster file as a GDALDataset. ">GDALOpenShared()</a>, but rather use <a class="el" href="gdal_8h.html#add1fc2ca3e674f68568816b932b398c6" title="Drop a reference to this object, and destroy if no longer referenced. ">GDALReleaseDataset()</a> if wanting to immediately release the reference(s) and make the returned dataset the owner of them.</p>
<p>Valid use cases:</p>
<div class="fragment"><div class="line">hSrcDataset = <a class="code" href="gdal_8h.html#a6836f0f810396c5e45622c8ef94624d4">GDALOpen</a>(...)</div><div class="line">hGridDataset = <a class="code" href="gdal_8h.html#a6836f0f810396c5e45622c8ef94624d4">GDALOpen</a>(...)</div><div class="line">hDstDataset = <a class="code" href="gdal__alg_8h.html#a365c29462f64484e80600559d493d6d5">GDALApplyVerticalShiftGrid</a>(hSrcDataset, hGridDataset, ...)</div><div class="line"><a class="code" href="gdal_8h.html#add1fc2ca3e674f68568816b932b398c6">GDALReleaseDataset</a>(hSrcDataset);</div><div class="line"><a class="code" href="gdal_8h.html#add1fc2ca3e674f68568816b932b398c6">GDALReleaseDataset</a>(hGridDataset);</div><div class="line">if( hDstDataset )</div><div class="line">{</div><div class="line">    <span class="comment">// Do things with hDstDataset </span></div><div class="line">    <a class="code" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc">GDALClose</a>(hDstDataset) <span class="comment">// will close hSrcDataset and hGridDataset</span></div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcDataset</td><td>source (DEM) dataset. Must not be NULL. </td></tr>
    <tr><td class="paramname">hGridDataset</td><td>vertical grid shift dataset. Must not be NULL. </td></tr>
    <tr><td class="paramname">bInverse</td><td>if set to FALSE, hGridDataset values will be added to hSrcDataset. If set to TRUE, they will be subtracted. </td></tr>
    <tr><td class="paramname">dfSrcUnitToMeter</td><td>the factor to convert values from hSrcDataset to meters (1.0 if source values are in meter). </td></tr>
    <tr><td class="paramname">dfDstUnitToMeter</td><td>the factor to convert shifted values from meter (1.0 if output values must be in meter). </td></tr>
    <tr><td class="paramname">papszOptions</td><td>list of options, or NULL. Supported options are: <ul>
<li>
RESAMPLING=NEAREST/BILINEAR/CUBIC. Defaults to BILINEAR. </li>
<li>
MAX_ERROR=val. Maximum error measured in input pixels that is allowed in approximating the transformation (0.0 for exact calculations). Defaults to 0.125 </li>
<li>
DATATYPE=Byte/UInt16/Int16/Float32/Float64. Output data type. If not specified will be the same as the one of hSrcDataset. </li>
<li>
ERROR_ON_MISSING_VERT_SHIFT=YES/NO. Whether a missing/nodata value in hGridDataset should cause I/O requests to fail. Default is NO (in which case 0 will be used) </li>
<li>
SRC_SRS=srs_def. Override projection on hSrcDataset; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new dataset corresponding to hSrcDataset adjusted with hGridDataset, or NULL. If not NULL, it must be closed with <a class="el" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc" title="Close GDAL dataset. ">GDALClose()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a766ccb23b021d30d86908c08ad8d1668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766ccb23b021d30d86908c08ad8d1668">&#9670;&nbsp;</a></span>GDALApproxTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALApproxTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCBData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panSuccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform approximate transformation. </p>
<p>Actually performs the approximate transformation described in <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer. ">GDALCreateApproxTransformer()</a>. This function matches the <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc()</a> signature. Details of the arguments are described there. </p>

</div>
</div>
<a id="abe2846ac3a350c24f07dc9ceac8f4d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2846ac3a350c24f07dc9ceac8f4d14">&#9670;&nbsp;</a></span>GDALChecksumImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALChecksumImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute checksum for image region. </p>
<p>Computes a 16bit (0-65535) checksum from a region of raster data on a GDAL supported band. Floating point data is converted to 32bit integer so decimal portions of such raster data will not affect the checksum. Real and Imaginary components of complex bands influence the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBand</td><td>the raster band to read from. </td></tr>
    <tr><td class="paramname">nXOff</td><td>pixel offset of window to read. </td></tr>
    <tr><td class="paramname">nYOff</td><td>line offset of window to read. </td></tr>
    <tr><td class="paramname">nXSize</td><td>pixel size of window to read. </td></tr>
    <tr><td class="paramname">nYSize</td><td>line size of window to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Checksum value. </dd></dl>

</div>
</div>
<a id="aee648e2898ddca419ce0f682fcf99389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee648e2898ddca419ce0f682fcf99389">&#9670;&nbsp;</a></span>GDALComputeMatchingPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGDAL__GCP.html">GDAL_GCP</a>* GDALComputeMatchingPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hFirstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hSecondImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnGCPCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GDALComputeMatchingPoints. </p>
<p>TODO document </p>

</div>
</div>
<a id="a61e48f88c3b4b3cf7957c61dc7bd1ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e48f88c3b4b3cf7957c61dc7bd1ead">&#9670;&nbsp;</a></span>GDALComputeMedianCutPCT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALComputeMedianCutPCT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hRed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hGreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hBlue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int, int, void *)&#160;</td>
          <td class="paramname"><em>pfnIncludePixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a>&#160;</td>
          <td class="paramname"><em>hColorTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute optimal PCT for RGB image. </p>
<p>This function implements a median cut algorithm to compute an "optimal" pseudocolor table for representing an input RGB image. This PCT could then be used with <a class="el" href="gdal__alg_8h.html#a284dbcc27295b7e678b1f7d4fa1506cb" title="24bit to 8bit conversion with dithering. ">GDALDitherRGB2PCT()</a> to convert a 24bit RGB image into an eightbit pseudo-colored image.</p>
<p>This code was based on the tiffmedian.c code from libtiff (www.libtiff.org) which was based on a paper by Paul Heckbert:</p>
<pre class="fragment">*   "Color  Image Quantization for Frame Buffer Display", Paul
*   Heckbert, SIGGRAPH proceedings, 1982, pp. 297-307.
* </pre><p>The red, green and blue input bands do not necessarily need to come from the same file, but they must be the same width and height. They will be clipped to 8bit during reading, so non-eight bit bands are generally inappropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hRed</td><td>Red input band. </td></tr>
    <tr><td class="paramname">hGreen</td><td>Green input band. </td></tr>
    <tr><td class="paramname">hBlue</td><td>Blue input band. </td></tr>
    <tr><td class="paramname">pfnIncludePixel</td><td>function used to test which pixels should be included in the analysis. At this time this argument is ignored and all pixels are utilized. This should normally be NULL. </td></tr>
    <tr><td class="paramname">nColors</td><td>the desired number of colors to be returned (2-256). </td></tr>
    <tr><td class="paramname">hColorTable</td><td>the colors will be returned in this color table object. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a id="a851815400a579aae9de01199b416fa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851815400a579aae9de01199b416fa42">&#9670;&nbsp;</a></span>GDALComputeProximity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALComputeProximity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hProximityBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the proximity of all pixels in the image to a set of pixels in the source image. </p>
<p>This function attempts to compute the proximity of all pixels in the image to a set of pixels in the source image. The following options are used to define the behavior of the function. By default all non-zero pixels in hSrcBand will be considered the "target", and all proximities will be computed in pixels. Note that target pixels are set to the value corresponding to a distance of zero.</p>
<p>The progress function args may be NULL or a valid progress reporting function such as GDALTermProgress/NULL.</p>
<p>Options:</p>
<p>VALUES=n[,n]*</p>
<p>A list of target pixel values to measure the distance from. If this option is not provided proximity will be computed from non-zero pixel values. Currently pixel values are internally processed as integers.</p>
<p>DISTUNITS=[PIXEL]/GEO</p>
<p>Indicates whether distances will be computed in pixel units or in georeferenced units. The default is pixel units. This also determines the interpretation of MAXDIST.</p>
<p>MAXDIST=n</p>
<p>The maximum distance to search. Proximity distances greater than this value will not be computed. Instead output pixels will be set to a nodata value.</p>
<p>NODATA=n</p>
<p>The NODATA value to use on the output band for pixels that are beyond MAXDIST. If not provided, the hProximityBand will be queried for a nodata value. If one is not found, 65535 will be used.</p>
<p>USE_INPUT_NODATA=YES/NO</p>
<p>If this option is set, the input data set no-data value will be respected. Leaving no data pixels in the input as no data pixels in the proximity output.</p>
<p>FIXED_BUF_VAL=n</p>
<p>If this option is set, all pixels within the MAXDIST threadhold are set to this fixed value instead of to a proximity distance. </p>

</div>
</div>
<a id="aceaf98ad40f159cbfb626988c054c085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaf98ad40f159cbfb626988c054c085">&#9670;&nbsp;</a></span>GDALContourGenerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALContourGenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfContourInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfContourBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFixedLevelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfFixedLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUseNoData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfNoDataValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iIDField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iElevField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create vector contours from raster DEM. </p>
<p>This function is kept for compatibility reason and will call the new variant GDALContourGenerateEx that is more extensible and provide more options.</p>
<p>Details about the algorithm are also given in the documentation of the new GDALContourenerateEx function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBand</td><td>The band to read raster data from. The whole band will be processed.</td></tr>
    <tr><td class="paramname">dfContourInterval</td><td>The elevation interval between contours generated.</td></tr>
    <tr><td class="paramname">dfContourBase</td><td>The "base" relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, ... the ContourBase would be 5.</td></tr>
    <tr><td class="paramname">nFixedLevelCount</td><td>The number of fixed levels. If this is greater than zero, then fixed levels will be used, and ContourInterval and ContourBase are ignored.</td></tr>
    <tr><td class="paramname">padfFixedLevels</td><td>The list of fixed contour levels at which contours should be generated. It will contain FixedLevelCount entries, and may be NULL if fixed levels are disabled (FixedLevelCount = 0).</td></tr>
    <tr><td class="paramname">bUseNoData</td><td>If TRUE the dfNoDataValue will be used.</td></tr>
    <tr><td class="paramname">dfNoDataValue</td><td>The value to use as a "nodata" value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.</td></tr>
    <tr><td class="paramname">hLayer</td><td>The layer to which new contour vectors will be written. Each contour will have a LINESTRING geometry attached to it. This is really of type OGRLayerH, but void * is used to avoid pulling the <a class="el" href="ogr__api_8h.html" title="C API and defines for OGRFeature, OGRGeometry, and OGRDataSource related classes. ...">ogr_api.h</a> file in here.</td></tr>
    <tr><td class="paramname">iIDField</td><td>If not -1 this will be used as a field index to indicate where a unique id should be written for each feature (contour) written.</td></tr>
    <tr><td class="paramname">iElevField</td><td>If not -1 this will be used as a field index to indicate where the elevation value of the contour should be written.</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>The callback data for the pfnProgress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a id="a03b3ec0026fe8b23d85c7c4d920613d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b3ec0026fe8b23d85c7c4d920613d9">&#9670;&nbsp;</a></span>GDALContourGenerateEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALContourGenerateEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create vector contours from raster DEM. </p>
<p>This algorithm is an implementation of "Marching squares" [1] that will generate contour vectors for the input raster band on the requested set of contour levels. The vector contours are written to the passed in OGR vector layer. Also, a NODATA value may be specified to identify pixels that should not be considered in contour line generation.</p>
<p>The gdal/apps/gdal_contour.cpp mainline can be used as an example of how to use this function.</p>
<p>[1] see <a href="https://en.wikipedia.org/wiki/Marching_squares">https://en.wikipedia.org/wiki/Marching_squares</a></p>
<p>ALGORITHM RULES</p>
<p>For contouring purposes raster pixel values are assumed to represent a point value at the center of the corresponding pixel region. For the purpose of contour generation we virtually connect each pixel center to the values to the left, right, top and bottom. We assume that the pixel value is linearly interpolated between the pixel centers along each line, and determine where (if any) contour lines will appear along these line segments. Then the contour crossings are connected.</p>
<p>This means that contour lines' nodes will not actually be on pixel edges, but rather along vertical and horizontal lines connecting the pixel centers.</p>
<pre class="fragment">General Case:

      5 |                  | 3
     -- + ---------------- + --
        |                  |
        |                  |
        |                  |
        |                  |
     10 +                  |
        |\                 |
        | \                |
     -- + -+-------------- + --
     12 |  10              | 1

Saddle Point:

      5 |                  | 12
     -- + -------------+-- + --
        |               \  |
        |                 \|
        |                  +
        |                  |
        +                  |
        |\                 |
        | \                |
     -- + -+-------------- + --
     12 |                  | 1

or:

      5 |                  | 12
     -- + -------------+-- + --
        |          __/     |
        |      ___/        |
        |  ___/          __+
        | /           __/  |
        +'         __/     |
        |       __/        |
        |   ,__/           |
     -- + -+-------------- + --
     12 |                  | 1
</pre><p>Nodata:</p>
<p>In the "nodata" case we treat the whole nodata pixel as a no-mans land. We extend the corner pixels near the nodata out to half way and then construct extra lines from those points to the center which is assigned an averaged value from the two nearby points (in this case (12+3+5)/3).</p>
<pre class="fragment">      5 |                  | 3
     -- + ---------------- + --
        |                  |
        |                  |
        |      6.7         |
        |        +---------+ 3
     10 +___     |
        |   \____+ 10
        |        |
     -- + -------+        +
     12 |       12           (nodata)</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBand</td><td>The band to read raster data from. The whole band will be processed.</td></tr>
    <tr><td class="paramname">hLayer</td><td>The layer to which new contour vectors will be written. Each contour will have a LINESTRING geometry attached to it (or POLYGON if POLYGONIZE=YES). This is really of type OGRLayerH, but void * is used to avoid pulling the <a class="el" href="ogr__api_8h.html" title="C API and defines for OGRFeature, OGRGeometry, and OGRDataSource related classes. ...">ogr_api.h</a> file in here.</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>The callback data for the pfnProgress function.</td></tr>
    <tr><td class="paramname">options</td><td>List of options</td></tr>
  </table>
  </dd>
</dl>
<p>Options:</p>
<p>LEVEL_INTERVAL=f</p>
<p>The elevation interval between contours generated.</p>
<p>LEVEL_BASE=f</p>
<p>The "base" relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, ... the LEVEL_BASE would be 5.</p>
<p>LEVEL_EXP_BASE=f</p>
<p>If greater than 0, contour levels are generated on an exponential scale. Levels will then be generated by LEVEL_EXP_BASE^k where k is a positive integer.</p>
<p>FIXED_LEVELS=f[,f]*</p>
<p>The list of fixed contour levels at which contours should be generated. This option has precedence on LEVEL_INTERVAL</p>
<p>NODATA=f</p>
<p>The value to use as a "nodata" value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.</p>
<p>ID_FIELD=d</p>
<p>This will be used as a field index to indicate where a unique id should be written for each feature (contour) written.</p>
<p>ELEV_FIELD=d</p>
<p>This will be used as a field index to indicate where the elevation value of the contour should be written. Only used in line contouring mode.</p>
<p>ELEV_FIELD_MIN=d</p>
<p>This will be used as a field index to indicate where the minimum elevation value of the polygon contour should be written. Only used in polygonal contouring mode.</p>
<p>ELEV_FIELD_MAX=d</p>
<p>This will be used as a field index to indicate where the maximum elevation value of the polygon contour should be written. Only used in polygonal contouring mode.</p>
<p>POLYGONIZE=YES|NO</p>
<p>If YES, contour polygons will be created, rather than polygon lines.</p>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a id="a4ec403b75384f0a71130eb009078426f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec403b75384f0a71130eb009078426f">&#9670;&nbsp;</a></span>GDALCreateApproxTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateApproxTransformer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnBaseTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBaseTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an approximating transformer. </p>
<p>This function creates a context for an approximated transformer. Basically a high precision transformer is supplied as input and internally linear approximations are computed to generate results to within a defined precision.</p>
<p>The approximation is actually done at the point where <a class="el" href="gdal__alg_8h.html#a766ccb23b021d30d86908c08ad8d1668" title="Perform approximate transformation. ">GDALApproxTransform()</a> calls are made, and depend on the assumption that the roughly linear. The first and last point passed in must be the extreme values and the intermediate values should describe a curve between the end points. The approximator transforms and center using the approximate transformer, and then compares the true middle transformed value to a linear approximation based on the end points. If the error is within the supplied threshold then the end points are used to linearly approximate all the values otherwise the inputs points are split into two smaller sets, and the function recursively called till a sufficiently small set of points if found that the linear approximation is OK, or that all the points are exactly computed.</p>
<p>This function is very suitable for approximating transformation results from output pixel/line space to input coordinates for warpers that operate on one input scanline at a time. Care should be taken using it in other circumstances as little internal validation is done, in order to keep things fast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnBaseTransformer</td><td>the high precision transformer which should be approximated. </td></tr>
    <tr><td class="paramname">pBaseTransformArg</td><td>the callback argument for the high precision transformer. </td></tr>
    <tr><td class="paramname">dfMaxError</td><td>the maximum cartesian error in the "output" space that is to be accepted in the linear approximation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>callback pointer suitable for use with <a class="el" href="gdal__alg_8h.html#a766ccb23b021d30d86908c08ad8d1668" title="Perform approximate transformation. ">GDALApproxTransform()</a>. It should be deallocated with <a class="el" href="gdal__alg_8h.html#aa8a1fd0719f5405e856e2103b23f1d9c" title="Cleanup approximate transformer. ">GDALDestroyApproxTransformer()</a>. </dd></dl>

</div>
</div>
<a id="ac57c80f7bf6752fac1dff8c2a21a15a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57c80f7bf6752fac1dff8c2a21a15a3">&#9670;&nbsp;</a></span>GDALCreateGCPTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGCPTransformer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGCPCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *&#160;</td>
          <td class="paramname"><em>pasGCPList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nReqOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bReversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create GCP based polynomial transformer. </p>
<p>Computes least squares fit polynomials from a provided set of GCPs, and stores the coefficients for later transformation of points between pixel/line and georeferenced coordinates.</p>
<p>The return value should be used as a TransformArg in combination with the transformation function GDALGCPTransform which fits the GDALTransformerFunc signature. The returned transform argument should be deallocated with GDALDestroyGCPTransformer when no longer needed.</p>
<p>This function may fail (returning nullptr) if the provided set of GCPs are inadequate for the requested order, the determinate is zero or they are otherwise "ill conditioned".</p>
<p>Note that 2nd order requires at least 6 GCPs, and 3rd order requires at least 10 gcps. If nReqOrder is 0 the highest order possible (limited to 2) with the provided gcp count will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nGCPCount</td><td>the number of GCPs in pasGCPList. </td></tr>
    <tr><td class="paramname">pasGCPList</td><td>an array of GCPs to be used as input. </td></tr>
    <tr><td class="paramname">nReqOrder</td><td>the requested polynomial order. It should be 1, 2 or 3. Using 3 is not recommended due to potential numeric instabilities issues. </td></tr>
    <tr><td class="paramname">bReversed</td><td>set it to TRUE to compute the reversed transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transform argument or nullptr if creation fails. </dd></dl>

</div>
</div>
<a id="a7671696d085085a0bfba3c3df9ffcc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7671696d085085a0bfba3c3df9ffcc0a">&#9670;&nbsp;</a></span>GDALCreateGenImgProjTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGenImgProjTransformer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrcWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hDstDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bGCPUseOK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfGCPErrorThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model. ">GDALGCPTransform()</a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation. ">GDALReprojectionTransform()</a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model. ">GDALGCPTransform()</a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcDS</td><td>source dataset, or NULL. </td></tr>
    <tr><td class="paramname">pszSrcWKT</td><td>the coordinate system for the source dataset. If NULL, it will be read from the dataset itself. </td></tr>
    <tr><td class="paramname">hDstDS</td><td>destination dataset (or NULL). </td></tr>
    <tr><td class="paramname">pszDstWKT</td><td>the coordinate system for the destination dataset. If NULL, and hDstDS not NULL, it will be read from the destination dataset. </td></tr>
    <tr><td class="paramname">bGCPUseOK</td><td>TRUE if GCPs should be used if the geotransform is not available on the source dataset (not destination). </td></tr>
    <tr><td class="paramname">dfGCPErrorThreshold</td><td>ignored/deprecated. </td></tr>
    <tr><td class="paramname">nOrder</td><td>the maximum order to use for GCP derived polynomials if possible. Use 0 to autoselect, or -1 for thin plate splines.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle suitable for use <a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6" title="Perform general image reprojection transformation. ">GDALGenImgProjTransform()</a>, and to be deallocated with <a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d" title="GenImgProjTransformer deallocator. ">GDALDestroyGenImgProjTransformer()</a>. </dd></dl>

</div>
</div>
<a id="a94cd172f78dbc41d6f407d662914f2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cd172f78dbc41d6f407d662914f2e3">&#9670;&nbsp;</a></span>GDALCreateGenImgProjTransformer2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGenImgProjTransformer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hDstDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model. ">GDALGCPTransform()</a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation. ">GDALReprojectionTransform()</a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model. ">GDALGCPTransform()</a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<p>Supported Options (specified with the -to switch of gdalwarp for example): </p><ul>
<li>
SRC_SRS: WKT SRS, or any string recognized by <a class="el" href="classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796" title="Set spatial reference from various text formats. ">OGRSpatialReference::SetFromUserInput()</a>, to be used as an override for hSrcDS. </li>
<li>
DST_SRS: WKT SRS, or any string recognized by <a class="el" href="classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796" title="Set spatial reference from various text formats. ">OGRSpatialReference::SetFromUserInput()</a>, to be used as an override for hDstDS. </li>
<li>
COORDINATE_OPERATION: (GDAL &gt;= 3.0) Coordinate operation, as a PROJ or WKT string, used as an override over the normally computed pipeline. The pipeline must take into account the axis order of the source and target SRS. </li>
<li>
COORDINATE_EPOCH: (GDAL &gt;= 3.0) Coordinate epoch, expressed as a decimal year. Useful for time-dependant coordinate operations. </li>
<li>
GCPS_OK: If false, GCPs will not be used, default is TRUE. </li>
<li>
REFINE_MINIMUM_GCPS: The minimum amount of GCPs that should be available after the refinement. </li>
<li>
REFINE_TOLERANCE: The tolerance that specifies when a GCP will be eliminated. </li>
<li>
MAX_GCP_ORDER: the maximum order to use for GCP derived polynomials if possible. The default is to autoselect based on the number of GCPs. A value of -1 triggers use of Thin Plate Spline instead of polynomials. </li>
<li>
SRC_METHOD: may have a value which is one of GEOTRANSFORM, GCP_POLYNOMIAL, GCP_TPS, GEOLOC_ARRAY, RPC to force only one geolocation method to be considered on the source dataset. Will be used for pixel/line to georef transformation on the source dataset. NO_GEOTRANSFORM can be used to specify the identity geotransform (ungeoreference image) </li>
<li>
DST_METHOD: may have a value which is one of GEOTRANSFORM, GCP_POLYNOMIAL, GCP_TPS, GEOLOC_ARRAY, RPC to force only one geolocation method to be considered on the target dataset. Will be used for pixel/line to georef transformation on the destination dataset. NO_GEOTRANSFORM can be used to specify the identity geotransform (ungeoreference image) </li>
<li>
RPC_HEIGHT: A fixed height to be used with RPC calculations. </li>
<li>
RPC_DEM: The name of a DEM file to be used with RPC calculations. </li>
<li>
Other RPC related options. See <a class="el" href="gdal__alg_8h.html#af4c3c0d4c79218995b3a1f0bac3700a0" title="Create an RPC based transformer. ">GDALCreateRPCTransformer()</a> </li>
<li>
INSERT_CENTER_LONG: May be set to FALSE to disable setting up a CENTER_LONG value on the coordinate system to rewrap things around the center of the image. </li>
<li>
SRC_APPROX_ERROR_IN_SRS_UNIT=err_threshold_in_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the source transformer. Must be defined together with SRC_APPROX_ERROR_IN_PIXEL to be taken into account. </li>
<li>
SRC_APPROX_ERROR_IN_PIXEL=err_threshold_in_pixel. (GDAL &gt;= 2.2) Use an approximate transformer for the source transformer.. Must be defined together with SRC_APPROX_ERROR_IN_SRS_UNIT to be taken into account. </li>
<li>
DST_APPROX_ERROR_IN_SRS_UNIT=err_threshold_in_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the destination transformer. Must be defined together with DST_APPROX_ERROR_IN_PIXEL to be taken into account. </li>
<li>
DST_APPROX_ERROR_IN_PIXEL=err_threshold_in_pixel. (GDAL &gt;= 2.2) Use an approximate transformer for the destination transformer. Must be defined together with DST_APPROX_ERROR_IN_SRS_UNIT to be taken into account. </li>
<li>
REPROJECTION_APPROX_ERROR_IN_SRC_SRS_UNIT=err_threshold_in_src_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the coordinate reprojection. Must be used together with REPROJECTION_APPROX_ERROR_IN_DST_SRS_UNIT to be taken into account. </li>
<li>
REPROJECTION_APPROX_ERROR_IN_DST_SRS_UNIT=err_threshold_in_dst_SRS_units. (GDAL &gt;= 2.2) Use an approximate transformer for the coordinate reprojection. Must be used together with REPROJECTION_APPROX_ERROR_IN_SRC_SRS_UNIT to be taken into account. </li>
<li>
AREA_OF_INTEREST=west_lon_deg,south_lat_deg,east_lon_deg,north_lat_deg. (GDAL &gt;= 3.0) Area of interest, used to compute the best coordinate operation between the source and target SRS. If not specified, the bounding box of the source raster will be used. </li>
</ul>
<p>The use case for the *_APPROX_ERROR_* options is when defining an approximate transformer on top of the GenImgProjTransformer globally is not practical. Such a use case is when the source dataset has RPC with a RPC DEM. In such case we don't want to use the approximate transformer on the RPC transformation, as the RPC DEM generally involves non-linearities that the approximate transformer will not detect. In such case, we must a non-approximated GenImgProjTransformer, but it might be worthwile to use approximate sub- transformers, for example on coordinate reprojection. For example if warping from a source dataset with RPC to a destination dataset with a UTM projection, since the inverse UTM transformation is rather costly. In which case, one can use the REPROJECTION_APPROX_ERROR_IN_SRC_SRS_UNIT and REPROJECTION_APPROX_ERROR_IN_DST_SRS_UNIT options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcDS</td><td>source dataset, or NULL. </td></tr>
    <tr><td class="paramname">hDstDS</td><td>destination dataset (or NULL). </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of string options (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle suitable for use <a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6" title="Perform general image reprojection transformation. ">GDALGenImgProjTransform()</a>, and to be deallocated with <a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d" title="GenImgProjTransformer deallocator. ">GDALDestroyGenImgProjTransformer()</a> or NULL on failure. </dd></dl>

</div>
</div>
<a id="a05f5de51947234a0481088bed2d7ce53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f5de51947234a0481088bed2d7ce53">&#9670;&nbsp;</a></span>GDALCreateGenImgProjTransformer3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGenImgProjTransformer3 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrcWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfSrcGeoTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfDstGeoTransform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model. ">GDALGCPTransform()</a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation. ">GDALReprojectionTransform()</a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model. ">GDALGCPTransform()</a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSrcWKT</td><td>source WKT (or NULL). </td></tr>
    <tr><td class="paramname">padfSrcGeoTransform</td><td>source geotransform (or NULL). </td></tr>
    <tr><td class="paramname">pszDstWKT</td><td>destination WKT (or NULL). </td></tr>
    <tr><td class="paramname">padfDstGeoTransform</td><td>destination geotransform (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle suitable for use <a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6" title="Perform general image reprojection transformation. ">GDALGenImgProjTransform()</a>, and to be deallocated with <a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d" title="GenImgProjTransformer deallocator. ">GDALDestroyGenImgProjTransformer()</a> or NULL on failure. </dd></dl>

</div>
</div>
<a id="a7307bae38fe0f59679172f82492cc02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7307bae38fe0f59679172f82492cc02d">&#9670;&nbsp;</a></span>GDALCreateGenImgProjTransformer4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGenImgProjTransformer4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSrcSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfSrcGeoTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hDstSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfDstGeoTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create image to image transformer. </p>
<p>Similar to <a class="el" href="gdal__alg_8h.html#a05f5de51947234a0481088bed2d7ce53" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer3()</a>, except that it takes OGRSpatialReferenceH objects and options. The options are the ones supported by <a class="el" href="gdal__alg_8h.html#ac026c145117134bc754bf25c84b207e1" title="Create reprojection transformer. ">GDALCreateReprojectionTransformerEx()</a></p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="adce63548b884096e55d1685d4bbd7e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce63548b884096e55d1685d4bbd7e63">&#9670;&nbsp;</a></span>GDALCreateReprojectionTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateReprojectionTransformer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSrcWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstWKT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create reprojection transformer. </p>
<p>Creates a callback data structure suitable for use with GDALReprojectionTransformation() to represent a transformation from one geographic or projected coordinate system to another. On input the coordinate systems are described in OpenGIS WKT format.</p>
<p>Internally the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> object is used to implement the reprojection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSrcWKT</td><td>the coordinate system for the source coordinate system. </td></tr>
    <tr><td class="paramname">pszDstWKT</td><td>the coordinate system for the destination coordinate system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for use with <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation. ">GDALReprojectionTransform()</a>, or NULL if the system fails to initialize the reprojection. </dd></dl>

</div>
</div>
<a id="ac026c145117134bc754bf25c84b207e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac026c145117134bc754bf25c84b207e1">&#9670;&nbsp;</a></span>GDALCreateReprojectionTransformerEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateReprojectionTransformerEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSrcSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hDstSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create reprojection transformer. </p>
<p>Creates a callback data structure suitable for use with GDALReprojectionTransformation() to represent a transformation from one geographic or projected coordinate system to another.</p>
<p>Internally the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> object is used to implement the reprojection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcSRS</td><td>the coordinate system for the source coordinate system. </td></tr>
    <tr><td class="paramname">hDstSRS</td><td>the coordinate system for the destination coordinate system. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options, or NULL. Currrently supported options are: <ul>
<li>
AREA_OF_INTEREST=west_long,south_lat,east_long,north_lat: Values in degrees. longitudes in [-180,180], latitudes in [-90,90]. </li>
<li>
COORDINATE_OPERATION=string: PROJ or WKT string representing a coordinate operation, overriding the default computed transformation. </li>
<li>
COORDINATE_EPOCH=decimal_year: Coordinate epoch, expressed as a decimal year. Useful for time-dependant coordinate operations. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for use with <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation. ">GDALReprojectionTransform()</a>, or NULL if the system fails to initialize the reprojection.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="af4c3c0d4c79218995b3a1f0bac3700a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c3c0d4c79218995b3a1f0bac3700a0">&#9670;&nbsp;</a></span>GDALCreateRPCTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateRPCTransformer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGDALRPCInfo.html">GDALRPCInfo</a> *&#160;</td>
          <td class="paramname"><em>psRPCInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bReversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfPixErrThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an RPC based transformer. </p>
<p>The geometric sensor model describing the physical relationship between image coordinates and ground coordinate is known as a Rigorous Projection Model. A Rigorous Projection Model expresses the mapping of the image space coordinates of rows and columns (r,c) onto the object space reference surface geodetic coordinates (long, lat, height).</p>
<p>RPC supports a generic description of the Rigorous Projection Models. The approximation used by GDAL (RPC00) is a set of rational polynomials expressing the normalized row and column values, (rn , cn), as a function of normalized geodetic latitude, longitude, and height, (P, L, H), given a set of normalized polynomial coefficients (LINE_NUM_COEF_n, LINE_DEN_COEF_n, SAMP_NUM_COEF_n, SAMP_DEN_COEF_n). Normalized values, rather than actual values are used in order to minimize introduction of errors during the calculations. The transformation between row and column values (r,c), and normalized row and column values (rn, cn), and between the geodetic latitude, longitude, and height and normalized geodetic latitude, longitude, and height (P, L, H), is defined by a set of normalizing translations (offsets) and scales that ensure all values are contained i the range -1 to +1.</p>
<p>This function creates a GDALTransformFunc compatible transformer for going between image pixel/line and long/lat/height coordinates using RPCs. The RPCs are provided in a <a class="el" href="structGDALRPCInfo.html" title="Structure to store Rational Polynomial Coefficients / Rigorous Projection Model. ">GDALRPCInfo</a> structure which is normally read from metadata using <a class="el" href="gdal_8h.html#a4f17f42304d641278fa57cae0aaa449f" title="Extract RPC info from metadata, and apply to an RPCInfo structure. ">GDALExtractRPCInfo()</a>.</p>
<p>GDAL RPC Metadata has the following entries (also described in GDAL RFC 22 and the GeoTIFF RPC document <a href="http://geotiff.maptools.org/rpc_prop.html">http://geotiff.maptools.org/rpc_prop.html</a> .</p>
<ul>
<li>
ERR_BIAS: Error - Bias. The RMS bias error in meters per horizontal axis of all points in the image (-1.0 if unknown) </li>
<li>
ERR_RAND: Error - Random. RMS random error in meters per horizontal axis of each point in the image (-1.0 if unknown) </li>
<li>
LINE_OFF: Line Offset </li>
<li>
SAMP_OFF: Sample Offset </li>
<li>
LAT_OFF: Geodetic Latitude Offset </li>
<li>
LONG_OFF: Geodetic Longitude Offset </li>
<li>
HEIGHT_OFF: Geodetic Height Offset </li>
<li>
LINE_SCALE: Line Scale </li>
<li>
SAMP_SCALE: Sample Scale </li>
<li>
LAT_SCALE: Geodetic Latitude Scale </li>
<li>
LONG_SCALE: Geodetic Longitude Scale </li>
<li>
<p class="startli">HEIGHT_SCALE: Geodetic Height Scale</p>
<p class="endli"></p>
</li>
<li>
LINE_NUM_COEFF (1-20): Line Numerator Coefficients. Twenty coefficients for the polynomial in the Numerator of the rn equation. (space separated) </li>
<li>
LINE_DEN_COEFF (1-20): Line Denominator Coefficients. Twenty coefficients for the polynomial in the Denominator of the rn equation. (space separated) </li>
<li>
SAMP_NUM_COEFF (1-20): Sample Numerator Coefficients. Twenty coefficients for the polynomial in the Numerator of the cn equation. (space separated) </li>
<li>
SAMP_DEN_COEFF (1-20): Sample Denominator Coefficients. Twenty coefficients for the polynomial in the Denominator of the cn equation. (space separated) </li>
</ul>
<p>The transformer normally maps from pixel/line/height to long/lat/height space as a forward transformation though in RPC terms that would be considered an inverse transformation (and is solved by iterative approximation using long/lat/height to pixel/line transformations). The default direction can be reversed by passing bReversed=TRUE.</p>
<p>The iterative solution of pixel/line to lat/long/height is currently run for up to 10 iterations or until the apparent error is less than dfPixErrThreshold pixels. Passing zero will not avoid all error, but will cause the operation to run for the maximum number of iterations.</p>
<p>Starting with GDAL 2.1, debugging of the RPC inverse transformer can be done by setting the RPC_INVERSE_VERBOSE configuration option to YES (in which case extra debug information will be displayed in the "RPC" debug category, so requiring CPL_DEBUG to be also set) and/or by setting RPC_INVERSE_LOG to a filename that will contain the content of iterations (this last option only makes sense when debugging point by point, since each time RPCInverseTransformPoint() is called, the file is rewritten).</p>
<p>Additional options to the transformer can be supplied in papszOptions.</p>
<p>Options:</p>
<ul>
<li>
<p class="startli">RPC_HEIGHT: a fixed height offset to be applied to all points passed in. In this situation the Z passed into the transformation function is assumed to be height above ground, and the RPC_HEIGHT is assumed to be an average height above sea level for ground in the target scene.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_HEIGHT_SCALE: a factor used to multiply heights above ground. Useful when elevation offsets of the DEM are not expressed in meters.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_DEM: the name of a GDAL dataset (a DEM file typically) used to extract elevation offsets from. In this situation the Z passed into the transformation function is assumed to be height above ground. This option should be used in replacement of RPC_HEIGHT to provide a way of defining a non uniform ground for the target scene</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_DEMINTERPOLATION: the DEM interpolation ("near", "bilinear" or "cubic"). Default is "bilinear".</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_DEM_MISSING_VALUE: value of DEM height that must be used in case the DEM has nodata value at the sampling point, or if its extent does not cover the requested coordinate. When not specified, missing values will cause a failed transform.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_DEM_APPLY_VDATUM_SHIFT: whether the vertical component of a compound SRS for the DEM should be used (when it is present). This is useful so as to be able to transform the "raw" values from the DEM expressed with respect to a geoid to the heights with respect to the WGS84 ellipsoid. When this is enabled, the GTIFF_REPORT_COMPD_CS configuration option will be also set temporarily so as to get the vertical information from GeoTIFF files. Defaults to TRUE. (GDAL &gt;= 2.1.0)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_PIXEL_ERROR_THRESHOLD: overrides the dfPixErrThreshold parameter, ie the error (measured in pixels) allowed in the iterative solution of pixel/line to lat/long computations (the other way is always exact given the equations). (GDAL &gt;= 2.1.0)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_MAX_ITERATIONS: maximum number of iterations allowed in the iterative solution of pixel/line to lat/long computations. Default value is 10 in the absence of a DEM, or 20 if there is a DEM. (GDAL &gt;= 2.1.0)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_FOOTPRINT: WKT or GeoJSON polygon (in long / lat coordinate space) with a validity footprint for the RPC. Any coordinate transformation that goes from or arrive outside this footprint will be considered invalid. This is useful in situations where the RPC values become highly unstable outside of the area on which they have been computed for, potentially leading to undesirable "echoes" / false positives. This requires GDAL to be built against GEOS.</p>
<p class="endli"></p>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psRPCInfo</td><td>Definition of the RPC parameters.</td></tr>
    <tr><td class="paramname">bReversed</td><td>If true "forward" transformation will be lat/long to pixel/line instead of the normal pixel/line to lat/long.</td></tr>
    <tr><td class="paramname">dfPixErrThreshold</td><td>the error (measured in pixels) allowed in the iterative solution of pixel/line to lat/long computations (the other way is always exact given the equations). Starting with GDAL 2.1, this may also be set through the RPC_PIXEL_ERROR_THRESHOLD transformer option. If a negative or null value is provided, then this defaults to 0.1 pixel.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>Other transformer options (i.e. RPC_HEIGHT=z).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformer callback data (deallocate with GDALDestroyTransformer()). </dd></dl>

</div>
</div>
<a id="a245802b88a8126c138d24febe6c9822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245802b88a8126c138d24febe6c9822a">&#9670;&nbsp;</a></span>GDALCreateTPSTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateTPSTransformer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGCPCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *&#160;</td>
          <td class="paramname"><em>pasGCPList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bReversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Thin Plate Spline transformer from GCPs. </p>
<p>The thin plate spline transformer produces exact transformation at all control points and smoothly varying transformations between control points with greatest influence from local control points. It is suitable for for many applications not well modeled by polynomial transformations.</p>
<p>Creating the TPS transformer involves solving systems of linear equations related to the number of control points involved. This solution is computed within this function call. It can be quite an expensive operation for large numbers of GCPs. For instance, for reference, it takes on the order of 10s for 400 GCPs on a 2GHz Athlon processor.</p>
<p>TPS Transformers are serializable.</p>
<p>The GDAL Thin Plate Spline transformer is based on code provided by Gilad Ronnen on behalf of VIZRT Inc (<a href="http://www.visrt.com">http://www.visrt.com</a>). Incorporation of the algorithm into GDAL was supported by the Centro di Ecologia Alpina (<a href="http://www.cealp.it">http://www.cealp.it</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nGCPCount</td><td>the number of GCPs in pasGCPList. </td></tr>
    <tr><td class="paramname">pasGCPList</td><td>an array of GCPs to be used as input. </td></tr>
    <tr><td class="paramname">bReversed</td><td>set it to TRUE to compute the reversed transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transform argument or NULL if creation fails. </dd></dl>

</div>
</div>
<a id="aa8a1fd0719f5405e856e2103b23f1d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a1fd0719f5405e856e2103b23f1d9c">&#9670;&nbsp;</a></span>GDALDestroyApproxTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyApproxTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCBData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup approximate transformer. </p>
<p>Deallocates the resources allocated by <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer. ">GDALCreateApproxTransformer()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCBData</td><td>callback data originally returned by <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer. ">GDALCreateApproxTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b1acbe5387ac769f7fee1de93b81011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1acbe5387ac769f7fee1de93b81011">&#9670;&nbsp;</a></span>GDALDestroyGCPTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyGCPTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy GCP transformer. </p>
<p>This function is used to destroy information about a GCP based polynomial transformation created with <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer. ">GDALCreateGCPTransformer()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformArg</td><td>the transform arg previously returned by <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer. ">GDALCreateGCPTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb383c4e5197e8e37ae1265cca8124d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb383c4e5197e8e37ae1265cca8124d">&#9670;&nbsp;</a></span>GDALDestroyGenImgProjTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyGenImgProjTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hTransformArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GenImgProjTransformer deallocator. </p>
<p>This function is used to deallocate the handle created with <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTransformArg</td><td>the handle to deallocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6cffb245df6fba275423f1333d89f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cffb245df6fba275423f1333d89f08">&#9670;&nbsp;</a></span>GDALDestroyReprojectionTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyReprojectionTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy reprojection transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformArg</td><td>the transformation handle returned by <a class="el" href="gdal__alg_8h.html#adce63548b884096e55d1685d4bbd7e63" title="Create reprojection transformer. ">GDALCreateReprojectionTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe5fccffbcc853230bc631441dc38469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5fccffbcc853230bc631441dc38469">&#9670;&nbsp;</a></span>GDALDestroyTPSTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyTPSTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy TPS transformer. </p>
<p>This function is used to destroy information about a GCP based polynomial transformation created with <a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a" title="Create Thin Plate Spline transformer from GCPs. ">GDALCreateTPSTransformer()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformArg</td><td>the transform arg previously returned by <a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a" title="Create Thin Plate Spline transformer from GCPs. ">GDALCreateTPSTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a284dbcc27295b7e678b1f7d4fa1506cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284dbcc27295b7e678b1f7d4fa1506cb">&#9670;&nbsp;</a></span>GDALDitherRGB2PCT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALDitherRGB2PCT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hRed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hGreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hBlue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a>&#160;</td>
          <td class="paramname"><em>hColorTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>24bit to 8bit conversion with dithering. </p>
<p>This functions utilizes Floyd-Steinberg dithering in the process of converting a 24bit RGB image into a pseudocolored 8bit image using a provided color table.</p>
<p>The red, green and blue input bands do not necessarily need to come from the same file, but they must be the same width and height. They will be clipped to 8bit during reading, so non-eight bit bands are generally inappropriate. Likewise the hTarget band will be written with 8bit values and must match the width and height of the source bands.</p>
<p>The color table cannot have more than 256 entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hRed</td><td>Red input band. </td></tr>
    <tr><td class="paramname">hGreen</td><td>Green input band. </td></tr>
    <tr><td class="paramname">hBlue</td><td>Blue input band. </td></tr>
    <tr><td class="paramname">hTarget</td><td>Output band. </td></tr>
    <tr><td class="paramname">hColorTable</td><td>the color table to use with the output band. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a id="a0a079afef61968f224b159d48423d1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a079afef61968f224b159d48423d1c6">&#9670;&nbsp;</a></span>GDALFillNodata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALFillNodata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hTargetBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxSearchDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDeprecatedOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSmoothingIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill selected raster regions by interpolation from the edges. </p>
<p>This algorithm will interpolate values for all designated nodata pixels (marked by zeros in hMaskBand). For each pixel a four direction conic search is done to find values to interpolate from (using inverse distance weighting). Once all values are interpolated, zero or more smoothing iterations (3x3 average filters on interpolated pixels) are applied to smooth out artifacts.</p>
<p>This algorithm is generally suitable for interpolating missing regions of fairly continuously varying rasters (such as elevation models for instance). It is also suitable for filling small holes and cracks in more irregularly varying images (like airphotos). It is generally not so great for interpolating a raster from sparse point data - see the algorithms defined in gdal_grid.h for that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTargetBand</td><td>the raster band to be modified in place. </td></tr>
    <tr><td class="paramname">hMaskBand</td><td>a mask band indicating pixels to be interpolated (zero valued). </td></tr>
    <tr><td class="paramname">dfMaxSearchDist</td><td>the maximum number of pixels to search in all directions to find values to interpolate from. </td></tr>
    <tr><td class="paramname">bDeprecatedOption</td><td>unused argument, should be zero. </td></tr>
    <tr><td class="paramname">nSmoothingIterations</td><td>the number of 3x3 smoothing filter passes to run (0 or more). </td></tr>
    <tr><td class="paramname">papszOptions</td><td>additional name=value options in a string list. <ul>
<li>
TEMP_FILE_DRIVER=gdal_driver_name. For example MEM. </li>
<li>
NODATA=value (starting with GDAL 2.4). Source pixels at that value will be ignored by the interpolator. Warning: currently this will not be honored by smoothing passes. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>the progress function to report completion. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="a7a789015334d677afcbef67e5a6b4a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a789015334d677afcbef67e5a6b4a7c">&#9670;&nbsp;</a></span>GDALFPolygonize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALFPolygonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hOutLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iPixValField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create polygon coverage from raster data. </p>
<p>This function creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Optionally each polygon may be labeled with the pixel value in an attribute. Optionally a mask band can be provided to determine which pixels are eligible for processing.</p>
<p>The source pixel band values are read into a 32bit float buffer. If you want to use a (probably faster) version using signed 32bit integer buffer, see <a class="el" href="gdal__alg_8h.html#a3f522a9035d3512b5d414fb4752671b1" title="Create polygon coverage from raster data. ">GDALPolygonize()</a>.</p>
<p>Polygon features will be created on the output layer, with polygon geometries representing the polygons. The polygon geometries will be in the georeferenced coordinate system of the image (based on the geotransform of the source dataset). It is acceptable for the output layer to already have features. Note that <a class="el" href="gdal__alg_8h.html#a7a789015334d677afcbef67e5a6b4a7c" title="Create polygon coverage from raster data. ">GDALFPolygonize()</a> does not set the coordinate system on the output layer. Application code should do this when the layer is created, presumably matching the raster coordinate system.</p>
<p>The algorithm used attempts to minimize memory use so that very large rasters can be processed. However, if the raster has many polygons or very large/complex polygons, the memory use for holding polygon enumerations and active polygon geometries may grow to be quite large.</p>
<p>The algorithm will generally produce very dense polygon geometries, with edges that follow exactly on pixel boundaries for all non-interior pixels. For non-thematic raster data (such as satellite images) the result will essentially be one small polygon per pixel, and memory and output layer sizes will be substantial. The algorithm is primarily intended for relatively simple thematic imagery, masks, and classification results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcBand</td><td>the source raster band to be processed. </td></tr>
    <tr><td class="paramname">hMaskBand</td><td>an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons. </td></tr>
    <tr><td class="paramname">hOutLayer</td><td>the vector feature layer to which the polygons should be written. </td></tr>
    <tr><td class="paramname">iPixValField</td><td>the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a name/value list of additional options <dl>
<dt>"8CONNECTED": May be set to "8" to use 8 connectedness. Otherwise 4 connectedness will be applied to the algorithm </dt>
<dd></dd>
</dl>
</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure on a failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a id="a9acdfd7db1541c1df5e29a031994d61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acdfd7db1541c1df5e29a031994d61b">&#9670;&nbsp;</a></span>GDALGCPTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALGCPTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panSuccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms point based on GCP derived polynomial model. </p>
<p>This function matches the GDALTransformerFunc signature, and can be used to transform one or more points from pixel/line coordinates to georeferenced coordinates (SrcToDst) or vice versa (DstToSrc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformArg</td><td>return value from <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer. ">GDALCreateGCPTransformer()</a>. </td></tr>
    <tr><td class="paramname">bDstToSrc</td><td>TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates. </td></tr>
    <tr><td class="paramname">nPointCount</td><td>the number of values in the x, y and z arrays. </td></tr>
    <tr><td class="paramname">x</td><td>array containing the X values to be transformed. </td></tr>
    <tr><td class="paramname">y</td><td>array containing the Y values to be transformed. </td></tr>
    <tr><td class="paramname">z</td><td>array containing the Z values to be transformed. </td></tr>
    <tr><td class="paramname">panSuccess</td><td>array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE. </dd></dl>

</div>
</div>
<a id="a109c26234c2f934164e29649353532b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109c26234c2f934164e29649353532b6">&#9670;&nbsp;</a></span>GDALGenImgProjTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALGenImgProjTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArgIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panSuccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform general image reprojection transformation. </p>
<p>Actually performs the transformation setup in <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer()</a>. This function matches the signature required by the <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc()</a>, and more details on the arguments can be found in that topic. </p>

</div>
</div>
<a id="a8a032e9bf590c95781321115df855cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a032e9bf590c95781321115df855cd2">&#9670;&nbsp;</a></span>GDALGetTransformerDstGeoTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALGetTransformerDstGeoTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfGeoTransform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ApproxTransformer or GenImgProj output geotransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformArg</td><td>transformer handle. </td></tr>
    <tr><td class="paramname">padfGeoTransform</td><td>(output) the destination geotransform to return (six doubles). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab95ca80bfa63d375c9242f8d10ba946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95ca80bfa63d375c9242f8d10ba946f">&#9670;&nbsp;</a></span>GDALGridContextCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gdal__alg_8h.html#a081f51e38cd0ac6d9e8a6e20a9a3332b">GDALGridContext</a>* GDALGridContextCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a>&#160;</td>
          <td class="paramname"><em>eAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bCallerWillKeepPointArraysAlive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a context to do regular gridding from the scattered data. </p>
<p>This function takes the arrays of X and Y coordinates and corresponding Z values as input to prepare computation of regular grid (or call it a raster) from these scattered data.</p>
<p>On Intel/AMD i386/x86_64 architectures, some gridding methods will be optimized with SSE instructions (provided GDAL has been compiled with such support, and it is available at runtime). Currently, only 'invdist' algorithm with default parameters has an optimized implementation. This can provide substantial speed-up, but sometimes at the expense of reduced floating point precision. This can be disabled by setting the GDAL_USE_SSE configuration option to NO. A further optimized version can use the AVX instruction set. This can be disabled by setting the GDAL_USE_AVX configuration option to NO.</p>
<p>It is possible to set the GDAL_NUM_THREADS configuration option to parallelize the processing. The value to set is the number of worker threads, or ALL_CPUS to use all the cores/CPUs of the computer (default value).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eAlgorithm</td><td>Gridding method. </td></tr>
    <tr><td class="paramname">poOptions</td><td>Options to control chosen gridding method. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">bCallerWillKeepPointArraysAlive</td><td>Whether the provided padfX, padfY, padfZ arrays will still be "alive" during the calls to <a class="el" href="gdal__alg_8h.html#a7da520568b6aaa37d76396d668f96390" title="Do the gridding of a window of a raster. ">GDALGridContextProcess()</a>. Setting to TRUE prevent them from being duplicated in the context. If unsure, set to FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the context (to be freed with <a class="el" href="gdal__alg_8h.html#a1d2d6dce1e7b14d8a26e03fb52e37286" title="Free a context used created by GDALGridContextCreate() ">GDALGridContextFree()</a>) or NULL in case or error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a1d2d6dce1e7b14d8a26e03fb52e37286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2d6dce1e7b14d8a26e03fb52e37286">&#9670;&nbsp;</a></span>GDALGridContextFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALGridContextFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a081f51e38cd0ac6d9e8a6e20a9a3332b">GDALGridContext</a> *&#160;</td>
          <td class="paramname"><em>psContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a context used created by <a class="el" href="gdal__alg_8h.html#ab95ca80bfa63d375c9242f8d10ba946f" title="Creates a context to do regular gridding from the scattered data. ">GDALGridContextCreate()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psContext</td><td>the context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a7da520568b6aaa37d76396d668f96390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da520568b6aaa37d76396d668f96390">&#9670;&nbsp;</a></span>GDALGridContextProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridContextProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a081f51e38cd0ac6d9e8a6e20a9a3332b">GDALGridContext</a> *&#160;</td>
          <td class="paramname"><em>psContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nYSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&#160;</td>
          <td class="paramname"><em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do the gridding of a window of a raster. </p>
<p>This function takes the gridding context as input to preprare computation of regular grid (or call it a raster) from these scattered data. You should supply the extent of the output grid and allocate array sufficient to hold such a grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psContext</td><td>Gridding context. </td></tr>
    <tr><td class="paramname">dfXMin</td><td>Lowest X border of output grid. </td></tr>
    <tr><td class="paramname">dfXMax</td><td>Highest X border of output grid. </td></tr>
    <tr><td class="paramname">dfYMin</td><td>Lowest Y border of output grid. </td></tr>
    <tr><td class="paramname">dfYMax</td><td>Highest Y border of output grid. </td></tr>
    <tr><td class="paramname">nXSize</td><td>Number of columns in output grid. </td></tr>
    <tr><td class="paramname">nYSize</td><td>Number of rows in output grid. </td></tr>
    <tr><td class="paramname">eType</td><td>Data type of output array. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to array where the computed grid will be stored. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a1fdef40bcdbc98eff2328b0d093d3a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdef40bcdbc98eff2328b0d093d3a22">&#9670;&nbsp;</a></span>GDALGridCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALGridCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a>&#160;</td>
          <td class="paramname"><em>eAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfYMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#aa623244ca15b034795eb015e4dec224d">GUInt32</a>&#160;</td>
          <td class="paramname"><em>nYSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&#160;</td>
          <td class="paramname"><em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create regular grid from the scattered data. </p>
<p>This function takes the arrays of X and Y coordinates and corresponding Z values as input and computes regular grid (or call it a raster) from these scattered data. You should supply geometry and extent of the output grid and allocate array sufficient to hold such a grid.</p>
<p>Starting with GDAL 1.10, it is possible to set the GDAL_NUM_THREADS configuration option to parallelize the processing. The value to set is the number of worker threads, or ALL_CPUS to use all the cores/CPUs of the computer (default value).</p>
<p>Starting with GDAL 1.10, on Intel/AMD i386/x86_64 architectures, some gridding methods will be optimized with SSE instructions (provided GDAL has been compiled with such support, and it is available at runtime). Currently, only 'invdist' algorithm with default parameters has an optimized implementation. This can provide substantial speed-up, but sometimes at the expense of reduced floating point precision. This can be disabled by setting the GDAL_USE_SSE configuration option to NO. Starting with GDAL 1.11, a further optimized version can use the AVX instruction set. This can be disabled by setting the GDAL_USE_AVX configuration option to NO.</p>
<p>Note: it will be more efficient to use <a class="el" href="gdal__alg_8h.html#ab95ca80bfa63d375c9242f8d10ba946f" title="Creates a context to do regular gridding from the scattered data. ">GDALGridContextCreate()</a>, <a class="el" href="gdal__alg_8h.html#a7da520568b6aaa37d76396d668f96390" title="Do the gridding of a window of a raster. ">GDALGridContextProcess()</a> and <a class="el" href="gdal__alg_8h.html#a1d2d6dce1e7b14d8a26e03fb52e37286" title="Free a context used created by GDALGridContextCreate() ">GDALGridContextFree()</a> when doing repeated gridding operations with the same algorithm, parameters and points, and moving the window in the output grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eAlgorithm</td><td>Gridding method. </td></tr>
    <tr><td class="paramname">poOptions</td><td>Options to control chosen gridding method. </td></tr>
    <tr><td class="paramname">nPoints</td><td>Number of elements in input arrays. </td></tr>
    <tr><td class="paramname">padfX</td><td>Input array of X coordinates. </td></tr>
    <tr><td class="paramname">padfY</td><td>Input array of Y coordinates. </td></tr>
    <tr><td class="paramname">padfZ</td><td>Input array of Z values. </td></tr>
    <tr><td class="paramname">dfXMin</td><td>Lowest X border of output grid. </td></tr>
    <tr><td class="paramname">dfXMax</td><td>Highest X border of output grid. </td></tr>
    <tr><td class="paramname">dfYMin</td><td>Lowest Y border of output grid. </td></tr>
    <tr><td class="paramname">dfYMax</td><td>Highest Y border of output grid. </td></tr>
    <tr><td class="paramname">nXSize</td><td>Number of columns in output grid. </td></tr>
    <tr><td class="paramname">nYSize</td><td>Number of rows in output grid. </td></tr>
    <tr><td class="paramname">eType</td><td>Data type of output array. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to array where the computed grid will be stored. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a id="aadb871f9f1bb30353e681c38a83c685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb871f9f1bb30353e681c38a83c685a">&#9670;&nbsp;</a></span>GDALHasTriangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALHasTriangulation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if GDAL is built with Delaunay triangulation support. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if GDAL is built with Delaunay triangulation support.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a64e6a52db0d3bd8dd1aba937a0e8b052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e6a52db0d3bd8dd1aba937a0e8b052">&#9670;&nbsp;</a></span>GDALOpenVerticalShiftGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> GDALOpenVerticalShiftGrid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszProj4Geoidgrids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load proj.4 geoidgrids as GDAL dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszProj4Geoidgrids</td><td>Value of proj.4 geoidgrids parameter. </td></tr>
    <tr><td class="paramname">pbError</td><td>If not NULL, the pointed value will be set to TRUE if an error occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dataset. If not NULL, it must be closed with <a class="el" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc" title="Close GDAL dataset. ">GDALClose()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a3f522a9035d3512b5d414fb4752671b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f522a9035d3512b5d414fb4752671b1">&#9670;&nbsp;</a></span>GDALPolygonize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALPolygonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hOutLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iPixValField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create polygon coverage from raster data. </p>
<p>This function creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Optionally each polygon may be labeled with the pixel value in an attribute. Optionally a mask band can be provided to determine which pixels are eligible for processing.</p>
<p>Note that currently the source pixel band values are read into a signed 32bit integer buffer (Int32), so floating point or complex bands will be implicitly truncated before processing. If you want to use a version using 32bit float buffers, see <a class="el" href="gdal__alg_8h.html#a7a789015334d677afcbef67e5a6b4a7c" title="Create polygon coverage from raster data. ">GDALFPolygonize()</a>.</p>
<p>Polygon features will be created on the output layer, with polygon geometries representing the polygons. The polygon geometries will be in the georeferenced coordinate system of the image (based on the geotransform of the source dataset). It is acceptable for the output layer to already have features. Note that <a class="el" href="gdal__alg_8h.html#a3f522a9035d3512b5d414fb4752671b1" title="Create polygon coverage from raster data. ">GDALPolygonize()</a> does not set the coordinate system on the output layer. Application code should do this when the layer is created, presumably matching the raster coordinate system.</p>
<p>The algorithm used attempts to minimize memory use so that very large rasters can be processed. However, if the raster has many polygons or very large/complex polygons, the memory use for holding polygon enumerations and active polygon geometries may grow to be quite large.</p>
<p>The algorithm will generally produce very dense polygon geometries, with edges that follow exactly on pixel boundaries for all non-interior pixels. For non-thematic raster data (such as satellite images) the result will essentially be one small polygon per pixel, and memory and output layer sizes will be substantial. The algorithm is primarily intended for relatively simple thematic imagery, masks, and classification results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcBand</td><td>the source raster band to be processed. </td></tr>
    <tr><td class="paramname">hMaskBand</td><td>an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons. </td></tr>
    <tr><td class="paramname">hOutLayer</td><td>the vector feature layer to which the polygons should be written. </td></tr>
    <tr><td class="paramname">iPixValField</td><td>the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a name/value list of additional options <dl>
<dt>"8CONNECTED": May be set to "8" to use 8 connectedness. Otherwise 4 connectedness will be applied to the algorithm </dt>
<dd></dd>
</dl>
</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure on a failure. </dd></dl>

</div>
</div>
<a id="a50caf4bc34703f0bcf515ecbe5061a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50caf4bc34703f0bcf515ecbe5061a0a">&#9670;&nbsp;</a></span>GDALRasterizeGeometries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALRasterizeGeometries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBandCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panBandList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGeomCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>pahGeometries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfGeomBurnValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Burn geometries into raster. </p>
<p>Rasterize a list of geometric objects into a raster dataset. The geometries are passed as an array of OGRGeometryH handlers.</p>
<p>If the geometries are in the georeferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates on the raster dataset.</p>
<p>The output raster may be of any GDAL supported datatype, though currently internally the burning is done either as GDT_Byte or GDT_Float32. This may be improved in the future. An explicit list of burn values for each geometry for each band must be passed in.</p>
<p>The papszOption list of options currently only supports one option. The "ALL_TOUCHED" option may be enabled by setting it to "TRUE".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>output data, must be opened in update mode. </td></tr>
    <tr><td class="paramname">nBandCount</td><td>the number of bands to be updated. </td></tr>
    <tr><td class="paramname">panBandList</td><td>the list of bands to be updated. </td></tr>
    <tr><td class="paramname">nGeomCount</td><td>the number of geometries being passed in pahGeometries. </td></tr>
    <tr><td class="paramname">pahGeometries</td><td>the array of geometries to burn in. </td></tr>
    <tr><td class="paramname">pfnTransformer</td><td>transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally. </td></tr>
    <tr><td class="paramname">pTransformArg</td><td>callback data for transformer. </td></tr>
    <tr><td class="paramname">padfGeomBurnValue</td><td>the array of values to burn into the raster. There should be nBandCount values for each geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>special options controlling rasterization <ul>
<li>
"ALL_TOUCHED": May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </li>
<li>
"BURN_VALUE_FROM": May be set to "Z" to use the Z values of the geometries. dfBurnValue is added to this before burning. Defaults to GDALBurnValueSrc.GBV_UserBurnValue in which case just the dfBurnValue is burned. This is implemented only for points and lines for now. The M value may be supported in the future. </li>
<li>
"MERGE_ALG": May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </li>
<li>
"CHUNKYSIZE": The height in lines of the chunk to operate on. The larger the chunk size the less times we need to make a pass through all the shapes. If it is not set or set to zero the default chunk size will be used. Default size will be estimated based on the GDAL cache buffer size using formula: cache_size_bytes/scanline_size_bytes, so the chunk will not exceed the cache. Not used in OPTIM=RASTER mode. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>the progress function to report completion. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure on error.</dd></dl>
<p><b>Example</b><br />
 GDALRasterizeGeometries rasterize output to MEM Dataset :<br />
 </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> nBufXSize      = 1024;</div><div class="line"><span class="keywordtype">int</span> nBufYSize      = 1024;</div><div class="line"><span class="keywordtype">int</span> nBandCount     = 1;</div><div class="line"><a class="code" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> eType = <a class="code" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4a38a66c26861d368e95ba42106ee3ab92">GDT_Byte</a>;</div><div class="line"><span class="keywordtype">int</span> nDataTypeSize  = <a class="code" href="gdal_8h.html#a94434a7edc8b22959639d1d5210af24d">GDALGetDataTypeSizeBytes</a>(eType);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span>* pData = <a class="code" href="cpl__conv_8h.html#a638021df488a13e18115e2e0c013bef0">CPLCalloc</a>( nBufXSize*nBufYSize*nBandCount, nDataTypeSize );</div><div class="line"><span class="keywordtype">char</span> memdsetpath[1024];</div><div class="line">sprintf(memdsetpath,<span class="stringliteral">&quot;MEM:::DATAPOINTER=0x%p,PIXELS=%d,LINES=%d,&quot;</span></div><div class="line">        <span class="stringliteral">&quot;BANDS=%d,DATATYPE=%s,PIXELOFFSET=%d,LINEOFFSET=%d&quot;</span>,</div><div class="line">        pData,nBufXSize,nBufYSize,nBandCount,<a class="code" href="gdal_8h.html#a33b543bd0b1e36598abb7fa9fd39add7">GDALGetDataTypeName</a>(eType),</div><div class="line">        nBandCount*nDataTypeSize, nBufXSize*nBandCount*nDataTypeSize );</div><div class="line"></div><div class="line"> <span class="comment">// Open Memory Dataset</span></div><div class="line"> <a class="code" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hMemDset = <a class="code" href="gdal_8h.html#a6836f0f810396c5e45622c8ef94624d4">GDALOpen</a>(memdsetpath, <a class="code" href="gdal_8h.html#a045e3967c208993f70257bfd40c9f1d7a61c6081de474ef2a756982d3c53130a2">GA_Update</a>);</div><div class="line"> <span class="comment">// or create it as follows</span></div><div class="line"> <span class="comment">// GDALDriverH hMemDriver = GDALGetDriverByName(&quot;MEM&quot;);</span></div><div class="line"> <span class="comment">// GDALDatasetH hMemDset = GDALCreate(hMemDriver, &quot;&quot;, nBufXSize, nBufYSize, nBandCount, eType, NULL);</span></div><div class="line"></div><div class="line"> <span class="keywordtype">double</span> adfGeoTransform[6];</div><div class="line"> <span class="comment">// Assign GeoTransform parameters,Omitted here.</span></div><div class="line"></div><div class="line"> <a class="code" href="gdal_8h.html#ae93448112c1a7e69f2764c1aa3c6c8b5">GDALSetGeoTransform</a>(hMemDset,adfGeoTransform);</div><div class="line"> <a class="code" href="gdal_8h.html#a145f2be5db1ac31a07a9d4389f4ace65">GDALSetProjection</a>(hMemDset,pszProjection); <span class="comment">// Can not</span></div><div class="line"> </div><div class="line"> <span class="comment">// Do something ...</span></div><div class="line"> <span class="comment">// Need an array of OGRGeometry objects,The assumption here is pahGeoms</span></div><div class="line"> </div><div class="line"> <span class="keywordtype">int</span> bandList[3] = { 1, 2, 3};</div><div class="line"> std::vector&lt;double&gt; geomBurnValue(nGeomCount*nBandCount,255.0);</div><div class="line"> <a class="code" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> err = <a class="code" href="gdal__alg_8h.html#a50caf4bc34703f0bcf515ecbe5061a0a">GDALRasterizeGeometries</a>(hMemDset, nBandCount, bandList,</div><div class="line">                         nGeomCount, pahGeoms, pfnTransformer, pTransformArg,</div><div class="line">                         geomBurnValue.data(), papszOptions,</div><div class="line">                         pfnProgress, pProgressArg);</div><div class="line"> <span class="keywordflow">if</span>( err != CE_None )</div><div class="line"> {</div><div class="line">     <span class="comment">// Do something ...</span></div><div class="line"> }</div><div class="line"> <a class="code" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc">GDALClose</a>(hMemDset);</div><div class="line"> <a class="code" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48">CPLFree</a>(pData);</div></div><!-- fragment --> 
</div>
</div>
<a id="adfe5e5d287d6c184aab03acbfa567cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe5e5d287d6c184aab03acbfa567cb1">&#9670;&nbsp;</a></span>GDALRasterizeLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALRasterizeLayers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBandCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panBandList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLayerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> *&#160;</td>
          <td class="paramname"><em>pahLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfLayerBurnValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Burn geometries from the specified list of layers into raster. </p>
<p>Rasterize all the geometric objects from a list of layers into a raster dataset. The layers are passed as an array of OGRLayerH handlers.</p>
<p>If the geometries are in the georeferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates on the raster dataset.</p>
<p>The output raster may be of any GDAL supported datatype, though currently internally the burning is done either as GDT_Byte or GDT_Float32. This may be improved in the future. An explicit list of burn values for each layer for each band must be passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>output data, must be opened in update mode. </td></tr>
    <tr><td class="paramname">nBandCount</td><td>the number of bands to be updated. </td></tr>
    <tr><td class="paramname">panBandList</td><td>the list of bands to be updated. </td></tr>
    <tr><td class="paramname">nLayerCount</td><td>the number of layers being passed in pahLayers array. </td></tr>
    <tr><td class="paramname">pahLayers</td><td>the array of layers to burn in. </td></tr>
    <tr><td class="paramname">pfnTransformer</td><td>transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally. </td></tr>
    <tr><td class="paramname">pTransformArg</td><td>callback data for transformer. </td></tr>
    <tr><td class="paramname">padfLayerBurnValues</td><td>the array of values to burn into the raster. There should be nBandCount values for each layer. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>special options controlling rasterization: <ul>
<li>
"ATTRIBUTE": Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </li>
<li>
"CHUNKYSIZE": The height in lines of the chunk to operate on. The larger the chunk size the less times we need to make a pass through all the shapes. If it is not set or set to zero the default chunk size will be used. Default size will be estimated based on the GDAL cache buffer size using formula: cache_size_bytes/scanline_size_bytes, so the chunk will not exceed the cache. </li>
<li>
"ALL_TOUCHED": May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </li>
<li>
"BURN_VALUE_FROM": May be set to "Z" to use the Z values of the geometries. The value from padfLayerBurnValues or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </li>
<li>
"MERGE_ALG": May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>the progress function to report completion. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure on error. </dd></dl>

</div>
</div>
<a id="ab791949af233e16c119e4f49ee573cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab791949af233e16c119e4f49ee573cae">&#9670;&nbsp;</a></span>GDALRasterizeLayersBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALRasterizeLayersBuf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBufXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBufYSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&#160;</td>
          <td class="paramname"><em>eBufType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPixelSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLineSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLayerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> *&#160;</td>
          <td class="paramname"><em>pahLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDstProjection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfDstGeoTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfBurnValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Burn geometries from the specified list of layer into raster. </p>
<p>Rasterize all the geometric objects from a list of layers into supplied raster buffer. The layers are passed as an array of OGRLayerH handlers.</p>
<p>If the geometries are in the georeferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates of the target raster.</p>
<p>The output raster may be of any GDAL supported datatype(non complex).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>pointer to the output data array.</td></tr>
    <tr><td class="paramname">nBufXSize</td><td>width of the output data array in pixels.</td></tr>
    <tr><td class="paramname">nBufYSize</td><td>height of the output data array in pixels.</td></tr>
    <tr><td class="paramname">eBufType</td><td>data type of the output data array.</td></tr>
    <tr><td class="paramname">nPixelSpace</td><td>The byte offset from the start of one pixel value in pData to the start of the next pixel value within a scanline. If defaulted (0) the size of the datatype eBufType is used.</td></tr>
    <tr><td class="paramname">nLineSpace</td><td>The byte offset from the start of one scanline in pData to the start of the next. If defaulted the size of the datatype eBufType * nBufXSize is used.</td></tr>
    <tr><td class="paramname">nLayerCount</td><td>the number of layers being passed in pahLayers array.</td></tr>
    <tr><td class="paramname">pahLayers</td><td>the array of layers to burn in.</td></tr>
    <tr><td class="paramname">pszDstProjection</td><td>WKT defining the coordinate system of the target raster.</td></tr>
    <tr><td class="paramname">padfDstGeoTransform</td><td>geotransformation matrix of the target raster.</td></tr>
    <tr><td class="paramname">pfnTransformer</td><td>transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally.</td></tr>
    <tr><td class="paramname">pTransformArg</td><td>callback data for transformer.</td></tr>
    <tr><td class="paramname">dfBurnValue</td><td>the value to burn into the raster.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>special options controlling rasterization: <ul>
<li>
"ATTRIBUTE": Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </li>
<li>
"ALL_TOUCHED": May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </li>
<li>
"BURN_VALUE_FROM": May be set to "Z" to use the Z values of the geometries. dfBurnValue or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </li>
<li>
"MERGE_ALG": May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>the progress function to report completion.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure on error. </dd></dl>

</div>
</div>
<a id="af00f74e03c57842b359130ca73857521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00f74e03c57842b359130ca73857521">&#9670;&nbsp;</a></span>GDALReprojectionTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALReprojectionTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panSuccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform reprojection transformation. </p>
<p>Actually performs the reprojection transformation described in <a class="el" href="gdal__alg_8h.html#adce63548b884096e55d1685d4bbd7e63" title="Create reprojection transformer. ">GDALCreateReprojectionTransformer()</a>. This function matches the <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc()</a> signature. Details of the arguments are described there. </p>

</div>
</div>
<a id="a18e841864cf6d93596626981d26c3000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e841864cf6d93596626981d26c3000">&#9670;&nbsp;</a></span>GDALSetGenImgProjTransformerDstGeoTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALSetGenImgProjTransformerDstGeoTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfGeoTransform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set GenImgProj output geotransform. </p>
<p>Normally the "destination geotransform", or transformation between georeferenced output coordinates and pixel/line coordinates on the destination file is extracted from the destination file by <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer()</a> and stored in the GenImgProj private info. However, sometimes it is inconvenient to have an output file handle with appropriate geotransform information when creating the transformation. For these cases, this function can be used to apply the destination geotransform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTransformArg</td><td>the handle to update. </td></tr>
    <tr><td class="paramname">padfGeoTransform</td><td>the destination geotransform to apply (six doubles). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac55a29540c5af804a75818eeaabfbfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55a29540c5af804a75818eeaabfbfd4">&#9670;&nbsp;</a></span>GDALSetTransformerDstGeoTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALSetTransformerDstGeoTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfGeoTransform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ApproxTransformer or GenImgProj output geotransform. </p>
<p>This is a layer above <a class="el" href="gdal__alg_8h.html#a18e841864cf6d93596626981d26c3000" title="Set GenImgProj output geotransform. ">GDALSetGenImgProjTransformerDstGeoTransform()</a> that checks that the passed hTransformArg is compatible.</p>
<p>Normally the "destination geotransform", or transformation between georeferenced output coordinates and pixel/line coordinates on the destination file is extracted from the destination file by <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer()</a> and stored in the GenImgProj private info. However, sometimes it is inconvenient to have an output file handle with appropriate geotransform information when creating the transformation. For these cases, this function can be used to apply the destination geotransform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformArg</td><td>the handle to update. </td></tr>
    <tr><td class="paramname">padfGeoTransform</td><td>the destination geotransform to apply (six doubles). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33309c0a316b223bd33ae5753cc7f616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33309c0a316b223bd33ae5753cc7f616">&#9670;&nbsp;</a></span>GDALSieveFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALSieveFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hDstBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSizeThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nConnectedness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes small raster polygons. </p>
<p>The function removes raster polygons smaller than a provided threshold size (in pixels) and replaces replaces them with the pixel value of the largest neighbour polygon.</p>
<p>Polygon are determined (per GDALRasterPolygonEnumerator) as regions of the raster where the pixels all have the same value, and that are contiguous (connected).</p>
<p>Pixels determined to be "nodata" per hMaskBand will not be treated as part of a polygon regardless of their pixel values. Nodata areas will never be changed nor affect polygon sizes.</p>
<p>Polygons smaller than the threshold with no neighbours that are as large as the threshold will not be altered. Polygons surrounded by nodata areas will therefore not be altered.</p>
<p>The algorithm makes three passes over the input file to enumerate the polygons and collect limited information about them. Memory use is proportional to the number of polygons (roughly 24 bytes per polygon), but is not directly related to the size of the raster. So very large raster files can be processed effectively if there aren't too many polygons. But extremely noisy rasters with many one pixel polygons will end up being expensive (in memory) to process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcBand</td><td>the source raster band to be processed. </td></tr>
    <tr><td class="paramname">hMaskBand</td><td>an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for inclusion in polygons. </td></tr>
    <tr><td class="paramname">hDstBand</td><td>the output raster band. It may be the same as hSrcBand to update the source in place. </td></tr>
    <tr><td class="paramname">nSizeThreshold</td><td>raster polygons with sizes smaller than this will be merged into their largest neighbour. </td></tr>
    <tr><td class="paramname">nConnectedness</td><td>either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>algorithm options in name=value list form. None currently supported. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a id="ae15910acb317cef94f3fd49dca6e4bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15910acb317cef94f3fd49dca6e4bab">&#9670;&nbsp;</a></span>GDALSimpleImageWarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALSimpleImageWarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hDstDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBandCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panBandList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszWarpOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform simple image warp. </p>
<p>Copies an image from a source dataset to a destination dataset applying an application defined transformation. This algorithm is called simple because it lacks many options such as resampling kernels (other than nearest neighbour), support for data types other than 8bit, and the ability to warp images without holding the entire source and destination image in memory.</p>
<p>The following option(s) may be passed in papszWarpOptions. </p><ul>
<li>
"INIT=v[,v...]": This option indicates that the output dataset should be initialized to the indicated value in any area valid data is not written. Distinct values may be listed for each band separated by columns. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcDS</td><td>the source image dataset. </td></tr>
    <tr><td class="paramname">hDstDS</td><td>the destination image dataset. </td></tr>
    <tr><td class="paramname">nBandCount</td><td>the number of bands to be warped. If zero, all bands will be processed. </td></tr>
    <tr><td class="paramname">panBandList</td><td>the list of bands to translate. </td></tr>
    <tr><td class="paramname">pfnTransform</td><td>the transformation function to call. See <a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc()</a>. </td></tr>
    <tr><td class="paramname">pTransformArg</td><td>the callback handle to pass to pfnTransform. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>the function used to report progress. See GDALProgressFunc(). </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>the callback handle to pass to pfnProgress. </td></tr>
    <tr><td class="paramname">papszWarpOptions</td><td>additional options controlling the warp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation completes, or FALSE if an error occurs. </dd></dl>

</div>
</div>
<a id="a816819e7495bfce06dbd110f7c57af65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816819e7495bfce06dbd110f7c57af65">&#9670;&nbsp;</a></span>GDALSuggestedWarpOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALSuggestedWarpOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfGeoTransformOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnLines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suggest output file size. </p>
<p>This function is used to suggest the size, and georeferenced extents appropriate given the indicated transformation and input file. It walks the edges of the input file (approximately 20 sample points along each edge) transforming into output coordinates in order to get an extents box.</p>
<p>Then a resolution is computed with the intent that the length of the distance from the top left corner of the output imagery to the bottom right corner would represent the same number of pixels as in the source image. Note that if the image is somewhat rotated the diagonal taken isn't of the whole output bounding rectangle, but instead of the locations where the top/left and bottom/right corners transform. The output pixel size is always square. This is intended to approximately preserve the resolution of the input data in the output file.</p>
<p>The values returned in padfGeoTransformOut, pnPixels and pnLines are the suggested number of pixels and lines for the output file, and the geotransform relating those pixels to the output georeferenced coordinates.</p>
<p>The trickiest part of using the function is ensuring that the transformer created is from source file pixel/line coordinates to output file georeferenced coordinates. This can be accomplished with <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer()</a> by passing a NULL for the hDstDS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcDS</td><td>the input image (it is assumed the whole input images is being transformed). </td></tr>
    <tr><td class="paramname">pfnTransformer</td><td>the transformer function. </td></tr>
    <tr><td class="paramname">pTransformArg</td><td>the callback data for the transformer function. </td></tr>
    <tr><td class="paramname">padfGeoTransformOut</td><td>the array of six doubles in which the suggested geotransform is returned. </td></tr>
    <tr><td class="paramname">pnPixels</td><td>int in which the suggest pixel width of output is returned. </td></tr>
    <tr><td class="paramname">pnLines</td><td>int in which the suggest pixel height of output is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None if successful or CE_Failure otherwise. </dd></dl>

</div>
</div>
<a id="a8ae26881b86e42ff958a8e81c4976fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae26881b86e42ff958a8e81c4976fb3">&#9670;&nbsp;</a></span>GDALSuggestedWarpOutput2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALSuggestedWarpOutput2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&#160;</td>
          <td class="paramname"><em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfGeoTransformOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suggest output file size. </p>
<p>This function is used to suggest the size, and georeferenced extents appropriate given the indicated transformation and input file. It walks the edges of the input file (approximately 20 sample points along each edge) transforming into output coordinates in order to get an extents box.</p>
<p>Then a resolution is computed with the intent that the length of the distance from the top left corner of the output imagery to the bottom right corner would represent the same number of pixels as in the source image. Note that if the image is somewhat rotated the diagonal taken isn't of the whole output bounding rectangle, but instead of the locations where the top/left and bottom/right corners transform. The output pixel size is always square. This is intended to approximately preserve the resolution of the input data in the output file.</p>
<p>The values returned in padfGeoTransformOut, pnPixels and pnLines are the suggested number of pixels and lines for the output file, and the geotransform relating those pixels to the output georeferenced coordinates.</p>
<p>The trickiest part of using the function is ensuring that the transformer created is from source file pixel/line coordinates to output file georeferenced coordinates. This can be accomplished with <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer. ">GDALCreateGenImgProjTransformer()</a> by passing a NULL for the hDstDS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSrcDS</td><td>the input image (it is assumed the whole input images is being transformed). </td></tr>
    <tr><td class="paramname">pfnTransformer</td><td>the transformer function. </td></tr>
    <tr><td class="paramname">pTransformArg</td><td>the callback data for the transformer function. </td></tr>
    <tr><td class="paramname">padfGeoTransformOut</td><td>the array of six doubles in which the suggested geotransform is returned. </td></tr>
    <tr><td class="paramname">pnPixels</td><td>int in which the suggest pixel width of output is returned. </td></tr>
    <tr><td class="paramname">pnLines</td><td>int in which the suggest pixel height of output is returned. </td></tr>
    <tr><td class="paramname">padfExtent</td><td>Four entry array to return extents as (xmin, ymin, xmax, ymax). </td></tr>
    <tr><td class="paramname">nOptions</td><td>Options, currently always zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None if successful or CE_Failure otherwise. </dd></dl>

</div>
</div>
<a id="ab8ba2028a33f1f4eede6fc05ded7cbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ba2028a33f1f4eede6fc05ded7cbd6">&#9670;&nbsp;</a></span>GDALTPSTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALTPSTransform </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panSuccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms point based on GCP derived polynomial model. </p>
<p>This function matches the GDALTransformerFunc signature, and can be used to transform one or more points from pixel/line coordinates to georeferenced coordinates (SrcToDst) or vice versa (DstToSrc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTransformArg</td><td>return value from <a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a" title="Create Thin Plate Spline transformer from GCPs. ">GDALCreateTPSTransformer()</a>. </td></tr>
    <tr><td class="paramname">bDstToSrc</td><td>TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates. </td></tr>
    <tr><td class="paramname">nPointCount</td><td>the number of values in the x, y and z arrays. </td></tr>
    <tr><td class="paramname">x</td><td>array containing the X values to be transformed. </td></tr>
    <tr><td class="paramname">y</td><td>array containing the Y values to be transformed. </td></tr>
    <tr><td class="paramname">z</td><td>array containing the Z values to be transformed. </td></tr>
    <tr><td class="paramname">panSuccess</td><td>array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE. </dd></dl>

</div>
</div>
<a id="a89ce288fe21fe395fc93c0026419f494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ce288fe21fe395fc93c0026419f494">&#9670;&nbsp;</a></span>GDALTransformGeolocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALTransformGeolocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hXBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hYBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hZBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aaede67ca444a06f0a6fed538e05d2220">GDALTransformerFunc</a>&#160;</td>
          <td class="paramname"><em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform locations held in bands. </p>
<p>The X/Y and possibly Z values in the identified bands are transformed using a spatial transformer. The changes values are written back to the source bands so they need to updatable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hXBand</td><td>the band containing the X locations (usually long/easting). </td></tr>
    <tr><td class="paramname">hYBand</td><td>the band containing the Y locations (usually lat/northing). </td></tr>
    <tr><td class="paramname">hZBand</td><td>the band containing the Z locations (may be NULL). </td></tr>
    <tr><td class="paramname">pfnTransformer</td><td>the transformer function. </td></tr>
    <tr><td class="paramname">pTransformArg</td><td>the callback data for the transformer function. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td class="paramname">pProgressArg</td><td>callback argument passed to pfnProgress. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>list of name/value options - none currently supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a id="a99cb9c1fa87a9054fcfe9f5f45720fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cb9c1fa87a9054fcfe9f5f45720fa9">&#9670;&nbsp;</a></span>GDALTriangulationComputeBarycentricCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALTriangulationComputeBarycentricCoefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *&#160;</td>
          <td class="paramname"><em>psDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes barycentric coefficients for each triangles of the triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDT</td><td>triangulation. </td></tr>
    <tr><td class="paramname">padfX</td><td>x coordinates of the points. Must be identical to the one passed to <a class="el" href="gdal__alg_8h.html#a498205ae5f4f0ec9f43e5c65bb392060" title="Computes a Delaunay triangulation of the passed points. ">GDALTriangulationCreateDelaunay()</a>. </td></tr>
    <tr><td class="paramname">padfY</td><td>y coordinates of the points. Must be identical to the one passed to <a class="el" href="gdal__alg_8h.html#a498205ae5f4f0ec9f43e5c65bb392060" title="Computes a Delaunay triangulation of the passed points. ">GDALTriangulationCreateDelaunay()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a2f846755f21f789d7a41ce2825713ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f846755f21f789d7a41ce2825713ee7">&#9670;&nbsp;</a></span>GDALTriangulationComputeBarycentricCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALTriangulationComputeBarycentricCoordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *&#160;</td>
          <td class="paramname"><em>psDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFacetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfL1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfL3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycentric coordinates of a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDT</td><td>triangulation. </td></tr>
    <tr><td class="paramname">nFacetIdx</td><td>index of the triangle in the triangulation </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of the point. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of the point. </td></tr>
    <tr><td class="paramname">pdfL1</td><td>(output) pointer to the 1st barycentric coordinate. </td></tr>
    <tr><td class="paramname">pdfL2</td><td>(output) pointer to the 2nd barycentric coordinate. </td></tr>
    <tr><td class="paramname">pdfL3</td><td>(output) pointer to the 2nd barycentric coordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a498205ae5f4f0ec9f43e5c65bb392060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498205ae5f4f0ec9f43e5c65bb392060">&#9670;&nbsp;</a></span>GDALTriangulationCreateDelaunay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGDALTriangulation.html">GDALTriangulation</a>* GDALTriangulationCreateDelaunay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a Delaunay triangulation of the passed points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nPoints</td><td>number of points </td></tr>
    <tr><td class="paramname">padfX</td><td>x coordinates of the points. </td></tr>
    <tr><td class="paramname">padfY</td><td>y coordinates of the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>triangulation that must be freed with <a class="el" href="gdal__alg_8h.html#a1d9ddc2b9ee90b2f9984e020d8f099f6" title="Free a triangulation. ">GDALTriangulationFree()</a>, or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a63207eb23887a93ca97ee218848231f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63207eb23887a93ca97ee218848231f0">&#9670;&nbsp;</a></span>GDALTriangulationFindFacetBruteForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALTriangulationFindFacetBruteForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *&#160;</td>
          <td class="paramname"><em>psDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panOutputFacetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the triangle that contains the point by iterating over all triangles. </p>
<p>If the function returns FALSE and *panOutputFacetIdx &gt;= 0, then it means the point is outside the hull of the triangulation, and *panOutputFacetIdx is the closest triangle to the point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDT</td><td>triangulation. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of the point. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of the point. </td></tr>
    <tr><td class="paramname">panOutputFacetIdx</td><td>(output) pointer to the index of the triangle, or -1 in case of failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index &gt;= 0 of the triangle in case of success, -1 otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="af4e3912995c59830c6bfcdf4ec1112fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e3912995c59830c6bfcdf4ec1112fc">&#9670;&nbsp;</a></span>GDALTriangulationFindFacetDirected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALTriangulationFindFacetDirected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *&#160;</td>
          <td class="paramname"><em>psDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFacetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panOutputFacetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the triangle that contains the point by walking in the triangulation. </p>
<p>If the function returns FALSE and *panOutputFacetIdx &gt;= 0, then it means the point is outside the hull of the triangulation, and *panOutputFacetIdx is the closest triangle to the point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDT</td><td>triangulation. </td></tr>
    <tr><td class="paramname">nFacetIdx</td><td>index of first triangle to start with. Must be &gt;= 0 &amp;&amp; &lt; psDT-&gt;nFacets </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of the point. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of the point. </td></tr>
    <tr><td class="paramname">panOutputFacetIdx</td><td>(output) pointer to the index of the triangle, or -1 in case of failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a1d9ddc2b9ee90b2f9984e020d8f099f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9ddc2b9ee90b2f9984e020d8f099f6">&#9670;&nbsp;</a></span>GDALTriangulationFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALTriangulationFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGDALTriangulation.html">GDALTriangulation</a> *&#160;</td>
          <td class="paramname"><em>psDT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDT</td><td>triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a95f01fd3f2e027e04f7b4f964c5fc3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f01fd3f2e027e04f7b4f964c5fc3fb">&#9670;&nbsp;</a></span>GDALViewshedGenerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> GDALViewshedGenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&#160;</td>
          <td class="paramname"><em>hBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDriverName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetRasterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszCreationOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfObserverX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfObserverY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfObserverHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTargetHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfVisibleVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfInvisibleVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfOutOfRangeVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfNoDataVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCurvCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a49244316dfeefdbbb188f2570911717d">GDALViewshedMode</a>&#160;</td>
          <td class="paramname"><em>eMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#aa5ee2833f6486e61e24903fe0f4dad4a">GDALViewshedOutputType</a>&#160;</td>
          <td class="paramname"><em>heightMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszExtraOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create viewshed from raster DEM. </p>
<p>This algorithm will generate a viewshed raster from an input DEM raster by using a modified algorithm of "Generating Viewsheds without Using Sightlines" published at <a href="https://www.asprs.org/wp-content/uploads/pers/2000journal/january/2000_jan_87-90.pdf">https://www.asprs.org/wp-content/uploads/pers/2000journal/january/2000_jan_87-90.pdf</a> This appoach provides a relatively fast calculation, since the output raster is generated in a single scan. The gdal/apps/gdal_viewshed.cpp mainline can be used as an example of how to use this function. The output raster will be of type Byte or Float64.</p>
<dl class="section note"><dt>Note</dt><dd>The algorithm as implemented currently will only output meaningful results if the georeferencing is in a projected coordinate reference system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBand</td><td>The band to read the DEM data from. Only the part of the raster within the specified maxdistance around the observer point is processed.</td></tr>
    <tr><td class="paramname">pszDriverName</td><td>Driver name (GTiff if set to NULL)</td></tr>
    <tr><td class="paramname">pszTargetRasterName</td><td>The name of the target raster to be generated. Must not be NULL</td></tr>
    <tr><td class="paramname">papszCreationOptions</td><td>creation options.</td></tr>
    <tr><td class="paramname">dfObserverX</td><td>observer X value (in SRS units)</td></tr>
    <tr><td class="paramname">dfObserverY</td><td>observer Y value (in SRS units)</td></tr>
    <tr><td class="paramname">dfObserverHeight</td><td>The height of the observer above the DEM surface.</td></tr>
    <tr><td class="paramname">dfTargetHeight</td><td>The height of the target above the DEM surface. (default 0)</td></tr>
    <tr><td class="paramname">dfVisibleVal</td><td>pixel value for visibility (default 255)</td></tr>
    <tr><td class="paramname">dfInvisibleVal</td><td>pixel value for invisibility (default 0)</td></tr>
    <tr><td class="paramname">dfOutOfRangeVal</td><td>The value to be set for the cells that fall outside of the range specified by dfMaxDistance.</td></tr>
    <tr><td class="paramname">dfNoDataVal</td><td>The value to be set for the cells that have no data. If set to a negative value, nodata is not set. Note: currently, no special processing of input cells at a nodata value is done (which may result in erroneous results).</td></tr>
    <tr><td class="paramname">dfCurvCoeff</td><td>Coefficient to consider the effect of the curvature and refraction. The height of the DEM is corrected according to the following formula: [Height] -= dfCurvCoeff * [Target Distance]^2 / [Earth Diameter] For the effect of the atmospheric refraction we can use 0.85714‬.</td></tr>
    <tr><td class="paramname">eMode</td><td>The mode of the viewshed calculation. Possible values GVM_Diagonal = 1, GVM_Edge = 2 (default), GVM_Max = 3, GVM_Min = 4.</td></tr>
    <tr><td class="paramname">dfMaxDistance</td><td>maximum distance range to compute viewshed. It is also used to clamp the extent of the output raster. If set to 0, then unlimited range is assumed, that is to say the computation is performed on the extent of the whole raster.</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>The callback data for the pfnProgress function.</td></tr>
    <tr><td class="paramname">heightMode</td><td>Type of information contained in output raster. Possible values GVOT_NORMAL = 1 (default), GVOT_MIN_TARGET_HEIGHT_FROM_DEM = 2, GVOT_MIN_TARGET_HEIGHT_FROM_GROUND = 3</td></tr>
  </table>
  </dd>
</dl>
<p>GVOT_NORMAL returns a raster of type Byte containing visible locations.</p>
<p>GVOT_MIN_TARGET_HEIGHT_FROM_DEM and GVOT_MIN_TARGET_HEIGHT_FROM_GROUND will return a raster of type Float64 containing the minimum target height for target to be visible from the DEM surface or ground level respectively. Parameters dfTargetHeight, dfVisibleVal and dfInvisibleVal will be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszExtraOptions</td><td>Future extra options. Must be set to NULL currently.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>not NULL output dataset on success (to be closed with <a class="el" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc" title="Close GDAL dataset. ">GDALClose()</a>) or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
